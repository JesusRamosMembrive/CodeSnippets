---FILES---
main.cpp
result

---main.cpp---
#include <iostream>
#include <limits>
#include <climits> // Para límites de tipos
#include <stdint.h>

int main() {
    
    int8_t numero = -128; // El valor mínimo para un entero de 8 bits con signo
    numero = numero - 1; // Esto causa underflow
    std::cout << "Valor después del underflow: " << static_cast<int>(numero) << std::endl; // Conversión a int para mostrar correctamente

    float numero2 = 1.0e-38f; // Un valor cercano al mínimo para float
    float divisor = 1.0e38f;
    float resultado = numero2 / divisor; // Esto causa underflow
    std::cout << "Valor después del underflow: " << resultado << std::endl;

    int a = std::numeric_limits<int>::max();
    int b = 1;

    if (a > std::numeric_limits<int>::max() - b) {
        std::cerr << "Error: Overflow detectado" << std::endl;
    } else {
        int resultado2 = a + b;
        std::cout << "Resultado: " << resultado2 << std::endl;
    }
    return 0;
}

---result---
Valor después del underflow: 127
Valor después del underflow: 0
Error: Overflow detectado

---EXPLANATION---
### Overflow y Underflow en C++

En programación, los conceptos de overflow y underflow se refieren a situaciones en las que el resultado de una operación aritmética está fuera del rango que puede ser representado por un tipo de dato específico. Estas situaciones pueden llevar a comportamientos inesperados y errores en los programas.

#### 1. **Overflow**

El overflow ocurre cuando el resultado de una operación aritmética excede el rango máximo que puede ser almacenado por un tipo de dato.

##### Ejemplo de Overflow con Enteros

Para un entero de 8 bits con signo (`int8_t`), el rango es de -128 a 127. Si se suma 1 a 127, se produce un overflow:

```cpp
#include <iostream>
#include <climits> // Para límites de tipos

int main() {
    int8_t numero = 127; // El valor máximo para un entero de 8 bits con signo
    numero = numero + 1; // Esto causa overflow
    std::cout << "Valor después del overflow: " << static_cast<int>(numero) << std::endl; // Conversión a int para mostrar correctamente
    return 0;
}
```

En este caso, el resultado será -128 debido a cómo se manejan los enteros en binario (envolvimiento o "wrap-around").

##### Ejemplo de Overflow con Enteros sin Signo

Para un entero sin signo de 8 bits (`uint8_t`), el rango es de 0 a 255. Si se suma 1 a 255, se produce un overflow:

```cpp
#include <iostream>
#include <cstdint> // Para uint8_t

int main() {
    uint8_t numero = 255; // El valor máximo para un entero de 8 bits sin signo
    numero = numero + 1; // Esto causa overflow
    std::cout << "Valor después del overflow: " << static_cast<int>(numero) << std::endl; // Conversión a int para mostrar correctamente
    return 0;
}
```

En este caso, el resultado será 0 debido al envolvimiento del valor.

#### 2. **Underflow**

El underflow ocurre cuando el resultado de una operación aritmética es menor que el valor mínimo que puede ser almacenado por un tipo de dato.

##### Ejemplo de Underflow con Enteros

Para un entero de 8 bits con signo, el rango es de -128 a 127. Si se resta 1 a -128, se produce un underflow:

```cpp
#include <iostream>
#include <climits> // Para límites de tipos

int main() {
    int8_t numero = -128; // El valor mínimo para un entero de 8 bits con signo
    numero = numero - 1; // Esto causa underflow
    std::cout << "Valor después del underflow: " << static_cast<int>(numero) << std::endl; // Conversión a int para mostrar correctamente
    return 0;
}
```

En este caso, el resultado será 127 debido al envolvimiento del valor.

##### Ejemplo de Underflow con Flotantes

El underflow también puede ocurrir con números en punto flotante cuando el resultado de una operación es más pequeño que el valor mínimo representable.

```cpp
#include <iostream>
#include <cfloat> // Para límites de tipos

int main() {
    float numero = 1.0e-38f; // Un valor cercano al mínimo para float
    float divisor = 1.0e38f;
    float resultado = numero / divisor; // Esto causa underflow
    std::cout << "Valor después del underflow: " << resultado << std::endl;
    return 0;
}
```

En este caso, el resultado será 0 porque el valor resultante es demasiado pequeño para ser representado por un float.

### Consecuencias y Manejo

El manejo adecuado de overflow y underflow es crucial para evitar comportamientos inesperados y errores en los programas. Algunas estrategias incluyen:

- **Chequeo de Rango:** Antes de realizar operaciones aritméticas, verifica que el resultado estará dentro del rango permitido para el tipo de dato.
- **Uso de Tipos Más Grandes:** Si se espera que los valores puedan exceder el rango de un tipo de dato, considera usar un tipo de dato más grande (por ejemplo, `int` en lugar de `short`).
- **Librerías y Funciones de Chequeo:** Utiliza funciones y librerías que proporcionen chequeo de overflow y underflow. Por ejemplo, en C++20, puedes usar la librería `std::numeric_limits` para verificar límites de tipos.

##### Ejemplo de Chequeo de Rango

```cpp
#include <iostream>
#include <limits>

int main() {
    int a = std::numeric_limits<int>::max();
    int b = 1;

    if (a > std::numeric_limits<int>::max() - b) {
        std::cerr << "Error: Overflow detectado" << std::endl;
    } else {
        int resultado = a + b;
        std::cout << "Resultado: " << resultado << std::endl;
    }
    return 0;
}
```

### Conclusión

El overflow y underflow son condiciones importantes a considerar en la programación, ya que pueden llevar a resultados inesperados y errores difíciles de detectar. Comprender cómo ocurren y cómo manejarlos es crucial para escribir programas robustos y confiables en C++.