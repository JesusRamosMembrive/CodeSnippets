---FILES---
main.cpp
result

---main.cpp---
#include <iostream>

int main(){

    //Overflow

    unsigned char data {250};

    ++data;
    std::cout << "data : " << static_cast<int>(data) << std::endl;

    ++data;
    std::cout << "data : " << static_cast<int>(data) << std::endl;

    ++data;
    std::cout << "data : " << static_cast<int>(data) << std::endl;

    ++data;
    std::cout << "data : " << static_cast<int>(data) << std::endl;

    ++data;
    std::cout << "data : " << std::hex <<  static_cast<int>(data) << std::endl; // 255

    ++data;  // Overflow
    std::cout << "data : " << static_cast<int>(data) << std::endl; // 256

    std::cout << std::dec ;


    data = 1;

    --data;
    std::cout << "data : " << static_cast<int>(data) << std::endl;

    --data;
    std::cout << "data : " << static_cast<int>(data) << std::endl;


    return 0;
}


---result---
data : 251
data : 252
data : 253
data : 254
data : ff
data : 0
data : 0
data : 255

---EXPLANATION---
### Desbordamiento (Overflow) y Subdesbordamiento (Underflow)

En C++, cuando se trabaja con tipos de datos numéricos de tamaño fijo, como `unsigned char`, `int`, `float`, etc., existe un rango limitado de valores que estos tipos pueden almacenar. Si se intenta almacenar un valor fuera de este rango, se produce un desbordamiento o un subdesbordamiento. En el caso de los tipos sin signo (`unsigned`), el desbordamiento reinicia el valor al inicio del rango, mientras que el subdesbordamiento lo ajusta al final del rango.

### Ejemplos en el Código

1. **Desbordamiento en un `unsigned char`:**
   ```cpp
   unsigned char data {250};

   ++data;
   std::cout << "data : " << static_cast<int>(data) << std::endl;

   ++data;
   std::cout << "data : " << static_cast<int>(data) << std::endl;

   ++data;
   std::cout << "data : " << static_cast<int>(data) << std::endl;

   ++data;
   std::cout << "data : " << static_cast<int>(data) << std::endl;

   ++data; 
   std::cout << "data : " << std::hex <<  static_cast<int>(data) << std::endl; // 255

   ++data;  // Desbordamiento
   std::cout << "data : " << static_cast<int>(data) << std::endl; // 256
   ```
   - `unsigned char` puede almacenar valores entre 0 y 255. Cuando `data` se incrementa más allá de 255, se produce un desbordamiento, y `data` vuelve a 0.
   - La conversión a `int` (`static_cast<int>`) es necesaria para imprimir el valor de `data` como un entero, ya que `char` se imprime como un carácter por defecto.
   - Después de incrementar `data` a 255 (`0xff` en hexadecimal), otro incremento hace que el valor se desborde y vuelva a 0.

2. **Subdesbordamiento en un `unsigned char`:**
   ```cpp
   data = 1;

   --data;
   std::cout << "data : " << static_cast<int>(data) << std::endl;

   --data;
   std::cout << "data : " << static_cast<int>(data) << std::endl;
   ```
   - Cuando `data` se decrementa por debajo de 0, se produce un subdesbordamiento y `data` se ajusta al valor máximo permitido (255 en este caso).

### Salida Esperada del Programa

```plaintext
data : 251
data : 252
data : 253
data : 254
data : ff
data : 0
data : 0
data : 255
```

### Conclusión

El desbordamiento y el subdesbordamiento son comportamientos importantes a entender al trabajar con tipos de datos numéricos en C++. Estos fenómenos pueden causar errores sutiles y difíciles de detectar si no se manejan adecuadamente. En el código proporcionado, el uso de `unsigned char` y las operaciones de incremento y decremento ilustran cómo los valores pueden circular dentro de los límites del tipo de dato. La conversión a `int` para la salida es crucial para comprender los resultados de estas operaciones.
