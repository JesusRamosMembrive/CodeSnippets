<---EXPLANATION--->
### Recursividad en C++

La recursividad es una técnica de programación en la que una función se llama a sí misma para resolver subproblemas más pequeños de un problema más grande. Esta técnica puede simplificar la resolución de problemas que tienen una estructura repetitiva o fractal, como problemas matemáticos, algoritmos de búsqueda y problemas relacionados con estructuras de datos.

#### Conceptos Básicos de Recursividad

1. **Caso Base:** Es la condición que termina la recursión. Sin un caso base, la función recursiva se llamaría a sí misma indefinidamente, lo que llevaría a un desbordamiento de pila.
2. **Caso Recursivo:** Es la parte de la función donde se hace la llamada recursiva. Esta llamada divide el problema en subproblemas más pequeños.

#### Ejemplo Clásico: Factorial de un Número

El factorial de un número `n` (denotado como `n!`) se define como el producto de todos los números enteros positivos hasta `n`. Matemáticamente, se define como:
- `0! = 1`
- `n! = n * (n - 1)!` para `n > 0`

##### Implementación Recursiva del Factorial

```cpp
#include <iostream>
using namespace std;

int factorial(int n) {
    if (n == 0) { // Caso base
        return 1;
    } else { // Caso recursivo
        return n * factorial(n - 1);
    }
}

int main() {
    int numero = 5;
    cout << "El factorial de " << numero << " es " << factorial(numero) << endl;
    return 0;
}
```

En este ejemplo:
- **Caso Base:** `if (n == 0) return 1;` detiene la recursión cuando `n` es 0.
- **Caso Recursivo:** `return n * factorial(n - 1);` llama a la función con `n - 1`.

#### Ejemplo: Serie de Fibonacci

La serie de Fibonacci es una secuencia donde cada número es la suma de los dos anteriores. Matemáticamente, se define como:
- `F(0) = 0`
- `F(1) = 1`
- `F(n) = F(n - 1) + F(n - 2)` para `n > 1`

##### Implementación Recursiva de Fibonacci

```cpp
#include <iostream>
using namespace std;

int fibonacci(int n) {
    if (n <= 1) { // Casos base
        return n;
    } else { // Caso recursivo
        return fibonacci(n - 1) + fibonacci(n - 2);
    }
}

int main() {
    int numero = 10;
    cout << "El término " << numero << " de la serie de Fibonacci es " << fibonacci(numero) << endl;
    return 0;
}
```

En este ejemplo:
- **Casos Base:** `if (n <= 1) return n;` detiene la recursión cuando `n` es 0 o 1.
- **Caso Recursivo:** `return fibonacci(n - 1) + fibonacci(n - 2);` llama a la función con `n - 1` y `n - 2`.

#### Recursividad de Cola

La recursividad de cola es una forma especial de recursión donde la llamada recursiva es la última operación que se realiza. Los compiladores pueden optimizar la recursividad de cola para evitar el desbordamiento de pila.

##### Ejemplo de Recursividad de Cola

```cpp
#include <iostream>
using namespace std;

int factorialCola(int n, int acumulador = 1) {
    if (n == 0) { // Caso base
        return acumulador;
    } else { // Caso recursivo de cola
        return factorialCola(n - 1, n * acumulador);
    }
}

int main() {
    int numero = 5;
    cout << "El factorial de " << numero << " (usando recursividad de cola) es " << factorialCola(numero) << endl;
    return 0;
}
```

En este ejemplo:
- **Caso Base:** `if (n == 0) return acumulador;` detiene la recursión cuando `n` es 0.
- **Caso Recursivo de Cola:** `return factorialCola(n - 1, n * acumulador);` pasa el cálculo parcial al siguiente llamado.

#### Consideraciones y Buenas Prácticas

1. **Evitar Desbordamientos de Pila:** La recursividad profunda puede llevar a un desbordamiento de pila. Utiliza recursividad de cola cuando sea posible y considera algoritmos iterativos para problemas grandes.
2. **Optimización:** Algunos problemas recursivos pueden beneficiarse de la memoización, donde se almacenan los resultados de subproblemas ya resueltos para evitar cálculos redundantes.
3. **Claridad del Código:** Asegúrate de que los casos base y recursivos estén claramente definidos y documentados para facilitar el mantenimiento y la comprensión del código.

#### Ejemplo Completo con Memoización

Memoización es una técnica de optimización que almacena los resultados de subproblemas para evitar cálculos redundantes.

##### Implementación de Fibonacci con Memoización

```cpp
#include <iostream>
#include <vector>
using namespace std;

vector<int> memo(100, -1); // Inicializar con -1

int fibonacciMemo(int n) {
    if (n <= 1) { // Casos base
        return n;
    }
    if (memo[n] != -1) { // Verificar si el resultado ya está calculado
        return memo[n];
    }
    // Calcular y almacenar el resultado
    memo[n] = fibonacciMemo(n - 1) + fibonacciMemo(n - 2);
    return memo[n];
}

int main() {
    int numero = 10;
    cout << "El término " << numero << " de la serie de Fibonacci (con memoización) es " << fibonacciMemo(numero) << endl;
    return 0;
}
```

### Conclusión

La recursividad es una herramienta poderosa en C++ que permite resolver problemas complejos dividiéndolos en subproblemas más simples. Entender y aplicar correctamente los casos base y recursivos es crucial para evitar errores y optimizar el rendimiento. La recursividad de cola y la memoización son técnicas avanzadas que pueden mejorar la eficiencia y evitar problemas comunes como el desbordamiento de pila. Con una comprensión sólida de la recursividad, los desarrolladores pueden abordar una amplia gama de problemas algorítmicos de manera efectiva.
<---FILES--->
Implementación Recursiva del Factorial
Implementación Recursiva del Factorial Result
Implementación Recursiva de Fibonacci
Implementación Recursiva de Fibonacci Result
Ejemplo de Recursividad de Cola
Ejemplo de Recursividad de Cola Result
Implementación de Fibonacci con Memoización
Implementación de Fibonacci con Memoización Result
<---Implementación Recursiva del Factorial--->
```cpp
#include <iostream>
using namespace std;

int factorial(int n) {
    if (n == 0) { // Caso base
        return 1;
    } else { // Caso recursivo
        return n * factorial(n - 1);
    }
}

int main() {
    int numero = 5;
    cout << "El factorial de " << numero << " es " << factorial(numero) << endl;
    return 0;
}
<---Implementación Recursiva del Factorial Result--->
<---Implementación Recursiva de Fibonacci--->
```cpp
#include <iostream>
using namespace std;

int fibonacci(int n) {
    if (n <= 1) { // Casos base
        return n;
    } else { // Caso recursivo
        return fibonacci(n - 1) + fibonacci(n - 2);
    }
}

int main() {
    int numero = 10;
    cout << "El término " << numero << " de la serie de Fibonacci es " << fibonacci(numero) << endl;
    return 0;
}
<---Implementación Recursiva de Fibonacci Result--->
<---Ejemplo de Recursividad de Cola--->
```cpp
#include <iostream>
using namespace std;

int factorialCola(int n, int acumulador = 1) {
    if (n == 0) { // Caso base
        return acumulador;
    } else { // Caso recursivo de cola
        return factorialCola(n - 1, n * acumulador);
    }
}

int main() {
    int numero = 5;
    cout << "El factorial de " << numero << " (usando recursividad de cola) es " << factorialCola(numero) << endl;
    return 0;
}
<---Ejemplo de Recursividad de Cola Result--->
<---Implementación de Fibonacci con Memoización--->
```cpp
#include <iostream>
#include <vector>
using namespace std;

vector<int> memo(100, -1); // Inicializar con -1

int fibonacciMemo(int n) {
    if (n <= 1) { // Casos base
        return n;
    }
    if (memo[n] != -1) { // Verificar si el resultado ya está calculado
        return memo[n];
    }
    // Calcular y almacenar el resultado
    memo[n] = fibonacciMemo(n - 1) + fibonacciMemo(n - 2);
    return memo[n];
}

int main() {
    int numero = 10;
    cout << "El término " << numero << " de la serie de Fibonacci (con memoización) es " << fibonacciMemo(numero) << endl;
    return 0;
}
<---Implementación de Fibonacci con Memoización Result--->
