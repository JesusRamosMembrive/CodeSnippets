<---FILES--->
main.cpp
result

<---main.cpp--->
#include <iostream>
#include <optional>
#include <string>
using namespace std;

optional<string> obtenerNombre(bool exito) {
    if (exito) {
        return "Juan";
    } else {
        return nullopt;
    }
}

string obtenerSaludo(const string& nombre) {
    if (nombre == "Juan") {
        return "Hola, Juan!";
    } else {
        return "Hola, desconocido!";
    }
}

int main() {
    if (auto nombre = obtenerNombre(true); nombre.has_value()) {
        cout << obtenerSaludo(nombre.value()) << endl;
    } else {
        cout << "No se obtuvo un nombre." << endl;
    }

    if (auto nombre = obtenerNombre(false); nombre.has_value()) {
        cout << obtenerSaludo(nombre.value()) << endl;
    } else {
        cout << "No se obtuvo un nombre." << endl;
    }

    switch (auto saludo = obtenerSaludo("Juan"); saludo[0]) {
    case 'H':
        cout << "Saludo: " << saludo << endl;
        break;
    default:
        cout << "Saludo desconocido" << endl;
    }

    return 0;
}


<---result--->
Hola, Juan!
No se obtuvo un nombre.
Saludo: Hola, Juan!

<---EXPLANATION--->
### Inicialización dentro de `if` y `switch` en C++

Desde C++17, es posible inicializar variables directamente dentro de la condición de un `if` o un `switch`. Esta característica mejora la legibilidad y el alcance del código, asegurando que las variables sólo sean accesibles dentro del ámbito de la estructura condicional donde se utilizan.

#### Inicialización dentro de `if`

La inicialización dentro de `if` permite declarar e inicializar una variable en la misma línea donde se evalúa la condición del `if`. La variable declarada es local al bloque del `if` y sus cláusulas `else`.

##### Sintaxis Básica

```cpp
if (auto variable = expresion; condicion) {
    // Código a ejecutar si la condición es verdadera
} else {
    // Código a ejecutar si la condición es falsa
}
```

##### Ejemplo

```cpp
#include <iostream>
#include <optional>
using namespace std;

optional<int> obtenerValor(bool exito) {
    if (exito) {
        return 42;
    } else {
        return nullopt;
    }
}

int main() {
    if (auto valor = obtenerValor(true); valor.has_value()) {
        cout << "Valor obtenido: " << valor.value() << endl;
    } else {
        cout << "No se obtuvo un valor." << endl;
    }

    if (auto valor = obtenerValor(false); valor.has_value()) {
        cout << "Valor obtenido: " << valor.value() << endl;
    } else {
        cout << "No se obtuvo un valor." << endl;
    }

    return 0;
}
```

En este ejemplo, la variable `valor` es declarada y inicializada dentro de la condición del `if`, y su alcance se limita al bloque del `if` y su correspondiente `else`.

#### Inicialización dentro de `switch`

La inicialización dentro de `switch` permite declarar e inicializar una variable en la misma línea donde se evalúa la expresión del `switch`. La variable declarada es local al bloque del `switch`.

##### Sintaxis Básica

```cpp
switch (auto variable = expresion; variable) {
    case valor1:
        // Código a ejecutar si variable == valor1
        break;
    case valor2:
        // Código a ejecutar si variable == valor2
        break;
    default:
        // Código a ejecutar si variable no coincide con ningún caso
}
```

##### Ejemplo

```cpp
#include <iostream>
#include <string>
using namespace std;

string obtenerCategoria(int edad) {
    if (edad < 0) {
        return "Invalido";
    } else if (edad <= 12) {
        return "Niño";
    } else if (edad <= 19) {
        return "Adolescente";
    } else if (edad <= 65) {
        return "Adulto";
    } else {
        return "Anciano";
    }
}

int main() {
    switch (auto categoria = obtenerCategoria(25); categoria[0]) {
        case 'N':
            cout << "Categoría: Niño" << endl;
            break;
        case 'A':
            cout << "Categoría: Adolescente" << endl;
            break;
        case 'A':
            cout << "Categoría: Adulto" << endl;
            break;
        case 'A':
            cout << "Categoría: Anciano" << endl;
            break;
        default:
            cout << "Categoría: Invalido" << endl;
    }

    return 0;
}
```

En este ejemplo, la variable `categoria` es declarada y inicializada dentro de la expresión del `switch`, y su alcance se limita al bloque del `switch`.

### Beneficios de la Inicialización en `if` y `switch`

1. **Mayor Legibilidad:** Permite declarar e inicializar variables justo donde se necesitan, mejorando la claridad del código.
2. **Ámbito Limitado:** Las variables están limitadas al bloque del `if` o `switch`, evitando posibles conflictos de nombres y errores de alcance.
3. **Eficiencia:** Facilita la optimización del código al reducir el ámbito de las variables.

### Ejemplo Completo

Aquí hay un ejemplo que combina la inicialización dentro de `if` y `switch` para demostrar cómo se pueden usar juntos de manera efectiva:

```cpp
#include <iostream>
#include <optional>
#include <string>
using namespace std;

optional<string> obtenerNombre(bool exito) {
    if (exito) {
        return "Juan";
    } else {
        return nullopt;
    }
}

string obtenerSaludo(const string& nombre) {
    if (nombre == "Juan") {
        return "Hola, Juan!";
    } else {
        return "Hola, desconocido!";
    }
}

int main() {
    if (auto nombre = obtenerNombre(true); nombre.has_value()) {
        cout << obtenerSaludo(nombre.value()) << endl;
    } else {
        cout << "No se obtuvo un nombre." << endl;
    }

    if (auto nombre = obtenerNombre(false); nombre.has_value()) {
        cout << obtenerSaludo(nombre.value()) << endl;
    } else {
        cout << "No se obtuvo un nombre." << endl;
    }

    switch (auto saludo = obtenerSaludo("Juan"); saludo[0]) {
        case 'H':
            cout << "Saludo: " << saludo << endl;
            break;
        default:
            cout << "Saludo desconocido" << endl;
    }

    return 0;
}
```

### Conclusión

La capacidad de inicializar variables dentro de `if` y `switch` en C++17 y posteriores mejora significativamente la legibilidad y el manejo de ámbitos en el código. Esta característica permite escribir código más limpio y seguro, reduciendo la posibilidad de errores relacionados con el alcance de las variables y mejorando la eficiencia del programa.