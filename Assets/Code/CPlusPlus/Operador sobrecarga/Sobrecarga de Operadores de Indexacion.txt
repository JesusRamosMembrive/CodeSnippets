<---EXPLANATION--->
### Sobrecarga de Operadores de Indexación en C++

La sobrecarga del operador de indexación `[]` permite definir cómo se deben comportar los objetos de una clase cuando se accede a sus elementos mediante un índice. Esta funcionalidad es especialmente útil para clases que representan colecciones o contenedores, como arrays, vectores, matrices, etc.

#### Ejemplo: Clase `DynamicArray` para Sobrecargar el Operador `[]`

Vamos a definir una clase `DynamicArray` que representa un array dinámico y sobrecargaremos el operador de indexación `[]`.

```cpp
// DynamicArray.h
#ifndef DYNAMICARRAY_H
#define DYNAMICARRAY_H

#include <iostream>
#include <stdexcept>

class DynamicArray {
private:
    int* data;
    size_t size;
public:
    // Constructor
    DynamicArray(size_t s) : size(s) {
        data = new int[size];
        for (size_t i = 0; i < size; ++i) {
            data[i] = 0;
        }
    }

    // Destructor
    ~DynamicArray() {
        delete[] data;
    }

    // Sobrecarga del operador []
    int& operator[](size_t index) {
        if (index >= size) {
            throw std::out_of_range("Índice fuera de rango");
        }
        return data[index];
    }

    // Sobrecarga del operador [] para acceso constante
    const int& operator[](size_t index) const {
        if (index >= size) {
            throw std::out_of_range("Índice fuera de rango");
        }
        return data[index];
    }

    // Método para obtener el tamaño del array
    size_t getSize() const {
        return size;
    }

    // Sobrecarga del operador << para la salida
    friend std::ostream& operator<<(std::ostream& os, const DynamicArray& arr) {
        for (size_t i = 0; i < arr.size; ++i) {
            os << arr.data[i] << " ";
        }
        return os;
    }
};

#endif // DYNAMICARRAY_H
```

```cpp
// main.cpp
#include "DynamicArray.h"
#include <iostream>

int main() {
    DynamicArray arr(5);

    // Asignar valores utilizando el operador []
    for (size_t i = 0; i < arr.getSize(); ++i) {
        arr[i] = static_cast<int>(i * 10);
    }

    // Imprimir valores utilizando el operador <<
    std::cout << "Array: " << arr << std::endl;

    // Acceder a un valor fuera de rango para demostrar el manejo de excepciones
    try {
        arr[10] = 100;
    } catch (const std::out_of_range& e) {
        std::cerr << "Error: " << e.what() << std::endl;
    }

    return 0;
}
```

### Explicación de los Operadores Sobrecargados

#### Sobrecarga del Operador `[]`

##### Versión No Constante

```cpp
int& operator[](size_t index) {
    if (index >= size) {
        throw std::out_of_range("Índice fuera de rango");
    }
    return data[index];
}
```
Esta versión permite el acceso y la modificación de los elementos del array. Si el índice está fuera del rango, se lanza una excepción `std::out_of_range`.

##### Versión Constante

```cpp
const int& operator[](size_t index) const {
    if (index >= size) {
        throw std::out_of_range("Índice fuera de rango");
    }
    return data[index];
}
```
Esta versión constante permite el acceso a los elementos del array sin permitir su modificación. También lanza una excepción `std::out_of_range` si el índice está fuera del rango.

### Ventajas de la Sobrecarga del Operador de Indexación

1. **Legibilidad y Facilidad de Uso**: Permite utilizar una sintaxis intuitiva y clara para acceder a los elementos de un contenedor, similar a la utilizada para arrays y punteros.
2. **Encapsulación**: Encapsula la lógica de acceso dentro de la clase, asegurando que los detalles de implementación estén
<---FILES--->
Versión No Constante
Versión No Constante Result
Versión Constante
Versión Constante Result
<---Versión No Constante--->
```cpp
int& operator[](size_t index) {
    if (index >= size) {
        throw std::out_of_range("Índice fuera de rango");
    }
    return data[index];
}
<---Versión No Constante Result--->
<---Versión Constante--->
```cpp
const int& operator[](size_t index) const {
    if (index >= size) {
        throw std::out_of_range("Índice fuera de rango");
    }
    return data[index];
}
<---Versión Constante Result--->
