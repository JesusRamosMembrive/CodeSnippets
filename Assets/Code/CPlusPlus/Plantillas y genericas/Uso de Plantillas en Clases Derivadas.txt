<---EXPLANATION--->
### Uso de Plantillas en Clases Derivadas en C++

Las plantillas en clases derivadas permiten crear jerarquías de clases genéricas, donde las clases derivadas pueden ser plantillas que heredan de clases base plantillas. Esto proporciona una gran flexibilidad y reutilización del código en el diseño orientado a objetos.

#### Definición de Clases Base y Derivadas con Plantillas

##### Clase Base Plantilla

Primero, definimos una clase base plantilla que puede aceptar un tipo genérico.

```cpp
#include <iostream>

// Clase base plantilla
template <typename T>
class Base {
public:
    T valor;

    Base(T v) : valor(v) {}

    void mostrar() {
        std::cout << "Valor en Base: " << valor << std::endl;
    }
};
```

En este ejemplo:
- `Base` es una clase plantilla con un tipo genérico `T`.
- Tiene un miembro de datos `valor` y un método `mostrar` que imprime este valor.

##### Clase Derivada Plantilla

Ahora, definimos una clase derivada que también es una plantilla y que hereda de la clase base plantilla.

```cpp
// Clase derivada plantilla
template <typename T>
class Derivada : public Base<T> {
public:
    Derivada(T v) : Base<T>(v) {}

    void mostrarDerivado() {
        std::cout << "Valor en Derivada: " << this->valor << std::endl;
    }
};
```

En este ejemplo:
- `Derivada` es una clase plantilla que hereda de `Base<T>`.
- Redefine el constructor para inicializar `Base` con el valor proporcionado.
- Añade un método `mostrarDerivado` que también imprime el valor.

##### Uso de las Clases Derivadas Plantilla

```cpp
int main() {
    Derivada<int> obj(10);
    obj.mostrar();            // Llama al método de la clase base
    obj.mostrarDerivado();    // Llama al método de la clase derivada

    Derivada<double> obj2(5.5);
    obj2.mostrar();           // Llama al método de la clase base
    obj2.mostrarDerivado();   // Llama al método de la clase derivada

    return 0;
}
```

En este ejemplo:
- Se crean objetos de `Derivada` con diferentes tipos (`int` y `double`).
- Se llaman métodos tanto de la clase base como de la clase derivada.

### Plantillas en Clases Derivadas con Múltiples Plantillas

También es posible que la clase derivada sea una plantilla con tipos diferentes de la clase base.

##### Ejemplo con Clases Derivadas con Múltiples Plantillas

```cpp
#include <iostream>

// Clase base plantilla
template <typename T>
class Base {
public:
    T valor;

    Base(T v) : valor(v) {}

    void mostrar() {
        std::cout << "Valor en Base: " << valor << std::endl;
    }
};

// Clase derivada plantilla con un tipo adicional
template <typename T, typename U>
class Derivada : public Base<T> {
public:
    U otroValor;

    Derivada(T v, U ov) : Base<T>(v), otroValor(ov) {}

    void mostrarDerivado() {
        std::cout << "Valor en Derivada: " << this->valor << ", Otro valor: " << otroValor << std::endl;
    }
};

int main() {
    Derivada<int, double> obj(10, 5.5);
    obj.mostrar();            // Llama al método de la clase base
    obj.mostrarDerivado();    // Llama al método de la clase derivada

    Derivada<std::string, int> obj2("Hola", 42);
    obj2.mostrar();           // Llama al método de la clase base
    obj2.mostrarDerivado();   // Llama al método de la clase derivada

    return 0;
}
```

En este ejemplo:
- `Derivada` acepta dos tipos genéricos: `T` para el tipo base y `U` para un tipo adicional específico de la clase derivada.
- El constructor de `Derivada` inicializa tanto la clase base como el nuevo miembro `otroValor`.
- `mostrarDerivado` imprime ambos valores.

### Consideraciones al Usar Plantillas en Clases Derivadas

1. **Acceso a Miembros Base:** En las clases derivadas plantillas, puede ser necesario utilizar el prefijo `this->` para acceder a los miembros de la clase base debido a la naturaleza dependiente del contexto de las plantillas.
2. **Especialización:** Las clases derivadas pueden especializar las funciones de la clase base según sea necesario para proporcionar implementaciones específicas de tipo.
3. **Compatibilidad y Reutilización:** Las plantillas permiten una gran flexibilidad, pero es importante asegurarse de que las clases derivadas mantengan la compatibilidad con las interfaces de la clase base para maximizar la reutilización del código.

### Conclusión

El uso de plantillas en clases derivadas en C++ permite crear jerarquías de clases altamente flexibles y reutilizables. Esto facilita la definición de clases genéricas que pueden trabajar con múltiples tipos y proporciona una estructura sólida para el diseño orientado a objetos. Al comprender y aplicar correctamente las plantillas en clases derivadas, los desarrolladores pueden escribir código más limpio, modular y adaptable a diferentes necesidades.
<---FILES--->
Clase Base Plantilla
Clase Base Plantilla Result
Clase Derivada Plantilla
Clase Derivada Plantilla Result
Uso de las Clases Derivadas Plantilla
Uso de las Clases Derivadas Plantilla Result
Ejemplo con Clases Derivadas con Múltiples Plantillas
Ejemplo con Clases Derivadas con Múltiples Plantillas Result
<---Clase Base Plantilla--->
```cpp
#include <iostream>

// Clase base plantilla
template <typename T>
class Base {
public:
    T valor;

    Base(T v) : valor(v) {}

    void mostrar() {
        std::cout << "Valor en Base: " << valor << std::endl;
    }
};
<---Clase Base Plantilla Result--->
<---Clase Derivada Plantilla--->
```cpp
// Clase derivada plantilla
template <typename T>
class Derivada : public Base<T> {
public:
    Derivada(T v) : Base<T>(v) {}

    void mostrarDerivado() {
        std::cout << "Valor en Derivada: " << this->valor << std::endl;
    }
};
<---Clase Derivada Plantilla Result--->
<---Uso de las Clases Derivadas Plantilla--->
```cpp
int main() {
    Derivada<int> obj(10);
    obj.mostrar();            // Llama al método de la clase base
    obj.mostrarDerivado();    // Llama al método de la clase derivada

    Derivada<double> obj2(5.5);
    obj2.mostrar();           // Llama al método de la clase base
    obj2.mostrarDerivado();   // Llama al método de la clase derivada

    return 0;
}
<---Uso de las Clases Derivadas Plantilla Result--->
<---Ejemplo con Clases Derivadas con Múltiples Plantillas--->
```cpp
#include <iostream>

// Clase base plantilla
template <typename T>
class Base {
public:
    T valor;

    Base(T v) : valor(v) {}

    void mostrar() {
        std::cout << "Valor en Base: " << valor << std::endl;
    }
};

// Clase derivada plantilla con un tipo adicional
template <typename T, typename U>
class Derivada : public Base<T> {
public:
    U otroValor;

    Derivada(T v, U ov) : Base<T>(v), otroValor(ov) {}

    void mostrarDerivado() {
        std::cout << "Valor en Derivada: " << this->valor << ", Otro valor: " << otroValor << std::endl;
    }
};

int main() {
    Derivada<int, double> obj(10, 5.5);
    obj.mostrar();            // Llama al método de la clase base
    obj.mostrarDerivado();    // Llama al método de la clase derivada

    Derivada<std::string, int> obj2("Hola", 42);
    obj2.mostrar();           // Llama al método de la clase base
    obj2.mostrarDerivado();   // Llama al método de la clase derivada

    return 0;
}
<---Ejemplo con Clases Derivadas con Múltiples Plantillas Result--->
