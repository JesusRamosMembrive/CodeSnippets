<---EXPLANATION--->
### Plantillas de Clase con `TypeTraits` en C++

Las `type traits` (características de tipos) en C++ son una colección de metaprogramas que permiten al programador obtener información sobre los tipos en tiempo de compilación. Utilizar `type traits` en plantillas de clase permite escribir código más robusto y genérico, adaptándose a las características de los tipos proporcionados por el usuario.

#### Introducción a `TypeTraits`

La biblioteca `<type_traits>` de C++ proporciona una variedad de utilidades para inspeccionar y modificar tipos en tiempo de compilación. Algunas de las características más comunes incluyen:

- `std::is_integral<T>`: Comprueba si `T` es un tipo integral.
- `std::is_floating_point<T>`: Comprueba si `T` es un tipo de punto flotante.
- `std::enable_if<cond, T>`: Habilita una declaración solo si la condición `cond` es verdadera.
- `std::conditional<cond, T, F>`: Selecciona `T` si `cond` es verdadera, de lo contrario selecciona `F`.

#### Ejemplo de Plantillas de Clase con `TypeTraits`

Vamos a utilizar `type traits` para definir una plantilla de clase que se comporte de manera diferente según el tipo de datos proporcionado.

##### Clase Plantilla que Utiliza `TypeTraits`

En este ejemplo, definimos una clase plantilla `MiClase` que se especializa en tipos integrales y de punto flotante.

```cpp
#include <iostream>
#include <type_traits>

// Definición de la clase plantilla
template <typename T>
class MiClase {
    static_assert(std::is_arithmetic<T>::value, "MiClase requiere un tipo aritmético.");

public:
    T valor;

    MiClase(T v) : valor(v) {}

    // Método que se especializa en tipos integrales
    void mostrar() const {
        if constexpr (std::is_integral<T>::value) {
            std::cout << "Valor (entero): " << valor << std::endl;
        } else if constexpr (std::is_floating_point<T>::value) {
            std::cout << "Valor (flotante): " << valor << std::endl;
        } else {
            std::cout << "Valor (otro): " << valor << std::endl;
        }
    }
};

int main() {
    MiClase<int> obj1(42);
    obj1.mostrar();  // Muestra: Valor (entero): 42

    MiClase<double> obj2(3.14);
    obj2.mostrar();  // Muestra: Valor (flotante): 3.14

    // MiClase<std::string> obj3("Hola");  // Error en tiempo de compilación debido a static_assert

    return 0;
}
```

En este ejemplo:
- `MiClase` solo acepta tipos aritméticos debido a `static_assert`.
- `mostrar` se especializa en función del tipo utilizando `if constexpr`.

#### Utilizando `std::enable_if` para Especialización Condicional

Podemos utilizar `std::enable_if` para habilitar o deshabilitar funciones en base a las características del tipo.

```cpp
#include <iostream>
#include <type_traits>

// Definición de la clase plantilla
template <typename T>
class MiClase {
    static_assert(std::is_arithmetic<T>::value, "MiClase requiere un tipo aritmético.");

public:
    T valor;

    MiClase(T v) : valor(v) {}

    // Método habilitado solo para tipos integrales
    template <typename U = T>
    typename std::enable_if<std::is_integral<U>::value, void>::type
    mostrar() const {
        std::cout << "Valor (entero): " << valor << std::endl;
    }

    // Método habilitado solo para tipos de punto flotante
    template <typename U = T>
    typename std::enable_if<std::is_floating_point<U>::value, void>::type
    mostrar() const {
        std::cout << "Valor (flotante): " << valor << std::endl;
    }
};

int main() {
    MiClase<int> obj1(42);
    obj1.mostrar();  // Muestra: Valor (entero): 42

    MiClase<double> obj2(3.14);
    obj2.mostrar();  // Muestra: Valor (flotante): 3.14

    // MiClase<std::string> obj3("Hola");  // Error en tiempo de compilación debido a static_assert

    return 0;
}
```

En este ejemplo:
- `mostrar` tiene dos versiones, cada una habilitada para un tipo específico usando `std::enable_if`.

#### Ejemplo Avanzado: Selección de Tipos con `std::conditional`

Podemos usar `std::conditional` para seleccionar tipos en tiempo de compilación basándonos en ciertas condiciones.

```cpp
#include <iostream>
#include <type_traits>

// Definición de la clase plantilla
template <typename T>
class MiClase {
    using TipoSeleccionado = typename std::conditional<
        std::is_integral<T>::value,
        int,
        double
    >::type;

    TipoSeleccionado valor;

public:
    MiClase(T v) : valor(v) {}

    void mostrar() const {
        if constexpr (std::is_integral<T>::value) {
            std::cout << "Valor (entero como int): " << valor << std::endl;
        } else {
            std::cout << "Valor (flotante como double): " << valor << std::endl;
        }
    }
};

int main() {
    MiClase<int> obj1(42);
    obj1.mostrar();  // Muestra: Valor (entero como int): 42

    MiClase<float> obj2(3.14f);
    obj2.mostrar();  // Muestra: Valor (flotante como double): 3.14

    return 0;
}
```

En este ejemplo:
- `TipoSeleccionado` es un alias que se resuelve a `int` si `T` es un tipo integral y a `double` si `T` es un tipo de punto flotante.
- El constructor y el método `mostrar` usan `TipoSeleccionado` en lugar de `T`.

### Ventajas de Usar `TypeTraits` en Plantillas de Clase

1. **Robustez:** Permiten escribir código que se adapta a diferentes tipos de manera segura en tiempo de compilación.
2. **Flexibilidad:** Facilitan la creación de clases y funciones genéricas que pueden trabajar con una amplia variedad de tipos.
3. **Eficiencia:** Las evaluaciones en tiempo de compilación eliminan la sobrecarga en tiempo de ejecución.

### Conclusión

Las `type traits` en C++ son herramientas poderosas para escribir plantillas de clase robustas y flexibles. Al utilizar `std::is_integral`, `std::enable_if`, `std::conditional` y otras utilidades de `<type_traits>`, los desarrolladores pueden crear clases y funciones que se adapten automáticamente a las características de los tipos en tiempo de compilación, mejorando la seguridad y eficiencia del código.
<---FILES--->
Clase Plantilla que Utiliza `TypeTraits`
Clase Plantilla que Utiliza `TypeTraits` Result
<---Clase Plantilla que Utiliza `TypeTraits`--->
```cpp
#include <iostream>
#include <type_traits>

// Definición de la clase plantilla
template <typename T>
class MiClase {
    static_assert(std::is_arithmetic<T>::value, "MiClase requiere un tipo aritmético.");

public:
    T valor;

    MiClase(T v) : valor(v) {}

    // Método que se especializa en tipos integrales
    void mostrar() const {
        if constexpr (std::is_integral<T>::value) {
            std::cout << "Valor (entero): " << valor << std::endl;
        } else if constexpr (std::is_floating_point<T>::value) {
            std::cout << "Valor (flotante): " << valor << std::endl;
        } else {
            std::cout << "Valor (otro): " << valor << std::endl;
        }
    }
};

int main() {
    MiClase<int> obj1(42);
    obj1.mostrar();  // Muestra: Valor (entero): 42

    MiClase<double> obj2(3.14);
    obj2.mostrar();  // Muestra: Valor (flotante): 3.14

    // MiClase<std::string> obj3("Hola");  // Error en tiempo de compilación debido a static_assert

    return 0;
}
```cpp
#include <iostream>
#include <type_traits>

// Definición de la clase plantilla
template <typename T>
class MiClase {
    static_assert(std::is_arithmetic<T>::value, "MiClase requiere un tipo aritmético.");

public:
    T valor;

    MiClase(T v) : valor(v) {}

    // Método habilitado solo para tipos integrales
    template <typename U = T>
    typename std::enable_if<std::is_integral<U>::value, void>::type
    mostrar() const {
        std::cout << "Valor (entero): " << valor << std::endl;
    }

    // Método habilitado solo para tipos de punto flotante
    template <typename U = T>
    typename std::enable_if<std::is_floating_point<U>::value, void>::type
    mostrar() const {
        std::cout << "Valor (flotante): " << valor << std::endl;
    }
};

int main() {
    MiClase<int> obj1(42);
    obj1.mostrar();  // Muestra: Valor (entero): 42

    MiClase<double> obj2(3.14);
    obj2.mostrar();  // Muestra: Valor (flotante): 3.14

    // MiClase<std::string> obj3("Hola");  // Error en tiempo de compilación debido a static_assert

    return 0;
}
```cpp
#include <iostream>
#include <type_traits>

// Definición de la clase plantilla
template <typename T>
class MiClase {
    using TipoSeleccionado = typename std::conditional<
        std::is_integral<T>::value,
        int,
        double
    >::type;

    TipoSeleccionado valor;

public:
    MiClase(T v) : valor(v) {}

    void mostrar() const {
        if constexpr (std::is_integral<T>::value) {
            std::cout << "Valor (entero como int): " << valor << std::endl;
        } else {
            std::cout << "Valor (flotante como double): " << valor << std::endl;
        }
    }
};

int main() {
    MiClase<int> obj1(42);
    obj1.mostrar();  // Muestra: Valor (entero como int): 42

    MiClase<float> obj2(3.14f);
    obj2.mostrar();  // Muestra: Valor (flotante como double): 3.14

    return 0;
}
<---Clase Plantilla que Utiliza `TypeTraits` Result--->
