<---EXPLANATION--->
### Introducción a las Plantillas en C++

Las plantillas en C++ son una característica poderosa que permite escribir código genérico, capaz de trabajar con cualquier tipo de dato. Esto facilita la reutilización de código y la creación de funciones y clases que operan de manera eficiente con diferentes tipos de datos.

#### Definición de Plantillas de Función

Las plantillas de función permiten crear funciones que pueden trabajar con cualquier tipo de dato.

##### Ejemplo Básico

```cpp
// plantilla_funcion.cpp
#include <iostream>

template <typename T>
T obtenerMayor(T a, T b) {
    return (a > b) ? a : b;
}

int main() {
    std::cout << "Mayor entre 3 y 7: " << obtenerMayor(3, 7) << std::endl;
    std::cout << "Mayor entre 5.5 y 2.2: " << obtenerMayor(5.5, 2.2) << std::endl;
    return 0;
}
```

En este ejemplo:
- La función `obtenerMayor` utiliza una plantilla para trabajar con cualquier tipo de dato (`int`, `double`, etc.).
- La palabra clave `template` seguida de `<typename T>` define una plantilla de función donde `T` es un parámetro de tipo.

#### Definición de Plantillas de Clase

Las plantillas de clase permiten crear clases genéricas que pueden manejar diferentes tipos de datos.

##### Ejemplo Básico

```cpp
// plantilla_clase.h
#ifndef PLANTILLA_CLASE_H
#define PLANTILLA_CLASE_H

template <typename T>
class MiClase {
public:
    MiClase(T valor);
    void mostrarValor();
private:
    T valor;
};

#include "plantilla_clase.cpp"
#endif // PLANTILLA_CLASE_H
```

```cpp
// plantilla_clase.cpp
#include <iostream>
#include "plantilla_clase.h"

template <typename T>
MiClase<T>::MiClase(T v) : valor(v) {}

template <typename T>
void MiClase<T>::mostrarValor() {
    std::cout << "El valor es: " << valor << std::endl;
}
```

```cpp
// main.cpp
#include "plantilla_clase.h"

int main() {
    MiClase<int> obj1(5);
    obj1.mostrarValor();
    
    MiClase<double> obj2(3.14);
    obj2.mostrarValor();

    return 0;
}
```

En este ejemplo:
- La clase `MiClase` es una plantilla que puede manejar diferentes tipos de datos (`int`, `double`, etc.).
- La palabra clave `template` seguida de `<typename T>` define una plantilla de clase.
- La implementación de los métodos de la plantilla de clase se encuentra en un archivo separado (`plantilla_clase.cpp`), y se incluye al final del archivo de cabecera.

### Buenas Prácticas para el Uso de Plantillas

#### 1. Mantener la Implementación de Plantillas en el Archivo de Cabecera

Aunque se puede separar la declaración y la implementación de plantillas en archivos `.h` y `.cpp` respectivamente, a menudo se recomienda mantener ambas en el archivo de cabecera para evitar problemas de enlace.

##### Ejemplo

```cpp
// MiClase.h
#ifndef MICLASE_H
#define MICLASE_H

#include <iostream>

template <typename T>
class MiClase {
public:
    MiClase(T valor) : valor(valor) {}
    void mostrarValor();
private:
    T valor;
};

template <typename T>
void MiClase<T>::mostrarValor() {
    std::cout << "El valor es: " << valor << std::endl;
}

#endif // MICLASE_H
```

#### 2. Utilizar Nombres Significativos para Parámetros de Tipo

Utilice nombres de parámetros de tipo que sean significativos para mejorar la legibilidad del código.

##### Ejemplo

```cpp
template <typename Tipo>
class Contenedor {
    Tipo elemento;
public:
    Contenedor(Tipo e) : elemento(e) {}
    Tipo obtenerElemento() { return elemento; }
};
```

#### 3. Documentar las Plantillas Adecuadamente

Asegúrese de documentar las plantillas para explicar el propósito de los parámetros de tipo y cómo se deben utilizar.

##### Ejemplo

```cpp
// MiClase.h
#ifndef MICLASE_H
#define MICLASE_H

#include <iostream>

// Clase plantilla que almacena y muestra un valor de cualquier tipo
template <typename T>
class MiClase {
public:
    // Constructor que inicializa el valor
    MiClase(T valor) : valor(valor) {}
    // Muestra el valor almacenado en la salida estándar
    void mostrarValor();
private:
    T valor; // El valor almacenado, de tipo T
};

template <typename T>
void MiClase<T>::mostrarValor() {
    std::cout << "El valor es: " << valor << std::endl;
}

#endif // MICLASE_H
```

### Conclusión

Las plantillas en C++ son una herramienta poderosa para escribir código genérico y reutilizable. Al seguir buenas prácticas como mantener la implementación en el archivo de cabecera, utilizar nombres significativos para los parámetros de tipo y documentar adecuadamente, se puede crear código claro y mantenible. Las plantillas permiten a los desarrolladores escribir funciones y clases que trabajan de manera eficiente con cualquier tipo de dato, mejorando la flexibilidad y reutilización del código.
<---FILES--->
Ejemplo Básico
Ejemplo Básico Result
Ejemplo
Ejemplo Result
<---Ejemplo Básico--->
```cpp
// plantilla_clase.h
#ifndef PLANTILLA_CLASE_H
#define PLANTILLA_CLASE_H

template <typename T>
class MiClase {
public:
    MiClase(T valor);
    void mostrarValor();
private:
    T valor;
};

#include "plantilla_clase.cpp"
#endif // PLANTILLA_CLASE_H
```cpp
// plantilla_clase.cpp
#include <iostream>
#include "plantilla_clase.h"

template <typename T>
MiClase<T>::MiClase(T v) : valor(v) {}

template <typename T>
void MiClase<T>::mostrarValor() {
    std::cout << "El valor es: " << valor << std::endl;
}
```cpp
// main.cpp
#include "plantilla_clase.h"

int main() {
    MiClase<int> obj1(5);
    obj1.mostrarValor();
    
    MiClase<double> obj2(3.14);
    obj2.mostrarValor();

    return 0;
}
<---Ejemplo Básico Result--->
<---Ejemplo--->
```cpp
// MiClase.h
#ifndef MICLASE_H
#define MICLASE_H

#include <iostream>

// Clase plantilla que almacena y muestra un valor de cualquier tipo
template <typename T>
class MiClase {
public:
    // Constructor que inicializa el valor
    MiClase(T valor) : valor(valor) {}
    // Muestra el valor almacenado en la salida estándar
    void mostrarValor();
private:
    T valor; // El valor almacenado, de tipo T
};

template <typename T>
void MiClase<T>::mostrarValor() {
    std::cout << "El valor es: " << valor << std::endl;
}

#endif // MICLASE_H
<---Ejemplo Result--->
