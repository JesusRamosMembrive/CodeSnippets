<---EXPLANATION--->
### Algoritmo de la Biblioteca Estándar: `std::set_union`

El algoritmo `std::set_union` es parte de la biblioteca estándar de C++ y se utiliza para combinar dos rangos ordenados en un solo rango ordenado que contiene todos los elementos de ambos rangos, sin duplicados. Es parte del encabezado `<algorithm>`.

#### Sintaxis de `std::set_union`

```cpp
#include <algorithm>

template <class InputIt1, class InputIt2, class OutputIt>
OutputIt set_union(InputIt1 first1, InputIt1 last1, InputIt2 first2, InputIt2 last2, OutputIt d_first);

template <class InputIt1, class InputIt2, class OutputIt, class Compare>
OutputIt set_union(InputIt1 first1, InputIt1 last1, InputIt2 first2, InputIt2 last2, OutputIt d_first, Compare comp);
```

- **`InputIt1 first1`**: Iterador al primer elemento del primer rango.
- **`InputIt1 last1`**: Iterador al elemento después del último en el primer rango.
- **`InputIt2 first2`**: Iterador al primer elemento del segundo rango.
- **`InputIt2 last2`**: Iterador al elemento después del último en el segundo rango.
- **`OutputIt d_first`**: Iterador al primer elemento del rango de destino.
- **`Compare comp`**: (Opcional) Función de comparación que toma dos argumentos.

#### Descripción

`std::set_union` fusiona los elementos de los dos rangos ordenados `[first1, last1)` y `[first2, last2)` en un solo rango ordenado comenzando en `d_first`. El rango de salida contiene todos los elementos de los dos rangos de entrada, sin duplicados. Si se proporciona una función de comparación `comp`, se utiliza para comparar los elementos en lugar del operador `<`.

#### Ejemplo de Uso de `std::set_union`

##### Ejemplo Básico

```cpp
#include <iostream>
#include <vector>
#include <algorithm>

int main() {
    std::vector<int> vec1 = {1, 3, 5, 7};
    std::vector<int> vec2 = {2, 3, 5, 8};
    std::vector<int> result;

    // Reservar espacio suficiente para el resultado
    result.reserve(vec1.size() + vec2.size());

    // Usar std::set_union para fusionar los dos vectores ordenados
    auto it = std::set_union(vec1.begin(), vec1.end(), vec2.begin(), vec2.end(), std::back_inserter(result));

    // Mostrar los elementos fusionados
    std::cout << "Elementos de la unión: ";
    for (int elem : result) {
        std::cout << elem << " ";
    }
    std::cout << std::endl;

    return 0;
}
```

En este ejemplo:
- `std::set_union(vec1.begin(), vec1.end(), vec2.begin(), vec2.end(), std::back_inserter(result))` fusiona los elementos de `vec1` y `vec2` en `result` sin duplicados.

### Uso con Comparación Personalizada

`std::set_union` puede utilizar una función de comparación personalizada para ordenar según un criterio específico.

##### Ejemplo con Comparación Personalizada

```cpp
#include <iostream>
#include <vector>
#include <algorithm>

struct Persona {
    std::string nombre;
    int edad;
};

bool compararPorEdad(const Persona& a, const Persona& b) {
    return a.edad < b.edad;
}

int main() {
    std::vector<Persona> grupo1 = {{"Ana", 25}, {"Carlos", 30}};
    std::vector<Persona> grupo2 = {{"Luis", 22}, {"Maria", 28}};
    std::vector<Persona> resultado;

    // Ordenar los vectores por edad
    std::sort(grupo1.begin(), grupo1.end(), compararPorEdad);
    std::sort(grupo2.begin(), grupo2.end(), compararPorEdad);

    // Usar std::set_union con comparación personalizada para fusionar los dos vectores ordenados
    std::set_union(grupo1.begin(), grupo1.end(), grupo2.begin(), grupo2.end(), std::back_inserter(resultado), compararPorEdad);

    // Mostrar las personas en la unión
    std::cout << "Personas en la unión: ";
    for (const auto& persona : resultado) {
        std::cout << persona.nombre << " (" << persona.edad << "), ";
    }
    std::cout << std::endl;

    return 0;
}
```

En este ejemplo:
- `std::set_union(grupo1.begin(), grupo1.end(), grupo2.begin(), grupo2.end(), std::back_inserter(resultado), compararPorEdad)` fusiona los elementos de `grupo1` y `grupo2` en `resultado` utilizando la función de comparación `compararPorEdad`.

### Consideraciones

- **Rendimiento:** `std::set_union` tiene una complejidad lineal (`O(N + M)`), donde `N` y `M` son los tamaños de los dos rangos de entrada.
- **Orden:** Los rangos de entrada deben estar ordenados según el mismo criterio de comparación (ya sea por el operador `<` o una función de comparación personalizada).
- **Tamaño del Rango de Salida:** El rango de salida debe ser lo suficientemente grande para contener todos los elementos fusionados. Utilizar `std::back_inserter` puede ser conveniente para manejar esto automáticamente.

### Variantes Relacionadas

Existen otros algoritmos similares que trabajan con conjuntos ordenados, como `std::set_intersection`, `std::set_difference` y `std::set_symmetric_difference`, cada uno de los cuales realiza una operación específica sobre dos conjuntos ordenados.

#### `std::set_intersection`

Copia los elementos presentes en ambos rangos ordenados.

##### Sintaxis

```cpp
template <class InputIt1, class InputIt2, class OutputIt>
OutputIt set_intersection(InputIt1 first1, InputIt1 last1, InputIt2 first2, InputIt2 last2, OutputIt d_first);

template <class InputIt1, class InputIt2, class OutputIt, class Compare>
OutputIt set_intersection(InputIt1 first1, InputIt1 last1, InputIt2 first2, InputIt2 last2, OutputIt d_first, Compare comp);
```

#### `std::set_difference`

Copia los elementos presentes en el primer rango pero no en el segundo.

##### Sintaxis

```cpp
template <class InputIt1, class InputIt2, class OutputIt>
OutputIt set_difference(InputIt1 first1, InputIt1 last1, InputIt2 first2, InputIt2 last2, OutputIt d_first);

template <class InputIt1, class InputIt2, class OutputIt, class Compare>
OutputIt set_difference(InputIt1 first1, InputIt1 last1, InputIt2 first2, InputIt2 last2, OutputIt d_first, Compare comp);
```

#### `std::set_symmetric_difference`

Copia los elementos presentes en exactamente uno de los dos rangos ordenados.

##### Sintaxis

```cpp
template <class InputIt1, class InputIt2, class OutputIt>
OutputIt set_symmetric_difference(InputIt1 first1, InputIt1 last1, InputIt2 first2, InputIt2 last2, OutputIt d_first);

template <class InputIt1, class InputIt2, class OutputIt, class Compare>
OutputIt set_symmetric_difference(InputIt1 first1, InputIt1 last1, InputIt2 first2, InputIt2 last2, OutputIt d_first, Compare comp);
```

### Conclusión

`std::set_union` es un algoritmo eficiente de la biblioteca estándar de C++ que permite combinar dos rangos ordenados en un solo rango ordenado sin duplicados. Es fundamental para trabajar con conjuntos de datos ordenados y puede utilizar comparaciones personalizadas para manejar criterios específicos. Comprender y utilizar `std::set_union`, junto con otros algoritmos relacionados como `std::set_intersection`, `std::set_difference` y `std::set_symmetric_difference`, es esencial para realizar operaciones de conjuntos eficientes en C++.
<---FILES--->
Ejemplo Básico
Ejemplo Básico Result
Ejemplo con Comparación Personalizada
Ejemplo con Comparación Personalizada Result
Sintaxis
Sintaxis Result
<---Ejemplo Básico--->
```cpp
#include <iostream>
#include <vector>
#include <algorithm>

int main() {
    std::vector<int> vec1 = {1, 3, 5, 7};
    std::vector<int> vec2 = {2, 3, 5, 8};
    std::vector<int> result;

    // Reservar espacio suficiente para el resultado
    result.reserve(vec1.size() + vec2.size());

    // Usar std::set_union para fusionar los dos vectores ordenados
    auto it = std::set_union(vec1.begin(), vec1.end(), vec2.begin(), vec2.end(), std::back_inserter(result));

    // Mostrar los elementos fusionados
    std::cout << "Elementos de la unión: ";
    for (int elem : result) {
        std::cout << elem << " ";
    }
    std::cout << std::endl;

    return 0;
}
<---Ejemplo Básico Result--->
<---Ejemplo con Comparación Personalizada--->
```cpp
#include <iostream>
#include <vector>
#include <algorithm>

struct Persona {
    std::string nombre;
    int edad;
};

bool compararPorEdad(const Persona& a, const Persona& b) {
    return a.edad < b.edad;
}

int main() {
    std::vector<Persona> grupo1 = {{"Ana", 25}, {"Carlos", 30}};
    std::vector<Persona> grupo2 = {{"Luis", 22}, {"Maria", 28}};
    std::vector<Persona> resultado;

    // Ordenar los vectores por edad
    std::sort(grupo1.begin(), grupo1.end(), compararPorEdad);
    std::sort(grupo2.begin(), grupo2.end(), compararPorEdad);

    // Usar std::set_union con comparación personalizada para fusionar los dos vectores ordenados
    std::set_union(grupo1.begin(), grupo1.end(), grupo2.begin(), grupo2.end(), std::back_inserter(resultado), compararPorEdad);

    // Mostrar las personas en la unión
    std::cout << "Personas en la unión: ";
    for (const auto& persona : resultado) {
        std::cout << persona.nombre << " (" << persona.edad << "), ";
    }
    std::cout << std::endl;

    return 0;
}
<---Ejemplo con Comparación Personalizada Result--->
<---Sintaxis--->
```cpp
template <class InputIt1, class InputIt2, class OutputIt>
OutputIt set_symmetric_difference(InputIt1 first1, InputIt1 last1, InputIt2 first2, InputIt2 last2, OutputIt d_first);

template <class InputIt1, class InputIt2, class OutputIt, class Compare>
OutputIt set_symmetric_difference(InputIt1 first1, InputIt1 last1, InputIt2 first2, InputIt2 last2, OutputIt d_first, Compare comp);
<---Sintaxis Result--->
