<---EXPLANATION--->
### Gestión de Memoria en C++

La gestión de memoria en C++ es un aspecto fundamental que todo desarrollador debe entender profundamente para evitar errores comunes como fugas de memoria y accesos inválidos. A diferencia de lenguajes de programación que manejan la memoria automáticamente, C++ permite y requiere que el programador gestione la asignación y liberación de memoria.

#### Tipos de Memoria en C++

En C++, la memoria se puede clasificar en dos tipos principales: memoria estática y memoria dinámica.

1. **Memoria Estática**: Se asigna en el tiempo de compilación. Incluye variables globales, variables estáticas y constantes.
2. **Memoria Dinámica**: Se asigna en el tiempo de ejecución usando operadores como `new` y `delete`.

#### Asignación y Liberación de Memoria

##### Memoria Estática

La memoria estática se gestiona automáticamente. Por ejemplo:

```cpp
#include <iostream>

int globalVariable = 10; // Variable global (memoria estática)

int main() {
    static int staticVariable = 20; // Variable estática local (memoria estática)
    return 0;
}
```

##### Memoria Dinámica

La memoria dinámica se asigna y libera manualmente usando `new` y `delete` para variables simples, y `new[]` y `delete[]` para arreglos.

##### Ejemplo Básico de Asignación Dinámica

```cpp
#include <iostream>

int main() {
    int* ptr = new int; // Asignar memoria para un entero
    *ptr = 100; // Usar la memoria asignada
    std::cout << *ptr << std::endl; // Salida: 100
    delete ptr; // Liberar la memoria

    return 0;
}
```

##### Ejemplo de Arreglo Dinámico

```cpp
#include <iostream>

int main() {
    int size = 5;
    int* array = new int[size]; // Asignar memoria para un arreglo de enteros

    for(int i = 0; i < size; ++i) {
        array[i] = i * 10; // Inicializar el arreglo
    }

    for(int i = 0; i < size; ++i) {
        std::cout << array[i] << " "; // Salida: 0 10 20 30 40
    }
    std::cout << std::endl;

    delete[] array; // Liberar la memoria

    return 0;
}
```

### Buenas Prácticas para la Gestión de Memoria

#### 1. Siempre Liberar la Memoria Asignada

No liberar la memoria asignada dinámicamente resulta en fugas de memoria, lo que puede llevar a que una aplicación consuma más memoria de la necesaria y eventualmente falle.

##### Ejemplo Incorrecto

```cpp
int* ptr = new int; // Asignar memoria
// ... uso de ptr
// Olvidar liberar la memoria: fuga de memoria
```

##### Ejemplo Correcto

```cpp
int* ptr = new int; // Asignar memoria
// ... uso de ptr
delete ptr; // Liberar memoria
```

#### 2. Usar Smart Pointers

Los punteros inteligentes (`smart pointers`) en la biblioteca estándar de C++ (`std::unique_ptr`, `std::shared_ptr`, etc.) ayudan a manejar la memoria de manera automática y evitar fugas de memoria.

##### Ejemplo con `std::unique_ptr`

```cpp
#include <iostream>
#include <memory>

int main() {
    std::unique_ptr<int> ptr = std::make_unique<int>(100); // Asignar memoria
    std::cout << *ptr << std::endl; // Salida: 100
    // Memoria se libera automáticamente cuando ptr sale del alcance

    return 0;
}
```

#### 3. Evitar Accesos Inválidos a Memoria

Acceder a memoria después de haberla liberado resulta en comportamiento indefinido. Siempre asegúrese de no usar punteros después de haber llamado a `delete`.

##### Ejemplo Incorrecto

```cpp
int* ptr = new int(10);
delete ptr; // Liberar memoria
std::cout << *ptr << std::endl; // Acceso inválido: comportamiento indefinido
```

##### Ejemplo Correcto

```cpp
int* ptr = new int(10);
delete ptr; // Liberar memoria
ptr = nullptr; // Evitar acceso inválido
```

### Gestión de Memoria en Clases

Cuando se diseñan clases que manejan recursos dinámicos, es esencial implementar correctamente el constructor de copia, el operador de asignación y el destructor.

#### Ejemplo: Clase con Gestión de Memoria

```cpp
#include <iostream>
#include <cstring>

class String {
private:
    char* data;
    size_t size;

public:
    String(const char* str) {
        size = strlen(str);
        data = new char[size + 1];
        strcpy(data, str);
    }

    ~String() {
        delete[] data;
    }

    // Constructor de copia
    String(const String& other) {
        size = other.size;
        data = new char[size + 1];
        strcpy(data, other.data);
    }

    // Operador de asignación
    String& operator=(const String& other) {
        if (this == &other) return *this;

        delete[] data;

        size = other.size;
        data = new char[size + 1];
        strcpy(data, other.data);
        return *this;
    }

    void print() const {
        std::cout << data << std::endl;
    }
};

int main() {
    String str1("Hello");
    String str2 = str1; // Constructor de copia
    String str3("World");
    str3 = str1; // Operador de asignación
    str1.print(); // Salida: Hello
    str2.print(); // Salida: Hello
    str3.print(); // Salida: Hello

    return 0;
}
```

### Conclusión

La gestión de memoria en C++ es un tema crítico que requiere atención cuidadosa para evitar errores como fugas de memoria y accesos inválidos. El uso de buenas prácticas como liberar memoria correctamente, usar punteros inteligentes y manejar adecuadamente la memoria en clases asegura que las aplicaciones sean eficientes y robustas. Al entender y aplicar estos conceptos, los desarrolladores pueden escribir código más seguro y mantenible.
<---FILES--->
Memoria Estática
Memoria Estática Result
Memoria Dinámica
Memoria Dinámica Result
Ejemplo Básico de Asignación Dinámica
Ejemplo Básico de Asignación Dinámica Result
Ejemplo de Arreglo Dinámico
Ejemplo de Arreglo Dinámico Result
Ejemplo Incorrecto
Ejemplo Incorrecto Result
Ejemplo Correcto
Ejemplo Correcto Result
Ejemplo con `std::unique_ptr`
Ejemplo con `std::unique_ptr` Result
<---Memoria Estática--->
```cpp
#include <iostream>

int globalVariable = 10; // Variable global (memoria estática)

int main() {
    static int staticVariable = 20; // Variable estática local (memoria estática)
    return 0;
}
<---Memoria Estática Result--->
<---Memoria Dinámica--->
<---Memoria Dinámica Result--->
<---Ejemplo Básico de Asignación Dinámica--->
```cpp
#include <iostream>

int main() {
    int* ptr = new int; // Asignar memoria para un entero
    *ptr = 100; // Usar la memoria asignada
    std::cout << *ptr << std::endl; // Salida: 100
    delete ptr; // Liberar la memoria

    return 0;
}
<---Ejemplo Básico de Asignación Dinámica Result--->
<---Ejemplo de Arreglo Dinámico--->
```cpp
#include <iostream>

int main() {
    int size = 5;
    int* array = new int[size]; // Asignar memoria para un arreglo de enteros

    for(int i = 0; i < size; ++i) {
        array[i] = i * 10; // Inicializar el arreglo
    }

    for(int i = 0; i < size; ++i) {
        std::cout << array[i] << " "; // Salida: 0 10 20 30 40
    }
    std::cout << std::endl;

    delete[] array; // Liberar la memoria

    return 0;
}
<---Ejemplo de Arreglo Dinámico Result--->
<---Ejemplo Incorrecto--->
```cpp
int* ptr = new int(10);
delete ptr; // Liberar memoria
std::cout << *ptr << std::endl; // Acceso inválido: comportamiento indefinido
<---Ejemplo Incorrecto Result--->
<---Ejemplo Correcto--->
```cpp
int* ptr = new int(10);
delete ptr; // Liberar memoria
ptr = nullptr; // Evitar acceso inválido
```cpp
#include <iostream>
#include <cstring>

class String {
private:
    char* data;
    size_t size;

public:
    String(const char* str) {
        size = strlen(str);
        data = new char[size + 1];
        strcpy(data, str);
    }

    ~String() {
        delete[] data;
    }

    // Constructor de copia
    String(const String& other) {
        size = other.size;
        data = new char[size + 1];
        strcpy(data, other.data);
    }

    // Operador de asignación
    String& operator=(const String& other) {
        if (this == &other) return *this;

        delete[] data;

        size = other.size;
        data = new char[size + 1];
        strcpy(data, other.data);
        return *this;
    }

    void print() const {
        std::cout << data << std::endl;
    }
};

int main() {
    String str1("Hello");
    String str2 = str1; // Constructor de copia
    String str3("World");
    str3 = str1; // Operador de asignación
    str1.print(); // Salida: Hello
    str2.print(); // Salida: Hello
    str3.print(); // Salida: Hello

    return 0;
}
<---Ejemplo Correcto Result--->
<---Ejemplo con `std::unique_ptr`--->
```cpp
#include <iostream>
#include <memory>

int main() {
    std::unique_ptr<int> ptr = std::make_unique<int>(100); // Asignar memoria
    std::cout << *ptr << std::endl; // Salida: 100
    // Memoria se libera automáticamente cuando ptr sale del alcance

    return 0;
}
<---Ejemplo con `std::unique_ptr` Result--->
