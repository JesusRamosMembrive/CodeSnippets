<---FILES--->
main.cpp
result

<---main.cpp--->
#include <iostream>
#include <algorithm>

class Ejemplo {
private:
    int* data;
    int size;

public:
    // Constructor
    Ejemplo(int size) : size(size) {
        data = new int[size];
    }

    // Destructor
    ~Ejemplo() {
        delete[] data;
    }

    // Constructor de copia
    Ejemplo(const Ejemplo& other) : size(other.size) {
        data = new int[other.size];
        std::copy(other.data, other.data + other.size, data);
    }

    // Operador de asignación de copia
    Ejemplo& operator=(const Ejemplo& other) {
        if (this != &other) {
            delete[] data;
            size = other.size;
            data = new int[other.size];
            std::copy(other.data, other.data + other.size, data);
        }
        return *this;
    }

    // Constructor de movimiento
    Ejemplo(Ejemplo&& other) noexcept : data(other.data), size(other.size) {
        other.data = nullptr;
        other.size = 0;
    }

    // Operador de asignación de movimiento
    Ejemplo& operator=(Ejemplo&& other) noexcept {
        if (this != &other) {
            delete[] data;
            data = other.data;
            size = other.size;
            other.data = nullptr;
            other.size = 0;
        }
        return *this;
    }
};

int main() {
    Ejemplo e1(10);  // Create an instance with an array of size 10
    Ejemplo e2 = e1; // Use the copy constructor

    Ejemplo e3(5);
    e3 = e1;         // Use the copy assignment operator

    Ejemplo e4 = std::move(e1); // Use the move constructor
    Ejemplo e5(15);
    e5 = std::move(e3);         // Use the move assignment operator

    return 0;
}


<---result--->
No hay print que mostrar.

<---EXPLANATION--->
### Destructores en C++

Un destructor es una función miembro especial de una clase que se llama automáticamente cuando un objeto de esa clase se destruye. Los destructores se utilizan para liberar recursos que el objeto pueda haber adquirido durante su vida, como memoria dinámica, archivos abiertos, o conexiones de red. El uso adecuado de destructores asegura que los recursos se gestionen de manera correcta, evitando fugas de memoria y otros problemas.

#### Características del Destructor

1. **Mismo Nombre que la Clase:** El destructor tiene el mismo nombre que la clase, precedido por un tilde (`~`).
2. **Sin Parámetros:** Un destructor no toma parámetros ni tiene un tipo de retorno.
3. **Automático:** Se llama automáticamente cuando un objeto sale de alcance o se elimina.
4. **Único:** Una clase puede tener solo un destructor.

##### Sintaxis del Destructor

```cpp
class NombreClase {
public:
    // Constructor
    NombreClase();

    // Destructor
    ~NombreClase();

    // Otros métodos y atributos
};
```

##### Ejemplo Básico de Destructor

```cpp
#include <iostream>
using namespace std;

class Persona {
public:
    string nombre;

    // Constructor
    Persona(string n) : nombre(n) {
        cout << "Constructor llamado para " << nombre << endl;
    }

    // Destructor
    ~Persona() {
        cout << "Destructor llamado para " << nombre << endl;
    }
};

int main() {
    Persona juan("Juan");
    {
        Persona maria("Maria");
    } // Destructor llamado para maria aquí

    cout << "Fin del main" << endl;
    return 0; // Destructor llamado para juan aquí
}
```

En este ejemplo, el destructor se llama automáticamente cuando los objetos `juan` y `maria` salen de su alcance.

#### Destructores y Recursos Dinámicos

Los destructores son especialmente importantes cuando una clase maneja recursos dinámicos, como memoria asignada dinámicamente, archivos, o conexiones de red. El destructor asegura que estos recursos se liberen correctamente cuando el objeto ya no se necesita.

##### Ejemplo con Recursos Dinámicos

```cpp
#include <iostream>
using namespace std;

class Array {
private:
    int* data;
    int size;

public:
    // Constructor
    Array(int s) : size(s) {
        data = new int[size]; // Asignar memoria dinámica
        cout << "Array de tamaño " << size << " creado." << endl;
    }

    // Destructor
    ~Array() {
        delete[] data; // Liberar memoria dinámica
        cout << "Array de tamaño " << size << " destruido." << endl;
    }

    // Método para establecer un valor en el array
    void setValue(int index, int value) {
        if (index >= 0 && index < size) {
            data[index] = value;
        }
    }

    // Método para obtener un valor del array
    int getValue(int index) const {
        if (index >= 0 && index < size) {
            return data[index];
        }
        return -1; // Valor de error
    }
};

int main() {
    Array arr(5);
    arr.setValue(0, 10);
    arr.setValue(1, 20);
    cout << "Valor en la posición 0: " << arr.getValue(0) << endl;
    cout << "Valor en la posición 1: " << arr.getValue(1) << endl;

    return 0;
}
```

En este ejemplo, el destructor de la clase `Array` se asegura de liberar la memoria asignada dinámicamente cuando el objeto `arr` se destruye.

#### Destructores en Clases Derivadas

En una jerarquía de herencia, los destructores de las clases base y derivadas se llaman en el orden correcto. Si una clase base tiene un destructor virtual, asegura que el destructor de la clase derivada se llame correctamente cuando se elimina un objeto a través de un puntero a la clase base.

##### Ejemplo con Herencia

```cpp
#include <iostream>
using namespace std;

class Base {
public:
    // Constructor
    Base() {
        cout << "Constructor de Base" << endl;
    }

    // Destructor virtual
    virtual ~Base() {
        cout << "Destructor de Base" << endl;
    }
};

class Derivada : public Base {
public:
    // Constructor
    Derivada() {
        cout << "Constructor de Derivada" << endl;
    }

    // Destructor
    ~Derivada() {
        cout << "Destructor de Derivada" << endl;
    }
};

int main() {
    Base* obj = new Derivada(); // Crear objeto de clase derivada
    delete obj; // Llamar al destructor virtual

    return 0;
}
```

En este ejemplo, el destructor de `Base` es virtual, asegurando que el destructor de `Derivada` se llame correctamente cuando el objeto se elimina a través de un puntero a la clase base.

#### Regla de Tres, Cinco y Cero

La "regla de tres" establece que si una clase necesita un destructor explícito, probablemente también necesite un constructor de copia y un operador de asignación de copia. La "regla de cinco" extiende esto a las operaciones de movimiento en C++11 y posteriores. La "regla de cero" sugiere usar tipos RAII (Resource Acquisition Is Initialization) para manejar recursos automáticamente, evitando la necesidad de destructores personalizados, constructores de copia, y operadores de asignación.

##### Regla de Tres

```cpp
class Ejemplo {
private:
    int* data;

public:
    // Constructor
    Ejemplo(int size) {
        data = new int[size];
    }

    // Destructor
    ~Ejemplo() {
        delete[] data;
    }

    // Constructor de copia
    Ejemplo(const Ejemplo& other) {
        data = new int[other.size];
        // Copiar datos...
    }

    // Operador de asignación de copia
    Ejemplo& operator=(const Ejemplo& other) {
        if (this != &other) {
            delete[] data;
            data = new int[other.size];
            // Copiar datos...
        }
        return *this;
    }
};
```

##### Regla de Cinco

```cpp
class Ejemplo {
private:
    int* data;

public:
    // Constructor
    Ejemplo(int size) {
        data = new int[size];
    }

    // Destructor
    ~Ejemplo() {
        delete[] data;
    }

    // Constructor de copia
    Ejemplo(const Ejemplo& other) {
        data = new int[other.size];
        // Copiar datos...
    }

    // Operador de asignación de copia
    Ejemplo& operator=(const Ejemplo& other) {
        if (this != &other) {
            delete[] data;
            data = new int[other.size];
            // Copiar datos...
        }
        return *this;
    }

    // Constructor de movimiento
    Ejemplo(Ejemplo&& other) noexcept : data(other.data) {
        other.data = nullptr;
    }

    // Operador de asignación de movimiento
    Ejemplo& operator=(Ejemplo&& other) noexcept {
        if (this != &other) {
            delete[] data;
            data = other.data;
            other.data = nullptr;
        }
        return *this;
    }
};
```

### Conclusión

Los destructores son una parte esencial de la administración de recursos en C++. Aseguran que los recursos adquiridos por un objeto se liberen adecuadamente cuando el objeto ya no se necesita. Entender cómo y cuándo implementar destructores, junto con las reglas de tres, cinco y cero, permite a los desarrolladores escribir código más seguro y eficiente, gestionando correctamente la memoria y otros recursos.