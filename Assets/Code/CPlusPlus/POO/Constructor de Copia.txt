<---EXPLANATION--->
### Constructor de Copia en C++

El constructor de copia es un tipo especial de constructor en C++ que se utiliza para crear un nuevo objeto como una copia de un objeto existente. Este constructor es fundamental para el manejo adecuado de la copia de objetos, especialmente cuando estos objetos manejan recursos dinámicos como memoria, archivos, o conexiones de red.

#### Definición del Constructor de Copia

El constructor de copia toma una referencia constante a un objeto del mismo tipo y copia los valores de sus atributos al nuevo objeto. La sintaxis general para declarar un constructor de copia es la siguiente:

```cpp
class Clase {
public:
    Clase(const Clase& other); // Constructor de copia
    // Otros miembros...
};
```

#### Ejemplo Básico de Constructor de Copia

Consideremos una clase `Persona` que tiene un nombre y una edad. Implementemos un constructor de copia para esta clase.

```cpp
#include <iostream>
#include <string>
using namespace std;

class Persona {
private:
    string nombre;
    int edad;

public:
    // Constructor parametrizado
    Persona(string n, int e) : nombre(n), edad(e) {}

    // Constructor de copia
    Persona(const Persona& other) {
        nombre = other.nombre;
        edad = other.edad;
    }

    // Método para mostrar la información
    void mostrar() const {
        cout << "Nombre: " << nombre << ", Edad: " << edad << endl;
    }
};

int main() {
    Persona p1("Juan", 30);
    Persona p2 = p1; // Llamada al constructor de copia

    p1.mostrar();
    p2.mostrar();

    return 0;
}
```

En este ejemplo, el constructor de copia copia los valores de `nombre` y `edad` de `p1` a `p2`.

#### Importancia del Constructor de Copia

El constructor de copia es crucial en situaciones donde los objetos manejan recursos dinámicos. Sin un constructor de copia adecuado, el compilador genera un constructor de copia por defecto que realiza una copia superficial, lo que puede llevar a problemas como la doble liberación de memoria.

##### Problema de la Copia Superficial

```cpp
class Cadena {
private:
    char* str;

public:
    // Constructor parametrizado
    Cadena(const char* s) {
        str = new char[strlen(s) + 1];
        strcpy(str, s);
    }

    // Destructor
    ~Cadena() {
        delete[] str;
    }

    // Constructor de copia por defecto (copia superficial)
    // Cadena(const Cadena& other) = default;

    // Método para mostrar la cadena
    void mostrar() const {
        cout << str << endl;
    }
};

int main() {
    Cadena c1("Hola");
    Cadena c2 = c1; // Copia superficial

    c1.mostrar();
    c2.mostrar();

    return 0;
}
```

En este ejemplo, `c2` realiza una copia superficial de `c1`, lo que significa que ambos objetos `c1` y `c2` apuntan a la misma ubicación de memoria. Esto puede causar problemas cuando se destruyen los objetos, ya que ambos intentarán liberar la misma memoria.

##### Solución con Constructor de Copia Profunda

```cpp
class Cadena {
private:
    char* str;

public:
    // Constructor parametrizado
    Cadena(const char* s) {
        str = new char[strlen(s) + 1];
        strcpy(str, s);
    }

    // Destructor
    ~Cadena() {
        delete[] str;
    }

    // Constructor de copia (copia profunda)
    Cadena(const Cadena& other) {
        str = new char[strlen(other.str) + 1];
        strcpy(str, other.str);
    }

    // Método para mostrar la cadena
    void mostrar() const {
        cout << str << endl;
    }
};

int main() {
    Cadena c1("Hola");
    Cadena c2 = c1; // Copia profunda

    c1.mostrar();
    c2.mostrar();

    return 0;
}
```

En este ejemplo, el constructor de copia realiza una copia profunda, lo que significa que `c2` tiene su propia copia de la cadena de caracteres, eliminando así el problema de la doble liberación de memoria.

#### Regla de Tres

La regla de tres establece que si una clase necesita un destructor explícito, un constructor de copia o un operador de asignación de copia, probablemente necesite los tres. Esto se debe a que todas estas funciones están relacionadas con la gestión de recursos.

##### Ejemplo Completo con la Regla de Tres

```cpp
class Recurso {
private:
    int* data;

public:
    // Constructor parametrizado
    Recurso(int valor) {
        data = new int(valor);
    }

    // Destructor
    ~Recurso() {
        delete data;
    }

    // Constructor de copia
    Recurso(const Recurso& other) {
        data = new int(*other.data);
    }

    // Operador de asignación de copia
    Recurso& operator=(const Recurso& other) {
        if (this != &other) {
            delete data;
            data = new int(*other.data);
        }
        return *this;
    }

    // Método para mostrar el valor
    void mostrar() const {
        cout << "Valor: " << *data << endl;
    }
};

int main() {
    Recurso r1(10);
    Recurso r2 = r1; // Llamada al constructor de copia
    Recurso r3(20);
    r3 = r1; // Llamada al operador de asignación de copia

    r1.mostrar();
    r2.mostrar();
    r3.mostrar();

    return 0;
}
```

En este ejemplo, la clase `Recurso` implementa la regla de tres, asegurando una gestión adecuada de la memoria dinámica.

### Conclusión

El constructor de copia es una característica esencial en C++ para la correcta gestión de la copia de objetos, especialmente cuando estos manejan recursos dinámicos. Implementar un constructor de copia adecuada previene problemas relacionados con copias superficiales y doble liberación de memoria. La regla de tres asegura que los destructores, constructores de copia y operadores de asignación de copia estén correctamente implementados para garantizar la integridad y eficiencia del manejo de recursos en las clases.
<---FILES--->
Problema de la Copia Superficial
Problema de la Copia Superficial Result
Solución con Constructor de Copia Profunda
Solución con Constructor de Copia Profunda Result
Ejemplo Completo con la Regla de Tres
Ejemplo Completo con la Regla de Tres Result
<---Problema de la Copia Superficial--->
```cpp
class Cadena {
private:
    char* str;

public:
    // Constructor parametrizado
    Cadena(const char* s) {
        str = new char[strlen(s) + 1];
        strcpy(str, s);
    }

    // Destructor
    ~Cadena() {
        delete[] str;
    }

    // Constructor de copia por defecto (copia superficial)
    // Cadena(const Cadena& other) = default;

    // Método para mostrar la cadena
    void mostrar() const {
        cout << str << endl;
    }
};

int main() {
    Cadena c1("Hola");
    Cadena c2 = c1; // Copia superficial

    c1.mostrar();
    c2.mostrar();

    return 0;
}
<---Problema de la Copia Superficial Result--->
<---Solución con Constructor de Copia Profunda--->
```cpp
class Cadena {
private:
    char* str;

public:
    // Constructor parametrizado
    Cadena(const char* s) {
        str = new char[strlen(s) + 1];
        strcpy(str, s);
    }

    // Destructor
    ~Cadena() {
        delete[] str;
    }

    // Constructor de copia (copia profunda)
    Cadena(const Cadena& other) {
        str = new char[strlen(other.str) + 1];
        strcpy(str, other.str);
    }

    // Método para mostrar la cadena
    void mostrar() const {
        cout << str << endl;
    }
};

int main() {
    Cadena c1("Hola");
    Cadena c2 = c1; // Copia profunda

    c1.mostrar();
    c2.mostrar();

    return 0;
}
<---Solución con Constructor de Copia Profunda Result--->
<---Ejemplo Completo con la Regla de Tres--->
```cpp
class Recurso {
private:
    int* data;

public:
    // Constructor parametrizado
    Recurso(int valor) {
        data = new int(valor);
    }

    // Destructor
    ~Recurso() {
        delete data;
    }

    // Constructor de copia
    Recurso(const Recurso& other) {
        data = new int(*other.data);
    }

    // Operador de asignación de copia
    Recurso& operator=(const Recurso& other) {
        if (this != &other) {
            delete data;
            data = new int(*other.data);
        }
        return *this;
    }

    // Método para mostrar el valor
    void mostrar() const {
        cout << "Valor: " << *data << endl;
    }
};

int main() {
    Recurso r1(10);
    Recurso r2 = r1; // Llamada al constructor de copia
    Recurso r3(20);
    r3 = r1; // Llamada al operador de asignación de copia

    r1.mostrar();
    r2.mostrar();
    r3.mostrar();

    return 0;
}
<---Ejemplo Completo con la Regla de Tres Result--->
