<---FILES--->
main.cpp
result

<---main.cpp--->
#include <iostream>
using namespace std;

class Base {
private:
    int datoPrivado;

protected:
    int datoProtegido;

public:
    int datoPublico;

    Base(int priv, int prot, int pub) : datoPrivado(priv), datoProtegido(prot), datoPublico(pub) {}

    int getDatoPrivado() const {
        return datoPrivado;
    }

    int getDatoProtegido() const {
        return datoProtegido;
    }
};

class Derivada : public Base {
public:
    Derivada(int priv, int prot, int pub) : Base(priv, prot, pub) {}

    void mostrarDatos() {
        // cout << "Dato privado: " << getDatoPrivado() << endl; // No se puede acceder directamente
        cout << "Dato protegido: " << getDatoProtegido() << endl;
        cout << "Dato público: " << datoPublico << endl;
    }
};

int main() {
    Derivada obj(1, 2, 3);
    obj.mostrarDatos();

    return 0;
}


<---result--->
Dato protegido: 2
Dato pÃºblico: 3

<---EXPLANATION--->
### Encapsulamiento en C++

El encapsulamiento es uno de los principios fundamentales de la programación orientada a objetos (POO). Este principio consiste en ocultar los detalles internos de la implementación de una clase y proporcionar una interfaz pública para interactuar con los objetos de esa clase. El encapsulamiento ayuda a proteger los datos y a mantener la integridad del estado del objeto, facilitando la modularidad y el mantenimiento del código.

#### Conceptos Clave del Encapsulamiento

1. **Acceso Controlado:** Solo los métodos permitidos pueden acceder o modificar los datos de un objeto.
2. **Ocultamiento de Información:** Los detalles internos de la implementación se ocultan al usuario.
3. **Interfaz Pública:** Se proporciona una interfaz clara y estable para interactuar con los datos del objeto.

#### Modificadores de Acceso

En C++, los modificadores de acceso se utilizan para controlar el nivel de acceso a los miembros de una clase. Existen tres modificadores de acceso principales:

1. **`public`:** Los miembros declarados como `public` son accesibles desde cualquier parte del programa.
2. **`private`:** Los miembros declarados como `private` solo son accesibles desde dentro de la propia clase.
3. **`protected`:** Los miembros declarados como `protected` son accesibles desde dentro de la clase y las clases derivadas.

##### Ejemplo Básico

```cpp
#include <iostream>
using namespace std;

class Ejemplo {
private:
    int datoPrivado; // Acceso privado

public:
    int datoPublico; // Acceso público

    // Constructor
    Ejemplo(int privado, int publico) : datoPrivado(privado), datoPublico(publico) {}

    // Método público para acceder al dato privado
    int getDatoPrivado() const {
        return datoPrivado;
    }

    // Método público para modificar el dato privado
    void setDatoPrivado(int valor) {
        datoPrivado = valor;
    }
};

int main() {
    Ejemplo obj(10, 20);

    // Acceso al dato público
    cout << "Dato público: " << obj.datoPublico << endl;

    // Acceso al dato privado a través de métodos públicos
    cout << "Dato privado: " << obj.getDatoPrivado() << endl;
    obj.setDatoPrivado(30);
    cout << "Dato privado modificado: " << obj.getDatoPrivado() << endl;

    return 0;
}
```

En este ejemplo, `datoPrivado` es un miembro privado y solo puede ser accedido y modificado a través de los métodos públicos `getDatoPrivado` y `setDatoPrivado`. `datoPublico` es un miembro público y puede ser accedido directamente.

#### Beneficios del Encapsulamiento

1. **Protección de Datos:** Los datos internos de un objeto están protegidos contra modificaciones indebidas.
2. **Mantenimiento:** Los detalles de implementación pueden cambiar sin afectar a los usuarios de la clase, siempre y cuando la interfaz pública permanezca constante.
3. **Modularidad:** Facilita la división del programa en módulos manejables y comprensibles.
4. **Reusabilidad:** Las clases encapsuladas pueden ser reutilizadas fácilmente en diferentes partes de un programa o en otros proyectos.

#### Encapsulamiento y Setters/Getters

Los setters y getters son métodos que proporcionan un acceso controlado a los atributos privados de una clase. A través de estos métodos, se puede aplicar lógica adicional para validar o transformar los datos antes de acceder o modificar los atributos.

##### Ejemplo con Setters y Getters

```cpp
#include <iostream>
using namespace std;

class Persona {
private:
    string nombre;
    int edad;

public:
    // Constructor
    Persona(string n, int e) : nombre(n), edad(e) {}

    // Getter para nombre
    string getNombre() const {
        return nombre;
    }

    // Setter para nombre
    void setNombre(string n) {
        nombre = n;
    }

    // Getter para edad
    int getEdad() const {
        return edad;
    }

    // Setter para edad con validación
    void setEdad(int e) {
        if (e > 0) {
            edad = e;
        } else {
            cout << "Edad no válida" << endl;
        }
    }

    // Método para mostrar información
    void mostrarInformacion() const {
        cout << "Nombre: " << nombre << ", Edad: " << edad << endl;
    }
};

int main() {
    Persona juan("Juan", 30);
    juan.mostrarInformacion();

    // Modificar atributos usando setters
    juan.setNombre("Juan Perez");
    juan.setEdad(31);
    juan.mostrarInformacion();

    // Intentar establecer una edad no válida
    juan.setEdad(-5);
    juan.mostrarInformacion();

    return 0;
}
```

En este ejemplo, `setNombre` y `setEdad` son métodos setters que permiten modificar los atributos privados `nombre` y `edad`. El método `setEdad` incluye una validación para asegurarse de que la edad sea positiva.

#### Encapsulamiento y Herencia

El encapsulamiento también juega un papel importante en la herencia. Los miembros `protected` pueden ser accedidos en clases derivadas, mientras que los miembros `private` no pueden ser accedidos directamente.

##### Ejemplo con Herencia

```cpp
#include <iostream>
using namespace std;

class Base {
private:
    int datoPrivado;

protected:
    int datoProtegido;

public:
    int datoPublico;

    Base(int priv, int prot, int pub) : datoPrivado(priv), datoProtegido(prot), datoPublico(pub) {}

    int getDatoPrivado() const {
        return datoPrivado;
    }

    int getDatoProtegido() const {
        return datoProtegido;
    }
};

class Derivada : public Base {
public:
    Derivada(int priv, int prot, int pub) : Base(priv, prot, pub) {}

    void mostrarDatos() {
        // cout << "Dato privado: " << getDatoPrivado() << endl; // No se puede acceder directamente
        cout << "Dato protegido: " << getDatoProtegido() << endl;
        cout << "Dato público: " << datoPublico << endl;
    }
};

int main() {
    Derivada obj(1, 2, 3);
    obj.mostrarDatos();

    return 0;
}
```

En este ejemplo, la clase `Derivada` hereda de la clase `Base`. Puede acceder al miembro `datoProtegido` a través de un método protegido en la clase base, pero no puede acceder directamente al miembro `datoPrivado`.

### Conclusión

El encapsulamiento es una técnica fundamental en la programación orientada a objetos que mejora la seguridad, la modularidad y la mantenibilidad del código. Al utilizar modificadores de acceso como `private`, `protected` y `public`, se puede controlar cómo se accede y modifica el estado interno de los objetos. Los setters y getters son herramientas esenciales para implementar el encapsulamiento, proporcionando un acceso controlado a los atributos privados. Con una comprensión sólida del encapsulamiento, los desarrolladores pueden crear clases robustas y seguras que faciliten el desarrollo de software de alta calidad.