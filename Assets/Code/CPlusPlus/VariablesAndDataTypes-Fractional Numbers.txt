---FILES---
main.cpp
result

---main.cpp---
#include <iostream>
#include <iomanip>

int main(){

    //Declare and initialize the variables
    float number1 {1.12345678901234567890f}; // Precision : 7
    double number2 {1.12345678901234567890}; // Precision : 15
    long double number3  {1.12345678901234567890L};
    
    //Print out the sizes
    std::cout << "sizeof float : " << sizeof(float) << std::endl;
    std::cout << "sizeof double : " << sizeof(double) << std::endl;
    std::cout << "sizeof long double : " << sizeof(long double) << std::endl;

    //Precision
    std::cout << std::setprecision(20); // Control the precision from std::cout.
    std::cout << "number1 is : " << number1 << std::endl; //7 digits
    std::cout << "number2 is : " << number2 << std::endl; // 15'ish digits
    std::cout << "number3 is : " << number3 << std::endl; // 15+ digits

    //Float problems : The precision is usually too limited
    //for a lot of applications
    float number4 = 192400023.0f;               // Error : narrowing conversion

    std::cout << "number4 : " << number4 << std::endl;

    //Scientific notation
    //What we have seen so far in terms of floating point types
    //is fixed notation. There is another notation, scientific
    //that is handy if you have really huge numbers or small numbers
    //to represent

    std::cout << "-------------------------" << std::endl;
    
    double number5 {192400023};
    double number6 {1.92400023e8};
    double number7 {1.924e8};           // Can ommit the lower 00023
                                        // for simplicity if our application allows that.
    double number8 {0.00000000003498};
    double number9 {3.498e-11}; // multiply with 10 exp(-11)
    
    std::cout << "number5 is : " << number5 << std::endl;
    std::cout << "number6 is : " << number6 << std::endl;
    std::cout << "number7 is : " << number7 << std::endl;
    std::cout << "number8 is : " << number8 << std::endl;
    std::cout << "number9 is : " << number9 << std::endl;

    //Infinity and Nan
    std::cout << std::endl;
    std::cout << "Infinity and NaN" << std::endl;
    
    double number10{ -5.6 };
    double number11{};//Initialized to 0
    double number12{};  //Initialized to 0

    //Infinity
    double result { number10 / number11 };
    
    
    std::cout << number10 << "/" << number11 << "  yields " << result << std::endl;
    std::cout << result << " + " << number10 << " yields " << result + number10 << std::endl;
    
    //NaN
    result = number11 / number12;
    
    
    std::cout << number11 << "/" << number12 << " = " << result << std::endl;
    
   
    return 0;
}

---result---
sizeof float : 4
sizeof double : 8
sizeof long double : 16
number1 is : 1.1234568357467651367
number2 is : 1.1234567890123456912
number3 is : 1.1234567890123456789
number4 : 192400016
-------------------------
number5 is : 192400023
number6 is : 192400023
number7 is : 192400000
number8 is : 3.4979999999999998372e-11
number9 is : 3.4979999999999998372e-11

Infinity and NaN
-5.5999999999999996447/0  yields -inf
-inf + -5.5999999999999996447 yields -inf
0/0 = nan

---EXPLANATION---

### Tipos de Datos de Punto Flotante en C++

En C++, los tipos de datos de punto flotante se utilizan para representar números con partes fraccionarias. Los tipos principales son `float`, `double` y `long double`, cada uno con diferentes niveles de precisión y tamaños. A continuación se explica cómo funcionan y sus particularidades.

#### Tamaños y Precisión

- **`float`**: Generalmente ocupa 4 bytes y tiene una precisión de aproximadamente 7 dígitos decimales. Se utiliza para ahorrar memoria en grandes arreglos de números flotantes donde la precisión no es crítica.
- **`double`**: Generalmente ocupa 8 bytes y tiene una precisión de alrededor de 15 dígitos decimales. Es el tipo de dato de punto flotante por defecto en C++.
- **`long double`**: Puede ocupar más de 8 bytes (dependiendo de la implementación) y proporciona más precisión que `double`. Es útil cuando se requiere una precisión extremadamente alta.

#### Ejemplo de Precisión

- **`float number1`**: 1.12345678901234567890f (Precisión: 7 dígitos)
- **`double number2`**: 1.12345678901234567890 (Precisión: 15 dígitos)
- **`long double number3`**: 1.12345678901234567890L (Precisión: más de 15 dígitos)

Al imprimir estos valores con una precisión de 20 dígitos, se observa que `float` pierde precisión después del séptimo dígito, mientras que `double` y `long double` mantienen más precisión.

#### Problemas de Precisión con `float`

La precisión de `float` es generalmente insuficiente para muchas aplicaciones. Por ejemplo, al asignar un número grande a una variable `float`, se pueden producir errores de redondeo.

#### Notación Científica

La notación científica es útil para representar números muy grandes o muy pequeños. En C++, se puede usar la letra `e` para denotar la notación científica.

- **`double number5`**: 192400023
- **`double number6`**: 1.92400023e8 (Equivalente a 192400023)
- **`double number7`**: 1.924e8 (Equivalente a 192400023, omitiendo los ceros menos significativos)
- **`double number8`**: 0.00000000003498
- **`double number9`**: 3.498e-11 (Equivalente a 0.00000000003498)

#### Infinito y NaN (Not a Number)

En operaciones de punto flotante, se pueden producir valores especiales como `Infinity` y `NaN`.

- **Infinito (`Infinity`)**: Resultado de dividir un número por cero.
  - **Ejemplo**:
    - `double number10 { -5.6 }`
    - `double number11 {}` (Inicializado a 0)
    - `double result { number10 / number11 }` (Resulta en Infinity)

- **NaN**: Resultado de una operación indefinida, como 0 dividido por 0.
  - **Ejemplo**:
    - `double number12 {}` (Inicializado a 0)
    - `result = number11 / number12` (Resulta en NaN)

Estos valores especiales se pueden manejar en el código para evitar errores inesperados.

### Conclusión

Los tipos de datos de punto flotante en C++ (`float`, `double` y `long double`) ofrecen diferentes niveles de precisión y tamaños para adaptarse a diversas necesidades de programación. Es crucial comprender sus diferencias y limitaciones para elegir el tipo adecuado según el contexto de la aplicación.

