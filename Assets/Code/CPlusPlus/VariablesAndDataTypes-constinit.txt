---FILES---
main.cpp
result

---main.cpp---
#include <iostream>

const int val1 {33};
constexpr int val2{34};
int val3 {35}; // Run time value

constinit int age = 88; // This is initialized at compile time
const constinit int age1 {val1}; // const and constinit can be combined
constinit int age2 {age1}; // Initializing with age would lead to a compiler error
                                 // age is not const
//constinit int age3 {val3}; // Error : val3 is evaluated at run time
                           // can't const initialize age3
                           
const constinit double weight {33.33};
//constexpr constinit double scale_factor{3.11};// Can't combine constexpr and constinit


int main(){

    //constinit double height{1.72};

    std::cout << "age : " << age << std::endl;
    std::cout << "age1 : " << age1 << std::endl;
    std::cout << "age2 : " << age2 << std::endl;
    
    age =33; // Can change a const init variable
    std::cout << "age : " << age << std::endl;
    
    //Combining const and constinit
    std::cout << "weight : " << weight << std::endl;
    //weight = 44.44; // Compiler error
    
    return 0;
}

---result---
age : 88
age1 : 33
age2 : 33
age : 33
weight : 33.33

---EXPLANATION---
### `constinit` en C++

La palabra clave `constinit` es utilizada en C++20 para asegurar que una variable global o estática sea inicializada en tiempo de compilación. A diferencia de `constexpr`, `constinit` no implica que la variable sea constante después de la inicialización; simplemente garantiza que su inicialización ocurra en tiempo de compilación.

### Ejemplos en el Código

1. **Declaración de variables con `const`, `constexpr` y `constinit`:**
   ```cpp
   const int val1 {33};
   constexpr int val2 {34};
   int val3 {35}; // Valor en tiempo de ejecución
   ```
   - `val1` es una constante cuyo valor se define en tiempo de compilación, pero puede ser evaluado en tiempo de ejecución.
   - `val2` es una constante evaluada en tiempo de compilación.
   - `val3` es una variable cuyo valor se define y puede cambiar en tiempo de ejecución.

2. **Uso de `constinit`:**
   ```cpp
   constinit int age = 88; // Inicializado en tiempo de compilación
   const constinit int age1 {val1}; // Combinación de const y constinit
   constinit int age2 {age1}; // Inicialización válida porque age1 es const
   // constinit int age3 {val3}; // Error: val3 se evalúa en tiempo de ejecución
   ```
   - `age` se inicializa en tiempo de compilación y su valor puede cambiar después.
   - `age1` combina `const` y `constinit`, asegurando que sea inicializado en tiempo de compilación y sea constante.
   - `age2` se inicializa con `age1`, lo cual es válido porque `age1` es una constante evaluada en tiempo de compilación.
   - `age3` da error porque intenta inicializarse con `val3`, que se evalúa en tiempo de ejecución.

3. **Variables con tipo `double` y `constinit`:**
   ```cpp
   const constinit double weight {33.33};
   // constexpr constinit double scale_factor{3.11}; // Error: no se pueden combinar constexpr y constinit
   ```
   - `weight` se inicializa en tiempo de compilación y es constante.
   - No se puede combinar `constexpr` y `constinit` porque `constexpr` implica inmutabilidad total y evaluación en tiempo de compilación, mientras que `constinit` solo garantiza la inicialización en tiempo de compilación.

4. **Uso de las variables en `main()`:**
   ```cpp
   int main(){
       std::cout << "age : " << age << std::endl;
       std::cout << "age1 : " << age1 << std::endl;
       std::cout << "age2 : " << age2 << std::endl;

       age = 33; // Se puede cambiar una variable constinit
       std::cout << "age : " << age << std::endl;

       std::cout << "weight : " << weight << std::endl;
       // weight = 44.44; // Error del compilador
       
       return 0;
   }
   ```
   - Se imprimen los valores de `age`, `age1` y `age2`.
   - `age` se modifica después de la inicialización, lo cual es permitido porque `constinit` no implica inmutabilidad.
   - `weight` es constante después de la inicialización y no se puede cambiar, lo cual resulta en un error si se intenta modificar.

### Conclusión

La palabra clave `constinit` en C++20 asegura que una variable sea inicializada en tiempo de compilación, pero no necesariamente implica que la variable sea constante después de la inicialización. Esto es útil para evitar inicializaciones en tiempo de ejecución y asegurar la eficiencia y predictibilidad del programa. La combinación con `const` permite crear variables que son constantes y están garantizadas a ser inicializadas en tiempo de compilación. Sin embargo, `constinit` no se puede combinar con `constexpr` debido a que `constexpr` ya implica una inicialización y evaluación en tiempo de compilación junto con la inmutabilidad.