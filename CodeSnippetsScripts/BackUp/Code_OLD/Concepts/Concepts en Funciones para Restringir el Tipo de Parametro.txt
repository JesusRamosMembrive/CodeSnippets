<---EXPLANATION--->
### Concepts en Funciones para Restringir el Tipo de Parámetro en C++

Los Concepts en C++20 son una herramienta poderosa que permite restringir los tipos de parámetros que pueden ser pasados a funciones plantilla. Esto mejora la seguridad del código al asegurar que solo los tipos que cumplen ciertos requisitos puedan ser utilizados.

### Definición de Concepts en Funciones

Para usar un Concept en una función, se especifica el Concept en la declaración de la plantilla. Aquí hay una guía paso a paso y ejemplos de cómo hacerlo.

#### Ejemplo 1: Uso de `std::integral`

Este Concept predefinido verifica si un tipo es un tipo integral (como `int`, `char`, etc.).

```cpp
#include <concepts>
#include <iostream>

// Función plantilla que solo acepta tipos integrales
template<std::integral T>
T sumar(T a, T b) {
    return a + b;
}

int main() {
    int x = 5, y = 3;
    std::cout << sumar(x, y) << std::endl;  // Funciona: int es un tipo integral

    // double a = 5.0, b = 3.0;
    // std::cout << sumar(a, b) << std::endl;  // Error de compilación: double no es un tipo integral
}
```

En este ejemplo, la función plantilla `sumar` solo acepta parámetros de tipo integral debido al Concept `std::integral`.

#### Ejemplo 2: Uso de `std::floating_point`

Este Concept predefinido verifica si un tipo es un tipo de punto flotante (como `float`, `double`, etc.).

```cpp
#include <concepts>
#include <iostream>

// Función plantilla que solo acepta tipos de punto flotante
template<std::floating_point T>
T multiplicar(T a, T b) {
    return a * b;
}

int main() {
    double x = 2.5, y = 3.5;
    std::cout << multiplicar(x, y) << std::endl;  // Funciona: double es un tipo de punto flotante

    // int a = 2, b = 3;
    // std::cout << multiplicar(a, b) << std::endl;  // Error de compilación: int no es un tipo de punto flotante
}
```

#### Ejemplo 3: Concept Personalizado `HasSizeMethod`

Este Concept verifica si un tipo tiene un método `size()` que retorna un valor convertible a `std::size_t`.

```cpp
#include <concepts>
#include <type_traits>
#include <iostream>

// Definir un Concept que requiere que T tenga un método `size()`
template<typename T>
concept HasSizeMethod = requires(T a) {
    { a.size() } -> std::convertible_to<std::size_t>;
};

// Función plantilla que solo acepta tipos que tienen un método `size()`
template<HasSizeMethod T>
std::size_t obtenerSize(const T& obj) {
    return obj.size();
}

class ConSize {
public:
    std::size_t size() const {
        return 42;
    }
};

class SinSize {
public:
    int length() const {
        return 84;
    }
};

int main() {
    ConSize cs;
    std::cout << obtenerSize(cs) << std::endl; // Funciona: ConSize tiene método `size()`

    // SinSize ss;
    // std::cout << obtenerSize(ss) << std::endl; // Error de compilación: SinSize no tiene método `size()`
}
```

#### Ejemplo 4: Concept Personalizado `Addable`

Este Concept verifica si dos instancias de un tipo pueden sumarse utilizando el operador `+`.

```cpp
#include <concepts>
#include <iostream>

// Definir un Concept que requiere que T soporte la operación de suma
template<typename T>
concept Addable = requires(T a, T b) {
    { a + b } -> std::same_as<T>;
};

// Función plantilla que solo acepta tipos que soportan la suma
template<Addable T>
T sumar(T a, T b) {
    return a + b;
}

int main() {
    int x = 5, y = 3;
    std::cout << sumar(x, y) << std::endl;  // Funciona: int soporta la suma

    double p = 5.5, q = 3.5;
    std::cout << sumar(p, q) << std::endl;  // Funciona: double soporta la suma

    // std::string s1 = "Hola, ", s2 = "Mundo!";
    // std::cout << sumar(s1, s2) << std::endl;  // Funciona: std::string soporta la suma (concatenación)
}
```

### Uso de Concepts en Parámetros de Funciones

Los Concepts también pueden ser utilizados directamente en la lista de parámetros de una función para restringir los tipos permitidos.

#### Ejemplo 5: Uso de Concepts en Parámetros

```cpp
#include <concepts>
#include <iostream>

// Definir un Concept que requiere que T sea un tipo integral
template<typename T>
concept Integral = std::is_integral_v<T>;

// Función que utiliza el Concept directamente en los parámetros
void imprimir(Integral auto valor) {
    std::cout << valor << std::endl;
}

int main() {
    imprimir(42);  // Funciona: 42 es un int (integral)
    // imprimir(42.0);  // Error de compilación: 42.0 es un double (no integral)
}
```

### Buenas Prácticas al Usar Concepts en Funciones

1. **Definir Concepts Claros y Específicos**: Asegúrese de que los Concepts sean claros y específicos para evitar confusiones.
2. **Reutilizar Concepts**: Defina Concepts reutilizables que puedan ser aplicados en múltiples funciones y contextos.
3. **Documentar**: Documente los Concepts y las funciones que los utilizan para facilitar la comprensión del código.
4. **Evitar Complejidad**: Mantenga los Concepts lo más simples posible para no complicar innecesariamente el código.

### Conclusión

Los Concepts en C++ permiten restringir los tipos de parámetros en funciones plantilla, proporcionando una forma clara y concisa de imponer restricciones de tipos. Esto no solo mejora la seguridad y la robustez del código, sino que también facilita la detección de errores en tiempo de compilación y mejora la legibilidad del código. Al definir y utilizar Concepts personalizados, puede asegurar que sus funciones solo acepten los tipos adecuados, evitando errores y mejorando la mantenibilidad del código.
<---FILES--->
