<---EXPLANATION--->
### `consteval` en Funciones en C++

La palabra clave `consteval` es una característica introducida en C++20 que se utiliza para declarar funciones que deben ser evaluadas en tiempo de compilación. A diferencia de `constexpr`, que permite la evaluación en tiempo de compilación pero también puede ser evaluada en tiempo de ejecución si es necesario, `consteval` garantiza que la función solo se puede evaluar en tiempo de compilación. Esto asegura que cualquier llamada a una función `consteval` se resuelva completamente durante la compilación.

#### Características de `consteval`

- **Evaluación en Tiempo de Compilación:** Las funciones declaradas como `consteval` deben ser evaluadas en tiempo de compilación. Intentar llamarlas en tiempo de ejecución resultará en un error de compilación.
- **Uso en Contextos Constantes:** Las funciones `consteval` son útiles para cálculos que deben resolverse completamente en tiempo de compilación, como la inicialización de constantes y el cálculo de valores que dependen de parámetros conocidos en tiempo de compilación.

#### Sintaxis

```cpp
consteval tipo_retorno nombre_funcion(lista_de_parametros) {
    // Cuerpo de la función
}
```

#### Ejemplo de Función `consteval`

Un ejemplo sencillo de una función `consteval` es el cálculo del factorial de un número.

```cpp
#include <iostream>
using namespace std;

// Función consteval para calcular el factorial de un número
consteval int factorial(int n) {
    if (n <= 1) {
        return 1;
    } else {
        return n * factorial(n - 1);
    }
}

int main() {
    constexpr int resultado = factorial(5); // Evaluado en tiempo de compilación
    cout << "El factorial de 5 es: " << resultado << endl;
    // int runtime_result = factorial(5); // Error: no se puede evaluar en tiempo de ejecución
    return 0;
}
```

En este ejemplo, la función `factorial` es declarada con `consteval`, lo que asegura que cualquier llamada a `factorial` debe ser evaluada en tiempo de compilación.

#### Diferencias entre `consteval` y `constexpr`

- **`constexpr`:** Permite que la función sea evaluada en tiempo de compilación o en tiempo de ejecución, dependiendo de cómo se utilice.
- **`consteval`:** Obliga a que la función sea evaluada en tiempo de compilación, y no permite su evaluación en tiempo de ejecución.

##### Ejemplo Comparativo

```cpp
#include <iostream>
using namespace std;

// Función constexpr
constexpr int cuadrado(int x) {
    return x * x;
}

// Función consteval
consteval int cubo(int x) {
    return x * x * x;
}

int main() {
    constexpr int valor1 = cuadrado(4); // Puede ser evaluado en tiempo de compilación o ejecución
    cout << "Cuadrado de 4: " << valor1 << endl;

    constexpr int valor2 = cubo(3); // Debe ser evaluado en tiempo de compilación
    cout << "Cubo de 3: " << valor2 << endl;

    // int runtime_val = cubo(3); // Error: no se puede evaluar en tiempo de ejecución

    return 0;
}
```

En este ejemplo, la función `cuadrado` puede ser evaluada en tiempo de compilación o en tiempo de ejecución, mientras que la función `cubo` debe ser evaluada en tiempo de compilación debido a la palabra clave `consteval`.

#### Uso de `consteval` en Inicialización Constante

Las funciones `consteval` son especialmente útiles para inicializar constantes que deben ser evaluadas en tiempo de compilación.

```cpp
#include <array>

consteval int fibonacci(int n) {
    if (n <= 1) return n;
    return fibonacci(n - 1) + fibonacci(n - 2);
}

int main() {
    constexpr int fib_10 = fibonacci(10); // Evaluado en tiempo de compilación
    std::array<int, fibonacci(5)> fib_array; // El tamaño del array es evaluado en tiempo de compilación
    std::cout << "El décimo término de Fibonacci es: " << fib_10 << std::endl;
    return 0;
}
```

En este ejemplo, la función `fibonacci` es utilizada para inicializar una constante y para determinar el tamaño de un array, ambos evaluados en tiempo de compilación.

### Ventajas de `consteval`

1. **Garantía de Tiempo de Compilación:** Asegura que los cálculos se realicen en tiempo de compilación, lo que puede mejorar el rendimiento en tiempo de ejecución y detectar errores antes.
2. **Optimización:** Permite al compilador realizar más optimizaciones, ya que los valores constantes se conocen en tiempo de compilación.
3. **Seguridad del Tipo:** Ayuda a evitar errores relacionados con el tipo en tiempo de ejecución al resolver expresiones en tiempo de compilación.

### Ejemplo Completo

A continuación, un ejemplo completo que ilustra el uso de funciones `consteval` en diferentes contextos:

```cpp
#include <iostream>
#include <array>
using namespace std;

consteval int fibonacci(int n) {
    if (n <= 1) return n;
    return fibonacci(n - 1) + fibonacci(n - 2);
}

consteval int sumar(int a, int b) {
    return a + b;
}

consteval int multiplicar(int a, int b) {
    return a * b;
}

int main() {
    constexpr int fib_10 = fibonacci(10); // Evaluado en tiempo de compilación
    constexpr int suma = sumar(7, 3); // Evaluado en tiempo de compilación
    constexpr int producto = multiplicar(4, 5); // Evaluado en tiempo de compilación

    std::array<int, fibonacci(5)> fib_array; // Tamaño del array evaluado en tiempo de compilación

    cout << "El décimo término de Fibonacci es: " << fib_10 << endl;
    cout << "La suma de 7 y 3 es: " << suma << endl;
    cout << "El producto de 4 y 5 es: " << producto << endl;

    return 0;
}
```

### Conclusión

La palabra clave `consteval` en C++20 proporciona una manera de asegurar que ciertas funciones sean evaluadas exclusivamente en tiempo de compilación. Esto permite optimizaciones adicionales y ayuda a garantizar la corrección del programa al detectar errores en una etapa temprana. Comprender y utilizar `consteval` puede mejorar significativamente la eficiencia y la seguridad del código en C++.
<---FILES--->
Ejemplo Comparativo
Ejemplo Comparativo Result
<---Ejemplo Comparativo--->
```cpp
#include <iostream>
using namespace std;

// Función constexpr
constexpr int cuadrado(int x) {
    return x * x;
}

// Función consteval
consteval int cubo(int x) {
    return x * x * x;
}

int main() {
    constexpr int valor1 = cuadrado(4); // Puede ser evaluado en tiempo de compilación o ejecución
    cout << "Cuadrado de 4: " << valor1 << endl;

    constexpr int valor2 = cubo(3); // Debe ser evaluado en tiempo de compilación
    cout << "Cubo de 3: " << valor2 << endl;

    // int runtime_val = cubo(3); // Error: no se puede evaluar en tiempo de ejecución

    return 0;
}
```cpp
#include <array>

consteval int fibonacci(int n) {
    if (n <= 1) return n;
    return fibonacci(n - 1) + fibonacci(n - 2);
}

int main() {
    constexpr int fib_10 = fibonacci(10); // Evaluado en tiempo de compilación
    std::array<int, fibonacci(5)> fib_array; // El tamaño del array es evaluado en tiempo de compilación
    std::cout << "El décimo término de Fibonacci es: " << fib_10 << std::endl;
    return 0;
}
```cpp
#include <iostream>
#include <array>
using namespace std;

consteval int fibonacci(int n) {
    if (n <= 1) return n;
    return fibonacci(n - 1) + fibonacci(n - 2);
}

consteval int sumar(int a, int b) {
    return a + b;
}

consteval int multiplicar(int a, int b) {
    return a * b;
}

int main() {
    constexpr int fib_10 = fibonacci(10); // Evaluado en tiempo de compilación
    constexpr int suma = sumar(7, 3); // Evaluado en tiempo de compilación
    constexpr int producto = multiplicar(4, 5); // Evaluado en tiempo de compilación

    std::array<int, fibonacci(5)> fib_array; // Tamaño del array evaluado en tiempo de compilación

    cout << "El décimo término de Fibonacci es: " << fib_10 << endl;
    cout << "La suma de 7 y 3 es: " << suma << endl;
    cout << "El producto de 4 y 5 es: " << producto << endl;

    return 0;
}
<---Ejemplo Comparativo Result--->
