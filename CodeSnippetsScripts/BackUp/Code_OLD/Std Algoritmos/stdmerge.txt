<---EXPLANATION--->
### Algoritmo de la Biblioteca Estándar: `std::merge`

La función `std::merge` es un algoritmo de la biblioteca estándar de C++ que se utiliza para fusionar dos rangos ordenados en un solo rango ordenado. Es parte del encabezado `<algorithm>` y es útil para combinar datos de manera eficiente mientras se mantiene el orden.

#### Sintaxis de `std::merge`

```cpp
#include <algorithm>

template <class InputIt1, class InputIt2, class OutputIt>
OutputIt merge(InputIt1 first1, InputIt1 last1, InputIt2 first2, InputIt2 last2, OutputIt d_first);

template <class InputIt1, class InputIt2, class OutputIt, class Compare>
OutputIt merge(InputIt1 first1, InputIt1 last1, InputIt2 first2, InputIt2 last2, OutputIt d_first, Compare comp);
```

- **`InputIt1 first1`**: Iterador al primer elemento del primer rango.
- **`InputIt1 last1`**: Iterador al elemento después del último en el primer rango.
- **`InputIt2 first2`**: Iterador al primer elemento del segundo rango.
- **`InputIt2 last2`**: Iterador al elemento después del último en el segundo rango.
- **`OutputIt d_first`**: Iterador al primer elemento del rango de destino.
- **`Compare comp`**: (Opcional) Función de comparación que toma dos argumentos.

#### Descripción

`std::merge` fusiona dos rangos ordenados `[first1, last1)` y `[first2, last2)` en un solo rango ordenado comenzando en `d_first`. El rango de salida debe ser lo suficientemente grande para contener todos los elementos fusionados. Si se proporciona una función de comparación `comp`, se utiliza para ordenar los elementos en lugar del operador `<`.

#### Ejemplo de Uso de `std::merge`

##### Ejemplo Básico

```cpp
#include <iostream>
#include <vector>
#include <algorithm>

int main() {
    std::vector<int> vec1 = {1, 3, 5, 7};
    std::vector<int> vec2 = {2, 4, 6, 8};
    std::vector<int> result(vec1.size() + vec2.size());

    // Usar std::merge para fusionar los dos vectores ordenados
    std::merge(vec1.begin(), vec1.end(), vec2.begin(), vec2.end(), result.begin());

    // Mostrar los elementos fusionados
    std::cout << "Elementos fusionados: ";
    for (int elem : result) {
        std::cout << elem << " ";
    }
    std::cout << std::endl;

    return 0;
}
```

En este ejemplo:
- `std::merge(vec1.begin(), vec1.end(), vec2.begin(), vec2.end(), result.begin())` fusiona los elementos de `vec1` y `vec2` en `result`.

### Uso con Comparación Personalizada

`std::merge` puede utilizar una función de comparación personalizada para ordenar según un criterio específico.

##### Ejemplo con Comparación Personalizada

```cpp
#include <iostream>
#include <vector>
#include <algorithm>

struct Persona {
    std::string nombre;
    int edad;
};

bool compararPorEdad(const Persona& a, const Persona& b) {
    return a.edad < b.edad;
}

int main() {
    std::vector<Persona> grupo1 = {{"Ana", 25}, {"Carlos", 30}};
    std::vector<Persona> grupo2 = {{"Luis", 22}, {"Maria", 28}};
    std::vector<Persona> resultado(grupo1.size() + grupo2.size());

    // Usar std::merge con comparación personalizada para fusionar los dos vectores ordenados
    std::merge(grupo1.begin(), grupo1.end(), grupo2.begin(), grupo2.end(), resultado.begin(), compararPorEdad);

    // Mostrar las personas fusionadas
    std::cout << "Personas fusionadas: ";
    for (const auto& persona : resultado) {
        std::cout << persona.nombre << " (" << persona.edad << "), ";
    }
    std::cout << std::endl;

    return 0;
}
```

En este ejemplo:
- `std::merge(grupo1.begin(), grupo1.end(), grupo2.begin(), grupo2.end(), resultado.begin(), compararPorEdad)` fusiona los elementos de `grupo1` y `grupo2` en `resultado` utilizando la función de comparación `compararPorEdad`.

### Consideraciones

- **Rendimiento:** `std::merge` tiene una complejidad lineal (`O(N)`) respecto a la suma de los tamaños de los dos rangos de entrada.
- **Orden:** Los rangos de entrada deben estar ordenados de acuerdo con el mismo criterio de comparación (ya sea el operador `<` o una función de comparación personalizada).
- **Tamaño del Rango de Salida:** El rango de salida debe ser lo suficientemente grande para contener todos los elementos fusionados. Asegúrate de reservar el espacio necesario antes de llamar a `std::merge`.

### Variantes: `std::inplace_merge`

`std::inplace_merge` es una variante que fusiona dos rangos adyacentes dentro de un mismo contenedor.

#### Sintaxis de `std::inplace_merge`

```cpp
#include <algorithm>

template <class BidirIt>
void inplace_merge(BidirIt first, BidirIt middle, BidirIt last);

template <class BidirIt, class Compare>
void inplace_merge(BidirIt first, BidirIt middle, BidirIt last, Compare comp);
```

- **`BidirIt first`**: Iterador al primer elemento del primer rango.
- **`BidirIt middle`**: Iterador al primer elemento del segundo rango.
- **`BidirIt last`**: Iterador al elemento después del último en el segundo rango.
- **`Compare comp`**: (Opcional) Función de comparación que toma dos argumentos.

#### Ejemplo de Uso de `std::inplace_merge`

```cpp
#include <iostream>
#include <vector>
#include <algorithm>

int main() {
    std::vector<int> vec = {1, 3, 5, 7, 2, 4, 6, 8};

    // Usar std::inplace_merge para fusionar los dos rangos adyacentes
    std::inplace_merge(vec.begin(), vec.begin() + 4, vec.end());

    // Mostrar los elementos fusionados
    std::cout << "Elementos después de std::inplace_merge: ";
    for (int elem : vec) {
        std::cout << elem << " ";
    }
    std::cout << std::endl;

    return 0;
}
```

En este ejemplo:
- `std::inplace_merge(vec.begin(), vec.begin() + 4, vec.end())` fusiona los dos rangos adyacentes `{1, 3, 5, 7}` y `{2, 4, 6, 8}` dentro del mismo contenedor `vec`.

### Conclusión

`std::merge` y `std::inplace_merge` son algoritmos de la biblioteca estándar de C++ que proporcionan formas eficientes de fusionar rangos ordenados en un solo rango ordenado. `std::merge` es útil cuando se trabaja con rangos de entrada separados y un rango de salida distinto, mientras que `std::inplace_merge` permite fusionar rangos adyacentes dentro de un mismo contenedor. Comprender y utilizar estos algoritmos es esencial para realizar fusiones eficientes y mantener el orden en contenedores en C++.
<---FILES--->
Ejemplo Básico
Ejemplo Básico Result
Ejemplo con Comparación Personalizada
Ejemplo con Comparación Personalizada Result
<---Ejemplo Básico--->
```cpp
#include <iostream>
#include <vector>
#include <algorithm>

int main() {
    std::vector<int> vec1 = {1, 3, 5, 7};
    std::vector<int> vec2 = {2, 4, 6, 8};
    std::vector<int> result(vec1.size() + vec2.size());

    // Usar std::merge para fusionar los dos vectores ordenados
    std::merge(vec1.begin(), vec1.end(), vec2.begin(), vec2.end(), result.begin());

    // Mostrar los elementos fusionados
    std::cout << "Elementos fusionados: ";
    for (int elem : result) {
        std::cout << elem << " ";
    }
    std::cout << std::endl;

    return 0;
}
<---Ejemplo Básico Result--->
<---Ejemplo con Comparación Personalizada--->
```cpp
#include <iostream>
#include <vector>
#include <algorithm>

struct Persona {
    std::string nombre;
    int edad;
};

bool compararPorEdad(const Persona& a, const Persona& b) {
    return a.edad < b.edad;
}

int main() {
    std::vector<Persona> grupo1 = {{"Ana", 25}, {"Carlos", 30}};
    std::vector<Persona> grupo2 = {{"Luis", 22}, {"Maria", 28}};
    std::vector<Persona> resultado(grupo1.size() + grupo2.size());

    // Usar std::merge con comparación personalizada para fusionar los dos vectores ordenados
    std::merge(grupo1.begin(), grupo1.end(), grupo2.begin(), grupo2.end(), resultado.begin(), compararPorEdad);

    // Mostrar las personas fusionadas
    std::cout << "Personas fusionadas: ";
    for (const auto& persona : resultado) {
        std::cout << persona.nombre << " (" << persona.edad << "), ";
    }
    std::cout << std::endl;

    return 0;
}
```cpp
#include <algorithm>

template <class BidirIt>
void inplace_merge(BidirIt first, BidirIt middle, BidirIt last);

template <class BidirIt, class Compare>
void inplace_merge(BidirIt first, BidirIt middle, BidirIt last, Compare comp);
```cpp
#include <iostream>
#include <vector>
#include <algorithm>

int main() {
    std::vector<int> vec = {1, 3, 5, 7, 2, 4, 6, 8};

    // Usar std::inplace_merge para fusionar los dos rangos adyacentes
    std::inplace_merge(vec.begin(), vec.begin() + 4, vec.end());

    // Mostrar los elementos fusionados
    std::cout << "Elementos después de std::inplace_merge: ";
    for (int elem : vec) {
        std::cout << elem << " ";
    }
    std::cout << std::endl;

    return 0;
}
<---Ejemplo con Comparación Personalizada Result--->
