<---EXPLANATION--->
### Programación Orientada a Objetos en C++: Clases y Objetos

La programación orientada a objetos (POO) es un paradigma de programación que utiliza "objetos" y sus interacciones para diseñar aplicaciones y programas. En C++, la POO es una característica central que permite organizar y estructurar el código de manera modular y reutilizable. Los dos conceptos fundamentales en la POO son las clases y los objetos.

#### Clases

Una clase en C++ es una plantilla o un molde que define los atributos y comportamientos de los objetos que se crean a partir de ella. Los atributos son variables que mantienen el estado del objeto, mientras que los comportamientos son funciones o métodos que definen lo que el objeto puede hacer.

##### Definición de una Clase

La sintaxis básica para definir una clase en C++ es la siguiente:

```cpp
class NombreClase {
public:
    // Atributos
    tipo_atributo nombre_atributo;

    // Métodos
    tipo_retorno nombre_metodo(parametros);

    // Otros componentes, como constructores, destructores, etc.
};
```

##### Ejemplo Básico de una Clase

```cpp
#include <iostream>
using namespace std;

class Persona {
public:
    // Atributos
    string nombre;
    int edad;

    // Métodos
    void saludar() {
        cout << "Hola, mi nombre es " << nombre << " y tengo " << edad << " años." << endl;
    }
};

int main() {
    // Crear un objeto de la clase Persona
    Persona juan;
    juan.nombre = "Juan";
    juan.edad = 30;

    // Llamar al método saludar
    juan.saludar();

    return 0;
}
```

En este ejemplo:
- `Persona` es una clase que tiene dos atributos (`nombre` y `edad`) y un método (`saludar`).
- `juan` es un objeto de la clase `Persona`.

#### Objetos

Un objeto es una instancia de una clase. Cada objeto tiene su propio estado (valores de los atributos) y puede usar los métodos definidos en la clase.

##### Creación de Objetos

Los objetos se crean declarando una variable del tipo de la clase:

```cpp
NombreClase nombre_objeto;
```

##### Ejemplo de Creación y Uso de Objetos

```cpp
#include <iostream>
using namespace std;

class Coche {
public:
    // Atributos
    string marca;
    string modelo;
    int anio;

    // Métodos
    void mostrarInformacion() {
        cout << "Marca: " << marca << ", Modelo: " << modelo << ", Año: " << anio << endl;
    }
};

int main() {
    // Crear objetos de la clase Coche
    Coche coche1;
    coche1.marca = "Toyota";
    coche1.modelo = "Corolla";
    coche1.anio = 2020;

    Coche coche2;
    coche2.marca = "Honda";
    coche2.modelo = "Civic";
    coche2.anio = 2019;

    // Llamar a los métodos de los objetos
    coche1.mostrarInformacion();
    coche2.mostrarInformacion();

    return 0;
}
```

En este ejemplo, `Coche` es una clase que define tres atributos y un método. Se crean dos objetos (`coche1` y `coche2`) y se llama al método `mostrarInformacion` para cada objeto.

#### Constructores y Destructores

Los constructores y destructores son funciones especiales que se utilizan para inicializar y limpiar objetos, respectivamente.

##### Constructores

Un constructor es una función que se llama automáticamente cuando se crea un objeto. Se utiliza para inicializar los atributos del objeto.

```cpp
class Persona {
public:
    string nombre;
    int edad;

    // Constructor
    Persona(string n, int e) {
        nombre = n;
        edad = e;
    }

    void saludar() {
        cout << "Hola, mi nombre es " << nombre << " y tengo " << edad << " años." << endl;
    }
};

int main() {
    // Crear un objeto de la clase Persona utilizando el constructor
    Persona juan("Juan", 30);
    juan.saludar();

    return 0;
}
```

##### Destructores

Un destructor es una función que se llama automáticamente cuando un objeto es destruido. Se utiliza para liberar recursos que el objeto haya adquirido durante su vida.

```cpp
class Persona {
public:
    string nombre;
    int edad;

    // Constructor
    Persona(string n, int e) {
        nombre = n;
        edad = e;
    }

    // Destructor
    ~Persona() {
        cout << "Destructor llamado para " << nombre << endl;
    }

    void saludar() {
        cout << "Hola, mi nombre es " << nombre << " y tengo " << edad << " años." << endl;
    }
};

int main() {
    // Crear un objeto de la clase Persona
    Persona juan("Juan", 30);
    juan.saludar();

    // El destructor se llamará automáticamente al final del alcance
    return 0;
}
```

#### Encapsulación

La encapsulación es un principio de la POO que restringe el acceso directo a los atributos de una clase. En lugar de eso, se proporcionan métodos públicos para acceder y modificar estos atributos.

##### Modificadores de Acceso

- **`public`:** Los miembros son accesibles desde cualquier parte del programa.
- **`private`:** Los miembros solo son accesibles desde dentro de la propia clase.
- **`protected`:** Los miembros son accesibles desde dentro de la clase y las clases derivadas.

```cpp
class Persona {
private:
    string nombre;
    int edad;

public:
    // Constructor
    Persona(string n, int e) : nombre(n), edad(e) {}

    // Métodos para acceder y modificar los atributos
    string getNombre() {
        return nombre;
    }

    void setNombre(string n) {
        nombre = n;
    }

    int getEdad() {
        return edad;
    }

    void setEdad(int e) {
        edad = e;
    }

    void saludar() {
        cout << "Hola, mi nombre es " << nombre << " y tengo " << edad << " años." << endl;
    }
};

int main() {
    Persona juan("Juan", 30);
    juan.saludar();

    juan.setEdad(31);
    cout << "Nueva edad de " << juan.getNombre() << ": " << juan.getEdad() << endl;

    return 0;
}
```

En este ejemplo, los atributos `nombre` y `edad` son privados, y se proporcionan métodos públicos para acceder y modificarlos.

### Conclusión

Las clases y objetos son los pilares de la programación orientada a objetos en C++. Las clases permiten definir plantillas para crear objetos, encapsulando datos y comportamientos relacionados. Los objetos son instancias de estas clases, y mediante el uso de constructores, destructores y modificadores de acceso, podemos gestionar y proteger eficazmente los datos dentro de nuestros programas. Con un entendimiento sólido de estos conceptos, los desarrolladores pueden crear aplicaciones más organizadas, modulares y mantenibles.
### Constructores en C++

Los constructores son funciones especiales de las clases en C++ que se utilizan para inicializar objetos. Un constructor tiene el mismo nombre que la clase y no tiene tipo de retorno, ni siquiera `void`. Los constructores pueden sobrecargarse, lo que significa que una clase puede tener más de un constructor con diferentes listas de parámetros.

#### Tipos de Constructores

1. **Constructor por Defecto**
2. **Constructor Parametrizado**
3. **Constructor de Copia**
4. **Constructor de Movimiento** (Introducido en C++11)

#### Constructor por Defecto

El constructor por defecto es un constructor que se llama automáticamente cuando se crea un objeto sin pasar argumentos. Si no se define explícitamente un constructor por defecto, el compilador genera uno implícitamente.

##### Ejemplo de Constructor por Defecto

```cpp
#include <iostream>
using namespace std;

class Persona {
public:
    string nombre;
    int edad;

    // Constructor por defecto
    Persona() {
        nombre = "Desconocido";
        edad = 0;
    }

    void mostrarInformacion() {
        cout << "Nombre: " << nombre << ", Edad: " << edad << endl;
    }
};

int main() {
    Persona p;  // Llama al constructor por defecto
    p.mostrarInformacion();

    return 0;
}
```

En este ejemplo, el constructor por defecto inicializa `nombre` a "Desconocido" y `edad` a 0.

#### Constructor Parametrizado

Un constructor parametrizado permite inicializar un objeto con valores específicos al momento de su creación.

##### Ejemplo de Constructor Parametrizado

```cpp
#include <iostream>
using namespace std;

class Persona {
public:
    string nombre;
    int edad;

    // Constructor parametrizado
    Persona(string n, int e) {
        nombre = n;
        edad = e;
    }

    void mostrarInformacion() {
        cout << "Nombre: " << nombre << ", Edad: " << edad << endl;
    }
};

int main() {
    Persona p("Juan", 30);  // Llama al constructor parametrizado
    p.mostrarInformacion();

    return 0;
}
```

En este ejemplo, el constructor parametrizado inicializa `nombre` y `edad` con los valores proporcionados.

#### Constructor de Copia

El constructor de copia se utiliza para crear un nuevo objeto como copia de un objeto existente. Se define tomando una referencia constante al objeto de la misma clase.

##### Ejemplo de Constructor de Copia

```cpp
#include <iostream>
using namespace std;

class Persona {
public:
    string nombre;
    int edad;

    // Constructor parametrizado
    Persona(string n, int e) {
        nombre = n;
        edad = e;
    }

    // Constructor de copia
    Persona(const Persona& p) {
        nombre = p.nombre;
        edad = p.edad;
    }

    void mostrarInformacion() {
        cout << "Nombre: " << nombre << ", Edad: " << edad << endl;
    }
};

int main() {
    Persona p1("Juan", 30);  // Llama al constructor parametrizado
    Persona p2 = p1;         // Llama al constructor de copia
    p2.mostrarInformacion();

    return 0;
}
```

En este ejemplo, el constructor de copia crea un nuevo objeto `p2` como una copia de `p1`.

#### Constructor de Movimiento (Introducido en C++11)

El constructor de movimiento se utiliza para transferir los recursos de un objeto a otro, evitando copias innecesarias. Se define tomando un rvalue reference al objeto de la misma clase.

##### Ejemplo de Constructor de Movimiento

```cpp
#include <iostream>
using namespace std;

class Persona {
public:
    string nombre;
    int edad;

    // Constructor parametrizado
    Persona(string n, int e) : nombre(n), edad(e) {}

    // Constructor de movimiento
    Persona(Persona&& p) noexcept : nombre(move(p.nombre)), edad(p.edad) {
        p.edad = 0; // Opcional: Dejar el objeto fuente en un estado válido
    }

    void mostrarInformacion() {
        cout << "Nombre: " << nombre << ", Edad: " << edad << endl;
    }
};

int main() {
    Persona p1("Juan", 30);  // Llama al constructor parametrizado
    Persona p2 = move(p1);   // Llama al constructor de movimiento
    p2.mostrarInformacion();

    // p1 está en un estado indefinido, pero válido
    cout << "Después de mover, p1: ";
    p1.mostrarInformacion();

    return 0;
}
```

En este ejemplo, el constructor de movimiento transfiere los recursos de `p1` a `p2`, evitando una copia completa.

#### Inicialización de Miembros (Lista de Inicialización)

Es una buena práctica inicializar los miembros de la clase en la lista de inicialización del constructor, especialmente para miembros constantes y referencias.

##### Ejemplo con Lista de Inicialización

```cpp
#include <iostream>
using namespace std;

class Punto {
public:
    const int x;
    const int y;

    // Constructor con lista de inicialización
    Punto(int a, int b) : x(a), y(b) {}

    void mostrarInformacion() {
        cout << "Punto(" << x << ", " << y << ")" << endl;
    }
};

int main() {
    Punto p(10, 20);  // Llama al constructor con lista de inicialización
    p.mostrarInformacion();

    return 0;
}
```

En este ejemplo, los miembros `x` y `y` se inicializan en la lista de inicialización del constructor.

#### Constructores Predeterminados por el Compilador

Si no se definen constructores, el compilador proporciona un constructor por defecto, un constructor de copia y un operador de asignación de copia. Estos constructores realizan inicializaciones y copias miembro a miembro.

### Ejemplo Completo con Diferentes Constructores

```cpp
#include <iostream>
using namespace std;

class Persona {
private:
    string nombre;
    int edad;

public:
    // Constructor por defecto
    Persona() : nombre("Desconocido"), edad(0) {}

    // Constructor parametrizado
    Persona(string n, int e) : nombre(n), edad(e) {}

    // Constructor de copia
    Persona(const Persona& p) : nombre(p.nombre), edad(p.edad) {}

    // Constructor de movimiento
    Persona(Persona&& p) noexcept : nombre(move(p.nombre)), edad(p.edad) {
        p.edad = 0;
    }

    void mostrarInformacion() {
        cout << "Nombre: " << nombre << ", Edad: " << edad << endl;
    }
};

int main() {
    // Usando el constructor por defecto
    Persona p1;
    p1.mostrarInformacion();

    // Usando el constructor parametrizado
    Persona p2("Juan", 30);
    p2.mostrarInformacion();

    // Usando el constructor de copia
    Persona p3 = p2;
    p3.mostrarInformacion();

    // Usando el constructor de movimiento
    Persona p4 = move(p2);
    p4.mostrarInformacion();

    // Estado después del movimiento
    cout << "Después de mover, p2: ";
    p2.mostrarInformacion();

    return 0;
}
```

En este ejemplo, la clase `Persona` define todos los tipos principales de constructores, y el programa demuestra cómo usarlos.

### Conclusión

Los constructores son fundamentales para la inicialización de objetos en C++. La capacidad de definir diferentes tipos de constructores (por defecto, parametrizados, de copia y de movimiento) proporciona flexibilidad y control sobre cómo se crean e inicializan los objetos. Utilizar correctamente estos constructores puede mejorar la eficiencia y la robustez del código, asegurando que los objetos se encuentren en estados válidos desde su creación.
### Setters y Getters en una Clase

Los setters y getters son métodos en una clase que se utilizan para controlar el acceso y la modificación de los atributos privados. Estos métodos ayudan a mantener el principio de encapsulación, permitiendo el acceso controlado a los datos de la clase y protegiendo la integridad de los atributos.

#### Encapsulación

La encapsulación es uno de los pilares de la programación orientada a objetos. Consiste en ocultar los detalles internos de una clase y proporcionar métodos públicos para acceder y modificar los datos. Esto mejora la seguridad y la integridad del estado del objeto.

##### Definición de Atributos Privados

En C++, los atributos de una clase se pueden declarar como privados utilizando el modificador de acceso `private`. Esto significa que estos atributos solo pueden ser accedidos y modificados desde dentro de la propia clase.

```cpp
class Persona {
private:
    string nombre;
    int edad;

public:
    // Métodos públicos
};
```

#### Métodos Getters

Los métodos getters se utilizan para acceder a los valores de los atributos privados. Generalmente, los getters son funciones constantes (`const`) porque no modifican el estado del objeto.

##### Ejemplo de Getters

```cpp
class Persona {
private:
    string nombre;
    int edad;

public:
    // Constructor
    Persona(string n, int e) : nombre(n), edad(e) {}

    // Getter para el nombre
    string getNombre() const {
        return nombre;
    }

    // Getter para la edad
    int getEdad() const {
        return edad;
    }
};
```

En este ejemplo, `getNombre` y `getEdad` son métodos getters que devuelven los valores de `nombre` y `edad`, respectivamente.

#### Métodos Setters

Los métodos setters se utilizan para modificar los valores de los atributos privados. Los setters permiten validar y controlar los datos antes de asignarlos a los atributos.

##### Ejemplo de Setters

```cpp
class Persona {
private:
    string nombre;
    int edad;

public:
    // Constructor
    Persona(string n, int e) : nombre(n), edad(e) {}

    // Setter para el nombre
    void setNombre(string n) {
        nombre = n;
    }

    // Setter para la edad
    void setEdad(int e) {
        if (e > 0) {  // Validación simple
            edad = e;
        } else {
            cout << "Edad no válida." << endl;
        }
    }

    // Getters
    string getNombre() const {
        return nombre;
    }

    int getEdad() const {
        return edad;
    }
};
```

En este ejemplo, `setNombre` y `setEdad` son métodos setters que permiten modificar los valores de `nombre` y `edad`, respectivamente. El setter `setEdad` incluye una validación para asegurarse de que la edad sea positiva.

#### Uso de Setters y Getters

Los setters y getters se utilizan en el programa principal para interactuar con los atributos privados de la clase.

##### Ejemplo Completo

```cpp
#include <iostream>
using namespace std;

class Persona {
private:
    string nombre;
    int edad;

public:
    // Constructor
    Persona(string n, int e) : nombre(n), edad(e) {}

    // Setters
    void setNombre(string n) {
        nombre = n;
    }

    void setEdad(int e) {
        if (e > 0) {
            edad = e;
        } else {
            cout << "Edad no válida." << endl;
        }
    }

    // Getters
    string getNombre() const {
        return nombre;
    }

    int getEdad() const {
        return edad;
    }

    // Método para mostrar información
    void mostrarInformacion() const {
        cout << "Nombre: " << nombre << ", Edad: " << edad << endl;
    }
};

int main() {
    // Crear un objeto de la clase Persona
    Persona juan("Juan", 30);
    juan.mostrarInformacion();

    // Modificar los atributos usando setters
    juan.setNombre("Juan Perez");
    juan.setEdad(31);
    juan.mostrarInformacion();

    // Intentar establecer una edad no válida
    juan.setEdad(-5);
    juan.mostrarInformacion();

    // Acceder a los atributos usando getters
    cout << "Nombre: " << juan.getNombre() << endl;
    cout << "Edad: " << juan.getEdad() << endl;

    return 0;
}
```

En este ejemplo, se crea un objeto `juan` de la clase `Persona`, se utilizan los setters para modificar sus atributos y los getters para acceder a ellos. La validación en el setter `setEdad` asegura que la edad no pueda establecerse en un valor no válido.

### Conclusión

Los setters y getters son herramientas esenciales en la programación orientada a objetos para implementar la encapsulación. Permiten controlar el acceso y la modificación de los atributos privados de una clase, asegurando que los datos se manejen de manera segura y consistente. Con el uso adecuado de setters y getters, se puede mejorar la robustez y mantenibilidad del código.
### Encapsulamiento en C++

El encapsulamiento es uno de los principios fundamentales de la programación orientada a objetos (POO). Este principio consiste en ocultar los detalles internos de la implementación de una clase y proporcionar una interfaz pública para interactuar con los objetos de esa clase. El encapsulamiento ayuda a proteger los datos y a mantener la integridad del estado del objeto, facilitando la modularidad y el mantenimiento del código.

#### Conceptos Clave del Encapsulamiento

1. **Acceso Controlado:** Solo los métodos permitidos pueden acceder o modificar los datos de un objeto.
2. **Ocultamiento de Información:** Los detalles internos de la implementación se ocultan al usuario.
3. **Interfaz Pública:** Se proporciona una interfaz clara y estable para interactuar con los datos del objeto.

#### Modificadores de Acceso

En C++, los modificadores de acceso se utilizan para controlar el nivel de acceso a los miembros de una clase. Existen tres modificadores de acceso principales:

1. **`public`:** Los miembros declarados como `public` son accesibles desde cualquier parte del programa.
2. **`private`:** Los miembros declarados como `private` solo son accesibles desde dentro de la propia clase.
3. **`protected`:** Los miembros declarados como `protected` son accesibles desde dentro de la clase y las clases derivadas.

##### Ejemplo Básico

```cpp
#include <iostream>
using namespace std;

class Ejemplo {
private:
    int datoPrivado; // Acceso privado

public:
    int datoPublico; // Acceso público

    // Constructor
    Ejemplo(int privado, int publico) : datoPrivado(privado), datoPublico(publico) {}

    // Método público para acceder al dato privado
    int getDatoPrivado() const {
        return datoPrivado;
    }

    // Método público para modificar el dato privado
    void setDatoPrivado(int valor) {
        datoPrivado = valor;
    }
};

int main() {
    Ejemplo obj(10, 20);

    // Acceso al dato público
    cout << "Dato público: " << obj.datoPublico << endl;

    // Acceso al dato privado a través de métodos públicos
    cout << "Dato privado: " << obj.getDatoPrivado() << endl;
    obj.setDatoPrivado(30);
    cout << "Dato privado modificado: " << obj.getDatoPrivado() << endl;

    return 0;
}
```

En este ejemplo, `datoPrivado` es un miembro privado y solo puede ser accedido y modificado a través de los métodos públicos `getDatoPrivado` y `setDatoPrivado`. `datoPublico` es un miembro público y puede ser accedido directamente.

#### Beneficios del Encapsulamiento

1. **Protección de Datos:** Los datos internos de un objeto están protegidos contra modificaciones indebidas.
2. **Mantenimiento:** Los detalles de implementación pueden cambiar sin afectar a los usuarios de la clase, siempre y cuando la interfaz pública permanezca constante.
3. **Modularidad:** Facilita la división del programa en módulos manejables y comprensibles.
4. **Reusabilidad:** Las clases encapsuladas pueden ser reutilizadas fácilmente en diferentes partes de un programa o en otros proyectos.

#### Encapsulamiento y Setters/Getters

Los setters y getters son métodos que proporcionan un acceso controlado a los atributos privados de una clase. A través de estos métodos, se puede aplicar lógica adicional para validar o transformar los datos antes de acceder o modificar los atributos.

##### Ejemplo con Setters y Getters

```cpp
#include <iostream>
using namespace std;

class Persona {
private:
    string nombre;
    int edad;

public:
    // Constructor
    Persona(string n, int e) : nombre(n), edad(e) {}

    // Getter para nombre
    string getNombre() const {
        return nombre;
    }

    // Setter para nombre
    void setNombre(string n) {
        nombre = n;
    }

    // Getter para edad
    int getEdad() const {
        return edad;
    }

    // Setter para edad con validación
    void setEdad(int e) {
        if (e > 0) {
            edad = e;
        } else {
            cout << "Edad no válida" << endl;
        }
    }

    // Método para mostrar información
    void mostrarInformacion() const {
        cout << "Nombre: " << nombre << ", Edad: " << edad << endl;
    }
};

int main() {
    Persona juan("Juan", 30);
    juan.mostrarInformacion();

    // Modificar atributos usando setters
    juan.setNombre("Juan Perez");
    juan.setEdad(31);
    juan.mostrarInformacion();

    // Intentar establecer una edad no válida
    juan.setEdad(-5);
    juan.mostrarInformacion();

    return 0;
}
```

En este ejemplo, `setNombre` y `setEdad` son métodos setters que permiten modificar los atributos privados `nombre` y `edad`. El método `setEdad` incluye una validación para asegurarse de que la edad sea positiva.

#### Encapsulamiento y Herencia

El encapsulamiento también juega un papel importante en la herencia. Los miembros `protected` pueden ser accedidos en clases derivadas, mientras que los miembros `private` no pueden ser accedidos directamente.

##### Ejemplo con Herencia

```cpp
#include <iostream>
using namespace std;

class Base {
private:
    int datoPrivado;

protected:
    int datoProtegido;

public:
    int datoPublico;

    Base(int priv, int prot, int pub) : datoPrivado(priv), datoProtegido(prot), datoPublico(pub) {}

    int getDatoPrivado() const {
        return datoPrivado;
    }

    int getDatoProtegido() const {
        return datoProtegido;
    }
};

class Derivada : public Base {
public:
    Derivada(int priv, int prot, int pub) : Base(priv, prot, pub) {}

    void mostrarDatos() {
        // cout << "Dato privado: " << getDatoPrivado() << endl; // No se puede acceder directamente
        cout << "Dato protegido: " << getDatoProtegido() << endl;
        cout << "Dato público: " << datoPublico << endl;
    }
};

int main() {
    Derivada obj(1, 2, 3);
    obj.mostrarDatos();

    return 0;
}
```

En este ejemplo, la clase `Derivada` hereda de la clase `Base`. Puede acceder al miembro `datoProtegido` a través de un método protegido en la clase base, pero no puede acceder directamente al miembro `datoPrivado`.

### Conclusión

El encapsulamiento es una técnica fundamental en la programación orientada a objetos que mejora la seguridad, la modularidad y la mantenibilidad del código. Al utilizar modificadores de acceso como `private`, `protected` y `public`, se puede controlar cómo se accede y modifica el estado interno de los objetos. Los setters y getters son herramientas esenciales para implementar el encapsulamiento, proporcionando un acceso controlado a los atributos privados. Con una comprensión sólida del encapsulamiento, los desarrolladores pueden crear clases robustas y seguras que faciliten el desarrollo de software de alta calidad.
### Destructores en C++

Un destructor es una función miembro especial de una clase que se llama automáticamente cuando un objeto de esa clase se destruye. Los destructores se utilizan para liberar recursos que el objeto pueda haber adquirido durante su vida, como memoria dinámica, archivos abiertos, o conexiones de red. El uso adecuado de destructores asegura que los recursos se gestionen de manera correcta, evitando fugas de memoria y otros problemas.

#### Características del Destructor

1. **Mismo Nombre que la Clase:** El destructor tiene el mismo nombre que la clase, precedido por un tilde (`~`).
2. **Sin Parámetros:** Un destructor no toma parámetros ni tiene un tipo de retorno.
3. **Automático:** Se llama automáticamente cuando un objeto sale de alcance o se elimina.
4. **Único:** Una clase puede tener solo un destructor.

##### Sintaxis del Destructor

```cpp
class NombreClase {
public:
    // Constructor
    NombreClase();

    // Destructor
    ~NombreClase();

    // Otros métodos y atributos
};
```

##### Ejemplo Básico de Destructor

```cpp
#include <iostream>
using namespace std;

class Persona {
public:
    string nombre;

    // Constructor
    Persona(string n) : nombre(n) {
        cout << "Constructor llamado para " << nombre << endl;
    }

    // Destructor
    ~Persona() {
        cout << "Destructor llamado para " << nombre << endl;
    }
};

int main() {
    Persona juan("Juan");
    {
        Persona maria("Maria");
    } // Destructor llamado para maria aquí

    cout << "Fin del main" << endl;
    return 0; // Destructor llamado para juan aquí
}
```

En este ejemplo, el destructor se llama automáticamente cuando los objetos `juan` y `maria` salen de su alcance.

#### Destructores y Recursos Dinámicos

Los destructores son especialmente importantes cuando una clase maneja recursos dinámicos, como memoria asignada dinámicamente, archivos, o conexiones de red. El destructor asegura que estos recursos se liberen correctamente cuando el objeto ya no se necesita.

##### Ejemplo con Recursos Dinámicos

```cpp
#include <iostream>
using namespace std;

class Array {
private:
    int* data;
    int size;

public:
    // Constructor
    Array(int s) : size(s) {
        data = new int[size]; // Asignar memoria dinámica
        cout << "Array de tamaño " << size << " creado." << endl;
    }

    // Destructor
    ~Array() {
        delete[] data; // Liberar memoria dinámica
        cout << "Array de tamaño " << size << " destruido." << endl;
    }

    // Método para establecer un valor en el array
    void setValue(int index, int value) {
        if (index >= 0 && index < size) {
            data[index] = value;
        }
    }

    // Método para obtener un valor del array
    int getValue(int index) const {
        if (index >= 0 && index < size) {
            return data[index];
        }
        return -1; // Valor de error
    }
};

int main() {
    Array arr(5);
    arr.setValue(0, 10);
    arr.setValue(1, 20);
    cout << "Valor en la posición 0: " << arr.getValue(0) << endl;
    cout << "Valor en la posición 1: " << arr.getValue(1) << endl;

    return 0;
}
```

En este ejemplo, el destructor de la clase `Array` se asegura de liberar la memoria asignada dinámicamente cuando el objeto `arr` se destruye.

#### Destructores en Clases Derivadas

En una jerarquía de herencia, los destructores de las clases base y derivadas se llaman en el orden correcto. Si una clase base tiene un destructor virtual, asegura que el destructor de la clase derivada se llame correctamente cuando se elimina un objeto a través de un puntero a la clase base.

##### Ejemplo con Herencia

```cpp
#include <iostream>
using namespace std;

class Base {
public:
    // Constructor
    Base() {
        cout << "Constructor de Base" << endl;
    }

    // Destructor virtual
    virtual ~Base() {
        cout << "Destructor de Base" << endl;
    }
};

class Derivada : public Base {
public:
    // Constructor
    Derivada() {
        cout << "Constructor de Derivada" << endl;
    }

    // Destructor
    ~Derivada() {
        cout << "Destructor de Derivada" << endl;
    }
};

int main() {
    Base* obj = new Derivada(); // Crear objeto de clase derivada
    delete obj; // Llamar al destructor virtual

    return 0;
}
```

En este ejemplo, el destructor de `Base` es virtual, asegurando que el destructor de `Derivada` se llame correctamente cuando el objeto se elimina a través de un puntero a la clase base.

#### Regla de Tres, Cinco y Cero

La "regla de tres" establece que si una clase necesita un destructor explícito, probablemente también necesite un constructor de copia y un operador de asignación de copia. La "regla de cinco" extiende esto a las operaciones de movimiento en C++11 y posteriores. La "regla de cero" sugiere usar tipos RAII (Resource Acquisition Is Initialization) para manejar recursos automáticamente, evitando la necesidad de destructores personalizados, constructores de copia, y operadores de asignación.

##### Regla de Tres

```cpp
class Ejemplo {
private:
    int* data;

public:
    // Constructor
    Ejemplo(int size) {
        data = new int[size];
    }

    // Destructor
    ~Ejemplo() {
        delete[] data;
    }

    // Constructor de copia
    Ejemplo(const Ejemplo& other) {
        data = new int[other.size];
        // Copiar datos...
    }

    // Operador de asignación de copia
    Ejemplo& operator=(const Ejemplo& other) {
        if (this != &other) {
            delete[] data;
            data = new int[other.size];
            // Copiar datos...
        }
        return *this;
    }
};
```

##### Regla de Cinco

```cpp
class Ejemplo {
private:
    int* data;

public:
    // Constructor
    Ejemplo(int size) {
        data = new int[size];
    }

    // Destructor
    ~Ejemplo() {
        delete[] data;
    }

    // Constructor de copia
    Ejemplo(const Ejemplo& other) {
        data = new int[other.size];
        // Copiar datos...
    }

    // Operador de asignación de copia
    Ejemplo& operator=(const Ejemplo& other) {
        if (this != &other) {
            delete[] data;
            data = new int[other.size];
            // Copiar datos...
        }
        return *this;
    }

    // Constructor de movimiento
    Ejemplo(Ejemplo&& other) noexcept : data(other.data) {
        other.data = nullptr;
    }

    // Operador de asignación de movimiento
    Ejemplo& operator=(Ejemplo&& other) noexcept {
        if (this != &other) {
            delete[] data;
            data = other.data;
            other.data = nullptr;
        }
        return *this;
    }
};
```

### Conclusión

Los destructores son una parte esencial de la administración de recursos en C++. Aseguran que los recursos adquiridos por un objeto se liberen adecuadamente cuando el objeto ya no se necesita. Entender cómo y cuándo implementar destructores, junto con las reglas de tres, cinco y cero, permite a los desarrolladores escribir código más seguro y eficiente, gestionando correctamente la memoria y otros recursos.
### Sobrecarga de Operadores en C++

La sobrecarga de operadores es una característica de C++ que permite a los programadores definir o alterar el comportamiento de los operadores para tipos de datos definidos por el usuario (clases). Esto hace que los objetos de las clases puedan ser utilizados de manera similar a los tipos de datos integrados, mejorando la legibilidad y usabilidad del código.

#### Fundamentos de la Sobrecarga de Operadores

1. **Definición:** La sobrecarga de operadores permite redefinir la funcionalidad de los operadores (como +, -, *, /, etc.) para que funcionen con objetos de clases definidas por el usuario.
2. **Sintaxis:** Se utiliza la palabra clave `operator` seguida del operador que se desea sobrecargar.
3. **Limitaciones:** No todos los operadores pueden ser sobrecargados, y no se pueden cambiar la precedencia, la asociatividad, o el número de operandos de un operador.

##### Ejemplo de Sobrecarga de Operadores

```cpp
#include <iostream>
using namespace std;

class Complejo {
private:
    double real;
    double imaginario;

public:
    // Constructor
    Complejo(double r = 0.0, double i = 0.0) : real(r), imaginario(i) {}

    // Sobrecarga del operador +
    Complejo operator+(const Complejo& c) const {
        return Complejo(real + c.real, imaginario + c.imaginario);
    }

    // Sobrecarga del operador <<
    friend ostream& operator<<(ostream& os, const Complejo& c) {
        os << "(" << c.real << " + " << c.imaginario << "i)";
        return os;
    }
};

int main() {
    Complejo c1(3.0, 4.0);
    Complejo c2(1.0, 2.0);

    Complejo c3 = c1 + c2;  // Usando la sobrecarga del operador +

    cout << "c1: " << c1 << endl;
    cout << "c2: " << c2 << endl;
    cout << "c3: " << c3 << endl;  // Usando la sobrecarga del operador <<

    return 0;
}
```

En este ejemplo:
- Se sobrecarga el operador `+` para la clase `Complejo`, permitiendo sumar dos objetos `Complejo`.
- Se sobrecarga el operador `<<` para permitir la salida de objetos `Complejo` usando `cout`.

#### Sobrecarga de Operadores Aritméticos

Los operadores aritméticos como `+`, `-`, `*`, `/`, `%`, etc., se pueden sobrecargar para realizar operaciones específicas con objetos de clases.

##### Ejemplo de Sobrecarga del Operador `*`

```cpp
#include <iostream>
using namespace std;

class Vector {
private:
    double x, y, z;

public:
    // Constructor
    Vector(double x, double y, double z) : x(x), y(y), z(z) {}

    // Sobrecarga del operador *
    Vector operator*(double escalar) const {
        return Vector(x * escalar, y * escalar, z * escalar);
    }

    // Sobrecarga del operador <<
    friend ostream& operator<<(ostream& os, const Vector& v) {
        os << "{" << v.x << ", " << v.y << ", " << v.z << "}";
        return os;
    }
};

int main() {
    Vector v1(1.0, 2.0, 3.0);
    Vector v2 = v1 * 2.0;

    cout << "v1: " << v1 << endl;
    cout << "v2: " << v2 << endl;

    return 0;
}
```

En este ejemplo, se sobrecarga el operador `*` para multiplicar un objeto `Vector` por un escalar.

#### Sobrecarga de Operadores de Comparación

Los operadores de comparación como `==`, `!=`, `<`, `>`, `<=`, `>=` se pueden sobrecargar para comparar objetos de clases.

##### Ejemplo de Sobrecarga del Operador `==`

```cpp
#include <iostream>
using namespace std;

class Punto {
private:
    int x, y;

public:
    // Constructor
    Punto(int x = 0, int y = 0) : x(x), y(y) {}

    // Sobrecarga del operador ==
    bool operator==(const Punto& p) const {
        return (x == p.x && y == p.y);
    }

    // Sobrecarga del operador <<
    friend ostream& operator<<(ostream& os, const Punto& p) {
        os << "(" << p.x << ", " << p.y << ")";
        return os;
    }
};

int main() {
    Punto p1(1, 2);
    Punto p2(1, 2);
    Punto p3(3, 4);

    cout << "p1: " << p1 << endl;
    cout << "p2: " << p2 << endl;
    cout << "p3: " << p3 << endl;

    cout << "p1 == p2: " << (p1 == p2) << endl;
    cout << "p1 == p3: " << (p1 == p3) << endl;

    return 0;
}
```

En este ejemplo, se sobrecarga el operador `==` para comparar dos objetos `Punto`.

#### Sobrecarga de Operadores de Incremento y Decremento

Los operadores de incremento (`++`) y decremento (`--`) se pueden sobrecargar tanto en su forma prefija como postfija.

##### Ejemplo de Sobrecarga del Operador `++`

```cpp
#include <iostream>
using namespace std;

class Contador {
private:
    int valor;

public:
    // Constructor
    Contador(int v = 0) : valor(v) {}

    // Sobrecarga del operador prefijo ++
    Contador& operator++() {
        ++valor;
        return *this;
    }

    // Sobrecarga del operador postfijo ++
    Contador operator++(int) {
        Contador temp = *this;
        ++valor;
        return temp;
    }

    // Sobrecarga del operador <<
    friend ostream& operator<<(ostream& os, const Contador& c) {
        os << c.valor;
        return os;
    }
};

int main() {
    Contador c(5);

    cout << "Valor inicial: " << c << endl;

    ++c;
    cout << "Después del prefijo ++: " << c << endl;

    c++;
    cout << "Después del postfijo ++: " << c << endl;

    return 0;
}
```

En este ejemplo, se sobrecargan tanto la forma prefija como postfija del operador `++` para la clase `Contador`.

#### Sobrecarga de Operadores de Acceso

Los operadores de acceso como `[]`, `->`, `*`, `()` se pueden sobrecargar para proporcionar comportamientos personalizados.

##### Ejemplo de Sobrecarga del Operador `[]`

```cpp
#include <iostream>
using namespace std;

class Array {
private:
    int* datos;
    int tamano;

public:
    // Constructor
    Array(int tamano) : tamano(tamano) {
        datos = new int[tamano];
        for (int i = 0; i < tamano; ++i) {
            datos[i] = 0;
        }
    }

    // Destructor
    ~Array() {
        delete[] datos;
    }

    // Sobrecarga del operador []
    int& operator[](int indice) {
        if (indice >= 0 && indice < tamano) {
            return datos[indice];
        }
        throw out_of_range("Índice fuera de rango");
    }

    // Sobrecarga del operador <<
    friend ostream& operator<<(ostream& os, const Array& arr) {
        os << "[";
        for (int i = 0; i < arr.tamano; ++i) {
            os << arr.datos[i];
            if (i < arr.tamano - 1) {
                os << ", ";
            }
        }
        os << "]";
        return os;
    }
};

int main() {
    Array arr(5);

    arr[0] = 10;
    arr[1] = 20;
    arr[2] = 30;

    cout << "Array: " << arr << endl;

    try {
        arr[5] = 50;  // Esto lanzará una excepción
    } catch (const out_of_range& e) {
        cout << e.what() << endl;
    }

    return 0;
}
```

En este ejemplo, se sobrecarga el operador `[]` para permitir el acceso a los elementos de un objeto `Array`.

### Conclusión

La sobrecarga de operadores en C++ permite definir cómo los operadores deben comportarse con los objetos de tipos definidos por el usuario. Esto facilita el uso intuitivo de estos objetos y mejora la legibilidad del código. Sin embargo, es importante usar la sobrecarga de operadores de manera adecuada y clara, evitando abusos que puedan llevar a un código confuso o difícil de mantener. Con una comprensión sólida de la sobrecarga de operadores, los desarrolladores pueden crear clases más poderosas y flexibles en C++.
### Destructor en C++

En la programación orientada a objetos en C++, un destructor es una función especial que se llama automáticamente cuando un objeto de la clase sale del alcance o se elimina. Los destructores se utilizan principalmente para liberar recursos que el objeto pueda haber adquirido durante su ciclo de vida, como memoria dinámica, archivos abiertos, conexiones de red, etc.

#### Características del Destructor

1. **Mismo Nombre que la Clase:** El destructor tiene el mismo nombre que la clase, precedido por un tilde (`~`).
2. **Sin Parámetros ni Tipo de Retorno:** Un destructor no toma parámetros ni tiene un tipo de retorno.
3. **Automático:** Se llama automáticamente cuando el objeto sale del alcance o se elimina.

##### Sintaxis del Destructor

```cpp
class NombreClase {
public:
    // Constructor
    NombreClase();

    // Destructor
    ~NombreClase();

    // Otros métodos y atributos
};
```

#### Ejemplo Básico de Destructor

```cpp
#include <iostream>
using namespace std;

class Persona {
public:
    string nombre;

    // Constructor
    Persona(string n) : nombre(n) {
        cout << "Constructor llamado para " << nombre << endl;
    }

    // Destructor
    ~Persona() {
        cout << "Destructor llamado para " << nombre << endl;
    }
};

int main() {
    Persona juan("Juan");
    {
        Persona maria("Maria");
    } // Destructor llamado para maria aquí

    cout << "Fin del main" << endl;
    return 0; // Destructor llamado para juan aquí
}
```

En este ejemplo, el destructor se llama automáticamente cuando los objetos `juan` y `maria` salen de su alcance.

#### Destructores y Recursos Dinámicos

Los destructores son especialmente importantes cuando una clase maneja recursos dinámicos, como memoria asignada dinámicamente, archivos o conexiones de red. El destructor asegura que estos recursos se liberen correctamente cuando el objeto ya no se necesita.

##### Ejemplo con Recursos Dinámicos

```cpp
#include <iostream>
using namespace std;

class Array {
private:
    int* data;
    int size;

public:
    // Constructor
    Array(int s) : size(s) {
        data = new int[size]; // Asignar memoria dinámica
        cout << "Array de tamaño " << size << " creado." << endl;
    }

    // Destructor
    ~Array() {
        delete[] data; // Liberar memoria dinámica
        cout << "Array de tamaño " << size << " destruido." << endl;
    }

    // Método para establecer un valor en el array
    void setValue(int index, int value) {
        if (index >= 0 && index < size) {
            data[index] = value;
        }
    }

    // Método para obtener un valor del array
    int getValue(int index) const {
        if (index >= 0 && index < size) {
            return data[index];
        }
        return -1; // Valor de error
    }
};

int main() {
    Array arr(5);
    arr.setValue(0, 10);
    arr.setValue(1, 20);
    cout << "Valor en la posición 0: " << arr.getValue(0) << endl;
    cout << "Valor en la posición 1: " << arr.getValue(1) << endl;

    return 0;
}
```

En este ejemplo, el destructor de la clase `Array` se asegura de liberar la memoria asignada dinámicamente cuando el objeto `arr` se destruye.

#### Destructores en Clases Derivadas

En una jerarquía de herencia, los destructores de las clases base y derivadas se llaman en el orden correcto. Si una clase base tiene un destructor virtual, asegura que el destructor de la clase derivada se llame correctamente cuando se elimina un objeto a través de un puntero a la clase base.

##### Ejemplo con Herencia

```cpp
#include <iostream>
using namespace std;

class Base {
public:
    // Constructor
    Base() {
        cout << "Constructor de Base" << endl;
    }

    // Destructor virtual
    virtual ~Base() {
        cout << "Destructor de Base" << endl;
    }
};

class Derivada : public Base {
public:
    // Constructor
    Derivada() {
        cout << "Constructor de Derivada" << endl;
    }

    // Destructor
    ~Derivada() {
        cout << "Destructor de Derivada" << endl;
    }
};

int main() {
    Base* obj = new Derivada(); // Crear objeto de clase derivada
    delete obj; // Llamar al destructor virtual

    return 0;
}
```

En este ejemplo, el destructor de `Base` es virtual, asegurando que el destructor de `Derivada` se llame correctamente cuando el objeto se elimina a través de un puntero a la clase base.

#### Regla de Tres, Cinco y Cero

La "regla de tres" establece que si una clase necesita un destructor explícito, probablemente también necesite un constructor de copia y un operador de asignación de copia. La "regla de cinco" extiende esto a las operaciones de movimiento en C++11 y posteriores. La "regla de cero" sugiere usar tipos RAII (Resource Acquisition Is Initialization) para manejar recursos automáticamente, evitando la necesidad de destructores personalizados, constructores de copia y operadores de asignación.

##### Regla de Tres

```cpp
class Ejemplo {
private:
    int* data;

public:
    // Constructor
    Ejemplo(int size) {
        data = new int[size];
    }

    // Destructor
    ~Ejemplo() {
        delete[] data;
    }

    // Constructor de copia
    Ejemplo(const Ejemplo& other) {
        data = new int[other.size];
        // Copiar datos...
    }

    // Operador de asignación de copia
    Ejemplo& operator=(const Ejemplo& other) {
        if (this != &other) {
            delete[] data;
            data = new int[other.size];
            // Copiar datos...
        }
        return *this;
    }
};
```

##### Regla de Cinco

```cpp
class Ejemplo {
private:
    int* data;

public:
    // Constructor
    Ejemplo(int size) {
        data = new int[size];
    }

    // Destructor
    ~Ejemplo() {
        delete[] data;
    }

    // Constructor de copia
    Ejemplo(const Ejemplo& other) {
        data = new int[other.size];
        // Copiar datos...
    }

    // Operador de asignación de copia
    Ejemplo& operator=(const Ejemplo& other) {
        if (this != &other) {
            delete[] data;
            data = new int[other.size];
            // Copiar datos...
        }
        return *this;
    }

    // Constructor de movimiento
    Ejemplo(Ejemplo&& other) noexcept : data(other.data) {
        other.data = nullptr;
    }

    // Operador de asignación de movimiento
    Ejemplo& operator=(Ejemplo&& other) noexcept {
        if (this != &other) {
            delete[] data;
            data = other.data;
            other.data = nullptr;
        }
        return *this;
    }
};
```

### Conclusión

Los destructores son una parte esencial de la administración de recursos en C++. Aseguran que los recursos adquiridos por un objeto se liberen adecuadamente cuando el objeto ya no se necesita. Entender cómo y cuándo implementar destructores, junto con las reglas de tres, cinco y cero, permite a los desarrolladores escribir código más seguro y eficiente, gestionando correctamente la memoria y otros recursos.
### Sobrecarga de Operadores en C++

La sobrecarga de operadores es una característica de C++ que permite a los programadores definir o modificar el comportamiento de los operadores para tipos de datos definidos por el usuario (clases). Esto hace que los objetos de estas clases puedan ser utilizados de manera similar a los tipos de datos integrados, mejorando la legibilidad y usabilidad del código.

#### Fundamentos de la Sobrecarga de Operadores

1. **Definición:** La sobrecarga de operadores permite redefinir la funcionalidad de los operadores (como +, -, *, /, etc.) para que funcionen con objetos de clases definidas por el usuario.
2. **Sintaxis:** Se utiliza la palabra clave `operator` seguida del operador que se desea sobrecargar.
3. **Limitaciones:** No todos los operadores pueden ser sobrecargados, y no se pueden cambiar la precedencia, la asociatividad, o el número de operandos de un operador.

##### Ejemplo de Sobrecarga de Operadores

```cpp
#include <iostream>
using namespace std;

class Complejo {
private:
    double real;
    double imaginario;

public:
    // Constructor
    Complejo(double r = 0.0, double i = 0.0) : real(r), imaginario(i) {}

    // Sobrecarga del operador +
    Complejo operator+(const Complejo& c) const {
        return Complejo(real + c.real, imaginario + c.imaginario);
    }

    // Sobrecarga del operador <<
    friend ostream& operator<<(ostream& os, const Complejo& c) {
        os << "(" << c.real << " + " << c.imaginario << "i)";
        return os;
    }
};

int main() {
    Complejo c1(3.0, 4.0);
    Complejo c2(1.0, 2.0);

    Complejo c3 = c1 + c2;  // Usando la sobrecarga del operador +

    cout << "c1: " << c1 << endl;
    cout << "c2: " << c2 << endl;
    cout << "c3: " << c3 << endl;  // Usando la sobrecarga del operador <<

    return 0;
}
```

En este ejemplo:
- Se sobrecarga el operador `+` para la clase `Complejo`, permitiendo sumar dos objetos `Complejo`.
- Se sobrecarga el operador `<<` para permitir la salida de objetos `Complejo` usando `cout`.

#### Sobrecarga de Operadores Aritméticos

Los operadores aritméticos como `+`, `-`, `*`, `/`, `%`, etc., se pueden sobrecargar para realizar operaciones específicas con objetos de clases.

##### Ejemplo de Sobrecarga del Operador `*`

```cpp
#include <iostream>
using namespace std;

class Vector {
private:
    double x, y, z;

public:
    // Constructor
    Vector(double x, double y, double z) : x(x), y(y), z(z) {}

    // Sobrecarga del operador *
    Vector operator*(double escalar) const {
        return Vector(x * escalar, y * escalar, z * escalar);
    }

    // Sobrecarga del operador <<
    friend ostream& operator<<(ostream& os, const Vector& v) {
        os << "{" << v.x << ", " << v.y << ", " << v.z << "}";
        return os;
    }
};

int main() {
    Vector v1(1.0, 2.0, 3.0);
    Vector v2 = v1 * 2.0;

    cout << "v1: " << v1 << endl;
    cout << "v2: " << v2 << endl;

    return 0;
}
```

En este ejemplo, se sobrecarga el operador `*` para multiplicar un objeto `Vector` por un escalar.

#### Sobrecarga de Operadores de Comparación

Los operadores de comparación como `==`, `!=`, `<`, `>`, `<=`, `>=` se pueden sobrecargar para comparar objetos de clases.

##### Ejemplo de Sobrecarga del Operador `==`

```cpp
#include <iostream>
using namespace std;

class Punto {
private:
    int x, y;

public:
    // Constructor
    Punto(int x = 0, int y = 0) : x(x), y(y) {}

    // Sobrecarga del operador ==
    bool operator==(const Punto& p) const {
        return (x == p.x && y == p.y);
    }

    // Sobrecarga del operador <<
    friend ostream& operator<<(ostream& os, const Punto& p) {
        os << "(" << p.x << ", " << p.y << ")";
        return os;
    }
};

int main() {
    Punto p1(1, 2);
    Punto p2(1, 2);
    Punto p3(3, 4);

    cout << "p1: " << p1 << endl;
    cout << "p2: " << p2 << endl;
    cout << "p3: " << p3 << endl;

    cout << "p1 == p2: " << (p1 == p2) << endl;
    cout << "p1 == p3: " << (p1 == p3) << endl;

    return 0;
}
```

En este ejemplo, se sobrecarga el operador `==` para comparar dos objetos `Punto`.

#### Sobrecarga de Operadores de Incremento y Decremento

Los operadores de incremento (`++`) y decremento (`--`) se pueden sobrecargar tanto en su forma prefija como postfija.

##### Ejemplo de Sobrecarga del Operador `++`

```cpp
#include <iostream>
using namespace std;

class Contador {
private:
    int valor;

public:
    // Constructor
    Contador(int v = 0) : valor(v) {}

    // Sobrecarga del operador prefijo ++
    Contador& operator++() {
        ++valor;
        return *this;
    }

    // Sobrecarga del operador postfijo ++
    Contador operator++(int) {
        Contador temp = *this;
        ++valor;
        return temp;
    }

    // Sobrecarga del operador <<
    friend ostream& operator<<(ostream& os, const Contador& c) {
        os << c.valor;
        return os;
    }
};

int main() {
    Contador c(5);

    cout << "Valor inicial: " << c << endl;

    ++c;
    cout << "Después del prefijo ++: " << c << endl;

    c++;
    cout << "Después del postfijo ++: " << c << endl;

    return 0;
}
```

En este ejemplo, se sobrecargan tanto la forma prefija como postfija del operador `++` para la clase `Contador`.

#### Sobrecarga de Operadores de Acceso

Los operadores de acceso como `[]`, `->`, `*`, `()` se pueden sobrecargar para proporcionar comportamientos personalizados.

##### Ejemplo de Sobrecarga del Operador `[]`

```cpp
#include <iostream>
using namespace std;

class Array {
private:
    int* datos;
    int tamano;

public:
    // Constructor
    Array(int tamano) : tamano(tamano) {
        datos = new int[tamano];
        for (int i = 0; i < tamano; ++i) {
            datos[i] = 0;
        }
    }

    // Destructor
    ~Array() {
        delete[] datos;
    }

    // Sobrecarga del operador []
    int& operator[](int indice) {
        if (indice >= 0 && indice < tamano) {
            return datos[indice];
        }
        throw out_of_range("Índice fuera de rango");
    }

    // Sobrecarga del operador <<
    friend ostream& operator<<(ostream& os, const Array& arr) {
        os << "[";
        for (int i = 0; i < arr.tamano; ++i) {
            os << arr.datos[i];
            if (i < arr.tamano - 1) {
                os << ", ";
            }
        }
        os << "]";
        return os;
    }
};

int main() {
    Array arr(5);

    arr[0] = 10;
    arr[1] = 20;
    arr[2] = 30;

    cout << "Array: " << arr << endl;

    try {
        arr[5] = 50;  // Esto lanzará una excepción
    } catch (const out_of_range& e) {
        cout << e.what() << endl;
    }

    return 0;
}
```

En este ejemplo, se sobrecarga el operador `[]` para permitir el acceso a los elementos de un objeto `Array`.

### Conclusión

La sobrecarga de operadores en C++ permite definir cómo los operadores deben comportarse con los objetos de tipos definidos por el usuario. Esto facilita el uso intuitivo de estos objetos y mejora la legibilidad del código. Sin embargo, es importante usar la sobrecarga de operadores de manera adecuada y clara, evitando abusos que puedan llevar a un código confuso o difícil de mantener. Con una comprensión sólida de la sobrecarga de operadores, los desarrolladores pueden crear clases más poderosas y flexibles en C++.
### Destructor en C++

En la programación orientada a objetos en C++, un destructor es una función especial que se llama automáticamente cuando un objeto de la clase sale del alcance o se elimina. Los destructores se utilizan principalmente para liberar recursos que el objeto pueda haber adquirido durante su ciclo de vida, como memoria dinámica, archivos abiertos, conexiones de red, etc.

#### Características del Destructor

1. **Mismo Nombre que la Clase:** El destructor tiene el mismo nombre que la clase, precedido por un tilde (`~`).
2. **Sin Parámetros ni Tipo de Retorno:** Un destructor no toma parámetros ni tiene un tipo de retorno.
3. **Automático:** Se llama automáticamente cuando el objeto sale del alcance o se elimina.

##### Sintaxis del Destructor

```cpp
class NombreClase {
public:
    // Constructor
    NombreClase();

    // Destructor
    ~NombreClase();

    // Otros métodos y atributos
};
```

#### Ejemplo Básico de Destructor

```cpp
#include <iostream>
using namespace std;

class Persona {
public:
    string nombre;

    // Constructor
    Persona(string n) : nombre(n) {
        cout << "Constructor llamado para " << nombre << endl;
    }

    // Destructor
    ~Persona() {
        cout << "Destructor llamado para " << nombre << endl;
    }
};

int main() {
    Persona juan("Juan");
    {
        Persona maria("Maria");
    } // Destructor llamado para maria aquí

    cout << "Fin del main" << endl;
    return 0; // Destructor llamado para juan aquí
}
```

En este ejemplo, el destructor se llama automáticamente cuando los objetos `juan` y `maria` salen de su alcance.

#### Destructores y Recursos Dinámicos

Los destructores son especialmente importantes cuando una clase maneja recursos dinámicos, como memoria asignada dinámicamente, archivos o conexiones de red. El destructor asegura que estos recursos se liberen correctamente cuando el objeto ya no se necesita.

##### Ejemplo con Recursos Dinámicos

```cpp
#include <iostream>
using namespace std;

class Array {
private:
    int* data;
    int size;

public:
    // Constructor
    Array(int s) : size(s) {
        data = new int[size]; // Asignar memoria dinámica
        cout << "Array de tamaño " << size << " creado." << endl;
    }

    // Destructor
    ~Array() {
        delete[] data; // Liberar memoria dinámica
        cout << "Array de tamaño " << size << " destruido." << endl;
    }

    // Método para establecer un valor en el array
    void setValue(int index, int value) {
        if (index >= 0 && index < size) {
            data[index] = value;
        }
    }

    // Método para obtener un valor del array
    int getValue(int index) const {
        if (index >= 0 && index < size) {
            return data[index];
        }
        return -1; // Valor de error
    }
};

int main() {
    Array arr(5);
    arr.setValue(0, 10);
    arr.setValue(1, 20);
    cout << "Valor en la posición 0: " << arr.getValue(0) << endl;
    cout << "Valor en la posición 1: " << arr.getValue(1) << endl;

    return 0;
}
```

En este ejemplo, el destructor de la clase `Array` se asegura de liberar la memoria asignada dinámicamente cuando el objeto `arr` se destruye.

#### Destructores en Clases Derivadas

En una jerarquía de herencia, los destructores de las clases base y derivadas se llaman en el orden correcto. Si una clase base tiene un destructor virtual, asegura que el destructor de la clase derivada se llame correctamente cuando se elimina un objeto a través de un puntero a la clase base.

##### Ejemplo con Herencia

```cpp
#include <iostream>
using namespace std;

class Base {
public:
    // Constructor
    Base() {
        cout << "Constructor de Base" << endl;
    }

    // Destructor virtual
    virtual ~Base() {
        cout << "Destructor de Base" << endl;
    }
};

class Derivada : public Base {
public:
    // Constructor
    Derivada() {
        cout << "Constructor de Derivada" << endl;
    }

    // Destructor
    ~Derivada() {
        cout << "Destructor de Derivada" << endl;
    }
};

int main() {
    Base* obj = new Derivada(); // Crear objeto de clase derivada
    delete obj; // Llamar al destructor virtual

    return 0;
}
```

En este ejemplo, el destructor de `Base` es virtual, asegurando que el destructor de `Derivada` se llame correctamente cuando el objeto se elimina a través de un puntero a la clase base.

#### Regla de Tres, Cinco y Cero

La "regla de tres" establece que si una clase necesita un destructor explícito, probablemente también necesite un constructor de copia y un operador de asignación de copia. La "regla de cinco" extiende esto a las operaciones de movimiento en C++11 y posteriores. La "regla de cero" sugiere usar tipos RAII (Resource Acquisition Is Initialization) para manejar recursos automáticamente, evitando la necesidad de destructores personalizados, constructores de copia y operadores de asignación.

##### Regla de Tres

```cpp
class Ejemplo {
private:
    int* data;

public:
    // Constructor
    Ejemplo(int size) {
        data = new int[size];
    }

    // Destructor
    ~Ejemplo() {
        delete[] data;
    }

    // Constructor de copia
    Ejemplo(const Ejemplo& other) {
        data = new int[other.size];
        // Copiar datos...
    }

    // Operador de asignación de copia
    Ejemplo& operator=(const Ejemplo& other) {
        if (this != &other) {
            delete[] data;
            data = new int[other.size];
            // Copiar datos...
        }
        return *this;
    }
};
```

##### Regla de Cinco

```cpp
class Ejemplo {
private:
    int* data;

public:
    // Constructor
    Ejemplo(int size) {
        data = new int[size];
    }

    // Destructor
    ~Ejemplo() {
        delete[] data;
    }

    // Constructor de copia
    Ejemplo(const Ejemplo& other) {
        data = new int[other.size];
        // Copiar datos...
    }

    // Operador de asignación de copia
    Ejemplo& operator=(const Ejemplo& other) {
        if (this != &other) {
            delete[] data;
            data = new int[other.size];
            // Copiar datos...
        }
        return *this;
    }

    // Constructor de movimiento
    Ejemplo(Ejemplo&& other) noexcept : data(other.data) {
        other.data = nullptr;
    }

    // Operador de asignación de movimiento
    Ejemplo& operator=(Ejemplo&& other) noexcept {
        if (this != &other) {
            delete[] data;
            data = other.data;
            other.data = nullptr;
        }
        return *this;
    }
};
```

### Conclusión

Los destructores son una parte esencial de la administración de recursos en C++. Aseguran que los recursos adquiridos por un objeto se liberen adecuadamente cuando el objeto ya no se necesita. Entender cómo y cuándo implementar destructores, junto con las reglas de tres, cinco y cero, permite a los desarrolladores escribir código más seguro y eficiente, gestionando correctamente la memoria y otros recursos.
### El Puntero `this` en C++

En C++, el puntero `this` es un puntero implícito disponible en las funciones miembro de una clase. Apunta al objeto actual que invoca la función miembro. El puntero `this` es muy útil para acceder a los miembros del objeto, distinguir entre miembros de la clase y parámetros con el mismo nombre, y para encadenar llamadas a funciones miembro.

#### Características del Puntero `this`

1. **Implícito:** No es necesario declarar o inicializar `this`; está disponible automáticamente en las funciones miembro.
2. **Apunta al Objeto Actual:** `this` siempre apunta al objeto que invoca la función miembro.
3. **Constancia en Funciones Constantes:** En funciones miembro constantes, `this` es un puntero a un objeto constante (`const`).

#### Uso Básico del Puntero `this`

El uso básico de `this` es para acceder a los miembros del objeto dentro de sus funciones miembro.

##### Ejemplo Básico

```cpp
#include <iostream>
using namespace std;

class Punto {
private:
    int x, y;

public:
    // Constructor
    Punto(int x = 0, int y = 0) : x(x), y(y) {}

    // Función para establecer valores usando this
    void setXY(int x, int y) {
        this->x = x;  // Acceso a miembro de la clase
        this->y = y;  // Acceso a miembro de la clase
    }

    // Función para mostrar valores
    void mostrar() const {
        cout << "Punto(" << x << ", " << y << ")" << endl;
    }
};

int main() {
    Punto p(10, 20);
    p.mostrar();

    p.setXY(30, 40);
    p.mostrar();

    return 0;
}
```

En este ejemplo, `this->x` y `this->y` se utilizan para acceder a los miembros `x` y `y` de la clase `Punto`.

#### Encadenamiento de Métodos

El puntero `this` se puede utilizar para devolver una referencia al objeto actual, permitiendo encadenar llamadas a métodos.

##### Ejemplo de Encadenamiento de Métodos

```cpp
#include <iostream>
using namespace std;

class Rectangulo {
private:
    int ancho, alto;

public:
    // Constructor
    Rectangulo(int ancho = 0, int alto = 0) : ancho(ancho), alto(alto) {}

    // Métodos para establecer valores con encadenamiento
    Rectangulo& setAncho(int ancho) {
        this->ancho = ancho;
        return *this;
    }

    Rectangulo& setAlto(int alto) {
        this->alto = alto;
        return *this;
    }

    // Función para mostrar valores
    void mostrar() const {
        cout << "Rectangulo(" << ancho << ", " << alto << ")" << endl;
    }
};

int main() {
    Rectangulo r;
    r.setAncho(10).setAlto(20);  // Encadenamiento de métodos
    r.mostrar();

    return 0;
}
```

En este ejemplo, `setAncho` y `setAlto` devuelven una referencia al objeto actual (`*this`), permitiendo encadenar las llamadas a métodos.

#### Uso de `this` en Funciones Constantes

En funciones miembro constantes, `this` es un puntero a un objeto constante (`const`), lo que garantiza que la función no puede modificar los miembros del objeto.

##### Ejemplo con Función Constante

```cpp
#include <iostream>
using namespace std;

class Circulo {
private:
    double radio;

public:
    // Constructor
    Circulo(double radio = 0) : radio(radio) {}

    // Método constante
    double getRadio() const {
        return this->radio;  // `this` es un puntero a un objeto constante
    }

    // Método para establecer el radio
    void setRadio(double radio) {
        this->radio = radio;
    }

    // Función para mostrar el radio
    void mostrar() const {
        cout << "Circulo con radio: " << this->getRadio() << endl;
    }
};

int main() {
    Circulo c(5.0);
    c.mostrar();

    c.setRadio(10.0);
    c.mostrar();

    return 0;
}
```

En este ejemplo, `getRadio` es una función constante que utiliza `this` para acceder al miembro `radio`.

#### Prevención de Auto-Asignación

El puntero `this` se puede utilizar para prevenir la auto-asignación en el operador de asignación sobrecargado.

##### Ejemplo de Prevención de Auto-Asignación

```cpp
#include <iostream>
#include <cstring>
using namespace std;

class Cadena {
private:
    char* str;

public:
    // Constructor
    Cadena(const char* s) {
        str = new char[strlen(s) + 1];
        strcpy(str, s);
    }

    // Destructor
    ~Cadena() {
        delete[] str;
    }

    // Constructor de copia
    Cadena(const Cadena& other) {
        str = new char[strlen(other.str) + 1];
        strcpy(str, other.str);
    }

    // Operador de asignación sobrecargado
    Cadena& operator=(const Cadena& other) {
        if (this != &other) {  // Prevención de auto-asignación
            delete[] str;
            str = new char[strlen(other.str) + 1];
            strcpy(str, other.str);
        }
        return *this;
    }

    // Función para mostrar la cadena
    void mostrar() const {
        cout << "Cadena: " << str << endl;
    }
};

int main() {
    Cadena c1("Hola");
    Cadena c2("Mundo");

    c1.mostrar();
    c2.mostrar();

    c2 = c1;  // Usando el operador de asignación sobrecargado
    c2.mostrar();

    return 0;
}
```

En este ejemplo, `this` se utiliza para comprobar la auto-asignación en el operador de asignación sobrecargado (`operator=`).

### Conclusión

El puntero `this` en C++ es una herramienta poderosa que permite a los programadores acceder y manipular los miembros del objeto actual dentro de las funciones miembro. Es fundamental para la implementación de técnicas como el encadenamiento de métodos, la prevención de auto-asignación y la diferenciación entre miembros de la clase y parámetros con el mismo nombre. Entender y utilizar correctamente `this` puede mejorar la claridad y la eficiencia del código orientado a objetos en C++.
<---FILES--->
Definición de una Clase
Definición de una Clase Result
Ejemplo Básico de una Clase
Ejemplo Básico de una Clase Result
Creación de Objetos
Creación de Objetos Result
Ejemplo de Creación y Uso de Objetos
Ejemplo de Creación y Uso de Objetos Result
Constructores
Constructores Result
Destructores
Destructores Result
Modificadores de Acceso
Modificadores de Acceso Result
Definición de una Clase
Definición de una Clase Result
Ejemplo Básico de una Clase
Ejemplo Básico de una Clase Result
Creación de Objetos
Creación de Objetos Result
Ejemplo de Creación y Uso de Objetos
Ejemplo de Creación y Uso de Objetos Result
Constructores
Constructores Result
Destructores
Destructores Result
Modificadores de Acceso
Modificadores de Acceso Result
Ejemplo de Constructor por Defecto
Ejemplo de Constructor por Defecto Result
Ejemplo de Constructor Parametrizado
Ejemplo de Constructor Parametrizado Result
Ejemplo de Constructor de Copia
Ejemplo de Constructor de Copia Result
Ejemplo de Constructor de Movimiento
Ejemplo de Constructor de Movimiento Result
Ejemplo con Lista de Inicialización
Ejemplo con Lista de Inicialización Result
Definición de una Clase
Definición de una Clase Result
Ejemplo Básico de una Clase
Ejemplo Básico de una Clase Result
Creación de Objetos
Creación de Objetos Result
Ejemplo de Creación y Uso de Objetos
Ejemplo de Creación y Uso de Objetos Result
Constructores
Constructores Result
Destructores
Destructores Result
Modificadores de Acceso
Modificadores de Acceso Result
Ejemplo de Constructor por Defecto
Ejemplo de Constructor por Defecto Result
Ejemplo de Constructor Parametrizado
Ejemplo de Constructor Parametrizado Result
Ejemplo de Constructor de Copia
Ejemplo de Constructor de Copia Result
Ejemplo de Constructor de Movimiento
Ejemplo de Constructor de Movimiento Result
Ejemplo con Lista de Inicialización
Ejemplo con Lista de Inicialización Result
Definición de Atributos Privados
Definición de Atributos Privados Result
Ejemplo de Getters
Ejemplo de Getters Result
Ejemplo de Setters
Ejemplo de Setters Result
Ejemplo Completo
Ejemplo Completo Result
Definición de una Clase
Definición de una Clase Result
Ejemplo Básico de una Clase
Ejemplo Básico de una Clase Result
Creación de Objetos
Creación de Objetos Result
Ejemplo de Creación y Uso de Objetos
Ejemplo de Creación y Uso de Objetos Result
Constructores
Constructores Result
Destructores
Destructores Result
Modificadores de Acceso
Modificadores de Acceso Result
Ejemplo de Constructor por Defecto
Ejemplo de Constructor por Defecto Result
Ejemplo de Constructor Parametrizado
Ejemplo de Constructor Parametrizado Result
Ejemplo de Constructor de Copia
Ejemplo de Constructor de Copia Result
Ejemplo de Constructor de Movimiento
Ejemplo de Constructor de Movimiento Result
Ejemplo con Lista de Inicialización
Ejemplo con Lista de Inicialización Result
Definición de Atributos Privados
Definición de Atributos Privados Result
Ejemplo de Getters
Ejemplo de Getters Result
Ejemplo de Setters
Ejemplo de Setters Result
Ejemplo Completo
Ejemplo Completo Result
Ejemplo Básico
Ejemplo Básico Result
Ejemplo con Setters y Getters
Ejemplo con Setters y Getters Result
Ejemplo con Herencia
Ejemplo con Herencia Result
Definición de una Clase
Definición de una Clase Result
Ejemplo Básico de una Clase
Ejemplo Básico de una Clase Result
Creación de Objetos
Creación de Objetos Result
Ejemplo de Creación y Uso de Objetos
Ejemplo de Creación y Uso de Objetos Result
Constructores
Constructores Result
Destructores
Destructores Result
Modificadores de Acceso
Modificadores de Acceso Result
Ejemplo de Constructor por Defecto
Ejemplo de Constructor por Defecto Result
Ejemplo de Constructor Parametrizado
Ejemplo de Constructor Parametrizado Result
Ejemplo de Constructor de Copia
Ejemplo de Constructor de Copia Result
Ejemplo de Constructor de Movimiento
Ejemplo de Constructor de Movimiento Result
Ejemplo con Lista de Inicialización
Ejemplo con Lista de Inicialización Result
Definición de Atributos Privados
Definición de Atributos Privados Result
Ejemplo de Getters
Ejemplo de Getters Result
Ejemplo de Setters
Ejemplo de Setters Result
Ejemplo Completo
Ejemplo Completo Result
Ejemplo Básico
Ejemplo Básico Result
Ejemplo con Setters y Getters
Ejemplo con Setters y Getters Result
Ejemplo con Herencia
Ejemplo con Herencia Result
Sintaxis del Destructor
Sintaxis del Destructor Result
Ejemplo Básico de Destructor
Ejemplo Básico de Destructor Result
Ejemplo con Recursos Dinámicos
Ejemplo con Recursos Dinámicos Result
Regla de Tres
Regla de Tres Result
Regla de Cinco
Regla de Cinco Result
Definición de una Clase
Definición de una Clase Result
Ejemplo Básico de una Clase
Ejemplo Básico de una Clase Result
Creación de Objetos
Creación de Objetos Result
Ejemplo de Creación y Uso de Objetos
Ejemplo de Creación y Uso de Objetos Result
Constructores
Constructores Result
Destructores
Destructores Result
Modificadores de Acceso
Modificadores de Acceso Result
Ejemplo de Constructor por Defecto
Ejemplo de Constructor por Defecto Result
Ejemplo de Constructor Parametrizado
Ejemplo de Constructor Parametrizado Result
Ejemplo de Constructor de Copia
Ejemplo de Constructor de Copia Result
Ejemplo de Constructor de Movimiento
Ejemplo de Constructor de Movimiento Result
Ejemplo con Lista de Inicialización
Ejemplo con Lista de Inicialización Result
Definición de Atributos Privados
Definición de Atributos Privados Result
Ejemplo de Getters
Ejemplo de Getters Result
Ejemplo de Setters
Ejemplo de Setters Result
Ejemplo Completo
Ejemplo Completo Result
Ejemplo Básico
Ejemplo Básico Result
Ejemplo con Setters y Getters
Ejemplo con Setters y Getters Result
Ejemplo con Herencia
Ejemplo con Herencia Result
Sintaxis del Destructor
Sintaxis del Destructor Result
Ejemplo Básico de Destructor
Ejemplo Básico de Destructor Result
Ejemplo con Recursos Dinámicos
Ejemplo con Recursos Dinámicos Result
Regla de Tres
Regla de Tres Result
Regla de Cinco
Regla de Cinco Result
Ejemplo de Sobrecarga de Operadores
Ejemplo de Sobrecarga de Operadores Result
Ejemplo de Sobrecarga del Operador `*`
Ejemplo de Sobrecarga del Operador `*` Result
Ejemplo de Sobrecarga del Operador `==`
Ejemplo de Sobrecarga del Operador `==` Result
Ejemplo de Sobrecarga del Operador `++`
Ejemplo de Sobrecarga del Operador `++` Result
Ejemplo de Sobrecarga del Operador `[]`
Ejemplo de Sobrecarga del Operador `[]` Result
Definición de una Clase
Definición de una Clase Result
Ejemplo Básico de una Clase
Ejemplo Básico de una Clase Result
Creación de Objetos
Creación de Objetos Result
Ejemplo de Creación y Uso de Objetos
Ejemplo de Creación y Uso de Objetos Result
Constructores
Constructores Result
Destructores
Destructores Result
Modificadores de Acceso
Modificadores de Acceso Result
Ejemplo de Constructor por Defecto
Ejemplo de Constructor por Defecto Result
Ejemplo de Constructor Parametrizado
Ejemplo de Constructor Parametrizado Result
Ejemplo de Constructor de Copia
Ejemplo de Constructor de Copia Result
Ejemplo de Constructor de Movimiento
Ejemplo de Constructor de Movimiento Result
Ejemplo con Lista de Inicialización
Ejemplo con Lista de Inicialización Result
Definición de Atributos Privados
Definición de Atributos Privados Result
Ejemplo de Getters
Ejemplo de Getters Result
Ejemplo de Setters
Ejemplo de Setters Result
Ejemplo Completo
Ejemplo Completo Result
Ejemplo Básico
Ejemplo Básico Result
Ejemplo con Setters y Getters
Ejemplo con Setters y Getters Result
Ejemplo con Herencia
Ejemplo con Herencia Result
Sintaxis del Destructor
Sintaxis del Destructor Result
Ejemplo Básico de Destructor
Ejemplo Básico de Destructor Result
Ejemplo con Recursos Dinámicos
Ejemplo con Recursos Dinámicos Result
Regla de Tres
Regla de Tres Result
Regla de Cinco
Regla de Cinco Result
Ejemplo de Sobrecarga de Operadores
Ejemplo de Sobrecarga de Operadores Result
Ejemplo de Sobrecarga del Operador `*`
Ejemplo de Sobrecarga del Operador `*` Result
Ejemplo de Sobrecarga del Operador `==`
Ejemplo de Sobrecarga del Operador `==` Result
Ejemplo de Sobrecarga del Operador `++`
Ejemplo de Sobrecarga del Operador `++` Result
Ejemplo de Sobrecarga del Operador `[]`
Ejemplo de Sobrecarga del Operador `[]` Result
Definición de una Clase
Definición de una Clase Result
Ejemplo Básico de una Clase
Ejemplo Básico de una Clase Result
Creación de Objetos
Creación de Objetos Result
Ejemplo de Creación y Uso de Objetos
Ejemplo de Creación y Uso de Objetos Result
Constructores
Constructores Result
Destructores
Destructores Result
Modificadores de Acceso
Modificadores de Acceso Result
Ejemplo de Constructor por Defecto
Ejemplo de Constructor por Defecto Result
Ejemplo de Constructor Parametrizado
Ejemplo de Constructor Parametrizado Result
Ejemplo de Constructor de Copia
Ejemplo de Constructor de Copia Result
Ejemplo de Constructor de Movimiento
Ejemplo de Constructor de Movimiento Result
Ejemplo con Lista de Inicialización
Ejemplo con Lista de Inicialización Result
Definición de Atributos Privados
Definición de Atributos Privados Result
Ejemplo de Getters
Ejemplo de Getters Result
Ejemplo de Setters
Ejemplo de Setters Result
Ejemplo Completo
Ejemplo Completo Result
Ejemplo Básico
Ejemplo Básico Result
Ejemplo con Setters y Getters
Ejemplo con Setters y Getters Result
Ejemplo con Herencia
Ejemplo con Herencia Result
Sintaxis del Destructor
Sintaxis del Destructor Result
Ejemplo Básico de Destructor
Ejemplo Básico de Destructor Result
Ejemplo con Recursos Dinámicos
Ejemplo con Recursos Dinámicos Result
Regla de Tres
Regla de Tres Result
Regla de Cinco
Regla de Cinco Result
Ejemplo de Sobrecarga de Operadores
Ejemplo de Sobrecarga de Operadores Result
Ejemplo de Sobrecarga del Operador `*`
Ejemplo de Sobrecarga del Operador `*` Result
Ejemplo de Sobrecarga del Operador `==`
Ejemplo de Sobrecarga del Operador `==` Result
Ejemplo de Sobrecarga del Operador `++`
Ejemplo de Sobrecarga del Operador `++` Result
Ejemplo de Sobrecarga del Operador `[]`
Ejemplo de Sobrecarga del Operador `[]` Result
Definición de una Clase
Definición de una Clase Result
Ejemplo Básico de una Clase
Ejemplo Básico de una Clase Result
Creación de Objetos
Creación de Objetos Result
Ejemplo de Creación y Uso de Objetos
Ejemplo de Creación y Uso de Objetos Result
Constructores
Constructores Result
Destructores
Destructores Result
Modificadores de Acceso
Modificadores de Acceso Result
Ejemplo de Constructor por Defecto
Ejemplo de Constructor por Defecto Result
Ejemplo de Constructor Parametrizado
Ejemplo de Constructor Parametrizado Result
Ejemplo de Constructor de Copia
Ejemplo de Constructor de Copia Result
Ejemplo de Constructor de Movimiento
Ejemplo de Constructor de Movimiento Result
Ejemplo con Lista de Inicialización
Ejemplo con Lista de Inicialización Result
Definición de Atributos Privados
Definición de Atributos Privados Result
Ejemplo de Getters
Ejemplo de Getters Result
Ejemplo de Setters
Ejemplo de Setters Result
Ejemplo Completo
Ejemplo Completo Result
Ejemplo Básico
Ejemplo Básico Result
Ejemplo con Setters y Getters
Ejemplo con Setters y Getters Result
Ejemplo con Herencia
Ejemplo con Herencia Result
Sintaxis del Destructor
Sintaxis del Destructor Result
Ejemplo Básico de Destructor
Ejemplo Básico de Destructor Result
Ejemplo con Recursos Dinámicos
Ejemplo con Recursos Dinámicos Result
Regla de Tres
Regla de Tres Result
Regla de Cinco
Regla de Cinco Result
Ejemplo de Sobrecarga de Operadores
Ejemplo de Sobrecarga de Operadores Result
Ejemplo de Sobrecarga del Operador `*`
Ejemplo de Sobrecarga del Operador `*` Result
Ejemplo de Sobrecarga del Operador `==`
Ejemplo de Sobrecarga del Operador `==` Result
Ejemplo de Sobrecarga del Operador `++`
Ejemplo de Sobrecarga del Operador `++` Result
Ejemplo de Sobrecarga del Operador `[]`
Ejemplo de Sobrecarga del Operador `[]` Result
Definición de una Clase
Definición de una Clase Result
Ejemplo Básico de una Clase
Ejemplo Básico de una Clase Result
Creación de Objetos
Creación de Objetos Result
Ejemplo de Creación y Uso de Objetos
Ejemplo de Creación y Uso de Objetos Result
Constructores
Constructores Result
Destructores
Destructores Result
Modificadores de Acceso
Modificadores de Acceso Result
Ejemplo de Constructor por Defecto
Ejemplo de Constructor por Defecto Result
Ejemplo de Constructor Parametrizado
Ejemplo de Constructor Parametrizado Result
Ejemplo de Constructor de Copia
Ejemplo de Constructor de Copia Result
Ejemplo de Constructor de Movimiento
Ejemplo de Constructor de Movimiento Result
Ejemplo con Lista de Inicialización
Ejemplo con Lista de Inicialización Result
Definición de Atributos Privados
Definición de Atributos Privados Result
Ejemplo de Getters
Ejemplo de Getters Result
Ejemplo de Setters
Ejemplo de Setters Result
Ejemplo Completo
Ejemplo Completo Result
Ejemplo Básico
Ejemplo Básico Result
Ejemplo con Setters y Getters
Ejemplo con Setters y Getters Result
Ejemplo con Herencia
Ejemplo con Herencia Result
Sintaxis del Destructor
Sintaxis del Destructor Result
Ejemplo Básico de Destructor
Ejemplo Básico de Destructor Result
Ejemplo con Recursos Dinámicos
Ejemplo con Recursos Dinámicos Result
Regla de Tres
Regla de Tres Result
Regla de Cinco
Regla de Cinco Result
Ejemplo de Sobrecarga de Operadores
Ejemplo de Sobrecarga de Operadores Result
Ejemplo de Sobrecarga del Operador `*`
Ejemplo de Sobrecarga del Operador `*` Result
Ejemplo de Sobrecarga del Operador `==`
Ejemplo de Sobrecarga del Operador `==` Result
Ejemplo de Sobrecarga del Operador `++`
Ejemplo de Sobrecarga del Operador `++` Result
Ejemplo de Sobrecarga del Operador `[]`
Ejemplo de Sobrecarga del Operador `[]` Result
Ejemplo de Encadenamiento de Métodos
Ejemplo de Encadenamiento de Métodos Result
Ejemplo con Función Constante
Ejemplo con Función Constante Result
Ejemplo de Prevención de Auto-Asignación
Ejemplo de Prevención de Auto-Asignación Result
<---Definición de una Clase--->
```cpp
class NombreClase {
public:
    // Atributos
    tipo_atributo nombre_atributo;

    // Métodos
    tipo_retorno nombre_metodo(parametros);

    // Otros componentes, como constructores, destructores, etc.
};
<---Definición de una Clase Result--->
<---Ejemplo Básico de una Clase--->
```cpp
#include <iostream>
using namespace std;

class Persona {
public:
    // Atributos
    string nombre;
    int edad;

    // Métodos
    void saludar() {
        cout << "Hola, mi nombre es " << nombre << " y tengo " << edad << " años." << endl;
    }
};

int main() {
    // Crear un objeto de la clase Persona
    Persona juan;
    juan.nombre = "Juan";
    juan.edad = 30;

    // Llamar al método saludar
    juan.saludar();

    return 0;
}
<---Ejemplo Básico de una Clase Result--->
<---Creación de Objetos--->
```cpp
NombreClase nombre_objeto;
<---Creación de Objetos Result--->
<---Ejemplo de Creación y Uso de Objetos--->
```cpp
#include <iostream>
using namespace std;

class Coche {
public:
    // Atributos
    string marca;
    string modelo;
    int anio;

    // Métodos
    void mostrarInformacion() {
        cout << "Marca: " << marca << ", Modelo: " << modelo << ", Año: " << anio << endl;
    }
};

int main() {
    // Crear objetos de la clase Coche
    Coche coche1;
    coche1.marca = "Toyota";
    coche1.modelo = "Corolla";
    coche1.anio = 2020;

    Coche coche2;
    coche2.marca = "Honda";
    coche2.modelo = "Civic";
    coche2.anio = 2019;

    // Llamar a los métodos de los objetos
    coche1.mostrarInformacion();
    coche2.mostrarInformacion();

    return 0;
}
<---Ejemplo de Creación y Uso de Objetos Result--->
<---Constructores--->
```cpp
class Persona {
public:
    string nombre;
    int edad;

    // Constructor
    Persona(string n, int e) {
        nombre = n;
        edad = e;
    }

    void saludar() {
        cout << "Hola, mi nombre es " << nombre << " y tengo " << edad << " años." << endl;
    }
};

int main() {
    // Crear un objeto de la clase Persona utilizando el constructor
    Persona juan("Juan", 30);
    juan.saludar();

    return 0;
}
<---Constructores Result--->
<---Destructores--->
```cpp
class Persona {
public:
    string nombre;
    int edad;

    // Constructor
    Persona(string n, int e) {
        nombre = n;
        edad = e;
    }

    // Destructor
    ~Persona() {
        cout << "Destructor llamado para " << nombre << endl;
    }

    void saludar() {
        cout << "Hola, mi nombre es " << nombre << " y tengo " << edad << " años." << endl;
    }
};

int main() {
    // Crear un objeto de la clase Persona
    Persona juan("Juan", 30);
    juan.saludar();

    // El destructor se llamará automáticamente al final del alcance
    return 0;
}
<---Destructores Result--->
<---Modificadores de Acceso--->
```cpp
class Persona {
private:
    string nombre;
    int edad;

public:
    // Constructor
    Persona(string n, int e) : nombre(n), edad(e) {}

    // Métodos para acceder y modificar los atributos
    string getNombre() {
        return nombre;
    }

    void setNombre(string n) {
        nombre = n;
    }

    int getEdad() {
        return edad;
    }

    void setEdad(int e) {
        edad = e;
    }

    void saludar() {
        cout << "Hola, mi nombre es " << nombre << " y tengo " << edad << " años." << endl;
    }
};

int main() {
    Persona juan("Juan", 30);
    juan.saludar();

    juan.setEdad(31);
    cout << "Nueva edad de " << juan.getNombre() << ": " << juan.getEdad() << endl;

    return 0;
}
<---Modificadores de Acceso Result--->
<---Definición de una Clase--->
```cpp
class NombreClase {
public:
    // Atributos
    tipo_atributo nombre_atributo;

    // Métodos
    tipo_retorno nombre_metodo(parametros);

    // Otros componentes, como constructores, destructores, etc.
};
<---Definición de una Clase Result--->
<---Ejemplo Básico de una Clase--->
```cpp
#include <iostream>
using namespace std;

class Persona {
public:
    // Atributos
    string nombre;
    int edad;

    // Métodos
    void saludar() {
        cout << "Hola, mi nombre es " << nombre << " y tengo " << edad << " años." << endl;
    }
};

int main() {
    // Crear un objeto de la clase Persona
    Persona juan;
    juan.nombre = "Juan";
    juan.edad = 30;

    // Llamar al método saludar
    juan.saludar();

    return 0;
}
<---Ejemplo Básico de una Clase Result--->
<---Creación de Objetos--->
```cpp
NombreClase nombre_objeto;
<---Creación de Objetos Result--->
<---Ejemplo de Creación y Uso de Objetos--->
```cpp
#include <iostream>
using namespace std;

class Coche {
public:
    // Atributos
    string marca;
    string modelo;
    int anio;

    // Métodos
    void mostrarInformacion() {
        cout << "Marca: " << marca << ", Modelo: " << modelo << ", Año: " << anio << endl;
    }
};

int main() {
    // Crear objetos de la clase Coche
    Coche coche1;
    coche1.marca = "Toyota";
    coche1.modelo = "Corolla";
    coche1.anio = 2020;

    Coche coche2;
    coche2.marca = "Honda";
    coche2.modelo = "Civic";
    coche2.anio = 2019;

    // Llamar a los métodos de los objetos
    coche1.mostrarInformacion();
    coche2.mostrarInformacion();

    return 0;
}
<---Ejemplo de Creación y Uso de Objetos Result--->
<---Constructores--->
```cpp
class Persona {
public:
    string nombre;
    int edad;

    // Constructor
    Persona(string n, int e) {
        nombre = n;
        edad = e;
    }

    void saludar() {
        cout << "Hola, mi nombre es " << nombre << " y tengo " << edad << " años." << endl;
    }
};

int main() {
    // Crear un objeto de la clase Persona utilizando el constructor
    Persona juan("Juan", 30);
    juan.saludar();

    return 0;
}
<---Constructores Result--->
<---Destructores--->
```cpp
class Persona {
public:
    string nombre;
    int edad;

    // Constructor
    Persona(string n, int e) {
        nombre = n;
        edad = e;
    }

    // Destructor
    ~Persona() {
        cout << "Destructor llamado para " << nombre << endl;
    }

    void saludar() {
        cout << "Hola, mi nombre es " << nombre << " y tengo " << edad << " años." << endl;
    }
};

int main() {
    // Crear un objeto de la clase Persona
    Persona juan("Juan", 30);
    juan.saludar();

    // El destructor se llamará automáticamente al final del alcance
    return 0;
}
<---Destructores Result--->
<---Modificadores de Acceso--->
```cpp
class Persona {
private:
    string nombre;
    int edad;

public:
    // Constructor
    Persona(string n, int e) : nombre(n), edad(e) {}

    // Métodos para acceder y modificar los atributos
    string getNombre() {
        return nombre;
    }

    void setNombre(string n) {
        nombre = n;
    }

    int getEdad() {
        return edad;
    }

    void setEdad(int e) {
        edad = e;
    }

    void saludar() {
        cout << "Hola, mi nombre es " << nombre << " y tengo " << edad << " años." << endl;
    }
};

int main() {
    Persona juan("Juan", 30);
    juan.saludar();

    juan.setEdad(31);
    cout << "Nueva edad de " << juan.getNombre() << ": " << juan.getEdad() << endl;

    return 0;
}
<---Modificadores de Acceso Result--->
<---Ejemplo de Constructor por Defecto--->
```cpp
#include <iostream>
using namespace std;

class Persona {
public:
    string nombre;
    int edad;

    // Constructor por defecto
    Persona() {
        nombre = "Desconocido";
        edad = 0;
    }

    void mostrarInformacion() {
        cout << "Nombre: " << nombre << ", Edad: " << edad << endl;
    }
};

int main() {
    Persona p;  // Llama al constructor por defecto
    p.mostrarInformacion();

    return 0;
}
<---Ejemplo de Constructor por Defecto Result--->
<---Ejemplo de Constructor Parametrizado--->
```cpp
#include <iostream>
using namespace std;

class Persona {
public:
    string nombre;
    int edad;

    // Constructor parametrizado
    Persona(string n, int e) {
        nombre = n;
        edad = e;
    }

    void mostrarInformacion() {
        cout << "Nombre: " << nombre << ", Edad: " << edad << endl;
    }
};

int main() {
    Persona p("Juan", 30);  // Llama al constructor parametrizado
    p.mostrarInformacion();

    return 0;
}
<---Ejemplo de Constructor Parametrizado Result--->
<---Ejemplo de Constructor de Copia--->
```cpp
#include <iostream>
using namespace std;

class Persona {
public:
    string nombre;
    int edad;

    // Constructor parametrizado
    Persona(string n, int e) {
        nombre = n;
        edad = e;
    }

    // Constructor de copia
    Persona(const Persona& p) {
        nombre = p.nombre;
        edad = p.edad;
    }

    void mostrarInformacion() {
        cout << "Nombre: " << nombre << ", Edad: " << edad << endl;
    }
};

int main() {
    Persona p1("Juan", 30);  // Llama al constructor parametrizado
    Persona p2 = p1;         // Llama al constructor de copia
    p2.mostrarInformacion();

    return 0;
}
<---Ejemplo de Constructor de Copia Result--->
<---Ejemplo de Constructor de Movimiento--->
```cpp
#include <iostream>
using namespace std;

class Persona {
public:
    string nombre;
    int edad;

    // Constructor parametrizado
    Persona(string n, int e) : nombre(n), edad(e) {}

    // Constructor de movimiento
    Persona(Persona&& p) noexcept : nombre(move(p.nombre)), edad(p.edad) {
        p.edad = 0; // Opcional: Dejar el objeto fuente en un estado válido
    }

    void mostrarInformacion() {
        cout << "Nombre: " << nombre << ", Edad: " << edad << endl;
    }
};

int main() {
    Persona p1("Juan", 30);  // Llama al constructor parametrizado
    Persona p2 = move(p1);   // Llama al constructor de movimiento
    p2.mostrarInformacion();

    // p1 está en un estado indefinido, pero válido
    cout << "Después de mover, p1: ";
    p1.mostrarInformacion();

    return 0;
}
<---Ejemplo de Constructor de Movimiento Result--->
<---Ejemplo con Lista de Inicialización--->
```cpp
#include <iostream>
using namespace std;

class Punto {
public:
    const int x;
    const int y;

    // Constructor con lista de inicialización
    Punto(int a, int b) : x(a), y(b) {}

    void mostrarInformacion() {
        cout << "Punto(" << x << ", " << y << ")" << endl;
    }
};

int main() {
    Punto p(10, 20);  // Llama al constructor con lista de inicialización
    p.mostrarInformacion();

    return 0;
}
```cpp
#include <iostream>
using namespace std;

class Persona {
private:
    string nombre;
    int edad;

public:
    // Constructor por defecto
    Persona() : nombre("Desconocido"), edad(0) {}

    // Constructor parametrizado
    Persona(string n, int e) : nombre(n), edad(e) {}

    // Constructor de copia
    Persona(const Persona& p) : nombre(p.nombre), edad(p.edad) {}

    // Constructor de movimiento
    Persona(Persona&& p) noexcept : nombre(move(p.nombre)), edad(p.edad) {
        p.edad = 0;
    }

    void mostrarInformacion() {
        cout << "Nombre: " << nombre << ", Edad: " << edad << endl;
    }
};

int main() {
    // Usando el constructor por defecto
    Persona p1;
    p1.mostrarInformacion();

    // Usando el constructor parametrizado
    Persona p2("Juan", 30);
    p2.mostrarInformacion();

    // Usando el constructor de copia
    Persona p3 = p2;
    p3.mostrarInformacion();

    // Usando el constructor de movimiento
    Persona p4 = move(p2);
    p4.mostrarInformacion();

    // Estado después del movimiento
    cout << "Después de mover, p2: ";
    p2.mostrarInformacion();

    return 0;
}
<---Ejemplo con Lista de Inicialización Result--->
<---Definición de una Clase--->
```cpp
class NombreClase {
public:
    // Atributos
    tipo_atributo nombre_atributo;

    // Métodos
    tipo_retorno nombre_metodo(parametros);

    // Otros componentes, como constructores, destructores, etc.
};
<---Definición de una Clase Result--->
<---Ejemplo Básico de una Clase--->
```cpp
#include <iostream>
using namespace std;

class Persona {
public:
    // Atributos
    string nombre;
    int edad;

    // Métodos
    void saludar() {
        cout << "Hola, mi nombre es " << nombre << " y tengo " << edad << " años." << endl;
    }
};

int main() {
    // Crear un objeto de la clase Persona
    Persona juan;
    juan.nombre = "Juan";
    juan.edad = 30;

    // Llamar al método saludar
    juan.saludar();

    return 0;
}
<---Ejemplo Básico de una Clase Result--->
<---Creación de Objetos--->
```cpp
NombreClase nombre_objeto;
<---Creación de Objetos Result--->
<---Ejemplo de Creación y Uso de Objetos--->
```cpp
#include <iostream>
using namespace std;

class Coche {
public:
    // Atributos
    string marca;
    string modelo;
    int anio;

    // Métodos
    void mostrarInformacion() {
        cout << "Marca: " << marca << ", Modelo: " << modelo << ", Año: " << anio << endl;
    }
};

int main() {
    // Crear objetos de la clase Coche
    Coche coche1;
    coche1.marca = "Toyota";
    coche1.modelo = "Corolla";
    coche1.anio = 2020;

    Coche coche2;
    coche2.marca = "Honda";
    coche2.modelo = "Civic";
    coche2.anio = 2019;

    // Llamar a los métodos de los objetos
    coche1.mostrarInformacion();
    coche2.mostrarInformacion();

    return 0;
}
<---Ejemplo de Creación y Uso de Objetos Result--->
<---Constructores--->
```cpp
class Persona {
public:
    string nombre;
    int edad;

    // Constructor
    Persona(string n, int e) {
        nombre = n;
        edad = e;
    }

    void saludar() {
        cout << "Hola, mi nombre es " << nombre << " y tengo " << edad << " años." << endl;
    }
};

int main() {
    // Crear un objeto de la clase Persona utilizando el constructor
    Persona juan("Juan", 30);
    juan.saludar();

    return 0;
}
<---Constructores Result--->
<---Destructores--->
```cpp
class Persona {
public:
    string nombre;
    int edad;

    // Constructor
    Persona(string n, int e) {
        nombre = n;
        edad = e;
    }

    // Destructor
    ~Persona() {
        cout << "Destructor llamado para " << nombre << endl;
    }

    void saludar() {
        cout << "Hola, mi nombre es " << nombre << " y tengo " << edad << " años." << endl;
    }
};

int main() {
    // Crear un objeto de la clase Persona
    Persona juan("Juan", 30);
    juan.saludar();

    // El destructor se llamará automáticamente al final del alcance
    return 0;
}
<---Destructores Result--->
<---Modificadores de Acceso--->
```cpp
class Persona {
private:
    string nombre;
    int edad;

public:
    // Constructor
    Persona(string n, int e) : nombre(n), edad(e) {}

    // Métodos para acceder y modificar los atributos
    string getNombre() {
        return nombre;
    }

    void setNombre(string n) {
        nombre = n;
    }

    int getEdad() {
        return edad;
    }

    void setEdad(int e) {
        edad = e;
    }

    void saludar() {
        cout << "Hola, mi nombre es " << nombre << " y tengo " << edad << " años." << endl;
    }
};

int main() {
    Persona juan("Juan", 30);
    juan.saludar();

    juan.setEdad(31);
    cout << "Nueva edad de " << juan.getNombre() << ": " << juan.getEdad() << endl;

    return 0;
}
<---Modificadores de Acceso Result--->
<---Ejemplo de Constructor por Defecto--->
```cpp
#include <iostream>
using namespace std;

class Persona {
public:
    string nombre;
    int edad;

    // Constructor por defecto
    Persona() {
        nombre = "Desconocido";
        edad = 0;
    }

    void mostrarInformacion() {
        cout << "Nombre: " << nombre << ", Edad: " << edad << endl;
    }
};

int main() {
    Persona p;  // Llama al constructor por defecto
    p.mostrarInformacion();

    return 0;
}
<---Ejemplo de Constructor por Defecto Result--->
<---Ejemplo de Constructor Parametrizado--->
```cpp
#include <iostream>
using namespace std;

class Persona {
public:
    string nombre;
    int edad;

    // Constructor parametrizado
    Persona(string n, int e) {
        nombre = n;
        edad = e;
    }

    void mostrarInformacion() {
        cout << "Nombre: " << nombre << ", Edad: " << edad << endl;
    }
};

int main() {
    Persona p("Juan", 30);  // Llama al constructor parametrizado
    p.mostrarInformacion();

    return 0;
}
<---Ejemplo de Constructor Parametrizado Result--->
<---Ejemplo de Constructor de Copia--->
```cpp
#include <iostream>
using namespace std;

class Persona {
public:
    string nombre;
    int edad;

    // Constructor parametrizado
    Persona(string n, int e) {
        nombre = n;
        edad = e;
    }

    // Constructor de copia
    Persona(const Persona& p) {
        nombre = p.nombre;
        edad = p.edad;
    }

    void mostrarInformacion() {
        cout << "Nombre: " << nombre << ", Edad: " << edad << endl;
    }
};

int main() {
    Persona p1("Juan", 30);  // Llama al constructor parametrizado
    Persona p2 = p1;         // Llama al constructor de copia
    p2.mostrarInformacion();

    return 0;
}
<---Ejemplo de Constructor de Copia Result--->
<---Ejemplo de Constructor de Movimiento--->
```cpp
#include <iostream>
using namespace std;

class Persona {
public:
    string nombre;
    int edad;

    // Constructor parametrizado
    Persona(string n, int e) : nombre(n), edad(e) {}

    // Constructor de movimiento
    Persona(Persona&& p) noexcept : nombre(move(p.nombre)), edad(p.edad) {
        p.edad = 0; // Opcional: Dejar el objeto fuente en un estado válido
    }

    void mostrarInformacion() {
        cout << "Nombre: " << nombre << ", Edad: " << edad << endl;
    }
};

int main() {
    Persona p1("Juan", 30);  // Llama al constructor parametrizado
    Persona p2 = move(p1);   // Llama al constructor de movimiento
    p2.mostrarInformacion();

    // p1 está en un estado indefinido, pero válido
    cout << "Después de mover, p1: ";
    p1.mostrarInformacion();

    return 0;
}
<---Ejemplo de Constructor de Movimiento Result--->
<---Ejemplo con Lista de Inicialización--->
```cpp
#include <iostream>
using namespace std;

class Punto {
public:
    const int x;
    const int y;

    // Constructor con lista de inicialización
    Punto(int a, int b) : x(a), y(b) {}

    void mostrarInformacion() {
        cout << "Punto(" << x << ", " << y << ")" << endl;
    }
};

int main() {
    Punto p(10, 20);  // Llama al constructor con lista de inicialización
    p.mostrarInformacion();

    return 0;
}
```cpp
#include <iostream>
using namespace std;

class Persona {
private:
    string nombre;
    int edad;

public:
    // Constructor por defecto
    Persona() : nombre("Desconocido"), edad(0) {}

    // Constructor parametrizado
    Persona(string n, int e) : nombre(n), edad(e) {}

    // Constructor de copia
    Persona(const Persona& p) : nombre(p.nombre), edad(p.edad) {}

    // Constructor de movimiento
    Persona(Persona&& p) noexcept : nombre(move(p.nombre)), edad(p.edad) {
        p.edad = 0;
    }

    void mostrarInformacion() {
        cout << "Nombre: " << nombre << ", Edad: " << edad << endl;
    }
};

int main() {
    // Usando el constructor por defecto
    Persona p1;
    p1.mostrarInformacion();

    // Usando el constructor parametrizado
    Persona p2("Juan", 30);
    p2.mostrarInformacion();

    // Usando el constructor de copia
    Persona p3 = p2;
    p3.mostrarInformacion();

    // Usando el constructor de movimiento
    Persona p4 = move(p2);
    p4.mostrarInformacion();

    // Estado después del movimiento
    cout << "Después de mover, p2: ";
    p2.mostrarInformacion();

    return 0;
}
<---Ejemplo con Lista de Inicialización Result--->
<---Definición de Atributos Privados--->
```cpp
class Persona {
private:
    string nombre;
    int edad;

public:
    // Métodos públicos
};
<---Definición de Atributos Privados Result--->
<---Ejemplo de Getters--->
```cpp
class Persona {
private:
    string nombre;
    int edad;

public:
    // Constructor
    Persona(string n, int e) : nombre(n), edad(e) {}

    // Getter para el nombre
    string getNombre() const {
        return nombre;
    }

    // Getter para la edad
    int getEdad() const {
        return edad;
    }
};
<---Ejemplo de Getters Result--->
<---Ejemplo de Setters--->
```cpp
class Persona {
private:
    string nombre;
    int edad;

public:
    // Constructor
    Persona(string n, int e) : nombre(n), edad(e) {}

    // Setter para el nombre
    void setNombre(string n) {
        nombre = n;
    }

    // Setter para la edad
    void setEdad(int e) {
        if (e > 0) {  // Validación simple
            edad = e;
        } else {
            cout << "Edad no válida." << endl;
        }
    }

    // Getters
    string getNombre() const {
        return nombre;
    }

    int getEdad() const {
        return edad;
    }
};
<---Ejemplo de Setters Result--->
<---Ejemplo Completo--->
```cpp
#include <iostream>
using namespace std;

class Persona {
private:
    string nombre;
    int edad;

public:
    // Constructor
    Persona(string n, int e) : nombre(n), edad(e) {}

    // Setters
    void setNombre(string n) {
        nombre = n;
    }

    void setEdad(int e) {
        if (e > 0) {
            edad = e;
        } else {
            cout << "Edad no válida." << endl;
        }
    }

    // Getters
    string getNombre() const {
        return nombre;
    }

    int getEdad() const {
        return edad;
    }

    // Método para mostrar información
    void mostrarInformacion() const {
        cout << "Nombre: " << nombre << ", Edad: " << edad << endl;
    }
};

int main() {
    // Crear un objeto de la clase Persona
    Persona juan("Juan", 30);
    juan.mostrarInformacion();

    // Modificar los atributos usando setters
    juan.setNombre("Juan Perez");
    juan.setEdad(31);
    juan.mostrarInformacion();

    // Intentar establecer una edad no válida
    juan.setEdad(-5);
    juan.mostrarInformacion();

    // Acceder a los atributos usando getters
    cout << "Nombre: " << juan.getNombre() << endl;
    cout << "Edad: " << juan.getEdad() << endl;

    return 0;
}
<---Ejemplo Completo Result--->
<---Definición de una Clase--->
```cpp
class NombreClase {
public:
    // Atributos
    tipo_atributo nombre_atributo;

    // Métodos
    tipo_retorno nombre_metodo(parametros);

    // Otros componentes, como constructores, destructores, etc.
};
<---Definición de una Clase Result--->
<---Ejemplo Básico de una Clase--->
```cpp
#include <iostream>
using namespace std;

class Persona {
public:
    // Atributos
    string nombre;
    int edad;

    // Métodos
    void saludar() {
        cout << "Hola, mi nombre es " << nombre << " y tengo " << edad << " años." << endl;
    }
};

int main() {
    // Crear un objeto de la clase Persona
    Persona juan;
    juan.nombre = "Juan";
    juan.edad = 30;

    // Llamar al método saludar
    juan.saludar();

    return 0;
}
<---Ejemplo Básico de una Clase Result--->
<---Creación de Objetos--->
```cpp
NombreClase nombre_objeto;
<---Creación de Objetos Result--->
<---Ejemplo de Creación y Uso de Objetos--->
```cpp
#include <iostream>
using namespace std;

class Coche {
public:
    // Atributos
    string marca;
    string modelo;
    int anio;

    // Métodos
    void mostrarInformacion() {
        cout << "Marca: " << marca << ", Modelo: " << modelo << ", Año: " << anio << endl;
    }
};

int main() {
    // Crear objetos de la clase Coche
    Coche coche1;
    coche1.marca = "Toyota";
    coche1.modelo = "Corolla";
    coche1.anio = 2020;

    Coche coche2;
    coche2.marca = "Honda";
    coche2.modelo = "Civic";
    coche2.anio = 2019;

    // Llamar a los métodos de los objetos
    coche1.mostrarInformacion();
    coche2.mostrarInformacion();

    return 0;
}
<---Ejemplo de Creación y Uso de Objetos Result--->
<---Constructores--->
```cpp
class Persona {
public:
    string nombre;
    int edad;

    // Constructor
    Persona(string n, int e) {
        nombre = n;
        edad = e;
    }

    void saludar() {
        cout << "Hola, mi nombre es " << nombre << " y tengo " << edad << " años." << endl;
    }
};

int main() {
    // Crear un objeto de la clase Persona utilizando el constructor
    Persona juan("Juan", 30);
    juan.saludar();

    return 0;
}
<---Constructores Result--->
<---Destructores--->
```cpp
class Persona {
public:
    string nombre;
    int edad;

    // Constructor
    Persona(string n, int e) {
        nombre = n;
        edad = e;
    }

    // Destructor
    ~Persona() {
        cout << "Destructor llamado para " << nombre << endl;
    }

    void saludar() {
        cout << "Hola, mi nombre es " << nombre << " y tengo " << edad << " años." << endl;
    }
};

int main() {
    // Crear un objeto de la clase Persona
    Persona juan("Juan", 30);
    juan.saludar();

    // El destructor se llamará automáticamente al final del alcance
    return 0;
}
<---Destructores Result--->
<---Modificadores de Acceso--->
```cpp
class Persona {
private:
    string nombre;
    int edad;

public:
    // Constructor
    Persona(string n, int e) : nombre(n), edad(e) {}

    // Métodos para acceder y modificar los atributos
    string getNombre() {
        return nombre;
    }

    void setNombre(string n) {
        nombre = n;
    }

    int getEdad() {
        return edad;
    }

    void setEdad(int e) {
        edad = e;
    }

    void saludar() {
        cout << "Hola, mi nombre es " << nombre << " y tengo " << edad << " años." << endl;
    }
};

int main() {
    Persona juan("Juan", 30);
    juan.saludar();

    juan.setEdad(31);
    cout << "Nueva edad de " << juan.getNombre() << ": " << juan.getEdad() << endl;

    return 0;
}
<---Modificadores de Acceso Result--->
<---Ejemplo de Constructor por Defecto--->
```cpp
#include <iostream>
using namespace std;

class Persona {
public:
    string nombre;
    int edad;

    // Constructor por defecto
    Persona() {
        nombre = "Desconocido";
        edad = 0;
    }

    void mostrarInformacion() {
        cout << "Nombre: " << nombre << ", Edad: " << edad << endl;
    }
};

int main() {
    Persona p;  // Llama al constructor por defecto
    p.mostrarInformacion();

    return 0;
}
<---Ejemplo de Constructor por Defecto Result--->
<---Ejemplo de Constructor Parametrizado--->
```cpp
#include <iostream>
using namespace std;

class Persona {
public:
    string nombre;
    int edad;

    // Constructor parametrizado
    Persona(string n, int e) {
        nombre = n;
        edad = e;
    }

    void mostrarInformacion() {
        cout << "Nombre: " << nombre << ", Edad: " << edad << endl;
    }
};

int main() {
    Persona p("Juan", 30);  // Llama al constructor parametrizado
    p.mostrarInformacion();

    return 0;
}
<---Ejemplo de Constructor Parametrizado Result--->
<---Ejemplo de Constructor de Copia--->
```cpp
#include <iostream>
using namespace std;

class Persona {
public:
    string nombre;
    int edad;

    // Constructor parametrizado
    Persona(string n, int e) {
        nombre = n;
        edad = e;
    }

    // Constructor de copia
    Persona(const Persona& p) {
        nombre = p.nombre;
        edad = p.edad;
    }

    void mostrarInformacion() {
        cout << "Nombre: " << nombre << ", Edad: " << edad << endl;
    }
};

int main() {
    Persona p1("Juan", 30);  // Llama al constructor parametrizado
    Persona p2 = p1;         // Llama al constructor de copia
    p2.mostrarInformacion();

    return 0;
}
<---Ejemplo de Constructor de Copia Result--->
<---Ejemplo de Constructor de Movimiento--->
```cpp
#include <iostream>
using namespace std;

class Persona {
public:
    string nombre;
    int edad;

    // Constructor parametrizado
    Persona(string n, int e) : nombre(n), edad(e) {}

    // Constructor de movimiento
    Persona(Persona&& p) noexcept : nombre(move(p.nombre)), edad(p.edad) {
        p.edad = 0; // Opcional: Dejar el objeto fuente en un estado válido
    }

    void mostrarInformacion() {
        cout << "Nombre: " << nombre << ", Edad: " << edad << endl;
    }
};

int main() {
    Persona p1("Juan", 30);  // Llama al constructor parametrizado
    Persona p2 = move(p1);   // Llama al constructor de movimiento
    p2.mostrarInformacion();

    // p1 está en un estado indefinido, pero válido
    cout << "Después de mover, p1: ";
    p1.mostrarInformacion();

    return 0;
}
<---Ejemplo de Constructor de Movimiento Result--->
<---Ejemplo con Lista de Inicialización--->
```cpp
#include <iostream>
using namespace std;

class Punto {
public:
    const int x;
    const int y;

    // Constructor con lista de inicialización
    Punto(int a, int b) : x(a), y(b) {}

    void mostrarInformacion() {
        cout << "Punto(" << x << ", " << y << ")" << endl;
    }
};

int main() {
    Punto p(10, 20);  // Llama al constructor con lista de inicialización
    p.mostrarInformacion();

    return 0;
}
```cpp
#include <iostream>
using namespace std;

class Persona {
private:
    string nombre;
    int edad;

public:
    // Constructor por defecto
    Persona() : nombre("Desconocido"), edad(0) {}

    // Constructor parametrizado
    Persona(string n, int e) : nombre(n), edad(e) {}

    // Constructor de copia
    Persona(const Persona& p) : nombre(p.nombre), edad(p.edad) {}

    // Constructor de movimiento
    Persona(Persona&& p) noexcept : nombre(move(p.nombre)), edad(p.edad) {
        p.edad = 0;
    }

    void mostrarInformacion() {
        cout << "Nombre: " << nombre << ", Edad: " << edad << endl;
    }
};

int main() {
    // Usando el constructor por defecto
    Persona p1;
    p1.mostrarInformacion();

    // Usando el constructor parametrizado
    Persona p2("Juan", 30);
    p2.mostrarInformacion();

    // Usando el constructor de copia
    Persona p3 = p2;
    p3.mostrarInformacion();

    // Usando el constructor de movimiento
    Persona p4 = move(p2);
    p4.mostrarInformacion();

    // Estado después del movimiento
    cout << "Después de mover, p2: ";
    p2.mostrarInformacion();

    return 0;
}
<---Ejemplo con Lista de Inicialización Result--->
<---Definición de Atributos Privados--->
```cpp
class Persona {
private:
    string nombre;
    int edad;

public:
    // Métodos públicos
};
<---Definición de Atributos Privados Result--->
<---Ejemplo de Getters--->
```cpp
class Persona {
private:
    string nombre;
    int edad;

public:
    // Constructor
    Persona(string n, int e) : nombre(n), edad(e) {}

    // Getter para el nombre
    string getNombre() const {
        return nombre;
    }

    // Getter para la edad
    int getEdad() const {
        return edad;
    }
};
<---Ejemplo de Getters Result--->
<---Ejemplo de Setters--->
```cpp
class Persona {
private:
    string nombre;
    int edad;

public:
    // Constructor
    Persona(string n, int e) : nombre(n), edad(e) {}

    // Setter para el nombre
    void setNombre(string n) {
        nombre = n;
    }

    // Setter para la edad
    void setEdad(int e) {
        if (e > 0) {  // Validación simple
            edad = e;
        } else {
            cout << "Edad no válida." << endl;
        }
    }

    // Getters
    string getNombre() const {
        return nombre;
    }

    int getEdad() const {
        return edad;
    }
};
<---Ejemplo de Setters Result--->
<---Ejemplo Completo--->
```cpp
#include <iostream>
using namespace std;

class Persona {
private:
    string nombre;
    int edad;

public:
    // Constructor
    Persona(string n, int e) : nombre(n), edad(e) {}

    // Setters
    void setNombre(string n) {
        nombre = n;
    }

    void setEdad(int e) {
        if (e > 0) {
            edad = e;
        } else {
            cout << "Edad no válida." << endl;
        }
    }

    // Getters
    string getNombre() const {
        return nombre;
    }

    int getEdad() const {
        return edad;
    }

    // Método para mostrar información
    void mostrarInformacion() const {
        cout << "Nombre: " << nombre << ", Edad: " << edad << endl;
    }
};

int main() {
    // Crear un objeto de la clase Persona
    Persona juan("Juan", 30);
    juan.mostrarInformacion();

    // Modificar los atributos usando setters
    juan.setNombre("Juan Perez");
    juan.setEdad(31);
    juan.mostrarInformacion();

    // Intentar establecer una edad no válida
    juan.setEdad(-5);
    juan.mostrarInformacion();

    // Acceder a los atributos usando getters
    cout << "Nombre: " << juan.getNombre() << endl;
    cout << "Edad: " << juan.getEdad() << endl;

    return 0;
}
<---Ejemplo Completo Result--->
<---Ejemplo Básico--->
```cpp
#include <iostream>
using namespace std;

class Ejemplo {
private:
    int datoPrivado; // Acceso privado

public:
    int datoPublico; // Acceso público

    // Constructor
    Ejemplo(int privado, int publico) : datoPrivado(privado), datoPublico(publico) {}

    // Método público para acceder al dato privado
    int getDatoPrivado() const {
        return datoPrivado;
    }

    // Método público para modificar el dato privado
    void setDatoPrivado(int valor) {
        datoPrivado = valor;
    }
};

int main() {
    Ejemplo obj(10, 20);

    // Acceso al dato público
    cout << "Dato público: " << obj.datoPublico << endl;

    // Acceso al dato privado a través de métodos públicos
    cout << "Dato privado: " << obj.getDatoPrivado() << endl;
    obj.setDatoPrivado(30);
    cout << "Dato privado modificado: " << obj.getDatoPrivado() << endl;

    return 0;
}
<---Ejemplo Básico Result--->
<---Ejemplo con Setters y Getters--->
```cpp
#include <iostream>
using namespace std;

class Persona {
private:
    string nombre;
    int edad;

public:
    // Constructor
    Persona(string n, int e) : nombre(n), edad(e) {}

    // Getter para nombre
    string getNombre() const {
        return nombre;
    }

    // Setter para nombre
    void setNombre(string n) {
        nombre = n;
    }

    // Getter para edad
    int getEdad() const {
        return edad;
    }

    // Setter para edad con validación
    void setEdad(int e) {
        if (e > 0) {
            edad = e;
        } else {
            cout << "Edad no válida" << endl;
        }
    }

    // Método para mostrar información
    void mostrarInformacion() const {
        cout << "Nombre: " << nombre << ", Edad: " << edad << endl;
    }
};

int main() {
    Persona juan("Juan", 30);
    juan.mostrarInformacion();

    // Modificar atributos usando setters
    juan.setNombre("Juan Perez");
    juan.setEdad(31);
    juan.mostrarInformacion();

    // Intentar establecer una edad no válida
    juan.setEdad(-5);
    juan.mostrarInformacion();

    return 0;
}
<---Ejemplo con Setters y Getters Result--->
<---Ejemplo con Herencia--->
```cpp
#include <iostream>
using namespace std;

class Base {
private:
    int datoPrivado;

protected:
    int datoProtegido;

public:
    int datoPublico;

    Base(int priv, int prot, int pub) : datoPrivado(priv), datoProtegido(prot), datoPublico(pub) {}

    int getDatoPrivado() const {
        return datoPrivado;
    }

    int getDatoProtegido() const {
        return datoProtegido;
    }
};

class Derivada : public Base {
public:
    Derivada(int priv, int prot, int pub) : Base(priv, prot, pub) {}

    void mostrarDatos() {
        // cout << "Dato privado: " << getDatoPrivado() << endl; // No se puede acceder directamente
        cout << "Dato protegido: " << getDatoProtegido() << endl;
        cout << "Dato público: " << datoPublico << endl;
    }
};

int main() {
    Derivada obj(1, 2, 3);
    obj.mostrarDatos();

    return 0;
}
<---Ejemplo con Herencia Result--->
<---Definición de una Clase--->
```cpp
class NombreClase {
public:
    // Atributos
    tipo_atributo nombre_atributo;

    // Métodos
    tipo_retorno nombre_metodo(parametros);

    // Otros componentes, como constructores, destructores, etc.
};
<---Definición de una Clase Result--->
<---Ejemplo Básico de una Clase--->
```cpp
#include <iostream>
using namespace std;

class Persona {
public:
    // Atributos
    string nombre;
    int edad;

    // Métodos
    void saludar() {
        cout << "Hola, mi nombre es " << nombre << " y tengo " << edad << " años." << endl;
    }
};

int main() {
    // Crear un objeto de la clase Persona
    Persona juan;
    juan.nombre = "Juan";
    juan.edad = 30;

    // Llamar al método saludar
    juan.saludar();

    return 0;
}
<---Ejemplo Básico de una Clase Result--->
<---Creación de Objetos--->
```cpp
NombreClase nombre_objeto;
<---Creación de Objetos Result--->
<---Ejemplo de Creación y Uso de Objetos--->
```cpp
#include <iostream>
using namespace std;

class Coche {
public:
    // Atributos
    string marca;
    string modelo;
    int anio;

    // Métodos
    void mostrarInformacion() {
        cout << "Marca: " << marca << ", Modelo: " << modelo << ", Año: " << anio << endl;
    }
};

int main() {
    // Crear objetos de la clase Coche
    Coche coche1;
    coche1.marca = "Toyota";
    coche1.modelo = "Corolla";
    coche1.anio = 2020;

    Coche coche2;
    coche2.marca = "Honda";
    coche2.modelo = "Civic";
    coche2.anio = 2019;

    // Llamar a los métodos de los objetos
    coche1.mostrarInformacion();
    coche2.mostrarInformacion();

    return 0;
}
<---Ejemplo de Creación y Uso de Objetos Result--->
<---Constructores--->
```cpp
class Persona {
public:
    string nombre;
    int edad;

    // Constructor
    Persona(string n, int e) {
        nombre = n;
        edad = e;
    }

    void saludar() {
        cout << "Hola, mi nombre es " << nombre << " y tengo " << edad << " años." << endl;
    }
};

int main() {
    // Crear un objeto de la clase Persona utilizando el constructor
    Persona juan("Juan", 30);
    juan.saludar();

    return 0;
}
<---Constructores Result--->
<---Destructores--->
```cpp
class Persona {
public:
    string nombre;
    int edad;

    // Constructor
    Persona(string n, int e) {
        nombre = n;
        edad = e;
    }

    // Destructor
    ~Persona() {
        cout << "Destructor llamado para " << nombre << endl;
    }

    void saludar() {
        cout << "Hola, mi nombre es " << nombre << " y tengo " << edad << " años." << endl;
    }
};

int main() {
    // Crear un objeto de la clase Persona
    Persona juan("Juan", 30);
    juan.saludar();

    // El destructor se llamará automáticamente al final del alcance
    return 0;
}
<---Destructores Result--->
<---Modificadores de Acceso--->
```cpp
class Persona {
private:
    string nombre;
    int edad;

public:
    // Constructor
    Persona(string n, int e) : nombre(n), edad(e) {}

    // Métodos para acceder y modificar los atributos
    string getNombre() {
        return nombre;
    }

    void setNombre(string n) {
        nombre = n;
    }

    int getEdad() {
        return edad;
    }

    void setEdad(int e) {
        edad = e;
    }

    void saludar() {
        cout << "Hola, mi nombre es " << nombre << " y tengo " << edad << " años." << endl;
    }
};

int main() {
    Persona juan("Juan", 30);
    juan.saludar();

    juan.setEdad(31);
    cout << "Nueva edad de " << juan.getNombre() << ": " << juan.getEdad() << endl;

    return 0;
}
<---Modificadores de Acceso Result--->
<---Ejemplo de Constructor por Defecto--->
```cpp
#include <iostream>
using namespace std;

class Persona {
public:
    string nombre;
    int edad;

    // Constructor por defecto
    Persona() {
        nombre = "Desconocido";
        edad = 0;
    }

    void mostrarInformacion() {
        cout << "Nombre: " << nombre << ", Edad: " << edad << endl;
    }
};

int main() {
    Persona p;  // Llama al constructor por defecto
    p.mostrarInformacion();

    return 0;
}
<---Ejemplo de Constructor por Defecto Result--->
<---Ejemplo de Constructor Parametrizado--->
```cpp
#include <iostream>
using namespace std;

class Persona {
public:
    string nombre;
    int edad;

    // Constructor parametrizado
    Persona(string n, int e) {
        nombre = n;
        edad = e;
    }

    void mostrarInformacion() {
        cout << "Nombre: " << nombre << ", Edad: " << edad << endl;
    }
};

int main() {
    Persona p("Juan", 30);  // Llama al constructor parametrizado
    p.mostrarInformacion();

    return 0;
}
<---Ejemplo de Constructor Parametrizado Result--->
<---Ejemplo de Constructor de Copia--->
```cpp
#include <iostream>
using namespace std;

class Persona {
public:
    string nombre;
    int edad;

    // Constructor parametrizado
    Persona(string n, int e) {
        nombre = n;
        edad = e;
    }

    // Constructor de copia
    Persona(const Persona& p) {
        nombre = p.nombre;
        edad = p.edad;
    }

    void mostrarInformacion() {
        cout << "Nombre: " << nombre << ", Edad: " << edad << endl;
    }
};

int main() {
    Persona p1("Juan", 30);  // Llama al constructor parametrizado
    Persona p2 = p1;         // Llama al constructor de copia
    p2.mostrarInformacion();

    return 0;
}
<---Ejemplo de Constructor de Copia Result--->
<---Ejemplo de Constructor de Movimiento--->
```cpp
#include <iostream>
using namespace std;

class Persona {
public:
    string nombre;
    int edad;

    // Constructor parametrizado
    Persona(string n, int e) : nombre(n), edad(e) {}

    // Constructor de movimiento
    Persona(Persona&& p) noexcept : nombre(move(p.nombre)), edad(p.edad) {
        p.edad = 0; // Opcional: Dejar el objeto fuente en un estado válido
    }

    void mostrarInformacion() {
        cout << "Nombre: " << nombre << ", Edad: " << edad << endl;
    }
};

int main() {
    Persona p1("Juan", 30);  // Llama al constructor parametrizado
    Persona p2 = move(p1);   // Llama al constructor de movimiento
    p2.mostrarInformacion();

    // p1 está en un estado indefinido, pero válido
    cout << "Después de mover, p1: ";
    p1.mostrarInformacion();

    return 0;
}
<---Ejemplo de Constructor de Movimiento Result--->
<---Ejemplo con Lista de Inicialización--->
```cpp
#include <iostream>
using namespace std;

class Punto {
public:
    const int x;
    const int y;

    // Constructor con lista de inicialización
    Punto(int a, int b) : x(a), y(b) {}

    void mostrarInformacion() {
        cout << "Punto(" << x << ", " << y << ")" << endl;
    }
};

int main() {
    Punto p(10, 20);  // Llama al constructor con lista de inicialización
    p.mostrarInformacion();

    return 0;
}
```cpp
#include <iostream>
using namespace std;

class Persona {
private:
    string nombre;
    int edad;

public:
    // Constructor por defecto
    Persona() : nombre("Desconocido"), edad(0) {}

    // Constructor parametrizado
    Persona(string n, int e) : nombre(n), edad(e) {}

    // Constructor de copia
    Persona(const Persona& p) : nombre(p.nombre), edad(p.edad) {}

    // Constructor de movimiento
    Persona(Persona&& p) noexcept : nombre(move(p.nombre)), edad(p.edad) {
        p.edad = 0;
    }

    void mostrarInformacion() {
        cout << "Nombre: " << nombre << ", Edad: " << edad << endl;
    }
};

int main() {
    // Usando el constructor por defecto
    Persona p1;
    p1.mostrarInformacion();

    // Usando el constructor parametrizado
    Persona p2("Juan", 30);
    p2.mostrarInformacion();

    // Usando el constructor de copia
    Persona p3 = p2;
    p3.mostrarInformacion();

    // Usando el constructor de movimiento
    Persona p4 = move(p2);
    p4.mostrarInformacion();

    // Estado después del movimiento
    cout << "Después de mover, p2: ";
    p2.mostrarInformacion();

    return 0;
}
<---Ejemplo con Lista de Inicialización Result--->
<---Definición de Atributos Privados--->
```cpp
class Persona {
private:
    string nombre;
    int edad;

public:
    // Métodos públicos
};
<---Definición de Atributos Privados Result--->
<---Ejemplo de Getters--->
```cpp
class Persona {
private:
    string nombre;
    int edad;

public:
    // Constructor
    Persona(string n, int e) : nombre(n), edad(e) {}

    // Getter para el nombre
    string getNombre() const {
        return nombre;
    }

    // Getter para la edad
    int getEdad() const {
        return edad;
    }
};
<---Ejemplo de Getters Result--->
<---Ejemplo de Setters--->
```cpp
class Persona {
private:
    string nombre;
    int edad;

public:
    // Constructor
    Persona(string n, int e) : nombre(n), edad(e) {}

    // Setter para el nombre
    void setNombre(string n) {
        nombre = n;
    }

    // Setter para la edad
    void setEdad(int e) {
        if (e > 0) {  // Validación simple
            edad = e;
        } else {
            cout << "Edad no válida." << endl;
        }
    }

    // Getters
    string getNombre() const {
        return nombre;
    }

    int getEdad() const {
        return edad;
    }
};
<---Ejemplo de Setters Result--->
<---Ejemplo Completo--->
```cpp
#include <iostream>
using namespace std;

class Persona {
private:
    string nombre;
    int edad;

public:
    // Constructor
    Persona(string n, int e) : nombre(n), edad(e) {}

    // Setters
    void setNombre(string n) {
        nombre = n;
    }

    void setEdad(int e) {
        if (e > 0) {
            edad = e;
        } else {
            cout << "Edad no válida." << endl;
        }
    }

    // Getters
    string getNombre() const {
        return nombre;
    }

    int getEdad() const {
        return edad;
    }

    // Método para mostrar información
    void mostrarInformacion() const {
        cout << "Nombre: " << nombre << ", Edad: " << edad << endl;
    }
};

int main() {
    // Crear un objeto de la clase Persona
    Persona juan("Juan", 30);
    juan.mostrarInformacion();

    // Modificar los atributos usando setters
    juan.setNombre("Juan Perez");
    juan.setEdad(31);
    juan.mostrarInformacion();

    // Intentar establecer una edad no válida
    juan.setEdad(-5);
    juan.mostrarInformacion();

    // Acceder a los atributos usando getters
    cout << "Nombre: " << juan.getNombre() << endl;
    cout << "Edad: " << juan.getEdad() << endl;

    return 0;
}
<---Ejemplo Completo Result--->
<---Ejemplo Básico--->
```cpp
#include <iostream>
using namespace std;

class Ejemplo {
private:
    int datoPrivado; // Acceso privado

public:
    int datoPublico; // Acceso público

    // Constructor
    Ejemplo(int privado, int publico) : datoPrivado(privado), datoPublico(publico) {}

    // Método público para acceder al dato privado
    int getDatoPrivado() const {
        return datoPrivado;
    }

    // Método público para modificar el dato privado
    void setDatoPrivado(int valor) {
        datoPrivado = valor;
    }
};

int main() {
    Ejemplo obj(10, 20);

    // Acceso al dato público
    cout << "Dato público: " << obj.datoPublico << endl;

    // Acceso al dato privado a través de métodos públicos
    cout << "Dato privado: " << obj.getDatoPrivado() << endl;
    obj.setDatoPrivado(30);
    cout << "Dato privado modificado: " << obj.getDatoPrivado() << endl;

    return 0;
}
<---Ejemplo Básico Result--->
<---Ejemplo con Setters y Getters--->
```cpp
#include <iostream>
using namespace std;

class Persona {
private:
    string nombre;
    int edad;

public:
    // Constructor
    Persona(string n, int e) : nombre(n), edad(e) {}

    // Getter para nombre
    string getNombre() const {
        return nombre;
    }

    // Setter para nombre
    void setNombre(string n) {
        nombre = n;
    }

    // Getter para edad
    int getEdad() const {
        return edad;
    }

    // Setter para edad con validación
    void setEdad(int e) {
        if (e > 0) {
            edad = e;
        } else {
            cout << "Edad no válida" << endl;
        }
    }

    // Método para mostrar información
    void mostrarInformacion() const {
        cout << "Nombre: " << nombre << ", Edad: " << edad << endl;
    }
};

int main() {
    Persona juan("Juan", 30);
    juan.mostrarInformacion();

    // Modificar atributos usando setters
    juan.setNombre("Juan Perez");
    juan.setEdad(31);
    juan.mostrarInformacion();

    // Intentar establecer una edad no válida
    juan.setEdad(-5);
    juan.mostrarInformacion();

    return 0;
}
<---Ejemplo con Setters y Getters Result--->
<---Ejemplo con Herencia--->
```cpp
#include <iostream>
using namespace std;

class Base {
public:
    // Constructor
    Base() {
        cout << "Constructor de Base" << endl;
    }

    // Destructor virtual
    virtual ~Base() {
        cout << "Destructor de Base" << endl;
    }
};

class Derivada : public Base {
public:
    // Constructor
    Derivada() {
        cout << "Constructor de Derivada" << endl;
    }

    // Destructor
    ~Derivada() {
        cout << "Destructor de Derivada" << endl;
    }
};

int main() {
    Base* obj = new Derivada(); // Crear objeto de clase derivada
    delete obj; // Llamar al destructor virtual

    return 0;
}
<---Ejemplo con Herencia Result--->
<---Sintaxis del Destructor--->
```cpp
class NombreClase {
public:
    // Constructor
    NombreClase();

    // Destructor
    ~NombreClase();

    // Otros métodos y atributos
};
<---Sintaxis del Destructor Result--->
<---Ejemplo Básico de Destructor--->
```cpp
#include <iostream>
using namespace std;

class Persona {
public:
    string nombre;

    // Constructor
    Persona(string n) : nombre(n) {
        cout << "Constructor llamado para " << nombre << endl;
    }

    // Destructor
    ~Persona() {
        cout << "Destructor llamado para " << nombre << endl;
    }
};

int main() {
    Persona juan("Juan");
    {
        Persona maria("Maria");
    } // Destructor llamado para maria aquí

    cout << "Fin del main" << endl;
    return 0; // Destructor llamado para juan aquí
}
<---Ejemplo Básico de Destructor Result--->
<---Ejemplo con Recursos Dinámicos--->
```cpp
#include <iostream>
using namespace std;

class Array {
private:
    int* data;
    int size;

public:
    // Constructor
    Array(int s) : size(s) {
        data = new int[size]; // Asignar memoria dinámica
        cout << "Array de tamaño " << size << " creado." << endl;
    }

    // Destructor
    ~Array() {
        delete[] data; // Liberar memoria dinámica
        cout << "Array de tamaño " << size << " destruido." << endl;
    }

    // Método para establecer un valor en el array
    void setValue(int index, int value) {
        if (index >= 0 && index < size) {
            data[index] = value;
        }
    }

    // Método para obtener un valor del array
    int getValue(int index) const {
        if (index >= 0 && index < size) {
            return data[index];
        }
        return -1; // Valor de error
    }
};

int main() {
    Array arr(5);
    arr.setValue(0, 10);
    arr.setValue(1, 20);
    cout << "Valor en la posición 0: " << arr.getValue(0) << endl;
    cout << "Valor en la posición 1: " << arr.getValue(1) << endl;

    return 0;
}
<---Ejemplo con Recursos Dinámicos Result--->
<---Regla de Tres--->
```cpp
class Ejemplo {
private:
    int* data;

public:
    // Constructor
    Ejemplo(int size) {
        data = new int[size];
    }

    // Destructor
    ~Ejemplo() {
        delete[] data;
    }

    // Constructor de copia
    Ejemplo(const Ejemplo& other) {
        data = new int[other.size];
        // Copiar datos...
    }

    // Operador de asignación de copia
    Ejemplo& operator=(const Ejemplo& other) {
        if (this != &other) {
            delete[] data;
            data = new int[other.size];
            // Copiar datos...
        }
        return *this;
    }
};
<---Regla de Tres Result--->
<---Regla de Cinco--->
```cpp
class Ejemplo {
private:
    int* data;

public:
    // Constructor
    Ejemplo(int size) {
        data = new int[size];
    }

    // Destructor
    ~Ejemplo() {
        delete[] data;
    }

    // Constructor de copia
    Ejemplo(const Ejemplo& other) {
        data = new int[other.size];
        // Copiar datos...
    }

    // Operador de asignación de copia
    Ejemplo& operator=(const Ejemplo& other) {
        if (this != &other) {
            delete[] data;
            data = new int[other.size];
            // Copiar datos...
        }
        return *this;
    }

    // Constructor de movimiento
    Ejemplo(Ejemplo&& other) noexcept : data(other.data) {
        other.data = nullptr;
    }

    // Operador de asignación de movimiento
    Ejemplo& operator=(Ejemplo&& other) noexcept {
        if (this != &other) {
            delete[] data;
            data = other.data;
            other.data = nullptr;
        }
        return *this;
    }
};
<---Regla de Cinco Result--->
<---Definición de una Clase--->
```cpp
class NombreClase {
public:
    // Atributos
    tipo_atributo nombre_atributo;

    // Métodos
    tipo_retorno nombre_metodo(parametros);

    // Otros componentes, como constructores, destructores, etc.
};
<---Definición de una Clase Result--->
<---Ejemplo Básico de una Clase--->
```cpp
#include <iostream>
using namespace std;

class Persona {
public:
    // Atributos
    string nombre;
    int edad;

    // Métodos
    void saludar() {
        cout << "Hola, mi nombre es " << nombre << " y tengo " << edad << " años." << endl;
    }
};

int main() {
    // Crear un objeto de la clase Persona
    Persona juan;
    juan.nombre = "Juan";
    juan.edad = 30;

    // Llamar al método saludar
    juan.saludar();

    return 0;
}
<---Ejemplo Básico de una Clase Result--->
<---Creación de Objetos--->
```cpp
NombreClase nombre_objeto;
<---Creación de Objetos Result--->
<---Ejemplo de Creación y Uso de Objetos--->
```cpp
#include <iostream>
using namespace std;

class Coche {
public:
    // Atributos
    string marca;
    string modelo;
    int anio;

    // Métodos
    void mostrarInformacion() {
        cout << "Marca: " << marca << ", Modelo: " << modelo << ", Año: " << anio << endl;
    }
};

int main() {
    // Crear objetos de la clase Coche
    Coche coche1;
    coche1.marca = "Toyota";
    coche1.modelo = "Corolla";
    coche1.anio = 2020;

    Coche coche2;
    coche2.marca = "Honda";
    coche2.modelo = "Civic";
    coche2.anio = 2019;

    // Llamar a los métodos de los objetos
    coche1.mostrarInformacion();
    coche2.mostrarInformacion();

    return 0;
}
<---Ejemplo de Creación y Uso de Objetos Result--->
<---Constructores--->
```cpp
class Persona {
public:
    string nombre;
    int edad;

    // Constructor
    Persona(string n, int e) {
        nombre = n;
        edad = e;
    }

    void saludar() {
        cout << "Hola, mi nombre es " << nombre << " y tengo " << edad << " años." << endl;
    }
};

int main() {
    // Crear un objeto de la clase Persona utilizando el constructor
    Persona juan("Juan", 30);
    juan.saludar();

    return 0;
}
<---Constructores Result--->
<---Destructores--->
```cpp
class Persona {
public:
    string nombre;
    int edad;

    // Constructor
    Persona(string n, int e) {
        nombre = n;
        edad = e;
    }

    // Destructor
    ~Persona() {
        cout << "Destructor llamado para " << nombre << endl;
    }

    void saludar() {
        cout << "Hola, mi nombre es " << nombre << " y tengo " << edad << " años." << endl;
    }
};

int main() {
    // Crear un objeto de la clase Persona
    Persona juan("Juan", 30);
    juan.saludar();

    // El destructor se llamará automáticamente al final del alcance
    return 0;
}
<---Destructores Result--->
<---Modificadores de Acceso--->
```cpp
class Persona {
private:
    string nombre;
    int edad;

public:
    // Constructor
    Persona(string n, int e) : nombre(n), edad(e) {}

    // Métodos para acceder y modificar los atributos
    string getNombre() {
        return nombre;
    }

    void setNombre(string n) {
        nombre = n;
    }

    int getEdad() {
        return edad;
    }

    void setEdad(int e) {
        edad = e;
    }

    void saludar() {
        cout << "Hola, mi nombre es " << nombre << " y tengo " << edad << " años." << endl;
    }
};

int main() {
    Persona juan("Juan", 30);
    juan.saludar();

    juan.setEdad(31);
    cout << "Nueva edad de " << juan.getNombre() << ": " << juan.getEdad() << endl;

    return 0;
}
<---Modificadores de Acceso Result--->
<---Ejemplo de Constructor por Defecto--->
```cpp
#include <iostream>
using namespace std;

class Persona {
public:
    string nombre;
    int edad;

    // Constructor por defecto
    Persona() {
        nombre = "Desconocido";
        edad = 0;
    }

    void mostrarInformacion() {
        cout << "Nombre: " << nombre << ", Edad: " << edad << endl;
    }
};

int main() {
    Persona p;  // Llama al constructor por defecto
    p.mostrarInformacion();

    return 0;
}
<---Ejemplo de Constructor por Defecto Result--->
<---Ejemplo de Constructor Parametrizado--->
```cpp
#include <iostream>
using namespace std;

class Persona {
public:
    string nombre;
    int edad;

    // Constructor parametrizado
    Persona(string n, int e) {
        nombre = n;
        edad = e;
    }

    void mostrarInformacion() {
        cout << "Nombre: " << nombre << ", Edad: " << edad << endl;
    }
};

int main() {
    Persona p("Juan", 30);  // Llama al constructor parametrizado
    p.mostrarInformacion();

    return 0;
}
<---Ejemplo de Constructor Parametrizado Result--->
<---Ejemplo de Constructor de Copia--->
```cpp
#include <iostream>
using namespace std;

class Persona {
public:
    string nombre;
    int edad;

    // Constructor parametrizado
    Persona(string n, int e) {
        nombre = n;
        edad = e;
    }

    // Constructor de copia
    Persona(const Persona& p) {
        nombre = p.nombre;
        edad = p.edad;
    }

    void mostrarInformacion() {
        cout << "Nombre: " << nombre << ", Edad: " << edad << endl;
    }
};

int main() {
    Persona p1("Juan", 30);  // Llama al constructor parametrizado
    Persona p2 = p1;         // Llama al constructor de copia
    p2.mostrarInformacion();

    return 0;
}
<---Ejemplo de Constructor de Copia Result--->
<---Ejemplo de Constructor de Movimiento--->
```cpp
#include <iostream>
using namespace std;

class Persona {
public:
    string nombre;
    int edad;

    // Constructor parametrizado
    Persona(string n, int e) : nombre(n), edad(e) {}

    // Constructor de movimiento
    Persona(Persona&& p) noexcept : nombre(move(p.nombre)), edad(p.edad) {
        p.edad = 0; // Opcional: Dejar el objeto fuente en un estado válido
    }

    void mostrarInformacion() {
        cout << "Nombre: " << nombre << ", Edad: " << edad << endl;
    }
};

int main() {
    Persona p1("Juan", 30);  // Llama al constructor parametrizado
    Persona p2 = move(p1);   // Llama al constructor de movimiento
    p2.mostrarInformacion();

    // p1 está en un estado indefinido, pero válido
    cout << "Después de mover, p1: ";
    p1.mostrarInformacion();

    return 0;
}
<---Ejemplo de Constructor de Movimiento Result--->
<---Ejemplo con Lista de Inicialización--->
```cpp
#include <iostream>
using namespace std;

class Punto {
public:
    const int x;
    const int y;

    // Constructor con lista de inicialización
    Punto(int a, int b) : x(a), y(b) {}

    void mostrarInformacion() {
        cout << "Punto(" << x << ", " << y << ")" << endl;
    }
};

int main() {
    Punto p(10, 20);  // Llama al constructor con lista de inicialización
    p.mostrarInformacion();

    return 0;
}
```cpp
#include <iostream>
using namespace std;

class Persona {
private:
    string nombre;
    int edad;

public:
    // Constructor por defecto
    Persona() : nombre("Desconocido"), edad(0) {}

    // Constructor parametrizado
    Persona(string n, int e) : nombre(n), edad(e) {}

    // Constructor de copia
    Persona(const Persona& p) : nombre(p.nombre), edad(p.edad) {}

    // Constructor de movimiento
    Persona(Persona&& p) noexcept : nombre(move(p.nombre)), edad(p.edad) {
        p.edad = 0;
    }

    void mostrarInformacion() {
        cout << "Nombre: " << nombre << ", Edad: " << edad << endl;
    }
};

int main() {
    // Usando el constructor por defecto
    Persona p1;
    p1.mostrarInformacion();

    // Usando el constructor parametrizado
    Persona p2("Juan", 30);
    p2.mostrarInformacion();

    // Usando el constructor de copia
    Persona p3 = p2;
    p3.mostrarInformacion();

    // Usando el constructor de movimiento
    Persona p4 = move(p2);
    p4.mostrarInformacion();

    // Estado después del movimiento
    cout << "Después de mover, p2: ";
    p2.mostrarInformacion();

    return 0;
}
<---Ejemplo con Lista de Inicialización Result--->
<---Definición de Atributos Privados--->
```cpp
class Persona {
private:
    string nombre;
    int edad;

public:
    // Métodos públicos
};
<---Definición de Atributos Privados Result--->
<---Ejemplo de Getters--->
```cpp
class Persona {
private:
    string nombre;
    int edad;

public:
    // Constructor
    Persona(string n, int e) : nombre(n), edad(e) {}

    // Getter para el nombre
    string getNombre() const {
        return nombre;
    }

    // Getter para la edad
    int getEdad() const {
        return edad;
    }
};
<---Ejemplo de Getters Result--->
<---Ejemplo de Setters--->
```cpp
class Persona {
private:
    string nombre;
    int edad;

public:
    // Constructor
    Persona(string n, int e) : nombre(n), edad(e) {}

    // Setter para el nombre
    void setNombre(string n) {
        nombre = n;
    }

    // Setter para la edad
    void setEdad(int e) {
        if (e > 0) {  // Validación simple
            edad = e;
        } else {
            cout << "Edad no válida." << endl;
        }
    }

    // Getters
    string getNombre() const {
        return nombre;
    }

    int getEdad() const {
        return edad;
    }
};
<---Ejemplo de Setters Result--->
<---Ejemplo Completo--->
```cpp
#include <iostream>
using namespace std;

class Persona {
private:
    string nombre;
    int edad;

public:
    // Constructor
    Persona(string n, int e) : nombre(n), edad(e) {}

    // Setters
    void setNombre(string n) {
        nombre = n;
    }

    void setEdad(int e) {
        if (e > 0) {
            edad = e;
        } else {
            cout << "Edad no válida." << endl;
        }
    }

    // Getters
    string getNombre() const {
        return nombre;
    }

    int getEdad() const {
        return edad;
    }

    // Método para mostrar información
    void mostrarInformacion() const {
        cout << "Nombre: " << nombre << ", Edad: " << edad << endl;
    }
};

int main() {
    // Crear un objeto de la clase Persona
    Persona juan("Juan", 30);
    juan.mostrarInformacion();

    // Modificar los atributos usando setters
    juan.setNombre("Juan Perez");
    juan.setEdad(31);
    juan.mostrarInformacion();

    // Intentar establecer una edad no válida
    juan.setEdad(-5);
    juan.mostrarInformacion();

    // Acceder a los atributos usando getters
    cout << "Nombre: " << juan.getNombre() << endl;
    cout << "Edad: " << juan.getEdad() << endl;

    return 0;
}
<---Ejemplo Completo Result--->
<---Ejemplo Básico--->
```cpp
#include <iostream>
using namespace std;

class Ejemplo {
private:
    int datoPrivado; // Acceso privado

public:
    int datoPublico; // Acceso público

    // Constructor
    Ejemplo(int privado, int publico) : datoPrivado(privado), datoPublico(publico) {}

    // Método público para acceder al dato privado
    int getDatoPrivado() const {
        return datoPrivado;
    }

    // Método público para modificar el dato privado
    void setDatoPrivado(int valor) {
        datoPrivado = valor;
    }
};

int main() {
    Ejemplo obj(10, 20);

    // Acceso al dato público
    cout << "Dato público: " << obj.datoPublico << endl;

    // Acceso al dato privado a través de métodos públicos
    cout << "Dato privado: " << obj.getDatoPrivado() << endl;
    obj.setDatoPrivado(30);
    cout << "Dato privado modificado: " << obj.getDatoPrivado() << endl;

    return 0;
}
<---Ejemplo Básico Result--->
<---Ejemplo con Setters y Getters--->
```cpp
#include <iostream>
using namespace std;

class Persona {
private:
    string nombre;
    int edad;

public:
    // Constructor
    Persona(string n, int e) : nombre(n), edad(e) {}

    // Getter para nombre
    string getNombre() const {
        return nombre;
    }

    // Setter para nombre
    void setNombre(string n) {
        nombre = n;
    }

    // Getter para edad
    int getEdad() const {
        return edad;
    }

    // Setter para edad con validación
    void setEdad(int e) {
        if (e > 0) {
            edad = e;
        } else {
            cout << "Edad no válida" << endl;
        }
    }

    // Método para mostrar información
    void mostrarInformacion() const {
        cout << "Nombre: " << nombre << ", Edad: " << edad << endl;
    }
};

int main() {
    Persona juan("Juan", 30);
    juan.mostrarInformacion();

    // Modificar atributos usando setters
    juan.setNombre("Juan Perez");
    juan.setEdad(31);
    juan.mostrarInformacion();

    // Intentar establecer una edad no válida
    juan.setEdad(-5);
    juan.mostrarInformacion();

    return 0;
}
<---Ejemplo con Setters y Getters Result--->
<---Ejemplo con Herencia--->
```cpp
#include <iostream>
using namespace std;

class Base {
public:
    // Constructor
    Base() {
        cout << "Constructor de Base" << endl;
    }

    // Destructor virtual
    virtual ~Base() {
        cout << "Destructor de Base" << endl;
    }
};

class Derivada : public Base {
public:
    // Constructor
    Derivada() {
        cout << "Constructor de Derivada" << endl;
    }

    // Destructor
    ~Derivada() {
        cout << "Destructor de Derivada" << endl;
    }
};

int main() {
    Base* obj = new Derivada(); // Crear objeto de clase derivada
    delete obj; // Llamar al destructor virtual

    return 0;
}
<---Ejemplo con Herencia Result--->
<---Sintaxis del Destructor--->
```cpp
class NombreClase {
public:
    // Constructor
    NombreClase();

    // Destructor
    ~NombreClase();

    // Otros métodos y atributos
};
<---Sintaxis del Destructor Result--->
<---Ejemplo Básico de Destructor--->
```cpp
#include <iostream>
using namespace std;

class Persona {
public:
    string nombre;

    // Constructor
    Persona(string n) : nombre(n) {
        cout << "Constructor llamado para " << nombre << endl;
    }

    // Destructor
    ~Persona() {
        cout << "Destructor llamado para " << nombre << endl;
    }
};

int main() {
    Persona juan("Juan");
    {
        Persona maria("Maria");
    } // Destructor llamado para maria aquí

    cout << "Fin del main" << endl;
    return 0; // Destructor llamado para juan aquí
}
<---Ejemplo Básico de Destructor Result--->
<---Ejemplo con Recursos Dinámicos--->
```cpp
#include <iostream>
using namespace std;

class Array {
private:
    int* data;
    int size;

public:
    // Constructor
    Array(int s) : size(s) {
        data = new int[size]; // Asignar memoria dinámica
        cout << "Array de tamaño " << size << " creado." << endl;
    }

    // Destructor
    ~Array() {
        delete[] data; // Liberar memoria dinámica
        cout << "Array de tamaño " << size << " destruido." << endl;
    }

    // Método para establecer un valor en el array
    void setValue(int index, int value) {
        if (index >= 0 && index < size) {
            data[index] = value;
        }
    }

    // Método para obtener un valor del array
    int getValue(int index) const {
        if (index >= 0 && index < size) {
            return data[index];
        }
        return -1; // Valor de error
    }
};

int main() {
    Array arr(5);
    arr.setValue(0, 10);
    arr.setValue(1, 20);
    cout << "Valor en la posición 0: " << arr.getValue(0) << endl;
    cout << "Valor en la posición 1: " << arr.getValue(1) << endl;

    return 0;
}
<---Ejemplo con Recursos Dinámicos Result--->
<---Regla de Tres--->
```cpp
class Ejemplo {
private:
    int* data;

public:
    // Constructor
    Ejemplo(int size) {
        data = new int[size];
    }

    // Destructor
    ~Ejemplo() {
        delete[] data;
    }

    // Constructor de copia
    Ejemplo(const Ejemplo& other) {
        data = new int[other.size];
        // Copiar datos...
    }

    // Operador de asignación de copia
    Ejemplo& operator=(const Ejemplo& other) {
        if (this != &other) {
            delete[] data;
            data = new int[other.size];
            // Copiar datos...
        }
        return *this;
    }
};
<---Regla de Tres Result--->
<---Regla de Cinco--->
```cpp
class Ejemplo {
private:
    int* data;

public:
    // Constructor
    Ejemplo(int size) {
        data = new int[size];
    }

    // Destructor
    ~Ejemplo() {
        delete[] data;
    }

    // Constructor de copia
    Ejemplo(const Ejemplo& other) {
        data = new int[other.size];
        // Copiar datos...
    }

    // Operador de asignación de copia
    Ejemplo& operator=(const Ejemplo& other) {
        if (this != &other) {
            delete[] data;
            data = new int[other.size];
            // Copiar datos...
        }
        return *this;
    }

    // Constructor de movimiento
    Ejemplo(Ejemplo&& other) noexcept : data(other.data) {
        other.data = nullptr;
    }

    // Operador de asignación de movimiento
    Ejemplo& operator=(Ejemplo&& other) noexcept {
        if (this != &other) {
            delete[] data;
            data = other.data;
            other.data = nullptr;
        }
        return *this;
    }
};
<---Regla de Cinco Result--->
<---Ejemplo de Sobrecarga de Operadores--->
```cpp
#include <iostream>
using namespace std;

class Complejo {
private:
    double real;
    double imaginario;

public:
    // Constructor
    Complejo(double r = 0.0, double i = 0.0) : real(r), imaginario(i) {}

    // Sobrecarga del operador +
    Complejo operator+(const Complejo& c) const {
        return Complejo(real + c.real, imaginario + c.imaginario);
    }

    // Sobrecarga del operador <<
    friend ostream& operator<<(ostream& os, const Complejo& c) {
        os << "(" << c.real << " + " << c.imaginario << "i)";
        return os;
    }
};

int main() {
    Complejo c1(3.0, 4.0);
    Complejo c2(1.0, 2.0);

    Complejo c3 = c1 + c2;  // Usando la sobrecarga del operador +

    cout << "c1: " << c1 << endl;
    cout << "c2: " << c2 << endl;
    cout << "c3: " << c3 << endl;  // Usando la sobrecarga del operador <<

    return 0;
}
<---Ejemplo de Sobrecarga de Operadores Result--->
<---Ejemplo de Sobrecarga del Operador `*`--->
```cpp
#include <iostream>
using namespace std;

class Vector {
private:
    double x, y, z;

public:
    // Constructor
    Vector(double x, double y, double z) : x(x), y(y), z(z) {}

    // Sobrecarga del operador *
    Vector operator*(double escalar) const {
        return Vector(x * escalar, y * escalar, z * escalar);
    }

    // Sobrecarga del operador <<
    friend ostream& operator<<(ostream& os, const Vector& v) {
        os << "{" << v.x << ", " << v.y << ", " << v.z << "}";
        return os;
    }
};

int main() {
    Vector v1(1.0, 2.0, 3.0);
    Vector v2 = v1 * 2.0;

    cout << "v1: " << v1 << endl;
    cout << "v2: " << v2 << endl;

    return 0;
}
<---Ejemplo de Sobrecarga del Operador `*` Result--->
<---Ejemplo de Sobrecarga del Operador `==`--->
```cpp
#include <iostream>
using namespace std;

class Punto {
private:
    int x, y;

public:
    // Constructor
    Punto(int x = 0, int y = 0) : x(x), y(y) {}

    // Sobrecarga del operador ==
    bool operator==(const Punto& p) const {
        return (x == p.x && y == p.y);
    }

    // Sobrecarga del operador <<
    friend ostream& operator<<(ostream& os, const Punto& p) {
        os << "(" << p.x << ", " << p.y << ")";
        return os;
    }
};

int main() {
    Punto p1(1, 2);
    Punto p2(1, 2);
    Punto p3(3, 4);

    cout << "p1: " << p1 << endl;
    cout << "p2: " << p2 << endl;
    cout << "p3: " << p3 << endl;

    cout << "p1 == p2: " << (p1 == p2) << endl;
    cout << "p1 == p3: " << (p1 == p3) << endl;

    return 0;
}
<---Ejemplo de Sobrecarga del Operador `==` Result--->
<---Ejemplo de Sobrecarga del Operador `++`--->
```cpp
#include <iostream>
using namespace std;

class Contador {
private:
    int valor;

public:
    // Constructor
    Contador(int v = 0) : valor(v) {}

    // Sobrecarga del operador prefijo ++
    Contador& operator++() {
        ++valor;
        return *this;
    }

    // Sobrecarga del operador postfijo ++
    Contador operator++(int) {
        Contador temp = *this;
        ++valor;
        return temp;
    }

    // Sobrecarga del operador <<
    friend ostream& operator<<(ostream& os, const Contador& c) {
        os << c.valor;
        return os;
    }
};

int main() {
    Contador c(5);

    cout << "Valor inicial: " << c << endl;

    ++c;
    cout << "Después del prefijo ++: " << c << endl;

    c++;
    cout << "Después del postfijo ++: " << c << endl;

    return 0;
}
<---Ejemplo de Sobrecarga del Operador `++` Result--->
<---Ejemplo de Sobrecarga del Operador `[]`--->
```cpp
#include <iostream>
using namespace std;

class Array {
private:
    int* datos;
    int tamano;

public:
    // Constructor
    Array(int tamano) : tamano(tamano) {
        datos = new int[tamano];
        for (int i = 0; i < tamano; ++i) {
            datos[i] = 0;
        }
    }

    // Destructor
    ~Array() {
        delete[] datos;
    }

    // Sobrecarga del operador []
    int& operator[](int indice) {
        if (indice >= 0 && indice < tamano) {
            return datos[indice];
        }
        throw out_of_range("Índice fuera de rango");
    }

    // Sobrecarga del operador <<
    friend ostream& operator<<(ostream& os, const Array& arr) {
        os << "[";
        for (int i = 0; i < arr.tamano; ++i) {
            os << arr.datos[i];
            if (i < arr.tamano - 1) {
                os << ", ";
            }
        }
        os << "]";
        return os;
    }
};

int main() {
    Array arr(5);

    arr[0] = 10;
    arr[1] = 20;
    arr[2] = 30;

    cout << "Array: " << arr << endl;

    try {
        arr[5] = 50;  // Esto lanzará una excepción
    } catch (const out_of_range& e) {
        cout << e.what() << endl;
    }

    return 0;
}
<---Ejemplo de Sobrecarga del Operador `[]` Result--->
<---Definición de una Clase--->
```cpp
class NombreClase {
public:
    // Atributos
    tipo_atributo nombre_atributo;

    // Métodos
    tipo_retorno nombre_metodo(parametros);

    // Otros componentes, como constructores, destructores, etc.
};
<---Definición de una Clase Result--->
<---Ejemplo Básico de una Clase--->
```cpp
#include <iostream>
using namespace std;

class Persona {
public:
    // Atributos
    string nombre;
    int edad;

    // Métodos
    void saludar() {
        cout << "Hola, mi nombre es " << nombre << " y tengo " << edad << " años." << endl;
    }
};

int main() {
    // Crear un objeto de la clase Persona
    Persona juan;
    juan.nombre = "Juan";
    juan.edad = 30;

    // Llamar al método saludar
    juan.saludar();

    return 0;
}
<---Ejemplo Básico de una Clase Result--->
<---Creación de Objetos--->
```cpp
NombreClase nombre_objeto;
<---Creación de Objetos Result--->
<---Ejemplo de Creación y Uso de Objetos--->
```cpp
#include <iostream>
using namespace std;

class Coche {
public:
    // Atributos
    string marca;
    string modelo;
    int anio;

    // Métodos
    void mostrarInformacion() {
        cout << "Marca: " << marca << ", Modelo: " << modelo << ", Año: " << anio << endl;
    }
};

int main() {
    // Crear objetos de la clase Coche
    Coche coche1;
    coche1.marca = "Toyota";
    coche1.modelo = "Corolla";
    coche1.anio = 2020;

    Coche coche2;
    coche2.marca = "Honda";
    coche2.modelo = "Civic";
    coche2.anio = 2019;

    // Llamar a los métodos de los objetos
    coche1.mostrarInformacion();
    coche2.mostrarInformacion();

    return 0;
}
<---Ejemplo de Creación y Uso de Objetos Result--->
<---Constructores--->
```cpp
class Persona {
public:
    string nombre;
    int edad;

    // Constructor
    Persona(string n, int e) {
        nombre = n;
        edad = e;
    }

    void saludar() {
        cout << "Hola, mi nombre es " << nombre << " y tengo " << edad << " años." << endl;
    }
};

int main() {
    // Crear un objeto de la clase Persona utilizando el constructor
    Persona juan("Juan", 30);
    juan.saludar();

    return 0;
}
<---Constructores Result--->
<---Destructores--->
```cpp
class Persona {
public:
    string nombre;
    int edad;

    // Constructor
    Persona(string n, int e) {
        nombre = n;
        edad = e;
    }

    // Destructor
    ~Persona() {
        cout << "Destructor llamado para " << nombre << endl;
    }

    void saludar() {
        cout << "Hola, mi nombre es " << nombre << " y tengo " << edad << " años." << endl;
    }
};

int main() {
    // Crear un objeto de la clase Persona
    Persona juan("Juan", 30);
    juan.saludar();

    // El destructor se llamará automáticamente al final del alcance
    return 0;
}
<---Destructores Result--->
<---Modificadores de Acceso--->
```cpp
class Persona {
private:
    string nombre;
    int edad;

public:
    // Constructor
    Persona(string n, int e) : nombre(n), edad(e) {}

    // Métodos para acceder y modificar los atributos
    string getNombre() {
        return nombre;
    }

    void setNombre(string n) {
        nombre = n;
    }

    int getEdad() {
        return edad;
    }

    void setEdad(int e) {
        edad = e;
    }

    void saludar() {
        cout << "Hola, mi nombre es " << nombre << " y tengo " << edad << " años." << endl;
    }
};

int main() {
    Persona juan("Juan", 30);
    juan.saludar();

    juan.setEdad(31);
    cout << "Nueva edad de " << juan.getNombre() << ": " << juan.getEdad() << endl;

    return 0;
}
<---Modificadores de Acceso Result--->
<---Ejemplo de Constructor por Defecto--->
```cpp
#include <iostream>
using namespace std;

class Persona {
public:
    string nombre;
    int edad;

    // Constructor por defecto
    Persona() {
        nombre = "Desconocido";
        edad = 0;
    }

    void mostrarInformacion() {
        cout << "Nombre: " << nombre << ", Edad: " << edad << endl;
    }
};

int main() {
    Persona p;  // Llama al constructor por defecto
    p.mostrarInformacion();

    return 0;
}
<---Ejemplo de Constructor por Defecto Result--->
<---Ejemplo de Constructor Parametrizado--->
```cpp
#include <iostream>
using namespace std;

class Persona {
public:
    string nombre;
    int edad;

    // Constructor parametrizado
    Persona(string n, int e) {
        nombre = n;
        edad = e;
    }

    void mostrarInformacion() {
        cout << "Nombre: " << nombre << ", Edad: " << edad << endl;
    }
};

int main() {
    Persona p("Juan", 30);  // Llama al constructor parametrizado
    p.mostrarInformacion();

    return 0;
}
<---Ejemplo de Constructor Parametrizado Result--->
<---Ejemplo de Constructor de Copia--->
```cpp
#include <iostream>
using namespace std;

class Persona {
public:
    string nombre;
    int edad;

    // Constructor parametrizado
    Persona(string n, int e) {
        nombre = n;
        edad = e;
    }

    // Constructor de copia
    Persona(const Persona& p) {
        nombre = p.nombre;
        edad = p.edad;
    }

    void mostrarInformacion() {
        cout << "Nombre: " << nombre << ", Edad: " << edad << endl;
    }
};

int main() {
    Persona p1("Juan", 30);  // Llama al constructor parametrizado
    Persona p2 = p1;         // Llama al constructor de copia
    p2.mostrarInformacion();

    return 0;
}
<---Ejemplo de Constructor de Copia Result--->
<---Ejemplo de Constructor de Movimiento--->
```cpp
#include <iostream>
using namespace std;

class Persona {
public:
    string nombre;
    int edad;

    // Constructor parametrizado
    Persona(string n, int e) : nombre(n), edad(e) {}

    // Constructor de movimiento
    Persona(Persona&& p) noexcept : nombre(move(p.nombre)), edad(p.edad) {
        p.edad = 0; // Opcional: Dejar el objeto fuente en un estado válido
    }

    void mostrarInformacion() {
        cout << "Nombre: " << nombre << ", Edad: " << edad << endl;
    }
};

int main() {
    Persona p1("Juan", 30);  // Llama al constructor parametrizado
    Persona p2 = move(p1);   // Llama al constructor de movimiento
    p2.mostrarInformacion();

    // p1 está en un estado indefinido, pero válido
    cout << "Después de mover, p1: ";
    p1.mostrarInformacion();

    return 0;
}
<---Ejemplo de Constructor de Movimiento Result--->
<---Ejemplo con Lista de Inicialización--->
```cpp
#include <iostream>
using namespace std;

class Punto {
public:
    const int x;
    const int y;

    // Constructor con lista de inicialización
    Punto(int a, int b) : x(a), y(b) {}

    void mostrarInformacion() {
        cout << "Punto(" << x << ", " << y << ")" << endl;
    }
};

int main() {
    Punto p(10, 20);  // Llama al constructor con lista de inicialización
    p.mostrarInformacion();

    return 0;
}
```cpp
#include <iostream>
using namespace std;

class Persona {
private:
    string nombre;
    int edad;

public:
    // Constructor por defecto
    Persona() : nombre("Desconocido"), edad(0) {}

    // Constructor parametrizado
    Persona(string n, int e) : nombre(n), edad(e) {}

    // Constructor de copia
    Persona(const Persona& p) : nombre(p.nombre), edad(p.edad) {}

    // Constructor de movimiento
    Persona(Persona&& p) noexcept : nombre(move(p.nombre)), edad(p.edad) {
        p.edad = 0;
    }

    void mostrarInformacion() {
        cout << "Nombre: " << nombre << ", Edad: " << edad << endl;
    }
};

int main() {
    // Usando el constructor por defecto
    Persona p1;
    p1.mostrarInformacion();

    // Usando el constructor parametrizado
    Persona p2("Juan", 30);
    p2.mostrarInformacion();

    // Usando el constructor de copia
    Persona p3 = p2;
    p3.mostrarInformacion();

    // Usando el constructor de movimiento
    Persona p4 = move(p2);
    p4.mostrarInformacion();

    // Estado después del movimiento
    cout << "Después de mover, p2: ";
    p2.mostrarInformacion();

    return 0;
}
<---Ejemplo con Lista de Inicialización Result--->
<---Definición de Atributos Privados--->
```cpp
class Persona {
private:
    string nombre;
    int edad;

public:
    // Métodos públicos
};
<---Definición de Atributos Privados Result--->
<---Ejemplo de Getters--->
```cpp
class Persona {
private:
    string nombre;
    int edad;

public:
    // Constructor
    Persona(string n, int e) : nombre(n), edad(e) {}

    // Getter para el nombre
    string getNombre() const {
        return nombre;
    }

    // Getter para la edad
    int getEdad() const {
        return edad;
    }
};
<---Ejemplo de Getters Result--->
<---Ejemplo de Setters--->
```cpp
class Persona {
private:
    string nombre;
    int edad;

public:
    // Constructor
    Persona(string n, int e) : nombre(n), edad(e) {}

    // Setter para el nombre
    void setNombre(string n) {
        nombre = n;
    }

    // Setter para la edad
    void setEdad(int e) {
        if (e > 0) {  // Validación simple
            edad = e;
        } else {
            cout << "Edad no válida." << endl;
        }
    }

    // Getters
    string getNombre() const {
        return nombre;
    }

    int getEdad() const {
        return edad;
    }
};
<---Ejemplo de Setters Result--->
<---Ejemplo Completo--->
```cpp
#include <iostream>
using namespace std;

class Persona {
private:
    string nombre;
    int edad;

public:
    // Constructor
    Persona(string n, int e) : nombre(n), edad(e) {}

    // Setters
    void setNombre(string n) {
        nombre = n;
    }

    void setEdad(int e) {
        if (e > 0) {
            edad = e;
        } else {
            cout << "Edad no válida." << endl;
        }
    }

    // Getters
    string getNombre() const {
        return nombre;
    }

    int getEdad() const {
        return edad;
    }

    // Método para mostrar información
    void mostrarInformacion() const {
        cout << "Nombre: " << nombre << ", Edad: " << edad << endl;
    }
};

int main() {
    // Crear un objeto de la clase Persona
    Persona juan("Juan", 30);
    juan.mostrarInformacion();

    // Modificar los atributos usando setters
    juan.setNombre("Juan Perez");
    juan.setEdad(31);
    juan.mostrarInformacion();

    // Intentar establecer una edad no válida
    juan.setEdad(-5);
    juan.mostrarInformacion();

    // Acceder a los atributos usando getters
    cout << "Nombre: " << juan.getNombre() << endl;
    cout << "Edad: " << juan.getEdad() << endl;

    return 0;
}
<---Ejemplo Completo Result--->
<---Ejemplo Básico--->
```cpp
#include <iostream>
using namespace std;

class Ejemplo {
private:
    int datoPrivado; // Acceso privado

public:
    int datoPublico; // Acceso público

    // Constructor
    Ejemplo(int privado, int publico) : datoPrivado(privado), datoPublico(publico) {}

    // Método público para acceder al dato privado
    int getDatoPrivado() const {
        return datoPrivado;
    }

    // Método público para modificar el dato privado
    void setDatoPrivado(int valor) {
        datoPrivado = valor;
    }
};

int main() {
    Ejemplo obj(10, 20);

    // Acceso al dato público
    cout << "Dato público: " << obj.datoPublico << endl;

    // Acceso al dato privado a través de métodos públicos
    cout << "Dato privado: " << obj.getDatoPrivado() << endl;
    obj.setDatoPrivado(30);
    cout << "Dato privado modificado: " << obj.getDatoPrivado() << endl;

    return 0;
}
<---Ejemplo Básico Result--->
<---Ejemplo con Setters y Getters--->
```cpp
#include <iostream>
using namespace std;

class Persona {
private:
    string nombre;
    int edad;

public:
    // Constructor
    Persona(string n, int e) : nombre(n), edad(e) {}

    // Getter para nombre
    string getNombre() const {
        return nombre;
    }

    // Setter para nombre
    void setNombre(string n) {
        nombre = n;
    }

    // Getter para edad
    int getEdad() const {
        return edad;
    }

    // Setter para edad con validación
    void setEdad(int e) {
        if (e > 0) {
            edad = e;
        } else {
            cout << "Edad no válida" << endl;
        }
    }

    // Método para mostrar información
    void mostrarInformacion() const {
        cout << "Nombre: " << nombre << ", Edad: " << edad << endl;
    }
};

int main() {
    Persona juan("Juan", 30);
    juan.mostrarInformacion();

    // Modificar atributos usando setters
    juan.setNombre("Juan Perez");
    juan.setEdad(31);
    juan.mostrarInformacion();

    // Intentar establecer una edad no válida
    juan.setEdad(-5);
    juan.mostrarInformacion();

    return 0;
}
<---Ejemplo con Setters y Getters Result--->
<---Ejemplo con Herencia--->
```cpp
#include <iostream>
using namespace std;

class Base {
public:
    // Constructor
    Base() {
        cout << "Constructor de Base" << endl;
    }

    // Destructor virtual
    virtual ~Base() {
        cout << "Destructor de Base" << endl;
    }
};

class Derivada : public Base {
public:
    // Constructor
    Derivada() {
        cout << "Constructor de Derivada" << endl;
    }

    // Destructor
    ~Derivada() {
        cout << "Destructor de Derivada" << endl;
    }
};

int main() {
    Base* obj = new Derivada(); // Crear objeto de clase derivada
    delete obj; // Llamar al destructor virtual

    return 0;
}
<---Ejemplo con Herencia Result--->
<---Sintaxis del Destructor--->
```cpp
class NombreClase {
public:
    // Constructor
    NombreClase();

    // Destructor
    ~NombreClase();

    // Otros métodos y atributos
};
```cpp
#include <iostream>
using namespace std;

class Persona {
public:
    string nombre;

    // Constructor
    Persona(string n) : nombre(n) {
        cout << "Constructor llamado para " << nombre << endl;
    }

    // Destructor
    ~Persona() {
        cout << "Destructor llamado para " << nombre << endl;
    }
};

int main() {
    Persona juan("Juan");
    {
        Persona maria("Maria");
    } // Destructor llamado para maria aquí

    cout << "Fin del main" << endl;
    return 0; // Destructor llamado para juan aquí
}
<---Sintaxis del Destructor Result--->
<---Ejemplo Básico de Destructor--->
```cpp
#include <iostream>
using namespace std;

class Persona {
public:
    string nombre;

    // Constructor
    Persona(string n) : nombre(n) {
        cout << "Constructor llamado para " << nombre << endl;
    }

    // Destructor
    ~Persona() {
        cout << "Destructor llamado para " << nombre << endl;
    }
};

int main() {
    Persona juan("Juan");
    {
        Persona maria("Maria");
    } // Destructor llamado para maria aquí

    cout << "Fin del main" << endl;
    return 0; // Destructor llamado para juan aquí
}
<---Ejemplo Básico de Destructor Result--->
<---Ejemplo con Recursos Dinámicos--->
```cpp
#include <iostream>
using namespace std;

class Array {
private:
    int* data;
    int size;

public:
    // Constructor
    Array(int s) : size(s) {
        data = new int[size]; // Asignar memoria dinámica
        cout << "Array de tamaño " << size << " creado." << endl;
    }

    // Destructor
    ~Array() {
        delete[] data; // Liberar memoria dinámica
        cout << "Array de tamaño " << size << " destruido." << endl;
    }

    // Método para establecer un valor en el array
    void setValue(int index, int value) {
        if (index >= 0 && index < size) {
            data[index] = value;
        }
    }

    // Método para obtener un valor del array
    int getValue(int index) const {
        if (index >= 0 && index < size) {
            return data[index];
        }
        return -1; // Valor de error
    }
};

int main() {
    Array arr(5);
    arr.setValue(0, 10);
    arr.setValue(1, 20);
    cout << "Valor en la posición 0: " << arr.getValue(0) << endl;
    cout << "Valor en la posición 1: " << arr.getValue(1) << endl;

    return 0;
}
<---Ejemplo con Recursos Dinámicos Result--->
<---Regla de Tres--->
```cpp
class Ejemplo {
private:
    int* data;

public:
    // Constructor
    Ejemplo(int size) {
        data = new int[size];
    }

    // Destructor
    ~Ejemplo() {
        delete[] data;
    }

    // Constructor de copia
    Ejemplo(const Ejemplo& other) {
        data = new int[other.size];
        // Copiar datos...
    }

    // Operador de asignación de copia
    Ejemplo& operator=(const Ejemplo& other) {
        if (this != &other) {
            delete[] data;
            data = new int[other.size];
            // Copiar datos...
        }
        return *this;
    }
};
<---Regla de Tres Result--->
<---Regla de Cinco--->
```cpp
class Ejemplo {
private:
    int* data;

public:
    // Constructor
    Ejemplo(int size) {
        data = new int[size];
    }

    // Destructor
    ~Ejemplo() {
        delete[] data;
    }

    // Constructor de copia
    Ejemplo(const Ejemplo& other) {
        data = new int[other.size];
        // Copiar datos...
    }

    // Operador de asignación de copia
    Ejemplo& operator=(const Ejemplo& other) {
        if (this != &other) {
            delete[] data;
            data = new int[other.size];
            // Copiar datos...
        }
        return *this;
    }

    // Constructor de movimiento
    Ejemplo(Ejemplo&& other) noexcept : data(other.data) {
        other.data = nullptr;
    }

    // Operador de asignación de movimiento
    Ejemplo& operator=(Ejemplo&& other) noexcept {
        if (this != &other) {
            delete[] data;
            data = other.data;
            other.data = nullptr;
        }
        return *this;
    }
};
<---Regla de Cinco Result--->
<---Ejemplo de Sobrecarga de Operadores--->
```cpp
#include <iostream>
using namespace std;

class Complejo {
private:
    double real;
    double imaginario;

public:
    // Constructor
    Complejo(double r = 0.0, double i = 0.0) : real(r), imaginario(i) {}

    // Sobrecarga del operador +
    Complejo operator+(const Complejo& c) const {
        return Complejo(real + c.real, imaginario + c.imaginario);
    }

    // Sobrecarga del operador <<
    friend ostream& operator<<(ostream& os, const Complejo& c) {
        os << "(" << c.real << " + " << c.imaginario << "i)";
        return os;
    }
};

int main() {
    Complejo c1(3.0, 4.0);
    Complejo c2(1.0, 2.0);

    Complejo c3 = c1 + c2;  // Usando la sobrecarga del operador +

    cout << "c1: " << c1 << endl;
    cout << "c2: " << c2 << endl;
    cout << "c3: " << c3 << endl;  // Usando la sobrecarga del operador <<

    return 0;
}
<---Ejemplo de Sobrecarga de Operadores Result--->
<---Ejemplo de Sobrecarga del Operador `*`--->
```cpp
#include <iostream>
using namespace std;

class Vector {
private:
    double x, y, z;

public:
    // Constructor
    Vector(double x, double y, double z) : x(x), y(y), z(z) {}

    // Sobrecarga del operador *
    Vector operator*(double escalar) const {
        return Vector(x * escalar, y * escalar, z * escalar);
    }

    // Sobrecarga del operador <<
    friend ostream& operator<<(ostream& os, const Vector& v) {
        os << "{" << v.x << ", " << v.y << ", " << v.z << "}";
        return os;
    }
};

int main() {
    Vector v1(1.0, 2.0, 3.0);
    Vector v2 = v1 * 2.0;

    cout << "v1: " << v1 << endl;
    cout << "v2: " << v2 << endl;

    return 0;
}
<---Ejemplo de Sobrecarga del Operador `*` Result--->
<---Ejemplo de Sobrecarga del Operador `==`--->
```cpp
#include <iostream>
using namespace std;

class Punto {
private:
    int x, y;

public:
    // Constructor
    Punto(int x = 0, int y = 0) : x(x), y(y) {}

    // Sobrecarga del operador ==
    bool operator==(const Punto& p) const {
        return (x == p.x && y == p.y);
    }

    // Sobrecarga del operador <<
    friend ostream& operator<<(ostream& os, const Punto& p) {
        os << "(" << p.x << ", " << p.y << ")";
        return os;
    }
};

int main() {
    Punto p1(1, 2);
    Punto p2(1, 2);
    Punto p3(3, 4);

    cout << "p1: " << p1 << endl;
    cout << "p2: " << p2 << endl;
    cout << "p3: " << p3 << endl;

    cout << "p1 == p2: " << (p1 == p2) << endl;
    cout << "p1 == p3: " << (p1 == p3) << endl;

    return 0;
}
<---Ejemplo de Sobrecarga del Operador `==` Result--->
<---Ejemplo de Sobrecarga del Operador `++`--->
```cpp
#include <iostream>
using namespace std;

class Contador {
private:
    int valor;

public:
    // Constructor
    Contador(int v = 0) : valor(v) {}

    // Sobrecarga del operador prefijo ++
    Contador& operator++() {
        ++valor;
        return *this;
    }

    // Sobrecarga del operador postfijo ++
    Contador operator++(int) {
        Contador temp = *this;
        ++valor;
        return temp;
    }

    // Sobrecarga del operador <<
    friend ostream& operator<<(ostream& os, const Contador& c) {
        os << c.valor;
        return os;
    }
};

int main() {
    Contador c(5);

    cout << "Valor inicial: " << c << endl;

    ++c;
    cout << "Después del prefijo ++: " << c << endl;

    c++;
    cout << "Después del postfijo ++: " << c << endl;

    return 0;
}
<---Ejemplo de Sobrecarga del Operador `++` Result--->
<---Ejemplo de Sobrecarga del Operador `[]`--->
```cpp
#include <iostream>
using namespace std;

class Array {
private:
    int* datos;
    int tamano;

public:
    // Constructor
    Array(int tamano) : tamano(tamano) {
        datos = new int[tamano];
        for (int i = 0; i < tamano; ++i) {
            datos[i] = 0;
        }
    }

    // Destructor
    ~Array() {
        delete[] datos;
    }

    // Sobrecarga del operador []
    int& operator[](int indice) {
        if (indice >= 0 && indice < tamano) {
            return datos[indice];
        }
        throw out_of_range("Índice fuera de rango");
    }

    // Sobrecarga del operador <<
    friend ostream& operator<<(ostream& os, const Array& arr) {
        os << "[";
        for (int i = 0; i < arr.tamano; ++i) {
            os << arr.datos[i];
            if (i < arr.tamano - 1) {
                os << ", ";
            }
        }
        os << "]";
        return os;
    }
};

int main() {
    Array arr(5);

    arr[0] = 10;
    arr[1] = 20;
    arr[2] = 30;

    cout << "Array: " << arr << endl;

    try {
        arr[5] = 50;  // Esto lanzará una excepción
    } catch (const out_of_range& e) {
        cout << e.what() << endl;
    }

    return 0;
}
<---Ejemplo de Sobrecarga del Operador `[]` Result--->
<---Definición de una Clase--->
```cpp
class NombreClase {
public:
    // Atributos
    tipo_atributo nombre_atributo;

    // Métodos
    tipo_retorno nombre_metodo(parametros);

    // Otros componentes, como constructores, destructores, etc.
};
<---Definición de una Clase Result--->
<---Ejemplo Básico de una Clase--->
```cpp
#include <iostream>
using namespace std;

class Persona {
public:
    // Atributos
    string nombre;
    int edad;

    // Métodos
    void saludar() {
        cout << "Hola, mi nombre es " << nombre << " y tengo " << edad << " años." << endl;
    }
};

int main() {
    // Crear un objeto de la clase Persona
    Persona juan;
    juan.nombre = "Juan";
    juan.edad = 30;

    // Llamar al método saludar
    juan.saludar();

    return 0;
}
<---Ejemplo Básico de una Clase Result--->
<---Creación de Objetos--->
```cpp
NombreClase nombre_objeto;
<---Creación de Objetos Result--->
<---Ejemplo de Creación y Uso de Objetos--->
```cpp
#include <iostream>
using namespace std;

class Coche {
public:
    // Atributos
    string marca;
    string modelo;
    int anio;

    // Métodos
    void mostrarInformacion() {
        cout << "Marca: " << marca << ", Modelo: " << modelo << ", Año: " << anio << endl;
    }
};

int main() {
    // Crear objetos de la clase Coche
    Coche coche1;
    coche1.marca = "Toyota";
    coche1.modelo = "Corolla";
    coche1.anio = 2020;

    Coche coche2;
    coche2.marca = "Honda";
    coche2.modelo = "Civic";
    coche2.anio = 2019;

    // Llamar a los métodos de los objetos
    coche1.mostrarInformacion();
    coche2.mostrarInformacion();

    return 0;
}
<---Ejemplo de Creación y Uso de Objetos Result--->
<---Constructores--->
```cpp
class Persona {
public:
    string nombre;
    int edad;

    // Constructor
    Persona(string n, int e) {
        nombre = n;
        edad = e;
    }

    void saludar() {
        cout << "Hola, mi nombre es " << nombre << " y tengo " << edad << " años." << endl;
    }
};

int main() {
    // Crear un objeto de la clase Persona utilizando el constructor
    Persona juan("Juan", 30);
    juan.saludar();

    return 0;
}
<---Constructores Result--->
<---Destructores--->
```cpp
class Persona {
public:
    string nombre;
    int edad;

    // Constructor
    Persona(string n, int e) {
        nombre = n;
        edad = e;
    }

    // Destructor
    ~Persona() {
        cout << "Destructor llamado para " << nombre << endl;
    }

    void saludar() {
        cout << "Hola, mi nombre es " << nombre << " y tengo " << edad << " años." << endl;
    }
};

int main() {
    // Crear un objeto de la clase Persona
    Persona juan("Juan", 30);
    juan.saludar();

    // El destructor se llamará automáticamente al final del alcance
    return 0;
}
<---Destructores Result--->
<---Modificadores de Acceso--->
```cpp
class Persona {
private:
    string nombre;
    int edad;

public:
    // Constructor
    Persona(string n, int e) : nombre(n), edad(e) {}

    // Métodos para acceder y modificar los atributos
    string getNombre() {
        return nombre;
    }

    void setNombre(string n) {
        nombre = n;
    }

    int getEdad() {
        return edad;
    }

    void setEdad(int e) {
        edad = e;
    }

    void saludar() {
        cout << "Hola, mi nombre es " << nombre << " y tengo " << edad << " años." << endl;
    }
};

int main() {
    Persona juan("Juan", 30);
    juan.saludar();

    juan.setEdad(31);
    cout << "Nueva edad de " << juan.getNombre() << ": " << juan.getEdad() << endl;

    return 0;
}
<---Modificadores de Acceso Result--->
<---Ejemplo de Constructor por Defecto--->
```cpp
#include <iostream>
using namespace std;

class Persona {
public:
    string nombre;
    int edad;

    // Constructor por defecto
    Persona() {
        nombre = "Desconocido";
        edad = 0;
    }

    void mostrarInformacion() {
        cout << "Nombre: " << nombre << ", Edad: " << edad << endl;
    }
};

int main() {
    Persona p;  // Llama al constructor por defecto
    p.mostrarInformacion();

    return 0;
}
<---Ejemplo de Constructor por Defecto Result--->
<---Ejemplo de Constructor Parametrizado--->
```cpp
#include <iostream>
using namespace std;

class Persona {
public:
    string nombre;
    int edad;

    // Constructor parametrizado
    Persona(string n, int e) {
        nombre = n;
        edad = e;
    }

    void mostrarInformacion() {
        cout << "Nombre: " << nombre << ", Edad: " << edad << endl;
    }
};

int main() {
    Persona p("Juan", 30);  // Llama al constructor parametrizado
    p.mostrarInformacion();

    return 0;
}
<---Ejemplo de Constructor Parametrizado Result--->
<---Ejemplo de Constructor de Copia--->
```cpp
#include <iostream>
using namespace std;

class Persona {
public:
    string nombre;
    int edad;

    // Constructor parametrizado
    Persona(string n, int e) {
        nombre = n;
        edad = e;
    }

    // Constructor de copia
    Persona(const Persona& p) {
        nombre = p.nombre;
        edad = p.edad;
    }

    void mostrarInformacion() {
        cout << "Nombre: " << nombre << ", Edad: " << edad << endl;
    }
};

int main() {
    Persona p1("Juan", 30);  // Llama al constructor parametrizado
    Persona p2 = p1;         // Llama al constructor de copia
    p2.mostrarInformacion();

    return 0;
}
<---Ejemplo de Constructor de Copia Result--->
<---Ejemplo de Constructor de Movimiento--->
```cpp
#include <iostream>
using namespace std;

class Persona {
public:
    string nombre;
    int edad;

    // Constructor parametrizado
    Persona(string n, int e) : nombre(n), edad(e) {}

    // Constructor de movimiento
    Persona(Persona&& p) noexcept : nombre(move(p.nombre)), edad(p.edad) {
        p.edad = 0; // Opcional: Dejar el objeto fuente en un estado válido
    }

    void mostrarInformacion() {
        cout << "Nombre: " << nombre << ", Edad: " << edad << endl;
    }
};

int main() {
    Persona p1("Juan", 30);  // Llama al constructor parametrizado
    Persona p2 = move(p1);   // Llama al constructor de movimiento
    p2.mostrarInformacion();

    // p1 está en un estado indefinido, pero válido
    cout << "Después de mover, p1: ";
    p1.mostrarInformacion();

    return 0;
}
<---Ejemplo de Constructor de Movimiento Result--->
<---Ejemplo con Lista de Inicialización--->
```cpp
#include <iostream>
using namespace std;

class Punto {
public:
    const int x;
    const int y;

    // Constructor con lista de inicialización
    Punto(int a, int b) : x(a), y(b) {}

    void mostrarInformacion() {
        cout << "Punto(" << x << ", " << y << ")" << endl;
    }
};

int main() {
    Punto p(10, 20);  // Llama al constructor con lista de inicialización
    p.mostrarInformacion();

    return 0;
}
```cpp
#include <iostream>
using namespace std;

class Persona {
private:
    string nombre;
    int edad;

public:
    // Constructor por defecto
    Persona() : nombre("Desconocido"), edad(0) {}

    // Constructor parametrizado
    Persona(string n, int e) : nombre(n), edad(e) {}

    // Constructor de copia
    Persona(const Persona& p) : nombre(p.nombre), edad(p.edad) {}

    // Constructor de movimiento
    Persona(Persona&& p) noexcept : nombre(move(p.nombre)), edad(p.edad) {
        p.edad = 0;
    }

    void mostrarInformacion() {
        cout << "Nombre: " << nombre << ", Edad: " << edad << endl;
    }
};

int main() {
    // Usando el constructor por defecto
    Persona p1;
    p1.mostrarInformacion();

    // Usando el constructor parametrizado
    Persona p2("Juan", 30);
    p2.mostrarInformacion();

    // Usando el constructor de copia
    Persona p3 = p2;
    p3.mostrarInformacion();

    // Usando el constructor de movimiento
    Persona p4 = move(p2);
    p4.mostrarInformacion();

    // Estado después del movimiento
    cout << "Después de mover, p2: ";
    p2.mostrarInformacion();

    return 0;
}
<---Ejemplo con Lista de Inicialización Result--->
<---Definición de Atributos Privados--->
```cpp
class Persona {
private:
    string nombre;
    int edad;

public:
    // Métodos públicos
};
<---Definición de Atributos Privados Result--->
<---Ejemplo de Getters--->
```cpp
class Persona {
private:
    string nombre;
    int edad;

public:
    // Constructor
    Persona(string n, int e) : nombre(n), edad(e) {}

    // Getter para el nombre
    string getNombre() const {
        return nombre;
    }

    // Getter para la edad
    int getEdad() const {
        return edad;
    }
};
<---Ejemplo de Getters Result--->
<---Ejemplo de Setters--->
```cpp
class Persona {
private:
    string nombre;
    int edad;

public:
    // Constructor
    Persona(string n, int e) : nombre(n), edad(e) {}

    // Setter para el nombre
    void setNombre(string n) {
        nombre = n;
    }

    // Setter para la edad
    void setEdad(int e) {
        if (e > 0) {  // Validación simple
            edad = e;
        } else {
            cout << "Edad no válida." << endl;
        }
    }

    // Getters
    string getNombre() const {
        return nombre;
    }

    int getEdad() const {
        return edad;
    }
};
<---Ejemplo de Setters Result--->
<---Ejemplo Completo--->
```cpp
#include <iostream>
using namespace std;

class Persona {
private:
    string nombre;
    int edad;

public:
    // Constructor
    Persona(string n, int e) : nombre(n), edad(e) {}

    // Setters
    void setNombre(string n) {
        nombre = n;
    }

    void setEdad(int e) {
        if (e > 0) {
            edad = e;
        } else {
            cout << "Edad no válida." << endl;
        }
    }

    // Getters
    string getNombre() const {
        return nombre;
    }

    int getEdad() const {
        return edad;
    }

    // Método para mostrar información
    void mostrarInformacion() const {
        cout << "Nombre: " << nombre << ", Edad: " << edad << endl;
    }
};

int main() {
    // Crear un objeto de la clase Persona
    Persona juan("Juan", 30);
    juan.mostrarInformacion();

    // Modificar los atributos usando setters
    juan.setNombre("Juan Perez");
    juan.setEdad(31);
    juan.mostrarInformacion();

    // Intentar establecer una edad no válida
    juan.setEdad(-5);
    juan.mostrarInformacion();

    // Acceder a los atributos usando getters
    cout << "Nombre: " << juan.getNombre() << endl;
    cout << "Edad: " << juan.getEdad() << endl;

    return 0;
}
<---Ejemplo Completo Result--->
<---Ejemplo Básico--->
```cpp
#include <iostream>
using namespace std;

class Ejemplo {
private:
    int datoPrivado; // Acceso privado

public:
    int datoPublico; // Acceso público

    // Constructor
    Ejemplo(int privado, int publico) : datoPrivado(privado), datoPublico(publico) {}

    // Método público para acceder al dato privado
    int getDatoPrivado() const {
        return datoPrivado;
    }

    // Método público para modificar el dato privado
    void setDatoPrivado(int valor) {
        datoPrivado = valor;
    }
};

int main() {
    Ejemplo obj(10, 20);

    // Acceso al dato público
    cout << "Dato público: " << obj.datoPublico << endl;

    // Acceso al dato privado a través de métodos públicos
    cout << "Dato privado: " << obj.getDatoPrivado() << endl;
    obj.setDatoPrivado(30);
    cout << "Dato privado modificado: " << obj.getDatoPrivado() << endl;

    return 0;
}
<---Ejemplo Básico Result--->
<---Ejemplo con Setters y Getters--->
```cpp
#include <iostream>
using namespace std;

class Persona {
private:
    string nombre;
    int edad;

public:
    // Constructor
    Persona(string n, int e) : nombre(n), edad(e) {}

    // Getter para nombre
    string getNombre() const {
        return nombre;
    }

    // Setter para nombre
    void setNombre(string n) {
        nombre = n;
    }

    // Getter para edad
    int getEdad() const {
        return edad;
    }

    // Setter para edad con validación
    void setEdad(int e) {
        if (e > 0) {
            edad = e;
        } else {
            cout << "Edad no válida" << endl;
        }
    }

    // Método para mostrar información
    void mostrarInformacion() const {
        cout << "Nombre: " << nombre << ", Edad: " << edad << endl;
    }
};

int main() {
    Persona juan("Juan", 30);
    juan.mostrarInformacion();

    // Modificar atributos usando setters
    juan.setNombre("Juan Perez");
    juan.setEdad(31);
    juan.mostrarInformacion();

    // Intentar establecer una edad no válida
    juan.setEdad(-5);
    juan.mostrarInformacion();

    return 0;
}
<---Ejemplo con Setters y Getters Result--->
<---Ejemplo con Herencia--->
```cpp
#include <iostream>
using namespace std;

class Base {
public:
    // Constructor
    Base() {
        cout << "Constructor de Base" << endl;
    }

    // Destructor virtual
    virtual ~Base() {
        cout << "Destructor de Base" << endl;
    }
};

class Derivada : public Base {
public:
    // Constructor
    Derivada() {
        cout << "Constructor de Derivada" << endl;
    }

    // Destructor
    ~Derivada() {
        cout << "Destructor de Derivada" << endl;
    }
};

int main() {
    Base* obj = new Derivada(); // Crear objeto de clase derivada
    delete obj; // Llamar al destructor virtual

    return 0;
}
<---Ejemplo con Herencia Result--->
<---Sintaxis del Destructor--->
```cpp
class NombreClase {
public:
    // Constructor
    NombreClase();

    // Destructor
    ~NombreClase();

    // Otros métodos y atributos
};
```cpp
#include <iostream>
using namespace std;

class Persona {
public:
    string nombre;

    // Constructor
    Persona(string n) : nombre(n) {
        cout << "Constructor llamado para " << nombre << endl;
    }

    // Destructor
    ~Persona() {
        cout << "Destructor llamado para " << nombre << endl;
    }
};

int main() {
    Persona juan("Juan");
    {
        Persona maria("Maria");
    } // Destructor llamado para maria aquí

    cout << "Fin del main" << endl;
    return 0; // Destructor llamado para juan aquí
}
<---Sintaxis del Destructor Result--->
<---Ejemplo Básico de Destructor--->
```cpp
#include <iostream>
using namespace std;

class Persona {
public:
    string nombre;

    // Constructor
    Persona(string n) : nombre(n) {
        cout << "Constructor llamado para " << nombre << endl;
    }

    // Destructor
    ~Persona() {
        cout << "Destructor llamado para " << nombre << endl;
    }
};

int main() {
    Persona juan("Juan");
    {
        Persona maria("Maria");
    } // Destructor llamado para maria aquí

    cout << "Fin del main" << endl;
    return 0; // Destructor llamado para juan aquí
}
<---Ejemplo Básico de Destructor Result--->
<---Ejemplo con Recursos Dinámicos--->
```cpp
#include <iostream>
using namespace std;

class Array {
private:
    int* data;
    int size;

public:
    // Constructor
    Array(int s) : size(s) {
        data = new int[size]; // Asignar memoria dinámica
        cout << "Array de tamaño " << size << " creado." << endl;
    }

    // Destructor
    ~Array() {
        delete[] data; // Liberar memoria dinámica
        cout << "Array de tamaño " << size << " destruido." << endl;
    }

    // Método para establecer un valor en el array
    void setValue(int index, int value) {
        if (index >= 0 && index < size) {
            data[index] = value;
        }
    }

    // Método para obtener un valor del array
    int getValue(int index) const {
        if (index >= 0 && index < size) {
            return data[index];
        }
        return -1; // Valor de error
    }
};

int main() {
    Array arr(5);
    arr.setValue(0, 10);
    arr.setValue(1, 20);
    cout << "Valor en la posición 0: " << arr.getValue(0) << endl;
    cout << "Valor en la posición 1: " << arr.getValue(1) << endl;

    return 0;
}
<---Ejemplo con Recursos Dinámicos Result--->
<---Regla de Tres--->
```cpp
class Ejemplo {
private:
    int* data;

public:
    // Constructor
    Ejemplo(int size) {
        data = new int[size];
    }

    // Destructor
    ~Ejemplo() {
        delete[] data;
    }

    // Constructor de copia
    Ejemplo(const Ejemplo& other) {
        data = new int[other.size];
        // Copiar datos...
    }

    // Operador de asignación de copia
    Ejemplo& operator=(const Ejemplo& other) {
        if (this != &other) {
            delete[] data;
            data = new int[other.size];
            // Copiar datos...
        }
        return *this;
    }
};
<---Regla de Tres Result--->
<---Regla de Cinco--->
```cpp
class Ejemplo {
private:
    int* data;

public:
    // Constructor
    Ejemplo(int size) {
        data = new int[size];
    }

    // Destructor
    ~Ejemplo() {
        delete[] data;
    }

    // Constructor de copia
    Ejemplo(const Ejemplo& other) {
        data = new int[other.size];
        // Copiar datos...
    }

    // Operador de asignación de copia
    Ejemplo& operator=(const Ejemplo& other) {
        if (this != &other) {
            delete[] data;
            data = new int[other.size];
            // Copiar datos...
        }
        return *this;
    }

    // Constructor de movimiento
    Ejemplo(Ejemplo&& other) noexcept : data(other.data) {
        other.data = nullptr;
    }

    // Operador de asignación de movimiento
    Ejemplo& operator=(Ejemplo&& other) noexcept {
        if (this != &other) {
            delete[] data;
            data = other.data;
            other.data = nullptr;
        }
        return *this;
    }
};
<---Regla de Cinco Result--->
<---Ejemplo de Sobrecarga de Operadores--->
```cpp
#include <iostream>
using namespace std;

class Complejo {
private:
    double real;
    double imaginario;

public:
    // Constructor
    Complejo(double r = 0.0, double i = 0.0) : real(r), imaginario(i) {}

    // Sobrecarga del operador +
    Complejo operator+(const Complejo& c) const {
        return Complejo(real + c.real, imaginario + c.imaginario);
    }

    // Sobrecarga del operador <<
    friend ostream& operator<<(ostream& os, const Complejo& c) {
        os << "(" << c.real << " + " << c.imaginario << "i)";
        return os;
    }
};

int main() {
    Complejo c1(3.0, 4.0);
    Complejo c2(1.0, 2.0);

    Complejo c3 = c1 + c2;  // Usando la sobrecarga del operador +

    cout << "c1: " << c1 << endl;
    cout << "c2: " << c2 << endl;
    cout << "c3: " << c3 << endl;  // Usando la sobrecarga del operador <<

    return 0;
}
<---Ejemplo de Sobrecarga de Operadores Result--->
<---Ejemplo de Sobrecarga del Operador `*`--->
```cpp
#include <iostream>
using namespace std;

class Vector {
private:
    double x, y, z;

public:
    // Constructor
    Vector(double x, double y, double z) : x(x), y(y), z(z) {}

    // Sobrecarga del operador *
    Vector operator*(double escalar) const {
        return Vector(x * escalar, y * escalar, z * escalar);
    }

    // Sobrecarga del operador <<
    friend ostream& operator<<(ostream& os, const Vector& v) {
        os << "{" << v.x << ", " << v.y << ", " << v.z << "}";
        return os;
    }
};

int main() {
    Vector v1(1.0, 2.0, 3.0);
    Vector v2 = v1 * 2.0;

    cout << "v1: " << v1 << endl;
    cout << "v2: " << v2 << endl;

    return 0;
}
<---Ejemplo de Sobrecarga del Operador `*` Result--->
<---Ejemplo de Sobrecarga del Operador `==`--->
```cpp
#include <iostream>
using namespace std;

class Punto {
private:
    int x, y;

public:
    // Constructor
    Punto(int x = 0, int y = 0) : x(x), y(y) {}

    // Sobrecarga del operador ==
    bool operator==(const Punto& p) const {
        return (x == p.x && y == p.y);
    }

    // Sobrecarga del operador <<
    friend ostream& operator<<(ostream& os, const Punto& p) {
        os << "(" << p.x << ", " << p.y << ")";
        return os;
    }
};

int main() {
    Punto p1(1, 2);
    Punto p2(1, 2);
    Punto p3(3, 4);

    cout << "p1: " << p1 << endl;
    cout << "p2: " << p2 << endl;
    cout << "p3: " << p3 << endl;

    cout << "p1 == p2: " << (p1 == p2) << endl;
    cout << "p1 == p3: " << (p1 == p3) << endl;

    return 0;
}
<---Ejemplo de Sobrecarga del Operador `==` Result--->
<---Ejemplo de Sobrecarga del Operador `++`--->
```cpp
#include <iostream>
using namespace std;

class Contador {
private:
    int valor;

public:
    // Constructor
    Contador(int v = 0) : valor(v) {}

    // Sobrecarga del operador prefijo ++
    Contador& operator++() {
        ++valor;
        return *this;
    }

    // Sobrecarga del operador postfijo ++
    Contador operator++(int) {
        Contador temp = *this;
        ++valor;
        return temp;
    }

    // Sobrecarga del operador <<
    friend ostream& operator<<(ostream& os, const Contador& c) {
        os << c.valor;
        return os;
    }
};

int main() {
    Contador c(5);

    cout << "Valor inicial: " << c << endl;

    ++c;
    cout << "Después del prefijo ++: " << c << endl;

    c++;
    cout << "Después del postfijo ++: " << c << endl;

    return 0;
}
<---Ejemplo de Sobrecarga del Operador `++` Result--->
<---Ejemplo de Sobrecarga del Operador `[]`--->
```cpp
#include <iostream>
using namespace std;

class Array {
private:
    int* datos;
    int tamano;

public:
    // Constructor
    Array(int tamano) : tamano(tamano) {
        datos = new int[tamano];
        for (int i = 0; i < tamano; ++i) {
            datos[i] = 0;
        }
    }

    // Destructor
    ~Array() {
        delete[] datos;
    }

    // Sobrecarga del operador []
    int& operator[](int indice) {
        if (indice >= 0 && indice < tamano) {
            return datos[indice];
        }
        throw out_of_range("Índice fuera de rango");
    }

    // Sobrecarga del operador <<
    friend ostream& operator<<(ostream& os, const Array& arr) {
        os << "[";
        for (int i = 0; i < arr.tamano; ++i) {
            os << arr.datos[i];
            if (i < arr.tamano - 1) {
                os << ", ";
            }
        }
        os << "]";
        return os;
    }
};

int main() {
    Array arr(5);

    arr[0] = 10;
    arr[1] = 20;
    arr[2] = 30;

    cout << "Array: " << arr << endl;

    try {
        arr[5] = 50;  // Esto lanzará una excepción
    } catch (const out_of_range& e) {
        cout << e.what() << endl;
    }

    return 0;
}
<---Ejemplo de Sobrecarga del Operador `[]` Result--->
<---Definición de una Clase--->
```cpp
class NombreClase {
public:
    // Atributos
    tipo_atributo nombre_atributo;

    // Métodos
    tipo_retorno nombre_metodo(parametros);

    // Otros componentes, como constructores, destructores, etc.
};
<---Definición de una Clase Result--->
<---Ejemplo Básico de una Clase--->
```cpp
#include <iostream>
using namespace std;

class Persona {
public:
    // Atributos
    string nombre;
    int edad;

    // Métodos
    void saludar() {
        cout << "Hola, mi nombre es " << nombre << " y tengo " << edad << " años." << endl;
    }
};

int main() {
    // Crear un objeto de la clase Persona
    Persona juan;
    juan.nombre = "Juan";
    juan.edad = 30;

    // Llamar al método saludar
    juan.saludar();

    return 0;
}
<---Ejemplo Básico de una Clase Result--->
<---Creación de Objetos--->
```cpp
NombreClase nombre_objeto;
<---Creación de Objetos Result--->
<---Ejemplo de Creación y Uso de Objetos--->
```cpp
#include <iostream>
using namespace std;

class Coche {
public:
    // Atributos
    string marca;
    string modelo;
    int anio;

    // Métodos
    void mostrarInformacion() {
        cout << "Marca: " << marca << ", Modelo: " << modelo << ", Año: " << anio << endl;
    }
};

int main() {
    // Crear objetos de la clase Coche
    Coche coche1;
    coche1.marca = "Toyota";
    coche1.modelo = "Corolla";
    coche1.anio = 2020;

    Coche coche2;
    coche2.marca = "Honda";
    coche2.modelo = "Civic";
    coche2.anio = 2019;

    // Llamar a los métodos de los objetos
    coche1.mostrarInformacion();
    coche2.mostrarInformacion();

    return 0;
}
<---Ejemplo de Creación y Uso de Objetos Result--->
<---Constructores--->
```cpp
class Persona {
public:
    string nombre;
    int edad;

    // Constructor
    Persona(string n, int e) {
        nombre = n;
        edad = e;
    }

    void saludar() {
        cout << "Hola, mi nombre es " << nombre << " y tengo " << edad << " años." << endl;
    }
};

int main() {
    // Crear un objeto de la clase Persona utilizando el constructor
    Persona juan("Juan", 30);
    juan.saludar();

    return 0;
}
<---Constructores Result--->
<---Destructores--->
```cpp
class Persona {
public:
    string nombre;
    int edad;

    // Constructor
    Persona(string n, int e) {
        nombre = n;
        edad = e;
    }

    // Destructor
    ~Persona() {
        cout << "Destructor llamado para " << nombre << endl;
    }

    void saludar() {
        cout << "Hola, mi nombre es " << nombre << " y tengo " << edad << " años." << endl;
    }
};

int main() {
    // Crear un objeto de la clase Persona
    Persona juan("Juan", 30);
    juan.saludar();

    // El destructor se llamará automáticamente al final del alcance
    return 0;
}
<---Destructores Result--->
<---Modificadores de Acceso--->
```cpp
class Persona {
private:
    string nombre;
    int edad;

public:
    // Constructor
    Persona(string n, int e) : nombre(n), edad(e) {}

    // Métodos para acceder y modificar los atributos
    string getNombre() {
        return nombre;
    }

    void setNombre(string n) {
        nombre = n;
    }

    int getEdad() {
        return edad;
    }

    void setEdad(int e) {
        edad = e;
    }

    void saludar() {
        cout << "Hola, mi nombre es " << nombre << " y tengo " << edad << " años." << endl;
    }
};

int main() {
    Persona juan("Juan", 30);
    juan.saludar();

    juan.setEdad(31);
    cout << "Nueva edad de " << juan.getNombre() << ": " << juan.getEdad() << endl;

    return 0;
}
<---Modificadores de Acceso Result--->
<---Ejemplo de Constructor por Defecto--->
```cpp
#include <iostream>
using namespace std;

class Persona {
public:
    string nombre;
    int edad;

    // Constructor por defecto
    Persona() {
        nombre = "Desconocido";
        edad = 0;
    }

    void mostrarInformacion() {
        cout << "Nombre: " << nombre << ", Edad: " << edad << endl;
    }
};

int main() {
    Persona p;  // Llama al constructor por defecto
    p.mostrarInformacion();

    return 0;
}
<---Ejemplo de Constructor por Defecto Result--->
<---Ejemplo de Constructor Parametrizado--->
```cpp
#include <iostream>
using namespace std;

class Persona {
public:
    string nombre;
    int edad;

    // Constructor parametrizado
    Persona(string n, int e) {
        nombre = n;
        edad = e;
    }

    void mostrarInformacion() {
        cout << "Nombre: " << nombre << ", Edad: " << edad << endl;
    }
};

int main() {
    Persona p("Juan", 30);  // Llama al constructor parametrizado
    p.mostrarInformacion();

    return 0;
}
<---Ejemplo de Constructor Parametrizado Result--->
<---Ejemplo de Constructor de Copia--->
```cpp
#include <iostream>
using namespace std;

class Persona {
public:
    string nombre;
    int edad;

    // Constructor parametrizado
    Persona(string n, int e) {
        nombre = n;
        edad = e;
    }

    // Constructor de copia
    Persona(const Persona& p) {
        nombre = p.nombre;
        edad = p.edad;
    }

    void mostrarInformacion() {
        cout << "Nombre: " << nombre << ", Edad: " << edad << endl;
    }
};

int main() {
    Persona p1("Juan", 30);  // Llama al constructor parametrizado
    Persona p2 = p1;         // Llama al constructor de copia
    p2.mostrarInformacion();

    return 0;
}
<---Ejemplo de Constructor de Copia Result--->
<---Ejemplo de Constructor de Movimiento--->
```cpp
#include <iostream>
using namespace std;

class Persona {
public:
    string nombre;
    int edad;

    // Constructor parametrizado
    Persona(string n, int e) : nombre(n), edad(e) {}

    // Constructor de movimiento
    Persona(Persona&& p) noexcept : nombre(move(p.nombre)), edad(p.edad) {
        p.edad = 0; // Opcional: Dejar el objeto fuente en un estado válido
    }

    void mostrarInformacion() {
        cout << "Nombre: " << nombre << ", Edad: " << edad << endl;
    }
};

int main() {
    Persona p1("Juan", 30);  // Llama al constructor parametrizado
    Persona p2 = move(p1);   // Llama al constructor de movimiento
    p2.mostrarInformacion();

    // p1 está en un estado indefinido, pero válido
    cout << "Después de mover, p1: ";
    p1.mostrarInformacion();

    return 0;
}
<---Ejemplo de Constructor de Movimiento Result--->
<---Ejemplo con Lista de Inicialización--->
```cpp
#include <iostream>
using namespace std;

class Punto {
public:
    const int x;
    const int y;

    // Constructor con lista de inicialización
    Punto(int a, int b) : x(a), y(b) {}

    void mostrarInformacion() {
        cout << "Punto(" << x << ", " << y << ")" << endl;
    }
};

int main() {
    Punto p(10, 20);  // Llama al constructor con lista de inicialización
    p.mostrarInformacion();

    return 0;
}
```cpp
#include <iostream>
using namespace std;

class Persona {
private:
    string nombre;
    int edad;

public:
    // Constructor por defecto
    Persona() : nombre("Desconocido"), edad(0) {}

    // Constructor parametrizado
    Persona(string n, int e) : nombre(n), edad(e) {}

    // Constructor de copia
    Persona(const Persona& p) : nombre(p.nombre), edad(p.edad) {}

    // Constructor de movimiento
    Persona(Persona&& p) noexcept : nombre(move(p.nombre)), edad(p.edad) {
        p.edad = 0;
    }

    void mostrarInformacion() {
        cout << "Nombre: " << nombre << ", Edad: " << edad << endl;
    }
};

int main() {
    // Usando el constructor por defecto
    Persona p1;
    p1.mostrarInformacion();

    // Usando el constructor parametrizado
    Persona p2("Juan", 30);
    p2.mostrarInformacion();

    // Usando el constructor de copia
    Persona p3 = p2;
    p3.mostrarInformacion();

    // Usando el constructor de movimiento
    Persona p4 = move(p2);
    p4.mostrarInformacion();

    // Estado después del movimiento
    cout << "Después de mover, p2: ";
    p2.mostrarInformacion();

    return 0;
}
<---Ejemplo con Lista de Inicialización Result--->
<---Definición de Atributos Privados--->
```cpp
class Persona {
private:
    string nombre;
    int edad;

public:
    // Métodos públicos
};
<---Definición de Atributos Privados Result--->
<---Ejemplo de Getters--->
```cpp
class Persona {
private:
    string nombre;
    int edad;

public:
    // Constructor
    Persona(string n, int e) : nombre(n), edad(e) {}

    // Getter para el nombre
    string getNombre() const {
        return nombre;
    }

    // Getter para la edad
    int getEdad() const {
        return edad;
    }
};
<---Ejemplo de Getters Result--->
<---Ejemplo de Setters--->
```cpp
class Persona {
private:
    string nombre;
    int edad;

public:
    // Constructor
    Persona(string n, int e) : nombre(n), edad(e) {}

    // Setter para el nombre
    void setNombre(string n) {
        nombre = n;
    }

    // Setter para la edad
    void setEdad(int e) {
        if (e > 0) {  // Validación simple
            edad = e;
        } else {
            cout << "Edad no válida." << endl;
        }
    }

    // Getters
    string getNombre() const {
        return nombre;
    }

    int getEdad() const {
        return edad;
    }
};
<---Ejemplo de Setters Result--->
<---Ejemplo Completo--->
```cpp
#include <iostream>
using namespace std;

class Persona {
private:
    string nombre;
    int edad;

public:
    // Constructor
    Persona(string n, int e) : nombre(n), edad(e) {}

    // Setters
    void setNombre(string n) {
        nombre = n;
    }

    void setEdad(int e) {
        if (e > 0) {
            edad = e;
        } else {
            cout << "Edad no válida." << endl;
        }
    }

    // Getters
    string getNombre() const {
        return nombre;
    }

    int getEdad() const {
        return edad;
    }

    // Método para mostrar información
    void mostrarInformacion() const {
        cout << "Nombre: " << nombre << ", Edad: " << edad << endl;
    }
};

int main() {
    // Crear un objeto de la clase Persona
    Persona juan("Juan", 30);
    juan.mostrarInformacion();

    // Modificar los atributos usando setters
    juan.setNombre("Juan Perez");
    juan.setEdad(31);
    juan.mostrarInformacion();

    // Intentar establecer una edad no válida
    juan.setEdad(-5);
    juan.mostrarInformacion();

    // Acceder a los atributos usando getters
    cout << "Nombre: " << juan.getNombre() << endl;
    cout << "Edad: " << juan.getEdad() << endl;

    return 0;
}
<---Ejemplo Completo Result--->
<---Ejemplo Básico--->
```cpp
#include <iostream>
using namespace std;

class Ejemplo {
private:
    int datoPrivado; // Acceso privado

public:
    int datoPublico; // Acceso público

    // Constructor
    Ejemplo(int privado, int publico) : datoPrivado(privado), datoPublico(publico) {}

    // Método público para acceder al dato privado
    int getDatoPrivado() const {
        return datoPrivado;
    }

    // Método público para modificar el dato privado
    void setDatoPrivado(int valor) {
        datoPrivado = valor;
    }
};

int main() {
    Ejemplo obj(10, 20);

    // Acceso al dato público
    cout << "Dato público: " << obj.datoPublico << endl;

    // Acceso al dato privado a través de métodos públicos
    cout << "Dato privado: " << obj.getDatoPrivado() << endl;
    obj.setDatoPrivado(30);
    cout << "Dato privado modificado: " << obj.getDatoPrivado() << endl;

    return 0;
}
<---Ejemplo Básico Result--->
<---Ejemplo con Setters y Getters--->
```cpp
#include <iostream>
using namespace std;

class Persona {
private:
    string nombre;
    int edad;

public:
    // Constructor
    Persona(string n, int e) : nombre(n), edad(e) {}

    // Getter para nombre
    string getNombre() const {
        return nombre;
    }

    // Setter para nombre
    void setNombre(string n) {
        nombre = n;
    }

    // Getter para edad
    int getEdad() const {
        return edad;
    }

    // Setter para edad con validación
    void setEdad(int e) {
        if (e > 0) {
            edad = e;
        } else {
            cout << "Edad no válida" << endl;
        }
    }

    // Método para mostrar información
    void mostrarInformacion() const {
        cout << "Nombre: " << nombre << ", Edad: " << edad << endl;
    }
};

int main() {
    Persona juan("Juan", 30);
    juan.mostrarInformacion();

    // Modificar atributos usando setters
    juan.setNombre("Juan Perez");
    juan.setEdad(31);
    juan.mostrarInformacion();

    // Intentar establecer una edad no válida
    juan.setEdad(-5);
    juan.mostrarInformacion();

    return 0;
}
<---Ejemplo con Setters y Getters Result--->
<---Ejemplo con Herencia--->
```cpp
#include <iostream>
using namespace std;

class Base {
public:
    // Constructor
    Base() {
        cout << "Constructor de Base" << endl;
    }

    // Destructor virtual
    virtual ~Base() {
        cout << "Destructor de Base" << endl;
    }
};

class Derivada : public Base {
public:
    // Constructor
    Derivada() {
        cout << "Constructor de Derivada" << endl;
    }

    // Destructor
    ~Derivada() {
        cout << "Destructor de Derivada" << endl;
    }
};

int main() {
    Base* obj = new Derivada(); // Crear objeto de clase derivada
    delete obj; // Llamar al destructor virtual

    return 0;
}
<---Ejemplo con Herencia Result--->
<---Sintaxis del Destructor--->
```cpp
class NombreClase {
public:
    // Constructor
    NombreClase();

    // Destructor
    ~NombreClase();

    // Otros métodos y atributos
};
```cpp
#include <iostream>
using namespace std;

class Persona {
public:
    string nombre;

    // Constructor
    Persona(string n) : nombre(n) {
        cout << "Constructor llamado para " << nombre << endl;
    }

    // Destructor
    ~Persona() {
        cout << "Destructor llamado para " << nombre << endl;
    }
};

int main() {
    Persona juan("Juan");
    {
        Persona maria("Maria");
    } // Destructor llamado para maria aquí

    cout << "Fin del main" << endl;
    return 0; // Destructor llamado para juan aquí
}
<---Sintaxis del Destructor Result--->
<---Ejemplo Básico de Destructor--->
```cpp
#include <iostream>
using namespace std;

class Persona {
public:
    string nombre;

    // Constructor
    Persona(string n) : nombre(n) {
        cout << "Constructor llamado para " << nombre << endl;
    }

    // Destructor
    ~Persona() {
        cout << "Destructor llamado para " << nombre << endl;
    }
};

int main() {
    Persona juan("Juan");
    {
        Persona maria("Maria");
    } // Destructor llamado para maria aquí

    cout << "Fin del main" << endl;
    return 0; // Destructor llamado para juan aquí
}
<---Ejemplo Básico de Destructor Result--->
<---Ejemplo con Recursos Dinámicos--->
```cpp
#include <iostream>
using namespace std;

class Array {
private:
    int* data;
    int size;

public:
    // Constructor
    Array(int s) : size(s) {
        data = new int[size]; // Asignar memoria dinámica
        cout << "Array de tamaño " << size << " creado." << endl;
    }

    // Destructor
    ~Array() {
        delete[] data; // Liberar memoria dinámica
        cout << "Array de tamaño " << size << " destruido." << endl;
    }

    // Método para establecer un valor en el array
    void setValue(int index, int value) {
        if (index >= 0 && index < size) {
            data[index] = value;
        }
    }

    // Método para obtener un valor del array
    int getValue(int index) const {
        if (index >= 0 && index < size) {
            return data[index];
        }
        return -1; // Valor de error
    }
};

int main() {
    Array arr(5);
    arr.setValue(0, 10);
    arr.setValue(1, 20);
    cout << "Valor en la posición 0: " << arr.getValue(0) << endl;
    cout << "Valor en la posición 1: " << arr.getValue(1) << endl;

    return 0;
}
<---Ejemplo con Recursos Dinámicos Result--->
<---Regla de Tres--->
```cpp
class Ejemplo {
private:
    int* data;

public:
    // Constructor
    Ejemplo(int size) {
        data = new int[size];
    }

    // Destructor
    ~Ejemplo() {
        delete[] data;
    }

    // Constructor de copia
    Ejemplo(const Ejemplo& other) {
        data = new int[other.size];
        // Copiar datos...
    }

    // Operador de asignación de copia
    Ejemplo& operator=(const Ejemplo& other) {
        if (this != &other) {
            delete[] data;
            data = new int[other.size];
            // Copiar datos...
        }
        return *this;
    }
};
<---Regla de Tres Result--->
<---Regla de Cinco--->
```cpp
class Ejemplo {
private:
    int* data;

public:
    // Constructor
    Ejemplo(int size) {
        data = new int[size];
    }

    // Destructor
    ~Ejemplo() {
        delete[] data;
    }

    // Constructor de copia
    Ejemplo(const Ejemplo& other) {
        data = new int[other.size];
        // Copiar datos...
    }

    // Operador de asignación de copia
    Ejemplo& operator=(const Ejemplo& other) {
        if (this != &other) {
            delete[] data;
            data = new int[other.size];
            // Copiar datos...
        }
        return *this;
    }

    // Constructor de movimiento
    Ejemplo(Ejemplo&& other) noexcept : data(other.data) {
        other.data = nullptr;
    }

    // Operador de asignación de movimiento
    Ejemplo& operator=(Ejemplo&& other) noexcept {
        if (this != &other) {
            delete[] data;
            data = other.data;
            other.data = nullptr;
        }
        return *this;
    }
};
<---Regla de Cinco Result--->
<---Ejemplo de Sobrecarga de Operadores--->
```cpp
#include <iostream>
using namespace std;

class Complejo {
private:
    double real;
    double imaginario;

public:
    // Constructor
    Complejo(double r = 0.0, double i = 0.0) : real(r), imaginario(i) {}

    // Sobrecarga del operador +
    Complejo operator+(const Complejo& c) const {
        return Complejo(real + c.real, imaginario + c.imaginario);
    }

    // Sobrecarga del operador <<
    friend ostream& operator<<(ostream& os, const Complejo& c) {
        os << "(" << c.real << " + " << c.imaginario << "i)";
        return os;
    }
};

int main() {
    Complejo c1(3.0, 4.0);
    Complejo c2(1.0, 2.0);

    Complejo c3 = c1 + c2;  // Usando la sobrecarga del operador +

    cout << "c1: " << c1 << endl;
    cout << "c2: " << c2 << endl;
    cout << "c3: " << c3 << endl;  // Usando la sobrecarga del operador <<

    return 0;
}
<---Ejemplo de Sobrecarga de Operadores Result--->
<---Ejemplo de Sobrecarga del Operador `*`--->
```cpp
#include <iostream>
using namespace std;

class Vector {
private:
    double x, y, z;

public:
    // Constructor
    Vector(double x, double y, double z) : x(x), y(y), z(z) {}

    // Sobrecarga del operador *
    Vector operator*(double escalar) const {
        return Vector(x * escalar, y * escalar, z * escalar);
    }

    // Sobrecarga del operador <<
    friend ostream& operator<<(ostream& os, const Vector& v) {
        os << "{" << v.x << ", " << v.y << ", " << v.z << "}";
        return os;
    }
};

int main() {
    Vector v1(1.0, 2.0, 3.0);
    Vector v2 = v1 * 2.0;

    cout << "v1: " << v1 << endl;
    cout << "v2: " << v2 << endl;

    return 0;
}
<---Ejemplo de Sobrecarga del Operador `*` Result--->
<---Ejemplo de Sobrecarga del Operador `==`--->
```cpp
#include <iostream>
using namespace std;

class Punto {
private:
    int x, y;

public:
    // Constructor
    Punto(int x = 0, int y = 0) : x(x), y(y) {}

    // Sobrecarga del operador ==
    bool operator==(const Punto& p) const {
        return (x == p.x && y == p.y);
    }

    // Sobrecarga del operador <<
    friend ostream& operator<<(ostream& os, const Punto& p) {
        os << "(" << p.x << ", " << p.y << ")";
        return os;
    }
};

int main() {
    Punto p1(1, 2);
    Punto p2(1, 2);
    Punto p3(3, 4);

    cout << "p1: " << p1 << endl;
    cout << "p2: " << p2 << endl;
    cout << "p3: " << p3 << endl;

    cout << "p1 == p2: " << (p1 == p2) << endl;
    cout << "p1 == p3: " << (p1 == p3) << endl;

    return 0;
}
<---Ejemplo de Sobrecarga del Operador `==` Result--->
<---Ejemplo de Sobrecarga del Operador `++`--->
```cpp
#include <iostream>
using namespace std;

class Contador {
private:
    int valor;

public:
    // Constructor
    Contador(int v = 0) : valor(v) {}

    // Sobrecarga del operador prefijo ++
    Contador& operator++() {
        ++valor;
        return *this;
    }

    // Sobrecarga del operador postfijo ++
    Contador operator++(int) {
        Contador temp = *this;
        ++valor;
        return temp;
    }

    // Sobrecarga del operador <<
    friend ostream& operator<<(ostream& os, const Contador& c) {
        os << c.valor;
        return os;
    }
};

int main() {
    Contador c(5);

    cout << "Valor inicial: " << c << endl;

    ++c;
    cout << "Después del prefijo ++: " << c << endl;

    c++;
    cout << "Después del postfijo ++: " << c << endl;

    return 0;
}
<---Ejemplo de Sobrecarga del Operador `++` Result--->
<---Ejemplo de Sobrecarga del Operador `[]`--->
```cpp
#include <iostream>
using namespace std;

class Array {
private:
    int* datos;
    int tamano;

public:
    // Constructor
    Array(int tamano) : tamano(tamano) {
        datos = new int[tamano];
        for (int i = 0; i < tamano; ++i) {
            datos[i] = 0;
        }
    }

    // Destructor
    ~Array() {
        delete[] datos;
    }

    // Sobrecarga del operador []
    int& operator[](int indice) {
        if (indice >= 0 && indice < tamano) {
            return datos[indice];
        }
        throw out_of_range("Índice fuera de rango");
    }

    // Sobrecarga del operador <<
    friend ostream& operator<<(ostream& os, const Array& arr) {
        os << "[";
        for (int i = 0; i < arr.tamano; ++i) {
            os << arr.datos[i];
            if (i < arr.tamano - 1) {
                os << ", ";
            }
        }
        os << "]";
        return os;
    }
};

int main() {
    Array arr(5);

    arr[0] = 10;
    arr[1] = 20;
    arr[2] = 30;

    cout << "Array: " << arr << endl;

    try {
        arr[5] = 50;  // Esto lanzará una excepción
    } catch (const out_of_range& e) {
        cout << e.what() << endl;
    }

    return 0;
}
<---Ejemplo de Sobrecarga del Operador `[]` Result--->
<---Definición de una Clase--->
```cpp
class NombreClase {
public:
    // Atributos
    tipo_atributo nombre_atributo;

    // Métodos
    tipo_retorno nombre_metodo(parametros);

    // Otros componentes, como constructores, destructores, etc.
};
<---Definición de una Clase Result--->
<---Ejemplo Básico de una Clase--->
```cpp
#include <iostream>
using namespace std;

class Persona {
public:
    // Atributos
    string nombre;
    int edad;

    // Métodos
    void saludar() {
        cout << "Hola, mi nombre es " << nombre << " y tengo " << edad << " años." << endl;
    }
};

int main() {
    // Crear un objeto de la clase Persona
    Persona juan;
    juan.nombre = "Juan";
    juan.edad = 30;

    // Llamar al método saludar
    juan.saludar();

    return 0;
}
<---Ejemplo Básico de una Clase Result--->
<---Creación de Objetos--->
```cpp
NombreClase nombre_objeto;
<---Creación de Objetos Result--->
<---Ejemplo de Creación y Uso de Objetos--->
```cpp
#include <iostream>
using namespace std;

class Coche {
public:
    // Atributos
    string marca;
    string modelo;
    int anio;

    // Métodos
    void mostrarInformacion() {
        cout << "Marca: " << marca << ", Modelo: " << modelo << ", Año: " << anio << endl;
    }
};

int main() {
    // Crear objetos de la clase Coche
    Coche coche1;
    coche1.marca = "Toyota";
    coche1.modelo = "Corolla";
    coche1.anio = 2020;

    Coche coche2;
    coche2.marca = "Honda";
    coche2.modelo = "Civic";
    coche2.anio = 2019;

    // Llamar a los métodos de los objetos
    coche1.mostrarInformacion();
    coche2.mostrarInformacion();

    return 0;
}
<---Ejemplo de Creación y Uso de Objetos Result--->
<---Constructores--->
```cpp
class Persona {
public:
    string nombre;
    int edad;

    // Constructor
    Persona(string n, int e) {
        nombre = n;
        edad = e;
    }

    void saludar() {
        cout << "Hola, mi nombre es " << nombre << " y tengo " << edad << " años." << endl;
    }
};

int main() {
    // Crear un objeto de la clase Persona utilizando el constructor
    Persona juan("Juan", 30);
    juan.saludar();

    return 0;
}
<---Constructores Result--->
<---Destructores--->
```cpp
class Persona {
public:
    string nombre;
    int edad;

    // Constructor
    Persona(string n, int e) {
        nombre = n;
        edad = e;
    }

    // Destructor
    ~Persona() {
        cout << "Destructor llamado para " << nombre << endl;
    }

    void saludar() {
        cout << "Hola, mi nombre es " << nombre << " y tengo " << edad << " años." << endl;
    }
};

int main() {
    // Crear un objeto de la clase Persona
    Persona juan("Juan", 30);
    juan.saludar();

    // El destructor se llamará automáticamente al final del alcance
    return 0;
}
<---Destructores Result--->
<---Modificadores de Acceso--->
```cpp
class Persona {
private:
    string nombre;
    int edad;

public:
    // Constructor
    Persona(string n, int e) : nombre(n), edad(e) {}

    // Métodos para acceder y modificar los atributos
    string getNombre() {
        return nombre;
    }

    void setNombre(string n) {
        nombre = n;
    }

    int getEdad() {
        return edad;
    }

    void setEdad(int e) {
        edad = e;
    }

    void saludar() {
        cout << "Hola, mi nombre es " << nombre << " y tengo " << edad << " años." << endl;
    }
};

int main() {
    Persona juan("Juan", 30);
    juan.saludar();

    juan.setEdad(31);
    cout << "Nueva edad de " << juan.getNombre() << ": " << juan.getEdad() << endl;

    return 0;
}
<---Modificadores de Acceso Result--->
<---Ejemplo de Constructor por Defecto--->
```cpp
#include <iostream>
using namespace std;

class Persona {
public:
    string nombre;
    int edad;

    // Constructor por defecto
    Persona() {
        nombre = "Desconocido";
        edad = 0;
    }

    void mostrarInformacion() {
        cout << "Nombre: " << nombre << ", Edad: " << edad << endl;
    }
};

int main() {
    Persona p;  // Llama al constructor por defecto
    p.mostrarInformacion();

    return 0;
}
<---Ejemplo de Constructor por Defecto Result--->
<---Ejemplo de Constructor Parametrizado--->
```cpp
#include <iostream>
using namespace std;

class Persona {
public:
    string nombre;
    int edad;

    // Constructor parametrizado
    Persona(string n, int e) {
        nombre = n;
        edad = e;
    }

    void mostrarInformacion() {
        cout << "Nombre: " << nombre << ", Edad: " << edad << endl;
    }
};

int main() {
    Persona p("Juan", 30);  // Llama al constructor parametrizado
    p.mostrarInformacion();

    return 0;
}
<---Ejemplo de Constructor Parametrizado Result--->
<---Ejemplo de Constructor de Copia--->
```cpp
#include <iostream>
using namespace std;

class Persona {
public:
    string nombre;
    int edad;

    // Constructor parametrizado
    Persona(string n, int e) {
        nombre = n;
        edad = e;
    }

    // Constructor de copia
    Persona(const Persona& p) {
        nombre = p.nombre;
        edad = p.edad;
    }

    void mostrarInformacion() {
        cout << "Nombre: " << nombre << ", Edad: " << edad << endl;
    }
};

int main() {
    Persona p1("Juan", 30);  // Llama al constructor parametrizado
    Persona p2 = p1;         // Llama al constructor de copia
    p2.mostrarInformacion();

    return 0;
}
<---Ejemplo de Constructor de Copia Result--->
<---Ejemplo de Constructor de Movimiento--->
```cpp
#include <iostream>
using namespace std;

class Persona {
public:
    string nombre;
    int edad;

    // Constructor parametrizado
    Persona(string n, int e) : nombre(n), edad(e) {}

    // Constructor de movimiento
    Persona(Persona&& p) noexcept : nombre(move(p.nombre)), edad(p.edad) {
        p.edad = 0; // Opcional: Dejar el objeto fuente en un estado válido
    }

    void mostrarInformacion() {
        cout << "Nombre: " << nombre << ", Edad: " << edad << endl;
    }
};

int main() {
    Persona p1("Juan", 30);  // Llama al constructor parametrizado
    Persona p2 = move(p1);   // Llama al constructor de movimiento
    p2.mostrarInformacion();

    // p1 está en un estado indefinido, pero válido
    cout << "Después de mover, p1: ";
    p1.mostrarInformacion();

    return 0;
}
<---Ejemplo de Constructor de Movimiento Result--->
<---Ejemplo con Lista de Inicialización--->
```cpp
#include <iostream>
using namespace std;

class Punto {
public:
    const int x;
    const int y;

    // Constructor con lista de inicialización
    Punto(int a, int b) : x(a), y(b) {}

    void mostrarInformacion() {
        cout << "Punto(" << x << ", " << y << ")" << endl;
    }
};

int main() {
    Punto p(10, 20);  // Llama al constructor con lista de inicialización
    p.mostrarInformacion();

    return 0;
}
```cpp
#include <iostream>
using namespace std;

class Persona {
private:
    string nombre;
    int edad;

public:
    // Constructor por defecto
    Persona() : nombre("Desconocido"), edad(0) {}

    // Constructor parametrizado
    Persona(string n, int e) : nombre(n), edad(e) {}

    // Constructor de copia
    Persona(const Persona& p) : nombre(p.nombre), edad(p.edad) {}

    // Constructor de movimiento
    Persona(Persona&& p) noexcept : nombre(move(p.nombre)), edad(p.edad) {
        p.edad = 0;
    }

    void mostrarInformacion() {
        cout << "Nombre: " << nombre << ", Edad: " << edad << endl;
    }
};

int main() {
    // Usando el constructor por defecto
    Persona p1;
    p1.mostrarInformacion();

    // Usando el constructor parametrizado
    Persona p2("Juan", 30);
    p2.mostrarInformacion();

    // Usando el constructor de copia
    Persona p3 = p2;
    p3.mostrarInformacion();

    // Usando el constructor de movimiento
    Persona p4 = move(p2);
    p4.mostrarInformacion();

    // Estado después del movimiento
    cout << "Después de mover, p2: ";
    p2.mostrarInformacion();

    return 0;
}
<---Ejemplo con Lista de Inicialización Result--->
<---Definición de Atributos Privados--->
```cpp
class Persona {
private:
    string nombre;
    int edad;

public:
    // Métodos públicos
};
<---Definición de Atributos Privados Result--->
<---Ejemplo de Getters--->
```cpp
class Persona {
private:
    string nombre;
    int edad;

public:
    // Constructor
    Persona(string n, int e) : nombre(n), edad(e) {}

    // Getter para el nombre
    string getNombre() const {
        return nombre;
    }

    // Getter para la edad
    int getEdad() const {
        return edad;
    }
};
<---Ejemplo de Getters Result--->
<---Ejemplo de Setters--->
```cpp
class Persona {
private:
    string nombre;
    int edad;

public:
    // Constructor
    Persona(string n, int e) : nombre(n), edad(e) {}

    // Setter para el nombre
    void setNombre(string n) {
        nombre = n;
    }

    // Setter para la edad
    void setEdad(int e) {
        if (e > 0) {  // Validación simple
            edad = e;
        } else {
            cout << "Edad no válida." << endl;
        }
    }

    // Getters
    string getNombre() const {
        return nombre;
    }

    int getEdad() const {
        return edad;
    }
};
<---Ejemplo de Setters Result--->
<---Ejemplo Completo--->
```cpp
#include <iostream>
using namespace std;

class Persona {
private:
    string nombre;
    int edad;

public:
    // Constructor
    Persona(string n, int e) : nombre(n), edad(e) {}

    // Setters
    void setNombre(string n) {
        nombre = n;
    }

    void setEdad(int e) {
        if (e > 0) {
            edad = e;
        } else {
            cout << "Edad no válida." << endl;
        }
    }

    // Getters
    string getNombre() const {
        return nombre;
    }

    int getEdad() const {
        return edad;
    }

    // Método para mostrar información
    void mostrarInformacion() const {
        cout << "Nombre: " << nombre << ", Edad: " << edad << endl;
    }
};

int main() {
    // Crear un objeto de la clase Persona
    Persona juan("Juan", 30);
    juan.mostrarInformacion();

    // Modificar los atributos usando setters
    juan.setNombre("Juan Perez");
    juan.setEdad(31);
    juan.mostrarInformacion();

    // Intentar establecer una edad no válida
    juan.setEdad(-5);
    juan.mostrarInformacion();

    // Acceder a los atributos usando getters
    cout << "Nombre: " << juan.getNombre() << endl;
    cout << "Edad: " << juan.getEdad() << endl;

    return 0;
}
<---Ejemplo Completo Result--->
<---Ejemplo Básico--->
```cpp
#include <iostream>
using namespace std;

class Punto {
private:
    int x, y;

public:
    // Constructor
    Punto(int x = 0, int y = 0) : x(x), y(y) {}

    // Función para establecer valores usando this
    void setXY(int x, int y) {
        this->x = x;  // Acceso a miembro de la clase
        this->y = y;  // Acceso a miembro de la clase
    }

    // Función para mostrar valores
    void mostrar() const {
        cout << "Punto(" << x << ", " << y << ")" << endl;
    }
};

int main() {
    Punto p(10, 20);
    p.mostrar();

    p.setXY(30, 40);
    p.mostrar();

    return 0;
}
<---Ejemplo Básico Result--->
<---Ejemplo con Setters y Getters--->
```cpp
#include <iostream>
using namespace std;

class Persona {
private:
    string nombre;
    int edad;

public:
    // Constructor
    Persona(string n, int e) : nombre(n), edad(e) {}

    // Getter para nombre
    string getNombre() const {
        return nombre;
    }

    // Setter para nombre
    void setNombre(string n) {
        nombre = n;
    }

    // Getter para edad
    int getEdad() const {
        return edad;
    }

    // Setter para edad con validación
    void setEdad(int e) {
        if (e > 0) {
            edad = e;
        } else {
            cout << "Edad no válida" << endl;
        }
    }

    // Método para mostrar información
    void mostrarInformacion() const {
        cout << "Nombre: " << nombre << ", Edad: " << edad << endl;
    }
};

int main() {
    Persona juan("Juan", 30);
    juan.mostrarInformacion();

    // Modificar atributos usando setters
    juan.setNombre("Juan Perez");
    juan.setEdad(31);
    juan.mostrarInformacion();

    // Intentar establecer una edad no válida
    juan.setEdad(-5);
    juan.mostrarInformacion();

    return 0;
}
<---Ejemplo con Setters y Getters Result--->
<---Ejemplo con Herencia--->
```cpp
#include <iostream>
using namespace std;

class Base {
public:
    // Constructor
    Base() {
        cout << "Constructor de Base" << endl;
    }

    // Destructor virtual
    virtual ~Base() {
        cout << "Destructor de Base" << endl;
    }
};

class Derivada : public Base {
public:
    // Constructor
    Derivada() {
        cout << "Constructor de Derivada" << endl;
    }

    // Destructor
    ~Derivada() {
        cout << "Destructor de Derivada" << endl;
    }
};

int main() {
    Base* obj = new Derivada(); // Crear objeto de clase derivada
    delete obj; // Llamar al destructor virtual

    return 0;
}
<---Ejemplo con Herencia Result--->
<---Sintaxis del Destructor--->
```cpp
class NombreClase {
public:
    // Constructor
    NombreClase();

    // Destructor
    ~NombreClase();

    // Otros métodos y atributos
};
```cpp
#include <iostream>
using namespace std;

class Persona {
public:
    string nombre;

    // Constructor
    Persona(string n) : nombre(n) {
        cout << "Constructor llamado para " << nombre << endl;
    }

    // Destructor
    ~Persona() {
        cout << "Destructor llamado para " << nombre << endl;
    }
};

int main() {
    Persona juan("Juan");
    {
        Persona maria("Maria");
    } // Destructor llamado para maria aquí

    cout << "Fin del main" << endl;
    return 0; // Destructor llamado para juan aquí
}
<---Sintaxis del Destructor Result--->
<---Ejemplo Básico de Destructor--->
```cpp
#include <iostream>
using namespace std;

class Persona {
public:
    string nombre;

    // Constructor
    Persona(string n) : nombre(n) {
        cout << "Constructor llamado para " << nombre << endl;
    }

    // Destructor
    ~Persona() {
        cout << "Destructor llamado para " << nombre << endl;
    }
};

int main() {
    Persona juan("Juan");
    {
        Persona maria("Maria");
    } // Destructor llamado para maria aquí

    cout << "Fin del main" << endl;
    return 0; // Destructor llamado para juan aquí
}
<---Ejemplo Básico de Destructor Result--->
<---Ejemplo con Recursos Dinámicos--->
```cpp
#include <iostream>
using namespace std;

class Array {
private:
    int* data;
    int size;

public:
    // Constructor
    Array(int s) : size(s) {
        data = new int[size]; // Asignar memoria dinámica
        cout << "Array de tamaño " << size << " creado." << endl;
    }

    // Destructor
    ~Array() {
        delete[] data; // Liberar memoria dinámica
        cout << "Array de tamaño " << size << " destruido." << endl;
    }

    // Método para establecer un valor en el array
    void setValue(int index, int value) {
        if (index >= 0 && index < size) {
            data[index] = value;
        }
    }

    // Método para obtener un valor del array
    int getValue(int index) const {
        if (index >= 0 && index < size) {
            return data[index];
        }
        return -1; // Valor de error
    }
};

int main() {
    Array arr(5);
    arr.setValue(0, 10);
    arr.setValue(1, 20);
    cout << "Valor en la posición 0: " << arr.getValue(0) << endl;
    cout << "Valor en la posición 1: " << arr.getValue(1) << endl;

    return 0;
}
<---Ejemplo con Recursos Dinámicos Result--->
<---Regla de Tres--->
```cpp
class Ejemplo {
private:
    int* data;

public:
    // Constructor
    Ejemplo(int size) {
        data = new int[size];
    }

    // Destructor
    ~Ejemplo() {
        delete[] data;
    }

    // Constructor de copia
    Ejemplo(const Ejemplo& other) {
        data = new int[other.size];
        // Copiar datos...
    }

    // Operador de asignación de copia
    Ejemplo& operator=(const Ejemplo& other) {
        if (this != &other) {
            delete[] data;
            data = new int[other.size];
            // Copiar datos...
        }
        return *this;
    }
};
<---Regla de Tres Result--->
<---Regla de Cinco--->
```cpp
class Ejemplo {
private:
    int* data;

public:
    // Constructor
    Ejemplo(int size) {
        data = new int[size];
    }

    // Destructor
    ~Ejemplo() {
        delete[] data;
    }

    // Constructor de copia
    Ejemplo(const Ejemplo& other) {
        data = new int[other.size];
        // Copiar datos...
    }

    // Operador de asignación de copia
    Ejemplo& operator=(const Ejemplo& other) {
        if (this != &other) {
            delete[] data;
            data = new int[other.size];
            // Copiar datos...
        }
        return *this;
    }

    // Constructor de movimiento
    Ejemplo(Ejemplo&& other) noexcept : data(other.data) {
        other.data = nullptr;
    }

    // Operador de asignación de movimiento
    Ejemplo& operator=(Ejemplo&& other) noexcept {
        if (this != &other) {
            delete[] data;
            data = other.data;
            other.data = nullptr;
        }
        return *this;
    }
};
<---Regla de Cinco Result--->
<---Ejemplo de Sobrecarga de Operadores--->
```cpp
#include <iostream>
using namespace std;

class Complejo {
private:
    double real;
    double imaginario;

public:
    // Constructor
    Complejo(double r = 0.0, double i = 0.0) : real(r), imaginario(i) {}

    // Sobrecarga del operador +
    Complejo operator+(const Complejo& c) const {
        return Complejo(real + c.real, imaginario + c.imaginario);
    }

    // Sobrecarga del operador <<
    friend ostream& operator<<(ostream& os, const Complejo& c) {
        os << "(" << c.real << " + " << c.imaginario << "i)";
        return os;
    }
};

int main() {
    Complejo c1(3.0, 4.0);
    Complejo c2(1.0, 2.0);

    Complejo c3 = c1 + c2;  // Usando la sobrecarga del operador +

    cout << "c1: " << c1 << endl;
    cout << "c2: " << c2 << endl;
    cout << "c3: " << c3 << endl;  // Usando la sobrecarga del operador <<

    return 0;
}
<---Ejemplo de Sobrecarga de Operadores Result--->
<---Ejemplo de Sobrecarga del Operador `*`--->
```cpp
#include <iostream>
using namespace std;

class Vector {
private:
    double x, y, z;

public:
    // Constructor
    Vector(double x, double y, double z) : x(x), y(y), z(z) {}

    // Sobrecarga del operador *
    Vector operator*(double escalar) const {
        return Vector(x * escalar, y * escalar, z * escalar);
    }

    // Sobrecarga del operador <<
    friend ostream& operator<<(ostream& os, const Vector& v) {
        os << "{" << v.x << ", " << v.y << ", " << v.z << "}";
        return os;
    }
};

int main() {
    Vector v1(1.0, 2.0, 3.0);
    Vector v2 = v1 * 2.0;

    cout << "v1: " << v1 << endl;
    cout << "v2: " << v2 << endl;

    return 0;
}
<---Ejemplo de Sobrecarga del Operador `*` Result--->
<---Ejemplo de Sobrecarga del Operador `==`--->
```cpp
#include <iostream>
using namespace std;

class Punto {
private:
    int x, y;

public:
    // Constructor
    Punto(int x = 0, int y = 0) : x(x), y(y) {}

    // Sobrecarga del operador ==
    bool operator==(const Punto& p) const {
        return (x == p.x && y == p.y);
    }

    // Sobrecarga del operador <<
    friend ostream& operator<<(ostream& os, const Punto& p) {
        os << "(" << p.x << ", " << p.y << ")";
        return os;
    }
};

int main() {
    Punto p1(1, 2);
    Punto p2(1, 2);
    Punto p3(3, 4);

    cout << "p1: " << p1 << endl;
    cout << "p2: " << p2 << endl;
    cout << "p3: " << p3 << endl;

    cout << "p1 == p2: " << (p1 == p2) << endl;
    cout << "p1 == p3: " << (p1 == p3) << endl;

    return 0;
}
<---Ejemplo de Sobrecarga del Operador `==` Result--->
<---Ejemplo de Sobrecarga del Operador `++`--->
```cpp
#include <iostream>
using namespace std;

class Contador {
private:
    int valor;

public:
    // Constructor
    Contador(int v = 0) : valor(v) {}

    // Sobrecarga del operador prefijo ++
    Contador& operator++() {
        ++valor;
        return *this;
    }

    // Sobrecarga del operador postfijo ++
    Contador operator++(int) {
        Contador temp = *this;
        ++valor;
        return temp;
    }

    // Sobrecarga del operador <<
    friend ostream& operator<<(ostream& os, const Contador& c) {
        os << c.valor;
        return os;
    }
};

int main() {
    Contador c(5);

    cout << "Valor inicial: " << c << endl;

    ++c;
    cout << "Después del prefijo ++: " << c << endl;

    c++;
    cout << "Después del postfijo ++: " << c << endl;

    return 0;
}
<---Ejemplo de Sobrecarga del Operador `++` Result--->
<---Ejemplo de Sobrecarga del Operador `[]`--->
```cpp
#include <iostream>
using namespace std;

class Array {
private:
    int* datos;
    int tamano;

public:
    // Constructor
    Array(int tamano) : tamano(tamano) {
        datos = new int[tamano];
        for (int i = 0; i < tamano; ++i) {
            datos[i] = 0;
        }
    }

    // Destructor
    ~Array() {
        delete[] datos;
    }

    // Sobrecarga del operador []
    int& operator[](int indice) {
        if (indice >= 0 && indice < tamano) {
            return datos[indice];
        }
        throw out_of_range("Índice fuera de rango");
    }

    // Sobrecarga del operador <<
    friend ostream& operator<<(ostream& os, const Array& arr) {
        os << "[";
        for (int i = 0; i < arr.tamano; ++i) {
            os << arr.datos[i];
            if (i < arr.tamano - 1) {
                os << ", ";
            }
        }
        os << "]";
        return os;
    }
};

int main() {
    Array arr(5);

    arr[0] = 10;
    arr[1] = 20;
    arr[2] = 30;

    cout << "Array: " << arr << endl;

    try {
        arr[5] = 50;  // Esto lanzará una excepción
    } catch (const out_of_range& e) {
        cout << e.what() << endl;
    }

    return 0;
}
<---Ejemplo de Sobrecarga del Operador `[]` Result--->
<---Ejemplo de Encadenamiento de Métodos--->
```cpp
#include <iostream>
using namespace std;

class Rectangulo {
private:
    int ancho, alto;

public:
    // Constructor
    Rectangulo(int ancho = 0, int alto = 0) : ancho(ancho), alto(alto) {}

    // Métodos para establecer valores con encadenamiento
    Rectangulo& setAncho(int ancho) {
        this->ancho = ancho;
        return *this;
    }

    Rectangulo& setAlto(int alto) {
        this->alto = alto;
        return *this;
    }

    // Función para mostrar valores
    void mostrar() const {
        cout << "Rectangulo(" << ancho << ", " << alto << ")" << endl;
    }
};

int main() {
    Rectangulo r;
    r.setAncho(10).setAlto(20);  // Encadenamiento de métodos
    r.mostrar();

    return 0;
}
<---Ejemplo de Encadenamiento de Métodos Result--->
<---Ejemplo con Función Constante--->
```cpp
#include <iostream>
using namespace std;

class Circulo {
private:
    double radio;

public:
    // Constructor
    Circulo(double radio = 0) : radio(radio) {}

    // Método constante
    double getRadio() const {
        return this->radio;  // `this` es un puntero a un objeto constante
    }

    // Método para establecer el radio
    void setRadio(double radio) {
        this->radio = radio;
    }

    // Función para mostrar el radio
    void mostrar() const {
        cout << "Circulo con radio: " << this->getRadio() << endl;
    }
};

int main() {
    Circulo c(5.0);
    c.mostrar();

    c.setRadio(10.0);
    c.mostrar();

    return 0;
}
<---Ejemplo con Función Constante Result--->
<---Ejemplo de Prevención de Auto-Asignación--->
```cpp
#include <iostream>
#include <cstring>
using namespace std;

class Cadena {
private:
    char* str;

public:
    // Constructor
    Cadena(const char* s) {
        str = new char[strlen(s) + 1];
        strcpy(str, s);
    }

    // Destructor
    ~Cadena() {
        delete[] str;
    }

    // Constructor de copia
    Cadena(const Cadena& other) {
        str = new char[strlen(other.str) + 1];
        strcpy(str, other.str);
    }

    // Operador de asignación sobrecargado
    Cadena& operator=(const Cadena& other) {
        if (this != &other) {  // Prevención de auto-asignación
            delete[] str;
            str = new char[strlen(other.str) + 1];
            strcpy(str, other.str);
        }
        return *this;
    }

    // Función para mostrar la cadena
    void mostrar() const {
        cout << "Cadena: " << str << endl;
    }
};

int main() {
    Cadena c1("Hola");
    Cadena c2("Mundo");

    c1.mostrar();
    c2.mostrar();

    c2 = c1;  // Usando el operador de asignación sobrecargado
    c2.mostrar();

    return 0;
}
<---Ejemplo de Prevención de Auto-Asignación Result--->
