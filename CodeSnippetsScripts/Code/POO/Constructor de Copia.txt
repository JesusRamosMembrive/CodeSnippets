<---EXPLANATION--->
### Programación Orientada a Objetos en C++: Clases y Objetos

La programación orientada a objetos (POO) es un paradigma de programación que utiliza "objetos" y sus interacciones para diseñar aplicaciones y programas. En C++, la POO es una característica central que permite organizar y estructurar el código de manera modular y reutilizable. Los dos conceptos fundamentales en la POO son las clases y los objetos.

#### Clases

Una clase en C++ es una plantilla o un molde que define los atributos y comportamientos de los objetos que se crean a partir de ella. Los atributos son variables que mantienen el estado del objeto, mientras que los comportamientos son funciones o métodos que definen lo que el objeto puede hacer.

##### Definición de una Clase

La sintaxis básica para definir una clase en C++ es la siguiente:

```cpp
class NombreClase {
public:
    // Atributos
    tipo_atributo nombre_atributo;

    // Métodos
    tipo_retorno nombre_metodo(parametros);

    // Otros componentes, como constructores, destructores, etc.
};
```

##### Ejemplo Básico de una Clase

```cpp
#include <iostream>
using namespace std;

class Persona {
public:
    // Atributos
    string nombre;
    int edad;

    // Métodos
    void saludar() {
        cout << "Hola, mi nombre es " << nombre << " y tengo " << edad << " años." << endl;
    }
};

int main() {
    // Crear un objeto de la clase Persona
    Persona juan;
    juan.nombre = "Juan";
    juan.edad = 30;

    // Llamar al método saludar
    juan.saludar();

    return 0;
}
```

En este ejemplo:
- `Persona` es una clase que tiene dos atributos (`nombre` y `edad`) y un método (`saludar`).
- `juan` es un objeto de la clase `Persona`.

#### Objetos

Un objeto es una instancia de una clase. Cada objeto tiene su propio estado (valores de los atributos) y puede usar los métodos definidos en la clase.

##### Creación de Objetos

Los objetos se crean declarando una variable del tipo de la clase:

```cpp
NombreClase nombre_objeto;
```

##### Ejemplo de Creación y Uso de Objetos

```cpp
#include <iostream>
using namespace std;

class Coche {
public:
    // Atributos
    string marca;
    string modelo;
    int anio;

    // Métodos
    void mostrarInformacion() {
        cout << "Marca: " << marca << ", Modelo: " << modelo << ", Año: " << anio << endl;
    }
};

int main() {
    // Crear objetos de la clase Coche
    Coche coche1;
    coche1.marca = "Toyota";
    coche1.modelo = "Corolla";
    coche1.anio = 2020;

    Coche coche2;
    coche2.marca = "Honda";
    coche2.modelo = "Civic";
    coche2.anio = 2019;

    // Llamar a los métodos de los objetos
    coche1.mostrarInformacion();
    coche2.mostrarInformacion();

    return 0;
}
```

En este ejemplo, `Coche` es una clase que define tres atributos y un método. Se crean dos objetos (`coche1` y `coche2`) y se llama al método `mostrarInformacion` para cada objeto.

#### Constructores y Destructores

Los constructores y destructores son funciones especiales que se utilizan para inicializar y limpiar objetos, respectivamente.

##### Constructores

Un constructor es una función que se llama automáticamente cuando se crea un objeto. Se utiliza para inicializar los atributos del objeto.

```cpp
class Persona {
public:
    string nombre;
    int edad;

    // Constructor
    Persona(string n, int e) {
        nombre = n;
        edad = e;
    }

    void saludar() {
        cout << "Hola, mi nombre es " << nombre << " y tengo " << edad << " años." << endl;
    }
};

int main() {
    // Crear un objeto de la clase Persona utilizando el constructor
    Persona juan("Juan", 30);
    juan.saludar();

    return 0;
}
```

##### Destructores

Un destructor es una función que se llama automáticamente cuando un objeto es destruido. Se utiliza para liberar recursos que el objeto haya adquirido durante su vida.

```cpp
class Persona {
public:
    string nombre;
    int edad;

    // Constructor
    Persona(string n, int e) {
        nombre = n;
        edad = e;
    }

    // Destructor
    ~Persona() {
        cout << "Destructor llamado para " << nombre << endl;
    }

    void saludar() {
        cout << "Hola, mi nombre es " << nombre << " y tengo " << edad << " años." << endl;
    }
};

int main() {
    // Crear un objeto de la clase Persona
    Persona juan("Juan", 30);
    juan.saludar();

    // El destructor se llamará automáticamente al final del alcance
    return 0;
}
```

#### Encapsulación

La encapsulación es un principio de la POO que restringe el acceso directo a los atributos de una clase. En lugar de eso, se proporcionan métodos públicos para acceder y modificar estos atributos.

##### Modificadores de Acceso

- **`public`:** Los miembros son accesibles desde cualquier parte del programa.
- **`private`:** Los miembros solo son accesibles desde dentro de la propia clase.
- **`protected`:** Los miembros son accesibles desde dentro de la clase y las clases derivadas.

```cpp
class Persona {
private:
    string nombre;
    int edad;

public:
    // Constructor
    Persona(string n, int e) : nombre(n), edad(e) {}

    // Métodos para acceder y modificar los atributos
    string getNombre() {
        return nombre;
    }

    void setNombre(string n) {
        nombre = n;
    }

    int getEdad() {
        return edad;
    }

    void setEdad(int e) {
        edad = e;
    }

    void saludar() {
        cout << "Hola, mi nombre es " << nombre << " y tengo " << edad << " años." << endl;
    }
};

int main() {
    Persona juan("Juan", 30);
    juan.saludar();

    juan.setEdad(31);
    cout << "Nueva edad de " << juan.getNombre() << ": " << juan.getEdad() << endl;

    return 0;
}
```

En este ejemplo, los atributos `nombre` y `edad` son privados, y se proporcionan métodos públicos para acceder y modificarlos.

### Conclusión

Las clases y objetos son los pilares de la programación orientada a objetos en C++. Las clases permiten definir plantillas para crear objetos, encapsulando datos y comportamientos relacionados. Los objetos son instancias de estas clases, y mediante el uso de constructores, destructores y modificadores de acceso, podemos gestionar y proteger eficazmente los datos dentro de nuestros programas. Con un entendimiento sólido de estos conceptos, los desarrolladores pueden crear aplicaciones más organizadas, modulares y mantenibles.
### Constructores en C++

Los constructores son funciones especiales de las clases en C++ que se utilizan para inicializar objetos. Un constructor tiene el mismo nombre que la clase y no tiene tipo de retorno, ni siquiera `void`. Los constructores pueden sobrecargarse, lo que significa que una clase puede tener más de un constructor con diferentes listas de parámetros.

#### Tipos de Constructores

1. **Constructor por Defecto**
2. **Constructor Parametrizado**
3. **Constructor de Copia**
4. **Constructor de Movimiento** (Introducido en C++11)

#### Constructor por Defecto

El constructor por defecto es un constructor que se llama automáticamente cuando se crea un objeto sin pasar argumentos. Si no se define explícitamente un constructor por defecto, el compilador genera uno implícitamente.

##### Ejemplo de Constructor por Defecto

```cpp
#include <iostream>
using namespace std;

class Persona {
public:
    string nombre;
    int edad;

    // Constructor por defecto
    Persona() {
        nombre = "Desconocido";
        edad = 0;
    }

    void mostrarInformacion() {
        cout << "Nombre: " << nombre << ", Edad: " << edad << endl;
    }
};

int main() {
    Persona p;  // Llama al constructor por defecto
    p.mostrarInformacion();

    return 0;
}
```

En este ejemplo, el constructor por defecto inicializa `nombre` a "Desconocido" y `edad` a 0.

#### Constructor Parametrizado

Un constructor parametrizado permite inicializar un objeto con valores específicos al momento de su creación.

##### Ejemplo de Constructor Parametrizado

```cpp
#include <iostream>
using namespace std;

class Persona {
public:
    string nombre;
    int edad;

    // Constructor parametrizado
    Persona(string n, int e) {
        nombre = n;
        edad = e;
    }

    void mostrarInformacion() {
        cout << "Nombre: " << nombre << ", Edad: " << edad << endl;
    }
};

int main() {
    Persona p("Juan", 30);  // Llama al constructor parametrizado
    p.mostrarInformacion();

    return 0;
}
```

En este ejemplo, el constructor parametrizado inicializa `nombre` y `edad` con los valores proporcionados.

#### Constructor de Copia

El constructor de copia se utiliza para crear un nuevo objeto como copia de un objeto existente. Se define tomando una referencia constante al objeto de la misma clase.

##### Ejemplo de Constructor de Copia

```cpp
#include <iostream>
using namespace std;

class Persona {
public:
    string nombre;
    int edad;

    // Constructor parametrizado
    Persona(string n, int e) {
        nombre = n;
        edad = e;
    }

    // Constructor de copia
    Persona(const Persona& p) {
        nombre = p.nombre;
        edad = p.edad;
    }

    void mostrarInformacion() {
        cout << "Nombre: " << nombre << ", Edad: " << edad << endl;
    }
};

int main() {
    Persona p1("Juan", 30);  // Llama al constructor parametrizado
    Persona p2 = p1;         // Llama al constructor de copia
    p2.mostrarInformacion();

    return 0;
}
```

En este ejemplo, el constructor de copia crea un nuevo objeto `p2` como una copia de `p1`.

#### Constructor de Movimiento (Introducido en C++11)

El constructor de movimiento se utiliza para transferir los recursos de un objeto a otro, evitando copias innecesarias. Se define tomando un rvalue reference al objeto de la misma clase.

##### Ejemplo de Constructor de Movimiento

```cpp
#include <iostream>
using namespace std;

class Persona {
public:
    string nombre;
    int edad;

    // Constructor parametrizado
    Persona(string n, int e) : nombre(n), edad(e) {}

    // Constructor de movimiento
    Persona(Persona&& p) noexcept : nombre(move(p.nombre)), edad(p.edad) {
        p.edad = 0; // Opcional: Dejar el objeto fuente en un estado válido
    }

    void mostrarInformacion() {
        cout << "Nombre: " << nombre << ", Edad: " << edad << endl;
    }
};

int main() {
    Persona p1("Juan", 30);  // Llama al constructor parametrizado
    Persona p2 = move(p1);   // Llama al constructor de movimiento
    p2.mostrarInformacion();

    // p1 está en un estado indefinido, pero válido
    cout << "Después de mover, p1: ";
    p1.mostrarInformacion();

    return 0;
}
```

En este ejemplo, el constructor de movimiento transfiere los recursos de `p1` a `p2`, evitando una copia completa.

#### Inicialización de Miembros (Lista de Inicialización)

Es una buena práctica inicializar los miembros de la clase en la lista de inicialización del constructor, especialmente para miembros constantes y referencias.

##### Ejemplo con Lista de Inicialización

```cpp
#include <iostream>
using namespace std;

class Punto {
public:
    const int x;
    const int y;

    // Constructor con lista de inicialización
    Punto(int a, int b) : x(a), y(b) {}

    void mostrarInformacion() {
        cout << "Punto(" << x << ", " << y << ")" << endl;
    }
};

int main() {
    Punto p(10, 20);  // Llama al constructor con lista de inicialización
    p.mostrarInformacion();

    return 0;
}
```

En este ejemplo, los miembros `x` y `y` se inicializan en la lista de inicialización del constructor.

#### Constructores Predeterminados por el Compilador

Si no se definen constructores, el compilador proporciona un constructor por defecto, un constructor de copia y un operador de asignación de copia. Estos constructores realizan inicializaciones y copias miembro a miembro.

### Ejemplo Completo con Diferentes Constructores

```cpp
#include <iostream>
using namespace std;

class Persona {
private:
    string nombre;
    int edad;

public:
    // Constructor por defecto
    Persona() : nombre("Desconocido"), edad(0) {}

    // Constructor parametrizado
    Persona(string n, int e) : nombre(n), edad(e) {}

    // Constructor de copia
    Persona(const Persona& p) : nombre(p.nombre), edad(p.edad) {}

    // Constructor de movimiento
    Persona(Persona&& p) noexcept : nombre(move(p.nombre)), edad(p.edad) {
        p.edad = 0;
    }

    void mostrarInformacion() {
        cout << "Nombre: " << nombre << ", Edad: " << edad << endl;
    }
};

int main() {
    // Usando el constructor por defecto
    Persona p1;
    p1.mostrarInformacion();

    // Usando el constructor parametrizado
    Persona p2("Juan", 30);
    p2.mostrarInformacion();

    // Usando el constructor de copia
    Persona p3 = p2;
    p3.mostrarInformacion();

    // Usando el constructor de movimiento
    Persona p4 = move(p2);
    p4.mostrarInformacion();

    // Estado después del movimiento
    cout << "Después de mover, p2: ";
    p2.mostrarInformacion();

    return 0;
}
```

En este ejemplo, la clase `Persona` define todos los tipos principales de constructores, y el programa demuestra cómo usarlos.

### Conclusión

Los constructores son fundamentales para la inicialización de objetos en C++. La capacidad de definir diferentes tipos de constructores (por defecto, parametrizados, de copia y de movimiento) proporciona flexibilidad y control sobre cómo se crean e inicializan los objetos. Utilizar correctamente estos constructores puede mejorar la eficiencia y la robustez del código, asegurando que los objetos se encuentren en estados válidos desde su creación.
### Setters y Getters en una Clase

Los setters y getters son métodos en una clase que se utilizan para controlar el acceso y la modificación de los atributos privados. Estos métodos ayudan a mantener el principio de encapsulación, permitiendo el acceso controlado a los datos de la clase y protegiendo la integridad de los atributos.

#### Encapsulación

La encapsulación es uno de los pilares de la programación orientada a objetos. Consiste en ocultar los detalles internos de una clase y proporcionar métodos públicos para acceder y modificar los datos. Esto mejora la seguridad y la integridad del estado del objeto.

##### Definición de Atributos Privados

En C++, los atributos de una clase se pueden declarar como privados utilizando el modificador de acceso `private`. Esto significa que estos atributos solo pueden ser accedidos y modificados desde dentro de la propia clase.

```cpp
class Persona {
private:
    string nombre;
    int edad;

public:
    // Métodos públicos
};
```

#### Métodos Getters

Los métodos getters se utilizan para acceder a los valores de los atributos privados. Generalmente, los getters son funciones constantes (`const`) porque no modifican el estado del objeto.

##### Ejemplo de Getters

```cpp
class Persona {
private:
    string nombre;
    int edad;

public:
    // Constructor
    Persona(string n, int e) : nombre(n), edad(e) {}

    // Getter para el nombre
    string getNombre() const {
        return nombre;
    }

    // Getter para la edad
    int getEdad() const {
        return edad;
    }
};
```

En este ejemplo, `getNombre` y `getEdad` son métodos getters que devuelven los valores de `nombre` y `edad`, respectivamente.

#### Métodos Setters

Los métodos setters se utilizan para modificar los valores de los atributos privados. Los setters permiten validar y controlar los datos antes de asignarlos a los atributos.

##### Ejemplo de Setters

```cpp
class Persona {
private:
    string nombre;
    int edad;

public:
    // Constructor
    Persona(string n, int e) : nombre(n), edad(e) {}

    // Setter para el nombre
    void setNombre(string n) {
        nombre = n;
    }

    // Setter para la edad
    void setEdad(int e) {
        if (e > 0) {  // Validación simple
            edad = e;
        } else {
            cout << "Edad no válida." << endl;
        }
    }

    // Getters
    string getNombre() const {
        return nombre;
    }

    int getEdad() const {
        return edad;
    }
};
```

En este ejemplo, `setNombre` y `setEdad` son métodos setters que permiten modificar los valores de `nombre` y `edad`, respectivamente. El setter `setEdad` incluye una validación para asegurarse de que la edad sea positiva.

#### Uso de Setters y Getters

Los setters y getters se utilizan en el programa principal para interactuar con los atributos privados de la clase.

##### Ejemplo Completo

```cpp
#include <iostream>
using namespace std;

class Persona {
private:
    string nombre;
    int edad;

public:
    // Constructor
    Persona(string n, int e) : nombre(n), edad(e) {}

    // Setters
    void setNombre(string n) {
        nombre = n;
    }

    void setEdad(int e) {
        if (e > 0) {
            edad = e;
        } else {
            cout << "Edad no válida." << endl;
        }
    }

    // Getters
    string getNombre() const {
        return nombre;
    }

    int getEdad() const {
        return edad;
    }

    // Método para mostrar información
    void mostrarInformacion() const {
        cout << "Nombre: " << nombre << ", Edad: " << edad << endl;
    }
};

int main() {
    // Crear un objeto de la clase Persona
    Persona juan("Juan", 30);
    juan.mostrarInformacion();

    // Modificar los atributos usando setters
    juan.setNombre("Juan Perez");
    juan.setEdad(31);
    juan.mostrarInformacion();

    // Intentar establecer una edad no válida
    juan.setEdad(-5);
    juan.mostrarInformacion();

    // Acceder a los atributos usando getters
    cout << "Nombre: " << juan.getNombre() << endl;
    cout << "Edad: " << juan.getEdad() << endl;

    return 0;
}
```

En este ejemplo, se crea un objeto `juan` de la clase `Persona`, se utilizan los setters para modificar sus atributos y los getters para acceder a ellos. La validación en el setter `setEdad` asegura que la edad no pueda establecerse en un valor no válido.

### Conclusión

Los setters y getters son herramientas esenciales en la programación orientada a objetos para implementar la encapsulación. Permiten controlar el acceso y la modificación de los atributos privados de una clase, asegurando que los datos se manejen de manera segura y consistente. Con el uso adecuado de setters y getters, se puede mejorar la robustez y mantenibilidad del código.
### Encapsulamiento en C++

El encapsulamiento es uno de los principios fundamentales de la programación orientada a objetos (POO). Este principio consiste en ocultar los detalles internos de la implementación de una clase y proporcionar una interfaz pública para interactuar con los objetos de esa clase. El encapsulamiento ayuda a proteger los datos y a mantener la integridad del estado del objeto, facilitando la modularidad y el mantenimiento del código.

#### Conceptos Clave del Encapsulamiento

1. **Acceso Controlado:** Solo los métodos permitidos pueden acceder o modificar los datos de un objeto.
2. **Ocultamiento de Información:** Los detalles internos de la implementación se ocultan al usuario.
3. **Interfaz Pública:** Se proporciona una interfaz clara y estable para interactuar con los datos del objeto.

#### Modificadores de Acceso

En C++, los modificadores de acceso se utilizan para controlar el nivel de acceso a los miembros de una clase. Existen tres modificadores de acceso principales:

1. **`public`:** Los miembros declarados como `public` son accesibles desde cualquier parte del programa.
2. **`private`:** Los miembros declarados como `private` solo son accesibles desde dentro de la propia clase.
3. **`protected`:** Los miembros declarados como `protected` son accesibles desde dentro de la clase y las clases derivadas.

##### Ejemplo Básico

```cpp
#include <iostream>
using namespace std;

class Ejemplo {
private:
    int datoPrivado; // Acceso privado

public:
    int datoPublico; // Acceso público

    // Constructor
    Ejemplo(int privado, int publico) : datoPrivado(privado), datoPublico(publico) {}

    // Método público para acceder al dato privado
    int getDatoPrivado() const {
        return datoPrivado;
    }

    // Método público para modificar el dato privado
    void setDatoPrivado(int valor) {
        datoPrivado = valor;
    }
};

int main() {
    Ejemplo obj(10, 20);

    // Acceso al dato público
    cout << "Dato público: " << obj.datoPublico << endl;

    // Acceso al dato privado a través de métodos públicos
    cout << "Dato privado: " << obj.getDatoPrivado() << endl;
    obj.setDatoPrivado(30);
    cout << "Dato privado modificado: " << obj.getDatoPrivado() << endl;

    return 0;
}
```

En este ejemplo, `datoPrivado` es un miembro privado y solo puede ser accedido y modificado a través de los métodos públicos `getDatoPrivado` y `setDatoPrivado`. `datoPublico` es un miembro público y puede ser accedido directamente.

#### Beneficios del Encapsulamiento

1. **Protección de Datos:** Los datos internos de un objeto están protegidos contra modificaciones indebidas.
2. **Mantenimiento:** Los detalles de implementación pueden cambiar sin afectar a los usuarios de la clase, siempre y cuando la interfaz pública permanezca constante.
3. **Modularidad:** Facilita la división del programa en módulos manejables y comprensibles.
4. **Reusabilidad:** Las clases encapsuladas pueden ser reutilizadas fácilmente en diferentes partes de un programa o en otros proyectos.

#### Encapsulamiento y Setters/Getters

Los setters y getters son métodos que proporcionan un acceso controlado a los atributos privados de una clase. A través de estos métodos, se puede aplicar lógica adicional para validar o transformar los datos antes de acceder o modificar los atributos.

##### Ejemplo con Setters y Getters

```cpp
#include <iostream>
using namespace std;

class Persona {
private:
    string nombre;
    int edad;

public:
    // Constructor
    Persona(string n, int e) : nombre(n), edad(e) {}

    // Getter para nombre
    string getNombre() const {
        return nombre;
    }

    // Setter para nombre
    void setNombre(string n) {
        nombre = n;
    }

    // Getter para edad
    int getEdad() const {
        return edad;
    }

    // Setter para edad con validación
    void setEdad(int e) {
        if (e > 0) {
            edad = e;
        } else {
            cout << "Edad no válida" << endl;
        }
    }

    // Método para mostrar información
    void mostrarInformacion() const {
        cout << "Nombre: " << nombre << ", Edad: " << edad << endl;
    }
};

int main() {
    Persona juan("Juan", 30);
    juan.mostrarInformacion();

    // Modificar atributos usando setters
    juan.setNombre("Juan Perez");
    juan.setEdad(31);
    juan.mostrarInformacion();

    // Intentar establecer una edad no válida
    juan.setEdad(-5);
    juan.mostrarInformacion();

    return 0;
}
```

En este ejemplo, `setNombre` y `setEdad` son métodos setters que permiten modificar los atributos privados `nombre` y `edad`. El método `setEdad` incluye una validación para asegurarse de que la edad sea positiva.

#### Encapsulamiento y Herencia

El encapsulamiento también juega un papel importante en la herencia. Los miembros `protected` pueden ser accedidos en clases derivadas, mientras que los miembros `private` no pueden ser accedidos directamente.

##### Ejemplo con Herencia

```cpp
#include <iostream>
using namespace std;

class Base {
private:
    int datoPrivado;

protected:
    int datoProtegido;

public:
    int datoPublico;

    Base(int priv, int prot, int pub) : datoPrivado(priv), datoProtegido(prot), datoPublico(pub) {}

    int getDatoPrivado() const {
        return datoPrivado;
    }

    int getDatoProtegido() const {
        return datoProtegido;
    }
};

class Derivada : public Base {
public:
    Derivada(int priv, int prot, int pub) : Base(priv, prot, pub) {}

    void mostrarDatos() {
        // cout << "Dato privado: " << getDatoPrivado() << endl; // No se puede acceder directamente
        cout << "Dato protegido: " << getDatoProtegido() << endl;
        cout << "Dato público: " << datoPublico << endl;
    }
};

int main() {
    Derivada obj(1, 2, 3);
    obj.mostrarDatos();

    return 0;
}
```

En este ejemplo, la clase `Derivada` hereda de la clase `Base`. Puede acceder al miembro `datoProtegido` a través de un método protegido en la clase base, pero no puede acceder directamente al miembro `datoPrivado`.

### Conclusión

El encapsulamiento es una técnica fundamental en la programación orientada a objetos que mejora la seguridad, la modularidad y la mantenibilidad del código. Al utilizar modificadores de acceso como `private`, `protected` y `public`, se puede controlar cómo se accede y modifica el estado interno de los objetos. Los setters y getters son herramientas esenciales para implementar el encapsulamiento, proporcionando un acceso controlado a los atributos privados. Con una comprensión sólida del encapsulamiento, los desarrolladores pueden crear clases robustas y seguras que faciliten el desarrollo de software de alta calidad.
### Destructores en C++

Un destructor es una función miembro especial de una clase que se llama automáticamente cuando un objeto de esa clase se destruye. Los destructores se utilizan para liberar recursos que el objeto pueda haber adquirido durante su vida, como memoria dinámica, archivos abiertos, o conexiones de red. El uso adecuado de destructores asegura que los recursos se gestionen de manera correcta, evitando fugas de memoria y otros problemas.

#### Características del Destructor

1. **Mismo Nombre que la Clase:** El destructor tiene el mismo nombre que la clase, precedido por un tilde (`~`).
2. **Sin Parámetros:** Un destructor no toma parámetros ni tiene un tipo de retorno.
3. **Automático:** Se llama automáticamente cuando un objeto sale de alcance o se elimina.
4. **Único:** Una clase puede tener solo un destructor.

##### Sintaxis del Destructor

```cpp
class NombreClase {
public:
    // Constructor
    NombreClase();

    // Destructor
    ~NombreClase();

    // Otros métodos y atributos
};
```

##### Ejemplo Básico de Destructor

```cpp
#include <iostream>
using namespace std;

class Persona {
public:
    string nombre;

    // Constructor
    Persona(string n) : nombre(n) {
        cout << "Constructor llamado para " << nombre << endl;
    }

    // Destructor
    ~Persona() {
        cout << "Destructor llamado para " << nombre << endl;
    }
};

int main() {
    Persona juan("Juan");
    {
        Persona maria("Maria");
    } // Destructor llamado para maria aquí

    cout << "Fin del main" << endl;
    return 0; // Destructor llamado para juan aquí
}
```

En este ejemplo, el destructor se llama automáticamente cuando los objetos `juan` y `maria` salen de su alcance.

#### Destructores y Recursos Dinámicos

Los destructores son especialmente importantes cuando una clase maneja recursos dinámicos, como memoria asignada dinámicamente, archivos, o conexiones de red. El destructor asegura que estos recursos se liberen correctamente cuando el objeto ya no se necesita.

##### Ejemplo con Recursos Dinámicos

```cpp
#include <iostream>
using namespace std;

class Array {
private:
    int* data;
    int size;

public:
    // Constructor
    Array(int s) : size(s) {
        data = new int[size]; // Asignar memoria dinámica
        cout << "Array de tamaño " << size << " creado." << endl;
    }

    // Destructor
    ~Array() {
        delete[] data; // Liberar memoria dinámica
        cout << "Array de tamaño " << size << " destruido." << endl;
    }

    // Método para establecer un valor en el array
    void setValue(int index, int value) {
        if (index >= 0 && index < size) {
            data[index] = value;
        }
    }

    // Método para obtener un valor del array
    int getValue(int index) const {
        if (index >= 0 && index < size) {
            return data[index];
        }
        return -1; // Valor de error
    }
};

int main() {
    Array arr(5);
    arr.setValue(0, 10);
    arr.setValue(1, 20);
    cout << "Valor en la posición 0: " << arr.getValue(0) << endl;
    cout << "Valor en la posición 1: " << arr.getValue(1) << endl;

    return 0;
}
```

En este ejemplo, el destructor de la clase `Array` se asegura de liberar la memoria asignada dinámicamente cuando el objeto `arr` se destruye.

#### Destructores en Clases Derivadas

En una jerarquía de herencia, los destructores de las clases base y derivadas se llaman en el orden correcto. Si una clase base tiene un destructor virtual, asegura que el destructor de la clase derivada se llame correctamente cuando se elimina un objeto a través de un puntero a la clase base.

##### Ejemplo con Herencia

```cpp
#include <iostream>
using namespace std;

class Base {
public:
    // Constructor
    Base() {
        cout << "Constructor de Base" << endl;
    }

    // Destructor virtual
    virtual ~Base() {
        cout << "Destructor de Base" << endl;
    }
};

class Derivada : public Base {
public:
    // Constructor
    Derivada() {
        cout << "Constructor de Derivada" << endl;
    }

    // Destructor
    ~Derivada() {
        cout << "Destructor de Derivada" << endl;
    }
};

int main() {
    Base* obj = new Derivada(); // Crear objeto de clase derivada
    delete obj; // Llamar al destructor virtual

    return 0;
}
```

En este ejemplo, el destructor de `Base` es virtual, asegurando que el destructor de `Derivada` se llame correctamente cuando el objeto se elimina a través de un puntero a la clase base.

#### Regla de Tres, Cinco y Cero

La "regla de tres" establece que si una clase necesita un destructor explícito, probablemente también necesite un constructor de copia y un operador de asignación de copia. La "regla de cinco" extiende esto a las operaciones de movimiento en C++11 y posteriores. La "regla de cero" sugiere usar tipos RAII (Resource Acquisition Is Initialization) para manejar recursos automáticamente, evitando la necesidad de destructores personalizados, constructores de copia, y operadores de asignación.

##### Regla de Tres

```cpp
class Ejemplo {
private:
    int* data;

public:
    // Constructor
    Ejemplo(int size) {
        data = new int[size];
    }

    // Destructor
    ~Ejemplo() {
        delete[] data;
    }

    // Constructor de copia
    Ejemplo(const Ejemplo& other) {
        data = new int[other.size];
        // Copiar datos...
    }

    // Operador de asignación de copia
    Ejemplo& operator=(const Ejemplo& other) {
        if (this != &other) {
            delete[] data;
            data = new int[other.size];
            // Copiar datos...
        }
        return *this;
    }
};
```

##### Regla de Cinco

```cpp
class Ejemplo {
private:
    int* data;

public:
    // Constructor
    Ejemplo(int size) {
        data = new int[size];
    }

    // Destructor
    ~Ejemplo() {
        delete[] data;
    }

    // Constructor de copia
    Ejemplo(const Ejemplo& other) {
        data = new int[other.size];
        // Copiar datos...
    }

    // Operador de asignación de copia
    Ejemplo& operator=(const Ejemplo& other) {
        if (this != &other) {
            delete[] data;
            data = new int[other.size];
            // Copiar datos...
        }
        return *this;
    }

    // Constructor de movimiento
    Ejemplo(Ejemplo&& other) noexcept : data(other.data) {
        other.data = nullptr;
    }

    // Operador de asignación de movimiento
    Ejemplo& operator=(Ejemplo&& other) noexcept {
        if (this != &other) {
            delete[] data;
            data = other.data;
            other.data = nullptr;
        }
        return *this;
    }
};
```

### Conclusión

Los destructores son una parte esencial de la administración de recursos en C++. Aseguran que los recursos adquiridos por un objeto se liberen adecuadamente cuando el objeto ya no se necesita. Entender cómo y cuándo implementar destructores, junto con las reglas de tres, cinco y cero, permite a los desarrolladores escribir código más seguro y eficiente, gestionando correctamente la memoria y otros recursos.
### Sobrecarga de Operadores en C++

La sobrecarga de operadores es una característica de C++ que permite a los programadores definir o alterar el comportamiento de los operadores para tipos de datos definidos por el usuario (clases). Esto hace que los objetos de las clases puedan ser utilizados de manera similar a los tipos de datos integrados, mejorando la legibilidad y usabilidad del código.

#### Fundamentos de la Sobrecarga de Operadores

1. **Definición:** La sobrecarga de operadores permite redefinir la funcionalidad de los operadores (como +, -, *, /, etc.) para que funcionen con objetos de clases definidas por el usuario.
2. **Sintaxis:** Se utiliza la palabra clave `operator` seguida del operador que se desea sobrecargar.
3. **Limitaciones:** No todos los operadores pueden ser sobrecargados, y no se pueden cambiar la precedencia, la asociatividad, o el número de operandos de un operador.

##### Ejemplo de Sobrecarga de Operadores

```cpp
#include <iostream>
using namespace std;

class Complejo {
private:
    double real;
    double imaginario;

public:
    // Constructor
    Complejo(double r = 0.0, double i = 0.0) : real(r), imaginario(i) {}

    // Sobrecarga del operador +
    Complejo operator+(const Complejo& c) const {
        return Complejo(real + c.real, imaginario + c.imaginario);
    }

    // Sobrecarga del operador <<
    friend ostream& operator<<(ostream& os, const Complejo& c) {
        os << "(" << c.real << " + " << c.imaginario << "i)";
        return os;
    }
};

int main() {
    Complejo c1(3.0, 4.0);
    Complejo c2(1.0, 2.0);

    Complejo c3 = c1 + c2;  // Usando la sobrecarga del operador +

    cout << "c1: " << c1 << endl;
    cout << "c2: " << c2 << endl;
    cout << "c3: " << c3 << endl;  // Usando la sobrecarga del operador <<

    return 0;
}
```

En este ejemplo:
- Se sobrecarga el operador `+` para la clase `Complejo`, permitiendo sumar dos objetos `Complejo`.
- Se sobrecarga el operador `<<` para permitir la salida de objetos `Complejo` usando `cout`.

#### Sobrecarga de Operadores Aritméticos

Los operadores aritméticos como `+`, `-`, `*`, `/`, `%`, etc., se pueden sobrecargar para realizar operaciones específicas con objetos de clases.

##### Ejemplo de Sobrecarga del Operador `*`

```cpp
#include <iostream>
using namespace std;

class Vector {
private:
    double x, y, z;

public:
    // Constructor
    Vector(double x, double y, double z) : x(x), y(y), z(z) {}

    // Sobrecarga del operador *
    Vector operator*(double escalar) const {
        return Vector(x * escalar, y * escalar, z * escalar);
    }

    // Sobrecarga del operador <<
    friend ostream& operator<<(ostream& os, const Vector& v) {
        os << "{" << v.x << ", " << v.y << ", " << v.z << "}";
        return os;
    }
};

int main() {
    Vector v1(1.0, 2.0, 3.0);
    Vector v2 = v1 * 2.0;

    cout << "v1: " << v1 << endl;
    cout << "v2: " << v2 << endl;

    return 0;
}
```

En este ejemplo, se sobrecarga el operador `*` para multiplicar un objeto `Vector` por un escalar.

#### Sobrecarga de Operadores de Comparación

Los operadores de comparación como `==`, `!=`, `<`, `>`, `<=`, `>=` se pueden sobrecargar para comparar objetos de clases.

##### Ejemplo de Sobrecarga del Operador `==`

```cpp
#include <iostream>
using namespace std;

class Punto {
private:
    int x, y;

public:
    // Constructor
    Punto(int x = 0, int y = 0) : x(x), y(y) {}

    // Sobrecarga del operador ==
    bool operator==(const Punto& p) const {
        return (x == p.x && y == p.y);
    }

    // Sobrecarga del operador <<
    friend ostream& operator<<(ostream& os, const Punto& p) {
        os << "(" << p.x << ", " << p.y << ")";
        return os;
    }
};

int main() {
    Punto p1(1, 2);
    Punto p2(1, 2);
    Punto p3(3, 4);

    cout << "p1: " << p1 << endl;
    cout << "p2: " << p2 << endl;
    cout << "p3: " << p3 << endl;

    cout << "p1 == p2: " << (p1 == p2) << endl;
    cout << "p1 == p3: " << (p1 == p3) << endl;

    return 0;
}
```

En este ejemplo, se sobrecarga el operador `==` para comparar dos objetos `Punto`.

#### Sobrecarga de Operadores de Incremento y Decremento

Los operadores de incremento (`++`) y decremento (`--`) se pueden sobrecargar tanto en su forma prefija como postfija.

##### Ejemplo de Sobrecarga del Operador `++`

```cpp
#include <iostream>
using namespace std;

class Contador {
private:
    int valor;

public:
    // Constructor
    Contador(int v = 0) : valor(v) {}

    // Sobrecarga del operador prefijo ++
    Contador& operator++() {
        ++valor;
        return *this;
    }

    // Sobrecarga del operador postfijo ++
    Contador operator++(int) {
        Contador temp = *this;
        ++valor;
        return temp;
    }

    // Sobrecarga del operador <<
    friend ostream& operator<<(ostream& os, const Contador& c) {
        os << c.valor;
        return os;
    }
};

int main() {
    Contador c(5);

    cout << "Valor inicial: " << c << endl;

    ++c;
    cout << "Después del prefijo ++: " << c << endl;

    c++;
    cout << "Después del postfijo ++: " << c << endl;

    return 0;
}
```

En este ejemplo, se sobrecargan tanto la forma prefija como postfija del operador `++` para la clase `Contador`.

#### Sobrecarga de Operadores de Acceso

Los operadores de acceso como `[]`, `->`, `*`, `()` se pueden sobrecargar para proporcionar comportamientos personalizados.

##### Ejemplo de Sobrecarga del Operador `[]`

```cpp
#include <iostream>
using namespace std;

class Array {
private:
    int* datos;
    int tamano;

public:
    // Constructor
    Array(int tamano) : tamano(tamano) {
        datos = new int[tamano];
        for (int i = 0; i < tamano; ++i) {
            datos[i] = 0;
        }
    }

    // Destructor
    ~Array() {
        delete[] datos;
    }

    // Sobrecarga del operador []
    int& operator[](int indice) {
        if (indice >= 0 && indice < tamano) {
            return datos[indice];
        }
        throw out_of_range("Índice fuera de rango");
    }

    // Sobrecarga del operador <<
    friend ostream& operator<<(ostream& os, const Array& arr) {
        os << "[";
        for (int i = 0; i < arr.tamano; ++i) {
            os << arr.datos[i];
            if (i < arr.tamano - 1) {
                os << ", ";
            }
        }
        os << "]";
        return os;
    }
};

int main() {
    Array arr(5);

    arr[0] = 10;
    arr[1] = 20;
    arr[2] = 30;

    cout << "Array: " << arr << endl;

    try {
        arr[5] = 50;  // Esto lanzará una excepción
    } catch (const out_of_range& e) {
        cout << e.what() << endl;
    }

    return 0;
}
```

En este ejemplo, se sobrecarga el operador `[]` para permitir el acceso a los elementos de un objeto `Array`.

### Conclusión

La sobrecarga de operadores en C++ permite definir cómo los operadores deben comportarse con los objetos de tipos definidos por el usuario. Esto facilita el uso intuitivo de estos objetos y mejora la legibilidad del código. Sin embargo, es importante usar la sobrecarga de operadores de manera adecuada y clara, evitando abusos que puedan llevar a un código confuso o difícil de mantener. Con una comprensión sólida de la sobrecarga de operadores, los desarrolladores pueden crear clases más poderosas y flexibles en C++.
### Destructor en C++

En la programación orientada a objetos en C++, un destructor es una función especial que se llama automáticamente cuando un objeto de la clase sale del alcance o se elimina. Los destructores se utilizan principalmente para liberar recursos que el objeto pueda haber adquirido durante su ciclo de vida, como memoria dinámica, archivos abiertos, conexiones de red, etc.

#### Características del Destructor

1. **Mismo Nombre que la Clase:** El destructor tiene el mismo nombre que la clase, precedido por un tilde (`~`).
2. **Sin Parámetros ni Tipo de Retorno:** Un destructor no toma parámetros ni tiene un tipo de retorno.
3. **Automático:** Se llama automáticamente cuando el objeto sale del alcance o se elimina.

##### Sintaxis del Destructor

```cpp
class NombreClase {
public:
    // Constructor
    NombreClase();

    // Destructor
    ~NombreClase();

    // Otros métodos y atributos
};
```

#### Ejemplo Básico de Destructor

```cpp
#include <iostream>
using namespace std;

class Persona {
public:
    string nombre;

    // Constructor
    Persona(string n) : nombre(n) {
        cout << "Constructor llamado para " << nombre << endl;
    }

    // Destructor
    ~Persona() {
        cout << "Destructor llamado para " << nombre << endl;
    }
};

int main() {
    Persona juan("Juan");
    {
        Persona maria("Maria");
    } // Destructor llamado para maria aquí

    cout << "Fin del main" << endl;
    return 0; // Destructor llamado para juan aquí
}
```

En este ejemplo, el destructor se llama automáticamente cuando los objetos `juan` y `maria` salen de su alcance.

#### Destructores y Recursos Dinámicos

Los destructores son especialmente importantes cuando una clase maneja recursos dinámicos, como memoria asignada dinámicamente, archivos o conexiones de red. El destructor asegura que estos recursos se liberen correctamente cuando el objeto ya no se necesita.

##### Ejemplo con Recursos Dinámicos

```cpp
#include <iostream>
using namespace std;

class Array {
private:
    int* data;
    int size;

public:
    // Constructor
    Array(int s) : size(s) {
        data = new int[size]; // Asignar memoria dinámica
        cout << "Array de tamaño " << size << " creado." << endl;
    }

    // Destructor
    ~Array() {
        delete[] data; // Liberar memoria dinámica
        cout << "Array de tamaño " << size << " destruido." << endl;
    }

    // Método para establecer un valor en el array
    void setValue(int index, int value) {
        if (index >= 0 && index < size) {
            data[index] = value;
        }
    }

    // Método para obtener un valor del array
    int getValue(int index) const {
        if (index >= 0 && index < size) {
            return data[index];
        }
        return -1; // Valor de error
    }
};

int main() {
    Array arr(5);
    arr.setValue(0, 10);
    arr.setValue(1, 20);
    cout << "Valor en la posición 0: " << arr.getValue(0) << endl;
    cout << "Valor en la posición 1: " << arr.getValue(1) << endl;

    return 0;
}
```

En este ejemplo, el destructor de la clase `Array` se asegura de liberar la memoria asignada dinámicamente cuando el objeto `arr` se destruye.

#### Destructores en Clases Derivadas

En una jerarquía de herencia, los destructores de las clases base y derivadas se llaman en el orden correcto. Si una clase base tiene un destructor virtual, asegura que el destructor de la clase derivada se llame correctamente cuando se elimina un objeto a través de un puntero a la clase base.

##### Ejemplo con Herencia

```cpp
#include <iostream>
using namespace std;

class Base {
public:
    // Constructor
    Base() {
        cout << "Constructor de Base" << endl;
    }

    // Destructor virtual
    virtual ~Base() {
        cout << "Destructor de Base" << endl;
    }
};

class Derivada : public Base {
public:
    // Constructor
    Derivada() {
        cout << "Constructor de Derivada" << endl;
    }

    // Destructor
    ~Derivada() {
        cout << "Destructor de Derivada" << endl;
    }
};

int main() {
    Base* obj = new Derivada(); // Crear objeto de clase derivada
    delete obj; // Llamar al destructor virtual

    return 0;
}
```

En este ejemplo, el destructor de `Base` es virtual, asegurando que el destructor de `Derivada` se llame correctamente cuando el objeto se elimina a través de un puntero a la clase base.

#### Regla de Tres, Cinco y Cero

La "regla de tres" establece que si una clase necesita un destructor explícito, probablemente también necesite un constructor de copia y un operador de asignación de copia. La "regla de cinco" extiende esto a las operaciones de movimiento en C++11 y posteriores. La "regla de cero" sugiere usar tipos RAII (Resource Acquisition Is Initialization) para manejar recursos automáticamente, evitando la necesidad de destructores personalizados, constructores de copia y operadores de asignación.

##### Regla de Tres

```cpp
class Ejemplo {
private:
    int* data;

public:
    // Constructor
    Ejemplo(int size) {
        data = new int[size];
    }

    // Destructor
    ~Ejemplo() {
        delete[] data;
    }

    // Constructor de copia
    Ejemplo(const Ejemplo& other) {
        data = new int[other.size];
        // Copiar datos...
    }

    // Operador de asignación de copia
    Ejemplo& operator=(const Ejemplo& other) {
        if (this != &other) {
            delete[] data;
            data = new int[other.size];
            // Copiar datos...
        }
        return *this;
    }
};
```

##### Regla de Cinco

```cpp
class Ejemplo {
private:
    int* data;

public:
    // Constructor
    Ejemplo(int size) {
        data = new int[size];
    }

    // Destructor
    ~Ejemplo() {
        delete[] data;
    }

    // Constructor de copia
    Ejemplo(const Ejemplo& other) {
        data = new int[other.size];
        // Copiar datos...
    }

    // Operador de asignación de copia
    Ejemplo& operator=(const Ejemplo& other) {
        if (this != &other) {
            delete[] data;
            data = new int[other.size];
            // Copiar datos...
        }
        return *this;
    }

    // Constructor de movimiento
    Ejemplo(Ejemplo&& other) noexcept : data(other.data) {
        other.data = nullptr;
    }

    // Operador de asignación de movimiento
    Ejemplo& operator=(Ejemplo&& other) noexcept {
        if (this != &other) {
            delete[] data;
            data = other.data;
            other.data = nullptr;
        }
        return *this;
    }
};
```

### Conclusión

Los destructores son una parte esencial de la administración de recursos en C++. Aseguran que los recursos adquiridos por un objeto se liberen adecuadamente cuando el objeto ya no se necesita. Entender cómo y cuándo implementar destructores, junto con las reglas de tres, cinco y cero, permite a los desarrolladores escribir código más seguro y eficiente, gestionando correctamente la memoria y otros recursos.
### Sobrecarga de Operadores en C++

La sobrecarga de operadores es una característica de C++ que permite a los programadores definir o modificar el comportamiento de los operadores para tipos de datos definidos por el usuario (clases). Esto hace que los objetos de estas clases puedan ser utilizados de manera similar a los tipos de datos integrados, mejorando la legibilidad y usabilidad del código.

#### Fundamentos de la Sobrecarga de Operadores

1. **Definición:** La sobrecarga de operadores permite redefinir la funcionalidad de los operadores (como +, -, *, /, etc.) para que funcionen con objetos de clases definidas por el usuario.
2. **Sintaxis:** Se utiliza la palabra clave `operator` seguida del operador que se desea sobrecargar.
3. **Limitaciones:** No todos los operadores pueden ser sobrecargados, y no se pueden cambiar la precedencia, la asociatividad, o el número de operandos de un operador.

##### Ejemplo de Sobrecarga de Operadores

```cpp
#include <iostream>
using namespace std;

class Complejo {
private:
    double real;
    double imaginario;

public:
    // Constructor
    Complejo(double r = 0.0, double i = 0.0) : real(r), imaginario(i) {}

    // Sobrecarga del operador +
    Complejo operator+(const Complejo& c) const {
        return Complejo(real + c.real, imaginario + c.imaginario);
    }

    // Sobrecarga del operador <<
    friend ostream& operator<<(ostream& os, const Complejo& c) {
        os << "(" << c.real << " + " << c.imaginario << "i)";
        return os;
    }
};

int main() {
    Complejo c1(3.0, 4.0);
    Complejo c2(1.0, 2.0);

    Complejo c3 = c1 + c2;  // Usando la sobrecarga del operador +

    cout << "c1: " << c1 << endl;
    cout << "c2: " << c2 << endl;
    cout << "c3: " << c3 << endl;  // Usando la sobrecarga del operador <<

    return 0;
}
```

En este ejemplo:
- Se sobrecarga el operador `+` para la clase `Complejo`, permitiendo sumar dos objetos `Complejo`.
- Se sobrecarga el operador `<<` para permitir la salida de objetos `Complejo` usando `cout`.

#### Sobrecarga de Operadores Aritméticos

Los operadores aritméticos como `+`, `-`, `*`, `/`, `%`, etc., se pueden sobrecargar para realizar operaciones específicas con objetos de clases.

##### Ejemplo de Sobrecarga del Operador `*`

```cpp
#include <iostream>
using namespace std;

class Vector {
private:
    double x, y, z;

public:
    // Constructor
    Vector(double x, double y, double z) : x(x), y(y), z(z) {}

    // Sobrecarga del operador *
    Vector operator*(double escalar) const {
        return Vector(x * escalar, y * escalar, z * escalar);
    }

    // Sobrecarga del operador <<
    friend ostream& operator<<(ostream& os, const Vector& v) {
        os << "{" << v.x << ", " << v.y << ", " << v.z << "}";
        return os;
    }
};

int main() {
    Vector v1(1.0, 2.0, 3.0);
    Vector v2 = v1 * 2.0;

    cout << "v1: " << v1 << endl;
    cout << "v2: " << v2 << endl;

    return 0;
}
```

En este ejemplo, se sobrecarga el operador `*` para multiplicar un objeto `Vector` por un escalar.

#### Sobrecarga de Operadores de Comparación

Los operadores de comparación como `==`, `!=`, `<`, `>`, `<=`, `>=` se pueden sobrecargar para comparar objetos de clases.

##### Ejemplo de Sobrecarga del Operador `==`

```cpp
#include <iostream>
using namespace std;

class Punto {
private:
    int x, y;

public:
    // Constructor
    Punto(int x = 0, int y = 0) : x(x), y(y) {}

    // Sobrecarga del operador ==
    bool operator==(const Punto& p) const {
        return (x == p.x && y == p.y);
    }

    // Sobrecarga del operador <<
    friend ostream& operator<<(ostream& os, const Punto& p) {
        os << "(" << p.x << ", " << p.y << ")";
        return os;
    }
};

int main() {
    Punto p1(1, 2);
    Punto p2(1, 2);
    Punto p3(3, 4);

    cout << "p1: " << p1 << endl;
    cout << "p2: " << p2 << endl;
    cout << "p3: " << p3 << endl;

    cout << "p1 == p2: " << (p1 == p2) << endl;
    cout << "p1 == p3: " << (p1 == p3) << endl;

    return 0;
}
```

En este ejemplo, se sobrecarga el operador `==` para comparar dos objetos `Punto`.

#### Sobrecarga de Operadores de Incremento y Decremento

Los operadores de incremento (`++`) y decremento (`--`) se pueden sobrecargar tanto en su forma prefija como postfija.

##### Ejemplo de Sobrecarga del Operador `++`

```cpp
#include <iostream>
using namespace std;

class Contador {
private:
    int valor;

public:
    // Constructor
    Contador(int v = 0) : valor(v) {}

    // Sobrecarga del operador prefijo ++
    Contador& operator++() {
        ++valor;
        return *this;
    }

    // Sobrecarga del operador postfijo ++
    Contador operator++(int) {
        Contador temp = *this;
        ++valor;
        return temp;
    }

    // Sobrecarga del operador <<
    friend ostream& operator<<(ostream& os, const Contador& c) {
        os << c.valor;
        return os;
    }
};

int main() {
    Contador c(5);

    cout << "Valor inicial: " << c << endl;

    ++c;
    cout << "Después del prefijo ++: " << c << endl;

    c++;
    cout << "Después del postfijo ++: " << c << endl;

    return 0;
}
```

En este ejemplo, se sobrecargan tanto la forma prefija como postfija del operador `++` para la clase `Contador`.

#### Sobrecarga de Operadores de Acceso

Los operadores de acceso como `[]`, `->`, `*`, `()` se pueden sobrecargar para proporcionar comportamientos personalizados.

##### Ejemplo de Sobrecarga del Operador `[]`

```cpp
#include <iostream>
using namespace std;

class Array {
private:
    int* datos;
    int tamano;

public:
    // Constructor
    Array(int tamano) : tamano(tamano) {
        datos = new int[tamano];
        for (int i = 0; i < tamano; ++i) {
            datos[i] = 0;
        }
    }

    // Destructor
    ~Array() {
        delete[] datos;
    }

    // Sobrecarga del operador []
    int& operator[](int indice) {
        if (indice >= 0 && indice < tamano) {
            return datos[indice];
        }
        throw out_of_range("Índice fuera de rango");
    }

    // Sobrecarga del operador <<
    friend ostream& operator<<(ostream& os, const Array& arr) {
        os << "[";
        for (int i = 0; i < arr.tamano; ++i) {
            os << arr.datos[i];
            if (i < arr.tamano - 1) {
                os << ", ";
            }
        }
        os << "]";
        return os;
    }
};

int main() {
    Array arr(5);

    arr[0] = 10;
    arr[1] = 20;
    arr[2] = 30;

    cout << "Array: " << arr << endl;

    try {
        arr[5] = 50;  // Esto lanzará una excepción
    } catch (const out_of_range& e) {
        cout << e.what() << endl;
    }

    return 0;
}
```

En este ejemplo, se sobrecarga el operador `[]` para permitir el acceso a los elementos de un objeto `Array`.

### Conclusión

La sobrecarga de operadores en C++ permite definir cómo los operadores deben comportarse con los objetos de tipos definidos por el usuario. Esto facilita el uso intuitivo de estos objetos y mejora la legibilidad del código. Sin embargo, es importante usar la sobrecarga de operadores de manera adecuada y clara, evitando abusos que puedan llevar a un código confuso o difícil de mantener. Con una comprensión sólida de la sobrecarga de operadores, los desarrolladores pueden crear clases más poderosas y flexibles en C++.
### Destructor en C++

En la programación orientada a objetos en C++, un destructor es una función especial que se llama automáticamente cuando un objeto de la clase sale del alcance o se elimina. Los destructores se utilizan principalmente para liberar recursos que el objeto pueda haber adquirido durante su ciclo de vida, como memoria dinámica, archivos abiertos, conexiones de red, etc.

#### Características del Destructor

1. **Mismo Nombre que la Clase:** El destructor tiene el mismo nombre que la clase, precedido por un tilde (`~`).
2. **Sin Parámetros ni Tipo de Retorno:** Un destructor no toma parámetros ni tiene un tipo de retorno.
3. **Automático:** Se llama automáticamente cuando el objeto sale del alcance o se elimina.

##### Sintaxis del Destructor

```cpp
class NombreClase {
public:
    // Constructor
    NombreClase();

    // Destructor
    ~NombreClase();

    // Otros métodos y atributos
};
```

#### Ejemplo Básico de Destructor

```cpp
#include <iostream>
using namespace std;

class Persona {
public:
    string nombre;

    // Constructor
    Persona(string n) : nombre(n) {
        cout << "Constructor llamado para " << nombre << endl;
    }

    // Destructor
    ~Persona() {
        cout << "Destructor llamado para " << nombre << endl;
    }
};

int main() {
    Persona juan("Juan");
    {
        Persona maria("Maria");
    } // Destructor llamado para maria aquí

    cout << "Fin del main" << endl;
    return 0; // Destructor llamado para juan aquí
}
```

En este ejemplo, el destructor se llama automáticamente cuando los objetos `juan` y `maria` salen de su alcance.

#### Destructores y Recursos Dinámicos

Los destructores son especialmente importantes cuando una clase maneja recursos dinámicos, como memoria asignada dinámicamente, archivos o conexiones de red. El destructor asegura que estos recursos se liberen correctamente cuando el objeto ya no se necesita.

##### Ejemplo con Recursos Dinámicos

```cpp
#include <iostream>
using namespace std;

class Array {
private:
    int* data;
    int size;

public:
    // Constructor
    Array(int s) : size(s) {
        data = new int[size]; // Asignar memoria dinámica
        cout << "Array de tamaño " << size << " creado." << endl;
    }

    // Destructor
    ~Array() {
        delete[] data; // Liberar memoria dinámica
        cout << "Array de tamaño " << size << " destruido." << endl;
    }

    // Método para establecer un valor en el array
    void setValue(int index, int value) {
        if (index >= 0 && index < size) {
            data[index] = value;
        }
    }

    // Método para obtener un valor del array
    int getValue(int index) const {
        if (index >= 0 && index < size) {
            return data[index];
        }
        return -1; // Valor de error
    }
};

int main() {
    Array arr(5);
    arr.setValue(0, 10);
    arr.setValue(1, 20);
    cout << "Valor en la posición 0: " << arr.getValue(0) << endl;
    cout << "Valor en la posición 1: " << arr.getValue(1) << endl;

    return 0;
}
```

En este ejemplo, el destructor de la clase `Array` se asegura de liberar la memoria asignada dinámicamente cuando el objeto `arr` se destruye.

#### Destructores en Clases Derivadas

En una jerarquía de herencia, los destructores de las clases base y derivadas se llaman en el orden correcto. Si una clase base tiene un destructor virtual, asegura que el destructor de la clase derivada se llame correctamente cuando se elimina un objeto a través de un puntero a la clase base.

##### Ejemplo con Herencia

```cpp
#include <iostream>
using namespace std;

class Base {
public:
    // Constructor
    Base() {
        cout << "Constructor de Base" << endl;
    }

    // Destructor virtual
    virtual ~Base() {
        cout << "Destructor de Base" << endl;
    }
};

class Derivada : public Base {
public:
    // Constructor
    Derivada() {
        cout << "Constructor de Derivada" << endl;
    }

    // Destructor
    ~Derivada() {
        cout << "Destructor de Derivada" << endl;
    }
};

int main() {
    Base* obj = new Derivada(); // Crear objeto de clase derivada
    delete obj; // Llamar al destructor virtual

    return 0;
}
```

En este ejemplo, el destructor de `Base` es virtual, asegurando que el destructor de `Derivada` se llame correctamente cuando el objeto se elimina a través de un puntero a la clase base.

#### Regla de Tres, Cinco y Cero

La "regla de tres" establece que si una clase necesita un destructor explícito, probablemente también necesite un constructor de copia y un operador de asignación de copia. La "regla de cinco" extiende esto a las operaciones de movimiento en C++11 y posteriores. La "regla de cero" sugiere usar tipos RAII (Resource Acquisition Is Initialization) para manejar recursos automáticamente, evitando la necesidad de destructores personalizados, constructores de copia y operadores de asignación.

##### Regla de Tres

```cpp
class Ejemplo {
private:
    int* data;

public:
    // Constructor
    Ejemplo(int size) {
        data = new int[size];
    }

    // Destructor
    ~Ejemplo() {
        delete[] data;
    }

    // Constructor de copia
    Ejemplo(const Ejemplo& other) {
        data = new int[other.size];
        // Copiar datos...
    }

    // Operador de asignación de copia
    Ejemplo& operator=(const Ejemplo& other) {
        if (this != &other) {
            delete[] data;
            data = new int[other.size];
            // Copiar datos...
        }
        return *this;
    }
};
```

##### Regla de Cinco

```cpp
class Ejemplo {
private:
    int* data;

public:
    // Constructor
    Ejemplo(int size) {
        data = new int[size];
    }

    // Destructor
    ~Ejemplo() {
        delete[] data;
    }

    // Constructor de copia
    Ejemplo(const Ejemplo& other) {
        data = new int[other.size];
        // Copiar datos...
    }

    // Operador de asignación de copia
    Ejemplo& operator=(const Ejemplo& other) {
        if (this != &other) {
            delete[] data;
            data = new int[other.size];
            // Copiar datos...
        }
        return *this;
    }

    // Constructor de movimiento
    Ejemplo(Ejemplo&& other) noexcept : data(other.data) {
        other.data = nullptr;
    }

    // Operador de asignación de movimiento
    Ejemplo& operator=(Ejemplo&& other) noexcept {
        if (this != &other) {
            delete[] data;
            data = other.data;
            other.data = nullptr;
        }
        return *this;
    }
};
```

### Conclusión

Los destructores son una parte esencial de la administración de recursos en C++. Aseguran que los recursos adquiridos por un objeto se liberen adecuadamente cuando el objeto ya no se necesita. Entender cómo y cuándo implementar destructores, junto con las reglas de tres, cinco y cero, permite a los desarrolladores escribir código más seguro y eficiente, gestionando correctamente la memoria y otros recursos.
### El Puntero `this` en C++

En C++, el puntero `this` es un puntero implícito disponible en las funciones miembro de una clase. Apunta al objeto actual que invoca la función miembro. El puntero `this` es muy útil para acceder a los miembros del objeto, distinguir entre miembros de la clase y parámetros con el mismo nombre, y para encadenar llamadas a funciones miembro.

#### Características del Puntero `this`

1. **Implícito:** No es necesario declarar o inicializar `this`; está disponible automáticamente en las funciones miembro.
2. **Apunta al Objeto Actual:** `this` siempre apunta al objeto que invoca la función miembro.
3. **Constancia en Funciones Constantes:** En funciones miembro constantes, `this` es un puntero a un objeto constante (`const`).

#### Uso Básico del Puntero `this`

El uso básico de `this` es para acceder a los miembros del objeto dentro de sus funciones miembro.

##### Ejemplo Básico

```cpp
#include <iostream>
using namespace std;

class Punto {
private:
    int x, y;

public:
    // Constructor
    Punto(int x = 0, int y = 0) : x(x), y(y) {}

    // Función para establecer valores usando this
    void setXY(int x, int y) {
        this->x = x;  // Acceso a miembro de la clase
        this->y = y;  // Acceso a miembro de la clase
    }

    // Función para mostrar valores
    void mostrar() const {
        cout << "Punto(" << x << ", " << y << ")" << endl;
    }
};

int main() {
    Punto p(10, 20);
    p.mostrar();

    p.setXY(30, 40);
    p.mostrar();

    return 0;
}
```

En este ejemplo, `this->x` y `this->y` se utilizan para acceder a los miembros `x` y `y` de la clase `Punto`.

#### Encadenamiento de Métodos

El puntero `this` se puede utilizar para devolver una referencia al objeto actual, permitiendo encadenar llamadas a métodos.

##### Ejemplo de Encadenamiento de Métodos

```cpp
#include <iostream>
using namespace std;

class Rectangulo {
private:
    int ancho, alto;

public:
    // Constructor
    Rectangulo(int ancho = 0, int alto = 0) : ancho(ancho), alto(alto) {}

    // Métodos para establecer valores con encadenamiento
    Rectangulo& setAncho(int ancho) {
        this->ancho = ancho;
        return *this;
    }

    Rectangulo& setAlto(int alto) {
        this->alto = alto;
        return *this;
    }

    // Función para mostrar valores
    void mostrar() const {
        cout << "Rectangulo(" << ancho << ", " << alto << ")" << endl;
    }
};

int main() {
    Rectangulo r;
    r.setAncho(10).setAlto(20);  // Encadenamiento de métodos
    r.mostrar();

    return 0;
}
```

En este ejemplo, `setAncho` y `setAlto` devuelven una referencia al objeto actual (`*this`), permitiendo encadenar las llamadas a métodos.

#### Uso de `this` en Funciones Constantes

En funciones miembro constantes, `this` es un puntero a un objeto constante (`const`), lo que garantiza que la función no puede modificar los miembros del objeto.

##### Ejemplo con Función Constante

```cpp
#include <iostream>
using namespace std;

class Circulo {
private:
    double radio;

public:
    // Constructor
    Circulo(double radio = 0) : radio(radio) {}

    // Método constante
    double getRadio() const {
        return this->radio;  // `this` es un puntero a un objeto constante
    }

    // Método para establecer el radio
    void setRadio(double radio) {
        this->radio = radio;
    }

    // Función para mostrar el radio
    void mostrar() const {
        cout << "Circulo con radio: " << this->getRadio() << endl;
    }
};

int main() {
    Circulo c(5.0);
    c.mostrar();

    c.setRadio(10.0);
    c.mostrar();

    return 0;
}
```

En este ejemplo, `getRadio` es una función constante que utiliza `this` para acceder al miembro `radio`.

#### Prevención de Auto-Asignación

El puntero `this` se puede utilizar para prevenir la auto-asignación en el operador de asignación sobrecargado.

##### Ejemplo de Prevención de Auto-Asignación

```cpp
#include <iostream>
#include <cstring>
using namespace std;

class Cadena {
private:
    char* str;

public:
    // Constructor
    Cadena(const char* s) {
        str = new char[strlen(s) + 1];
        strcpy(str, s);
    }

    // Destructor
    ~Cadena() {
        delete[] str;
    }

    // Constructor de copia
    Cadena(const Cadena& other) {
        str = new char[strlen(other.str) + 1];
        strcpy(str, other.str);
    }

    // Operador de asignación sobrecargado
    Cadena& operator=(const Cadena& other) {
        if (this != &other) {  // Prevención de auto-asignación
            delete[] str;
            str = new char[strlen(other.str) + 1];
            strcpy(str, other.str);
        }
        return *this;
    }

    // Función para mostrar la cadena
    void mostrar() const {
        cout << "Cadena: " << str << endl;
    }
};

int main() {
    Cadena c1("Hola");
    Cadena c2("Mundo");

    c1.mostrar();
    c2.mostrar();

    c2 = c1;  // Usando el operador de asignación sobrecargado
    c2.mostrar();

    return 0;
}
```

En este ejemplo, `this` se utiliza para comprobar la auto-asignación en el operador de asignación sobrecargado (`operator=`).

### Conclusión

El puntero `this` en C++ es una herramienta poderosa que permite a los programadores acceder y manipular los miembros del objeto actual dentro de las funciones miembro. Es fundamental para la implementación de técnicas como el encadenamiento de métodos, la prevención de auto-asignación y la diferenciación entre miembros de la clase y parámetros con el mismo nombre. Entender y utilizar correctamente `this` puede mejorar la claridad y la eficiencia del código orientado a objetos en C++.
### Miembros Constantes en una Clase en C++

En C++, los miembros constantes de una clase son aquellos que no pueden ser modificados una vez que se les ha asignado un valor. Esto puede aplicarse tanto a los atributos como a los métodos de una clase. El uso de miembros constantes ayuda a proteger la integridad del estado de los objetos, asegurando que ciertos datos permanezcan inmutables después de su inicialización.

#### Atributos Constantes

Los atributos constantes de una clase se declaran utilizando la palabra clave `const`. Un atributo constante debe ser inicializado en el momento de su declaración o en la lista de inicialización del constructor.

##### Ejemplo de Atributos Constantes

```cpp
#include <iostream>
using namespace std;

class Punto {
private:
    const int x;
    const int y;

public:
    // Constructor con lista de inicialización
    Punto(int x, int y) : x(x), y(y) {}

    // Métodos para obtener los valores de los atributos
    int getX() const {
        return x;
    }

    int getY() const {
        return y;
    }

    // Método para mostrar los valores
    void mostrar() const {
        cout << "Punto(" << x << ", " << y << ")" << endl;
    }
};

int main() {
    Punto p(10, 20);
    p.mostrar();

    // p.x = 30; // Error: no se puede modificar un miembro constante
    // p.y = 40; // Error: no se puede modificar un miembro constante

    return 0;
}
```

En este ejemplo, `x` y `y` son atributos constantes de la clase `Punto`, y se inicializan en la lista de inicialización del constructor. Una vez inicializados, no pueden ser modificados.

#### Métodos Constantes

Un método constante de una clase se declara añadiendo la palabra clave `const` al final de su declaración. Un método constante garantiza que no modificará ningún atributo del objeto.

##### Ejemplo de Métodos Constantes

```cpp
#include <iostream>
using namespace std;

class Circulo {
private:
    double radio;

public:
    // Constructor
    Circulo(double r) : radio(r) {}

    // Método constante para obtener el radio
    double getRadio() const {
        return radio;
    }

    // Método constante para calcular el área
    double area() const {
        return 3.14159 * radio * radio;
    }

    // Método constante para mostrar el radio
    void mostrar() const {
        cout << "Circulo con radio: " << radio << " y área: " << area() << endl;
    }
};

int main() {
    Circulo c(5.0);
    c.mostrar();

    // c.radio = 10.0; // Error: no se puede acceder a un miembro privado

    return 0;
}
```

En este ejemplo, `getRadio`, `area` y `mostrar` son métodos constantes de la clase `Circulo`. Estos métodos garantizan que no se modificarán los atributos del objeto.

#### Const Correctness

El concepto de const correctness se refiere a la práctica de usar `const` correctamente para garantizar que los métodos y atributos que no deben modificar el estado del objeto estén marcados como `const`. Esto ayuda a evitar errores y a documentar claramente la intención del código.

##### Ejemplo de Const Correctness

```cpp
#include <iostream>
using namespace std;

class Rectangulo {
private:
    double ancho;
    double alto;

public:
    // Constructor
    Rectangulo(double a, double h) : ancho(a), alto(h) {}

    // Método constante para obtener el ancho
    double getAncho() const {
        return ancho;
    }

    // Método constante para obtener el alto
    double getAlto() const {
        return alto;
    }

    // Método constante para calcular el área
    double area() const {
        return ancho * alto;
    }

    // Método para cambiar el tamaño del rectángulo
    void cambiarTamano(double a, double h) {
        ancho = a;
        alto = h;
    }

    // Método constante para mostrar el rectángulo
    void mostrar() const {
        cout << "Rectangulo de ancho: " << ancho << ", alto: " << alto << ", área: " << area() << endl;
    }
};

int main() {
    const Rectangulo r(10.0, 5.0);
    r.mostrar();

    // r.cambiarTamano(15.0, 7.5); // Error: no se puede llamar a un método no constante en un objeto constante

    return 0;
}
```

En este ejemplo, `getAncho`, `getAlto`, `area` y `mostrar` son métodos constantes que no modifican los atributos del objeto `Rectangulo`. El método `cambiarTamano` no es constante, por lo que no puede ser llamado en un objeto constante.

#### Puntero `this` en Métodos Constantes

En métodos constantes, el puntero `this` es un puntero a un objeto constante (`const`). Esto asegura que los métodos constantes no puedan modificar el estado del objeto.

##### Ejemplo con Puntero `this` en Métodos Constantes

```cpp
#include <iostream>
using namespace std;

class Triangulo {
private:
    double base;
    double altura;

public:
    // Constructor
    Triangulo(double b, double h) : base(b), altura(h) {}

    // Método constante para obtener la base
    double getBase() const {
        return this->base;
    }

    // Método constante para obtener la altura
    double getAltura() const {
        return this->altura;
    }

    // Método constante para calcular el área
    double area() const {
        return 0.5 * this->base * this->altura;
    }

    // Método constante para mostrar el triángulo
    void mostrar() const {
        cout << "Triangulo de base: " << this->getBase() << ", altura: " << this->getAltura() << ", área: " << this->area() << endl;
    }
};

int main() {
    Triangulo t(10.0, 5.0);
    t.mostrar();

    return 0;
}
```

En este ejemplo, `getBase`, `getAltura`, `area` y `mostrar` son métodos constantes que utilizan el puntero `this` para acceder a los miembros de la clase `Triangulo`.

### Conclusión

El uso de miembros constantes en una clase en C++ es una práctica fundamental para proteger la integridad del estado del objeto y asegurar la constancia donde sea necesario. Los atributos constantes no pueden ser modificados después de su inicialización, y los métodos constantes garantizan que no se modifiquen los atributos del objeto. Implementar const correctness ayuda a escribir código más seguro, legible y mantenible, y proporciona una clara documentación de la intención del código.
### Objetos Constantes en C++

En C++, un objeto constante es una instancia de una clase que se declara con la palabra clave `const`. Una vez que un objeto se declara como constante, no se pueden modificar sus atributos directamente, ni se pueden llamar métodos no constantes sobre él. Los objetos constantes son útiles para asegurar que ciertos datos permanezcan inmutables una vez inicializados.

#### Declaración de Objetos Constantes

Para declarar un objeto constante, se coloca la palabra clave `const` antes del tipo de objeto.

##### Ejemplo de Declaración de Objetos Constantes

```cpp
#include <iostream>
using namespace std;

class Punto {
private:
    int x, y;

public:
    // Constructor
    Punto(int x = 0, int y = 0) : x(x), y(y) {}

    // Métodos para obtener los valores de los atributos
    int getX() const {
        return x;
    }

    int getY() const {
        return y;
    }

    // Método para establecer los valores de los atributos
    void setXY(int x, int y) {
        this->x = x;
        this->y = y;
    }

    // Método para mostrar los valores
    void mostrar() const {
        cout << "Punto(" << x << ", " << y << ")" << endl;
    }
};

int main() {
    const Punto p(10, 20);
    p.mostrar();

    // p.setXY(30, 40); // Error: no se puede llamar a un método no constante en un objeto constante

    cout << "X: " << p.getX() << ", Y: " << p.getY() << endl;

    return 0;
}
```

En este ejemplo, `p` es un objeto constante de la clase `Punto`. No se pueden modificar sus atributos, ni llamar a métodos no constantes como `setXY`.

#### Acceso a Miembros de Objetos Constantes

Para que un método pueda ser llamado en un objeto constante, debe estar declarado como constante. Esto se hace añadiendo la palabra clave `const` al final de la declaración del método.

##### Ejemplo de Métodos Constantes en Objetos Constantes

```cpp
#include <iostream>
using namespace std;

class Circulo {
private:
    double radio;

public:
    // Constructor
    Circulo(double r) : radio(r) {}

    // Método constante para obtener el radio
    double getRadio() const {
        return radio;
    }

    // Método constante para calcular el área
    double area() const {
        return 3.14159 * radio * radio;
    }

    // Método constante para mostrar el radio
    void mostrar() const {
        cout << "Circulo con radio: " << radio << " y área: " << area() << endl;
    }
};

int main() {
    const Circulo c(5.0);
    c.mostrar();

    // c.setRadio(10.0); // Error: no se puede llamar a un método no constante en un objeto constante

    cout << "Radio: " << c.getRadio() << endl;
    cout << "Área: " << c.area() << endl;

    return 0;
}
```

En este ejemplo, `c` es un objeto constante de la clase `Circulo`. Solo se pueden llamar métodos constantes como `getRadio`, `area`, y `mostrar` en este objeto.

#### Inicialización de Objetos Constantes

Los objetos constantes deben ser inicializados en el momento de su declaración. Esto se puede hacer directamente en la declaración o utilizando el constructor de la clase.

##### Ejemplo de Inicialización de Objetos Constantes

```cpp
#include <iostream>
using namespace std;

class Rectangulo {
private:
    double ancho, alto;

public:
    // Constructor
    Rectangulo(double a, double h) : ancho(a), alto(h) {}

    // Método constante para obtener el ancho
    double getAncho() const {
        return ancho;
    }

    // Método constante para obtener el alto
    double getAlto() const {
        return alto;
    }

    // Método constante para calcular el área
    double area() const {
        return ancho * alto;
    }

    // Método constante para mostrar el rectángulo
    void mostrar() const {
        cout << "Rectangulo de ancho: " << ancho << ", alto: " << alto << ", área: " << area() << endl;
    }
};

int main() {
    const Rectangulo r(10.0, 5.0);
    r.mostrar();

    // r.cambiarTamano(15.0, 7.5); // Error: no se puede llamar a un método no constante en un objeto constante

    cout << "Ancho: " << r.getAncho() << endl;
    cout << "Alto: " << r.getAlto() << endl;
    cout << "Área: " << r.area() << endl;

    return 0;
}
```

En este ejemplo, `r` es un objeto constante de la clase `Rectangulo`. Los atributos `ancho` y `alto` se inicializan mediante el constructor y no se pueden modificar después.

#### Punteros a Objetos Constantes

Se pueden usar punteros para apuntar a objetos constantes. Un puntero a un objeto constante solo puede llamar métodos constantes de ese objeto.

##### Ejemplo de Puntero a Objeto Constante

```cpp
#include <iostream>
using namespace std;

class Triangulo {
private:
    double base, altura;

public:
    // Constructor
    Triangulo(double b, double h) : base(b), altura(h) {}

    // Método constante para obtener la base
    double getBase() const {
        return base;
    }

    // Método constante para obtener la altura
    double getAltura() const {
        return altura;
    }

    // Método constante para calcular el área
    double area() const {
        return 0.5 * base * altura;
    }

    // Método constante para mostrar el triángulo
    void mostrar() const {
        cout << "Triangulo de base: " << base << ", altura: " << altura << ", área: " << area() << endl;
    }
};

int main() {
    const Triangulo t(10.0, 5.0);
    const Triangulo* pt = &t;

    pt->mostrar();

    // pt->setBase(15.0); // Error: no se puede llamar a un método no constante en un objeto constante

    cout << "Base: " << pt->getBase() << endl;
    cout << "Altura: " << pt->getAltura() << endl;
    cout << "Área: " << pt->area() << endl;

    return 0;
}
```

En este ejemplo, `pt` es un puntero a un objeto constante `t` de la clase `Triangulo`. Solo se pueden llamar métodos constantes como `getBase`, `getAltura`, `area`, y `mostrar` a través de `pt`.

### Conclusión

Los objetos constantes en C++ son una herramienta importante para asegurar la inmutabilidad de los datos después de su inicialización. Declarar un objeto como `const` garantiza que no se pueden modificar sus atributos ni llamar a métodos no constantes sobre él. Utilizar objetos constantes ayuda a proteger la integridad del estado del objeto, mejorar la seguridad del código y proporcionar una clara documentación de la intención del código. Para trabajar efectivamente con objetos constantes, es crucial entender cómo declarar y utilizar métodos constantes y asegurarse de que los atributos necesarios se inicialicen adecuadamente.
### Constructores Explícitos en C++

En C++, un constructor explícito es un constructor que se define con la palabra clave `explicit`. Esta característica se utiliza para evitar conversiones implícitas no deseadas, mejorando la seguridad del tipo y la claridad del código. Al marcar un constructor como explícito, se asegura que las conversiones que involucran ese constructor solo se realicen explícitamente, lo que ayuda a prevenir errores sutiles y difíciles de depurar.

#### Definición de Constructores Explícitos

Un constructor explícito se declara añadiendo la palabra clave `explicit` antes de la declaración del constructor.

##### Sintaxis

```cpp
class Clase {
public:
    explicit Clase(Tipo parametro);
    // Otros miembros...
};
```

#### Ejemplo de Constructor Explícito

Consideremos una clase `Tiempo` que tiene un constructor que toma un solo argumento de tipo `int`, que representa los minutos.

##### Sin Constructor Explícito

```cpp
#include <iostream>
using namespace std;

class Tiempo {
private:
    int minutos;

public:
    // Constructor
    Tiempo(int m) : minutos(m) {}

    // Método para mostrar el tiempo
    void mostrar() const {
        cout << "Tiempo: " << minutos << " minutos" << endl;
    }
};

void imprimirTiempo(const Tiempo& t) {
    t.mostrar();
}

int main() {
    Tiempo t1 = 120;  // Conversión implícita
    t1.mostrar();

    imprimirTiempo(90);  // Conversión implícita

    return 0;
}
```

En este ejemplo, las conversiones implícitas permiten crear un objeto `Tiempo` a partir de un entero, lo que puede llevar a errores inadvertidos.

##### Con Constructor Explícito

```cpp
#include <iostream>
using namespace std;

class Tiempo {
private:
    int minutos;

public:
    // Constructor explícito
    explicit Tiempo(int m) : minutos(m) {}

    // Método para mostrar el tiempo
    void mostrar() const {
        cout << "Tiempo: " << minutos << " minutos" << endl;
    }
};

void imprimirTiempo(const Tiempo& t) {
    t.mostrar();
}

int main() {
    // Tiempo t1 = 120;  // Error: conversión implícita no permitida
    Tiempo t1(120);  // Correcto: conversión explícita
    t1.mostrar();

    // imprimirTiempo(90);  // Error: conversión implícita no permitida
    imprimirTiempo(Tiempo(90));  // Correcto: conversión explícita

    return 0;
}
```

En este ejemplo, al marcar el constructor como explícito, se evita la conversión implícita de `int` a `Tiempo`, forzando al programador a realizar la conversión explícitamente.

#### Ventajas de los Constructores Explícitos

1. **Prevención de Errores:** Evitan conversiones implícitas no deseadas que pueden llevar a errores difíciles de detectar.
2. **Claridad:** Hacen que las conversiones necesarias sean explícitas en el código, mejorando la legibilidad y la comprensión.
3. **Seguridad del Tipo:** Mejoran la seguridad del tipo al asegurar que solo se realicen conversiones explícitas, garantizando que los datos se manejen de manera apropiada.

#### Uso de Constructores Explícitos en Conversiones

Los constructores explícitos son particularmente útiles cuando una clase puede ser construida a partir de un solo argumento de un tipo diferente, para evitar conversiones implícitas no deseadas.

##### Ejemplo con Conversiones

```cpp
#include <iostream>
#include <string>
using namespace std;

class Cadena {
private:
    string valor;

public:
    // Constructor explícito
    explicit Cadena(const char* s) : valor(s) {}

    // Método para mostrar la cadena
    void mostrar() const {
        cout << "Cadena: " << valor << endl;
    }
};

void imprimirCadena(const Cadena& c) {
    c.mostrar();
}

int main() {
    // Cadena c1 = "Hola";  // Error: conversión implícita no permitida
    Cadena c1("Hola");  // Correcto: conversión explícita
    c1.mostrar();

    // imprimirCadena("Mundo");  // Error: conversión implícita no permitida
    imprimirCadena(Cadena("Mundo"));  // Correcto: conversión explícita

    return 0;
}
```

En este ejemplo, la clase `Cadena` tiene un constructor explícito que toma un `const char*`. Esto previene conversiones implícitas no deseadas desde `const char*` a `Cadena`.

#### Comparación con Constructores Implícitos

Para entender mejor la diferencia entre constructores explícitos e implícitos, considere la siguiente comparación:

##### Constructor Implícito

```cpp
class Impl {
public:
    Impl(int) {}
};

void f(Impl) {}

int main() {
    f(42);  // Correcto: conversión implícita permitida
    return 0;
}
```

##### Constructor Explícito

```cpp
class Expl {
public:
    explicit Expl(int) {}
};

void f(Expl) {}

int main() {
    // f(42);  // Error: conversión implícita no permitida
    f(Expl(42));  // Correcto: conversión explícita
    return 0;
}
```

En el caso del constructor implícito, la conversión de `int` a `Impl` se realiza automáticamente, mientras que en el caso del constructor explícito, se requiere una conversión explícita de `int` a `Expl`.

### Conclusión

Los constructores explícitos son una característica importante de C++ que mejora la seguridad del tipo y la claridad del código al evitar conversiones implícitas no deseadas. Al usar la palabra clave `explicit`, los programadores pueden controlar mejor cuándo y cómo se realizan las conversiones, previniendo errores y asegurando que las intenciones del código sean claras y precisas. Implementar constructores explícitos es una práctica recomendada cuando se diseña clases que pueden ser construidas a partir de un solo argumento de un tipo diferente.
### Constructor de Copia en C++

El constructor de copia es un tipo especial de constructor en C++ que se utiliza para crear un nuevo objeto como una copia de un objeto existente. Este constructor es fundamental para el manejo adecuado de la copia de objetos, especialmente cuando estos objetos manejan recursos dinámicos como memoria, archivos, o conexiones de red.

#### Definición del Constructor de Copia

El constructor de copia toma una referencia constante a un objeto del mismo tipo y copia los valores de sus atributos al nuevo objeto. La sintaxis general para declarar un constructor de copia es la siguiente:

```cpp
class Clase {
public:
    Clase(const Clase& other); // Constructor de copia
    // Otros miembros...
};
```

#### Ejemplo Básico de Constructor de Copia

Consideremos una clase `Persona` que tiene un nombre y una edad. Implementemos un constructor de copia para esta clase.

```cpp
#include <iostream>
#include <string>
using namespace std;

class Persona {
private:
    string nombre;
    int edad;

public:
    // Constructor parametrizado
    Persona(string n, int e) : nombre(n), edad(e) {}

    // Constructor de copia
    Persona(const Persona& other) {
        nombre = other.nombre;
        edad = other.edad;
    }

    // Método para mostrar la información
    void mostrar() const {
        cout << "Nombre: " << nombre << ", Edad: " << edad << endl;
    }
};

int main() {
    Persona p1("Juan", 30);
    Persona p2 = p1; // Llamada al constructor de copia

    p1.mostrar();
    p2.mostrar();

    return 0;
}
```

En este ejemplo, el constructor de copia copia los valores de `nombre` y `edad` de `p1` a `p2`.

#### Importancia del Constructor de Copia

El constructor de copia es crucial en situaciones donde los objetos manejan recursos dinámicos. Sin un constructor de copia adecuado, el compilador genera un constructor de copia por defecto que realiza una copia superficial, lo que puede llevar a problemas como la doble liberación de memoria.

##### Problema de la Copia Superficial

```cpp
class Cadena {
private:
    char* str;

public:
    // Constructor parametrizado
    Cadena(const char* s) {
        str = new char[strlen(s) + 1];
        strcpy(str, s);
    }

    // Destructor
    ~Cadena() {
        delete[] str;
    }

    // Constructor de copia por defecto (copia superficial)
    // Cadena(const Cadena& other) = default;

    // Método para mostrar la cadena
    void mostrar() const {
        cout << str << endl;
    }
};

int main() {
    Cadena c1("Hola");
    Cadena c2 = c1; // Copia superficial

    c1.mostrar();
    c2.mostrar();

    return 0;
}
```

En este ejemplo, `c2` realiza una copia superficial de `c1`, lo que significa que ambos objetos `c1` y `c2` apuntan a la misma ubicación de memoria. Esto puede causar problemas cuando se destruyen los objetos, ya que ambos intentarán liberar la misma memoria.

##### Solución con Constructor de Copia Profunda

```cpp
class Cadena {
private:
    char* str;

public:
    // Constructor parametrizado
    Cadena(const char* s) {
        str = new char[strlen(s) + 1];
        strcpy(str, s);
    }

    // Destructor
    ~Cadena() {
        delete[] str;
    }

    // Constructor de copia (copia profunda)
    Cadena(const Cadena& other) {
        str = new char[strlen(other.str) + 1];
        strcpy(str, other.str);
    }

    // Método para mostrar la cadena
    void mostrar() const {
        cout << str << endl;
    }
};

int main() {
    Cadena c1("Hola");
    Cadena c2 = c1; // Copia profunda

    c1.mostrar();
    c2.mostrar();

    return 0;
}
```

En este ejemplo, el constructor de copia realiza una copia profunda, lo que significa que `c2` tiene su propia copia de la cadena de caracteres, eliminando así el problema de la doble liberación de memoria.

#### Regla de Tres

La regla de tres establece que si una clase necesita un destructor explícito, un constructor de copia o un operador de asignación de copia, probablemente necesite los tres. Esto se debe a que todas estas funciones están relacionadas con la gestión de recursos.

##### Ejemplo Completo con la Regla de Tres

```cpp
class Recurso {
private:
    int* data;

public:
    // Constructor parametrizado
    Recurso(int valor) {
        data = new int(valor);
    }

    // Destructor
    ~Recurso() {
        delete data;
    }

    // Constructor de copia
    Recurso(const Recurso& other) {
        data = new int(*other.data);
    }

    // Operador de asignación de copia
    Recurso& operator=(const Recurso& other) {
        if (this != &other) {
            delete data;
            data = new int(*other.data);
        }
        return *this;
    }

    // Método para mostrar el valor
    void mostrar() const {
        cout << "Valor: " << *data << endl;
    }
};

int main() {
    Recurso r1(10);
    Recurso r2 = r1; // Llamada al constructor de copia
    Recurso r3(20);
    r3 = r1; // Llamada al operador de asignación de copia

    r1.mostrar();
    r2.mostrar();
    r3.mostrar();

    return 0;
}
```

En este ejemplo, la clase `Recurso` implementa la regla de tres, asegurando una gestión adecuada de la memoria dinámica.

### Conclusión

El constructor de copia es una característica esencial en C++ para la correcta gestión de la copia de objetos, especialmente cuando estos manejan recursos dinámicos. Implementar un constructor de copia adecuada previene problemas relacionados con copias superficiales y doble liberación de memoria. La regla de tres asegura que los destructores, constructores de copia y operadores de asignación de copia estén correctamente implementados para garantizar la integridad y eficiencia del manejo de recursos en las clases.
<---FILES--->
Definición de una Clase
Definición de una Clase Result
Ejemplo Básico de una Clase
Ejemplo Básico de una Clase Result
Creación de Objetos
Creación de Objetos Result
Ejemplo de Creación y Uso de Objetos
Ejemplo de Creación y Uso de Objetos Result
Constructores
Constructores Result
Destructores
Destructores Result
Modificadores de Acceso
Modificadores de Acceso Result
Definición de una Clase
Definición de una Clase Result
Ejemplo Básico de una Clase
Ejemplo Básico de una Clase Result
Creación de Objetos
Creación de Objetos Result
Ejemplo de Creación y Uso de Objetos
Ejemplo de Creación y Uso de Objetos Result
Constructores
Constructores Result
Destructores
Destructores Result
Modificadores de Acceso
Modificadores de Acceso Result
Ejemplo de Constructor por Defecto
Ejemplo de Constructor por Defecto Result
Ejemplo de Constructor Parametrizado
Ejemplo de Constructor Parametrizado Result
Ejemplo de Constructor de Copia
Ejemplo de Constructor de Copia Result
Ejemplo de Constructor de Movimiento
Ejemplo de Constructor de Movimiento Result
Ejemplo con Lista de Inicialización
Ejemplo con Lista de Inicialización Result
Definición de una Clase
Definición de una Clase Result
Ejemplo Básico de una Clase
Ejemplo Básico de una Clase Result
Creación de Objetos
Creación de Objetos Result
Ejemplo de Creación y Uso de Objetos
Ejemplo de Creación y Uso de Objetos Result
Constructores
Constructores Result
Destructores
Destructores Result
Modificadores de Acceso
Modificadores de Acceso Result
Ejemplo de Constructor por Defecto
Ejemplo de Constructor por Defecto Result
Ejemplo de Constructor Parametrizado
Ejemplo de Constructor Parametrizado Result
Ejemplo de Constructor de Copia
Ejemplo de Constructor de Copia Result
Ejemplo de Constructor de Movimiento
Ejemplo de Constructor de Movimiento Result
Ejemplo con Lista de Inicialización
Ejemplo con Lista de Inicialización Result
Definición de Atributos Privados
Definición de Atributos Privados Result
Ejemplo de Getters
Ejemplo de Getters Result
Ejemplo de Setters
Ejemplo de Setters Result
Ejemplo Completo
Ejemplo Completo Result
Definición de una Clase
Definición de una Clase Result
Ejemplo Básico de una Clase
Ejemplo Básico de una Clase Result
Creación de Objetos
Creación de Objetos Result
Ejemplo de Creación y Uso de Objetos
Ejemplo de Creación y Uso de Objetos Result
Constructores
Constructores Result
Destructores
Destructores Result
Modificadores de Acceso
Modificadores de Acceso Result
Ejemplo de Constructor por Defecto
Ejemplo de Constructor por Defecto Result
Ejemplo de Constructor Parametrizado
Ejemplo de Constructor Parametrizado Result
Ejemplo de Constructor de Copia
Ejemplo de Constructor de Copia Result
Ejemplo de Constructor de Movimiento
Ejemplo de Constructor de Movimiento Result
Ejemplo con Lista de Inicialización
Ejemplo con Lista de Inicialización Result
Definición de Atributos Privados
Definición de Atributos Privados Result
Ejemplo de Getters
Ejemplo de Getters Result
Ejemplo de Setters
Ejemplo de Setters Result
Ejemplo Completo
Ejemplo Completo Result
Ejemplo Básico
Ejemplo Básico Result
Ejemplo con Setters y Getters
Ejemplo con Setters y Getters Result
Ejemplo con Herencia
Ejemplo con Herencia Result
Definición de una Clase
Definición de una Clase Result
Ejemplo Básico de una Clase
Ejemplo Básico de una Clase Result
Creación de Objetos
Creación de Objetos Result
Ejemplo de Creación y Uso de Objetos
Ejemplo de Creación y Uso de Objetos Result
Constructores
Constructores Result
Destructores
Destructores Result
Modificadores de Acceso
Modificadores de Acceso Result
Ejemplo de Constructor por Defecto
Ejemplo de Constructor por Defecto Result
Ejemplo de Constructor Parametrizado
Ejemplo de Constructor Parametrizado Result
Ejemplo de Constructor de Copia
Ejemplo de Constructor de Copia Result
Ejemplo de Constructor de Movimiento
Ejemplo de Constructor de Movimiento Result
Ejemplo con Lista de Inicialización
Ejemplo con Lista de Inicialización Result
Definición de Atributos Privados
Definición de Atributos Privados Result
Ejemplo de Getters
Ejemplo de Getters Result
Ejemplo de Setters
Ejemplo de Setters Result
Ejemplo Completo
Ejemplo Completo Result
Ejemplo Básico
Ejemplo Básico Result
Ejemplo con Setters y Getters
Ejemplo con Setters y Getters Result
Ejemplo con Herencia
Ejemplo con Herencia Result
Sintaxis del Destructor
Sintaxis del Destructor Result
Ejemplo Básico de Destructor
Ejemplo Básico de Destructor Result
Ejemplo con Recursos Dinámicos
Ejemplo con Recursos Dinámicos Result
Regla de Tres
Regla de Tres Result
Regla de Cinco
Regla de Cinco Result
Definición de una Clase
Definición de una Clase Result
Ejemplo Básico de una Clase
Ejemplo Básico de una Clase Result
Creación de Objetos
Creación de Objetos Result
Ejemplo de Creación y Uso de Objetos
Ejemplo de Creación y Uso de Objetos Result
Constructores
Constructores Result
Destructores
Destructores Result
Modificadores de Acceso
Modificadores de Acceso Result
Ejemplo de Constructor por Defecto
Ejemplo de Constructor por Defecto Result
Ejemplo de Constructor Parametrizado
Ejemplo de Constructor Parametrizado Result
Ejemplo de Constructor de Copia
Ejemplo de Constructor de Copia Result
Ejemplo de Constructor de Movimiento
Ejemplo de Constructor de Movimiento Result
Ejemplo con Lista de Inicialización
Ejemplo con Lista de Inicialización Result
Definición de Atributos Privados
Definición de Atributos Privados Result
Ejemplo de Getters
Ejemplo de Getters Result
Ejemplo de Setters
Ejemplo de Setters Result
Ejemplo Completo
Ejemplo Completo Result
Ejemplo Básico
Ejemplo Básico Result
Ejemplo con Setters y Getters
Ejemplo con Setters y Getters Result
Ejemplo con Herencia
Ejemplo con Herencia Result
Sintaxis del Destructor
Sintaxis del Destructor Result
Ejemplo Básico de Destructor
Ejemplo Básico de Destructor Result
Ejemplo con Recursos Dinámicos
Ejemplo con Recursos Dinámicos Result
Regla de Tres
Regla de Tres Result
Regla de Cinco
Regla de Cinco Result
Ejemplo de Sobrecarga de Operadores
Ejemplo de Sobrecarga de Operadores Result
Ejemplo de Sobrecarga del Operador `*`
Ejemplo de Sobrecarga del Operador `*` Result
Ejemplo de Sobrecarga del Operador `==`
Ejemplo de Sobrecarga del Operador `==` Result
Ejemplo de Sobrecarga del Operador `++`
Ejemplo de Sobrecarga del Operador `++` Result
Ejemplo de Sobrecarga del Operador `[]`
Ejemplo de Sobrecarga del Operador `[]` Result
Definición de una Clase
Definición de una Clase Result
Ejemplo Básico de una Clase
Ejemplo Básico de una Clase Result
Creación de Objetos
Creación de Objetos Result
Ejemplo de Creación y Uso de Objetos
Ejemplo de Creación y Uso de Objetos Result
Constructores
Constructores Result
Destructores
Destructores Result
Modificadores de Acceso
Modificadores de Acceso Result
Ejemplo de Constructor por Defecto
Ejemplo de Constructor por Defecto Result
Ejemplo de Constructor Parametrizado
Ejemplo de Constructor Parametrizado Result
Ejemplo de Constructor de Copia
Ejemplo de Constructor de Copia Result
Ejemplo de Constructor de Movimiento
Ejemplo de Constructor de Movimiento Result
Ejemplo con Lista de Inicialización
Ejemplo con Lista de Inicialización Result
Definición de Atributos Privados
Definición de Atributos Privados Result
Ejemplo de Getters
Ejemplo de Getters Result
Ejemplo de Setters
Ejemplo de Setters Result
Ejemplo Completo
Ejemplo Completo Result
Ejemplo Básico
Ejemplo Básico Result
Ejemplo con Setters y Getters
Ejemplo con Setters y Getters Result
Ejemplo con Herencia
Ejemplo con Herencia Result
Sintaxis del Destructor
Sintaxis del Destructor Result
Ejemplo Básico de Destructor
Ejemplo Básico de Destructor Result
Ejemplo con Recursos Dinámicos
Ejemplo con Recursos Dinámicos Result
Regla de Tres
Regla de Tres Result
Regla de Cinco
Regla de Cinco Result
Ejemplo de Sobrecarga de Operadores
Ejemplo de Sobrecarga de Operadores Result
Ejemplo de Sobrecarga del Operador `*`
Ejemplo de Sobrecarga del Operador `*` Result
Ejemplo de Sobrecarga del Operador `==`
Ejemplo de Sobrecarga del Operador `==` Result
Ejemplo de Sobrecarga del Operador `++`
Ejemplo de Sobrecarga del Operador `++` Result
Ejemplo de Sobrecarga del Operador `[]`
Ejemplo de Sobrecarga del Operador `[]` Result
Definición de una Clase
Definición de una Clase Result
Ejemplo Básico de una Clase
Ejemplo Básico de una Clase Result
Creación de Objetos
Creación de Objetos Result
Ejemplo de Creación y Uso de Objetos
Ejemplo de Creación y Uso de Objetos Result
Constructores
Constructores Result
Destructores
Destructores Result
Modificadores de Acceso
Modificadores de Acceso Result
Ejemplo de Constructor por Defecto
Ejemplo de Constructor por Defecto Result
Ejemplo de Constructor Parametrizado
Ejemplo de Constructor Parametrizado Result
Ejemplo de Constructor de Copia
Ejemplo de Constructor de Copia Result
Ejemplo de Constructor de Movimiento
Ejemplo de Constructor de Movimiento Result
Ejemplo con Lista de Inicialización
Ejemplo con Lista de Inicialización Result
Definición de Atributos Privados
Definición de Atributos Privados Result
Ejemplo de Getters
Ejemplo de Getters Result
Ejemplo de Setters
Ejemplo de Setters Result
Ejemplo Completo
Ejemplo Completo Result
Ejemplo Básico
Ejemplo Básico Result
Ejemplo con Setters y Getters
Ejemplo con Setters y Getters Result
Ejemplo con Herencia
Ejemplo con Herencia Result
Sintaxis del Destructor
Sintaxis del Destructor Result
Ejemplo Básico de Destructor
Ejemplo Básico de Destructor Result
Ejemplo con Recursos Dinámicos
Ejemplo con Recursos Dinámicos Result
Regla de Tres
Regla de Tres Result
Regla de Cinco
Regla de Cinco Result
Ejemplo de Sobrecarga de Operadores
Ejemplo de Sobrecarga de Operadores Result
Ejemplo de Sobrecarga del Operador `*`
Ejemplo de Sobrecarga del Operador `*` Result
Ejemplo de Sobrecarga del Operador `==`
Ejemplo de Sobrecarga del Operador `==` Result
Ejemplo de Sobrecarga del Operador `++`
Ejemplo de Sobrecarga del Operador `++` Result
Ejemplo de Sobrecarga del Operador `[]`
Ejemplo de Sobrecarga del Operador `[]` Result
Definición de una Clase
Definición de una Clase Result
Ejemplo Básico de una Clase
Ejemplo Básico de una Clase Result
Creación de Objetos
Creación de Objetos Result
Ejemplo de Creación y Uso de Objetos
Ejemplo de Creación y Uso de Objetos Result
Constructores
Constructores Result
Destructores
Destructores Result
Modificadores de Acceso
Modificadores de Acceso Result
Ejemplo de Constructor por Defecto
Ejemplo de Constructor por Defecto Result
Ejemplo de Constructor Parametrizado
Ejemplo de Constructor Parametrizado Result
Ejemplo de Constructor de Copia
Ejemplo de Constructor de Copia Result
Ejemplo de Constructor de Movimiento
Ejemplo de Constructor de Movimiento Result
Ejemplo con Lista de Inicialización
Ejemplo con Lista de Inicialización Result
Definición de Atributos Privados
Definición de Atributos Privados Result
Ejemplo de Getters
Ejemplo de Getters Result
Ejemplo de Setters
Ejemplo de Setters Result
Ejemplo Completo
Ejemplo Completo Result
Ejemplo Básico
Ejemplo Básico Result
Ejemplo con Setters y Getters
Ejemplo con Setters y Getters Result
Ejemplo con Herencia
Ejemplo con Herencia Result
Sintaxis del Destructor
Sintaxis del Destructor Result
Ejemplo Básico de Destructor
Ejemplo Básico de Destructor Result
Ejemplo con Recursos Dinámicos
Ejemplo con Recursos Dinámicos Result
Regla de Tres
Regla de Tres Result
Regla de Cinco
Regla de Cinco Result
Ejemplo de Sobrecarga de Operadores
Ejemplo de Sobrecarga de Operadores Result
Ejemplo de Sobrecarga del Operador `*`
Ejemplo de Sobrecarga del Operador `*` Result
Ejemplo de Sobrecarga del Operador `==`
Ejemplo de Sobrecarga del Operador `==` Result
Ejemplo de Sobrecarga del Operador `++`
Ejemplo de Sobrecarga del Operador `++` Result
Ejemplo de Sobrecarga del Operador `[]`
Ejemplo de Sobrecarga del Operador `[]` Result
Definición de una Clase
Definición de una Clase Result
Ejemplo Básico de una Clase
Ejemplo Básico de una Clase Result
Creación de Objetos
Creación de Objetos Result
Ejemplo de Creación y Uso de Objetos
Ejemplo de Creación y Uso de Objetos Result
Constructores
Constructores Result
Destructores
Destructores Result
Modificadores de Acceso
Modificadores de Acceso Result
Ejemplo de Constructor por Defecto
Ejemplo de Constructor por Defecto Result
Ejemplo de Constructor Parametrizado
Ejemplo de Constructor Parametrizado Result
Ejemplo de Constructor de Copia
Ejemplo de Constructor de Copia Result
Ejemplo de Constructor de Movimiento
Ejemplo de Constructor de Movimiento Result
Ejemplo con Lista de Inicialización
Ejemplo con Lista de Inicialización Result
Definición de Atributos Privados
Definición de Atributos Privados Result
Ejemplo de Getters
Ejemplo de Getters Result
Ejemplo de Setters
Ejemplo de Setters Result
Ejemplo Completo
Ejemplo Completo Result
Ejemplo Básico
Ejemplo Básico Result
Ejemplo con Setters y Getters
Ejemplo con Setters y Getters Result
Ejemplo con Herencia
Ejemplo con Herencia Result
Sintaxis del Destructor
Sintaxis del Destructor Result
Ejemplo Básico de Destructor
Ejemplo Básico de Destructor Result
Ejemplo con Recursos Dinámicos
Ejemplo con Recursos Dinámicos Result
Regla de Tres
Regla de Tres Result
Regla de Cinco
Regla de Cinco Result
Ejemplo de Sobrecarga de Operadores
Ejemplo de Sobrecarga de Operadores Result
Ejemplo de Sobrecarga del Operador `*`
Ejemplo de Sobrecarga del Operador `*` Result
Ejemplo de Sobrecarga del Operador `==`
Ejemplo de Sobrecarga del Operador `==` Result
Ejemplo de Sobrecarga del Operador `++`
Ejemplo de Sobrecarga del Operador `++` Result
Ejemplo de Sobrecarga del Operador `[]`
Ejemplo de Sobrecarga del Operador `[]` Result
Ejemplo de Encadenamiento de Métodos
Ejemplo de Encadenamiento de Métodos Result
Ejemplo con Función Constante
Ejemplo con Función Constante Result
Ejemplo de Prevención de Auto-Asignación
Ejemplo de Prevención de Auto-Asignación Result
Definición de una Clase
Definición de una Clase Result
Ejemplo Básico de una Clase
Ejemplo Básico de una Clase Result
Creación de Objetos
Creación de Objetos Result
Ejemplo de Creación y Uso de Objetos
Ejemplo de Creación y Uso de Objetos Result
Constructores
Constructores Result
Destructores
Destructores Result
Modificadores de Acceso
Modificadores de Acceso Result
Ejemplo de Constructor por Defecto
Ejemplo de Constructor por Defecto Result
Ejemplo de Constructor Parametrizado
Ejemplo de Constructor Parametrizado Result
Ejemplo de Constructor de Copia
Ejemplo de Constructor de Copia Result
Ejemplo de Constructor de Movimiento
Ejemplo de Constructor de Movimiento Result
Ejemplo con Lista de Inicialización
Ejemplo con Lista de Inicialización Result
Definición de Atributos Privados
Definición de Atributos Privados Result
Ejemplo de Getters
Ejemplo de Getters Result
Ejemplo de Setters
Ejemplo de Setters Result
Ejemplo Completo
Ejemplo Completo Result
Ejemplo Básico
Ejemplo Básico Result
Ejemplo con Setters y Getters
Ejemplo con Setters y Getters Result
Ejemplo con Herencia
Ejemplo con Herencia Result
Sintaxis del Destructor
Sintaxis del Destructor Result
Ejemplo Básico de Destructor
Ejemplo Básico de Destructor Result
Ejemplo con Recursos Dinámicos
Ejemplo con Recursos Dinámicos Result
Regla de Tres
Regla de Tres Result
Regla de Cinco
Regla de Cinco Result
Ejemplo de Sobrecarga de Operadores
Ejemplo de Sobrecarga de Operadores Result
Ejemplo de Sobrecarga del Operador `*`
Ejemplo de Sobrecarga del Operador `*` Result
Ejemplo de Sobrecarga del Operador `==`
Ejemplo de Sobrecarga del Operador `==` Result
Ejemplo de Sobrecarga del Operador `++`
Ejemplo de Sobrecarga del Operador `++` Result
Ejemplo de Sobrecarga del Operador `[]`
Ejemplo de Sobrecarga del Operador `[]` Result
Ejemplo de Encadenamiento de Métodos
Ejemplo de Encadenamiento de Métodos Result
Ejemplo con Función Constante
Ejemplo con Función Constante Result
Ejemplo de Prevención de Auto-Asignación
Ejemplo de Prevención de Auto-Asignación Result
Ejemplo de Atributos Constantes
Ejemplo de Atributos Constantes Result
Ejemplo de Métodos Constantes
Ejemplo de Métodos Constantes Result
Ejemplo de Const Correctness
Ejemplo de Const Correctness Result
Ejemplo con Puntero `this` en Métodos Constantes
Ejemplo con Puntero `this` en Métodos Constantes Result
Definición de una Clase
Definición de una Clase Result
Ejemplo Básico de una Clase
Ejemplo Básico de una Clase Result
Creación de Objetos
Creación de Objetos Result
Ejemplo de Creación y Uso de Objetos
Ejemplo de Creación y Uso de Objetos Result
Constructores
Constructores Result
Destructores
Destructores Result
Modificadores de Acceso
Modificadores de Acceso Result
Ejemplo de Constructor por Defecto
Ejemplo de Constructor por Defecto Result
Ejemplo de Constructor Parametrizado
Ejemplo de Constructor Parametrizado Result
Ejemplo de Constructor de Copia
Ejemplo de Constructor de Copia Result
Ejemplo de Constructor de Movimiento
Ejemplo de Constructor de Movimiento Result
Ejemplo con Lista de Inicialización
Ejemplo con Lista de Inicialización Result
Definición de Atributos Privados
Definición de Atributos Privados Result
Ejemplo de Getters
Ejemplo de Getters Result
Ejemplo de Setters
Ejemplo de Setters Result
Ejemplo Completo
Ejemplo Completo Result
Ejemplo Básico
Ejemplo Básico Result
Ejemplo con Setters y Getters
Ejemplo con Setters y Getters Result
Ejemplo con Herencia
Ejemplo con Herencia Result
Sintaxis del Destructor
Sintaxis del Destructor Result
Ejemplo Básico de Destructor
Ejemplo Básico de Destructor Result
Ejemplo con Recursos Dinámicos
Ejemplo con Recursos Dinámicos Result
Regla de Tres
Regla de Tres Result
Regla de Cinco
Regla de Cinco Result
Ejemplo de Sobrecarga de Operadores
Ejemplo de Sobrecarga de Operadores Result
Ejemplo de Sobrecarga del Operador `*`
Ejemplo de Sobrecarga del Operador `*` Result
Ejemplo de Sobrecarga del Operador `==`
Ejemplo de Sobrecarga del Operador `==` Result
Ejemplo de Sobrecarga del Operador `++`
Ejemplo de Sobrecarga del Operador `++` Result
Ejemplo de Sobrecarga del Operador `[]`
Ejemplo de Sobrecarga del Operador `[]` Result
Ejemplo de Encadenamiento de Métodos
Ejemplo de Encadenamiento de Métodos Result
Ejemplo con Función Constante
Ejemplo con Función Constante Result
Ejemplo de Prevención de Auto-Asignación
Ejemplo de Prevención de Auto-Asignación Result
Ejemplo de Atributos Constantes
Ejemplo de Atributos Constantes Result
Ejemplo de Métodos Constantes
Ejemplo de Métodos Constantes Result
Ejemplo de Const Correctness
Ejemplo de Const Correctness Result
Ejemplo con Puntero `this` en Métodos Constantes
Ejemplo con Puntero `this` en Métodos Constantes Result
Ejemplo de Declaración de Objetos Constantes
Ejemplo de Declaración de Objetos Constantes Result
Ejemplo de Métodos Constantes en Objetos Constantes
Ejemplo de Métodos Constantes en Objetos Constantes Result
Ejemplo de Inicialización de Objetos Constantes
Ejemplo de Inicialización de Objetos Constantes Result
Ejemplo de Puntero a Objeto Constante
Ejemplo de Puntero a Objeto Constante Result
Definición de una Clase
Definición de una Clase Result
Ejemplo Básico de una Clase
Ejemplo Básico de una Clase Result
Creación de Objetos
Creación de Objetos Result
Ejemplo de Creación y Uso de Objetos
Ejemplo de Creación y Uso de Objetos Result
Constructores
Constructores Result
Destructores
Destructores Result
Modificadores de Acceso
Modificadores de Acceso Result
Ejemplo de Constructor por Defecto
Ejemplo de Constructor por Defecto Result
Ejemplo de Constructor Parametrizado
Ejemplo de Constructor Parametrizado Result
Ejemplo de Constructor de Copia
Ejemplo de Constructor de Copia Result
Ejemplo de Constructor de Movimiento
Ejemplo de Constructor de Movimiento Result
Ejemplo con Lista de Inicialización
Ejemplo con Lista de Inicialización Result
Definición de Atributos Privados
Definición de Atributos Privados Result
Ejemplo de Getters
Ejemplo de Getters Result
Ejemplo de Setters
Ejemplo de Setters Result
Ejemplo Completo
Ejemplo Completo Result
Ejemplo Básico
Ejemplo Básico Result
Ejemplo con Setters y Getters
Ejemplo con Setters y Getters Result
Ejemplo con Herencia
Ejemplo con Herencia Result
Sintaxis del Destructor
Sintaxis del Destructor Result
Ejemplo Básico de Destructor
Ejemplo Básico de Destructor Result
Ejemplo con Recursos Dinámicos
Ejemplo con Recursos Dinámicos Result
Regla de Tres
Regla de Tres Result
Regla de Cinco
Regla de Cinco Result
Ejemplo de Sobrecarga de Operadores
Ejemplo de Sobrecarga de Operadores Result
Ejemplo de Sobrecarga del Operador `*`
Ejemplo de Sobrecarga del Operador `*` Result
Ejemplo de Sobrecarga del Operador `==`
Ejemplo de Sobrecarga del Operador `==` Result
Ejemplo de Sobrecarga del Operador `++`
Ejemplo de Sobrecarga del Operador `++` Result
Ejemplo de Sobrecarga del Operador `[]`
Ejemplo de Sobrecarga del Operador `[]` Result
Ejemplo de Encadenamiento de Métodos
Ejemplo de Encadenamiento de Métodos Result
Ejemplo con Función Constante
Ejemplo con Función Constante Result
Ejemplo de Prevención de Auto-Asignación
Ejemplo de Prevención de Auto-Asignación Result
Ejemplo de Atributos Constantes
Ejemplo de Atributos Constantes Result
Ejemplo de Métodos Constantes
Ejemplo de Métodos Constantes Result
Ejemplo de Const Correctness
Ejemplo de Const Correctness Result
Ejemplo con Puntero `this` en Métodos Constantes
Ejemplo con Puntero `this` en Métodos Constantes Result
Ejemplo de Declaración de Objetos Constantes
Ejemplo de Declaración de Objetos Constantes Result
Ejemplo de Métodos Constantes en Objetos Constantes
Ejemplo de Métodos Constantes en Objetos Constantes Result
Ejemplo de Inicialización de Objetos Constantes
Ejemplo de Inicialización de Objetos Constantes Result
Ejemplo de Puntero a Objeto Constante
Ejemplo de Puntero a Objeto Constante Result
Sintaxis
Sintaxis Result
Sin Constructor Explícito
Sin Constructor Explícito Result
Con Constructor Explícito
Con Constructor Explícito Result
Ejemplo con Conversiones
Ejemplo con Conversiones Result
Constructor Implícito
Constructor Implícito Result
Constructor Explícito
Constructor Explícito Result
Definición de una Clase
Definición de una Clase Result
Ejemplo Básico de una Clase
Ejemplo Básico de una Clase Result
Creación de Objetos
Creación de Objetos Result
Ejemplo de Creación y Uso de Objetos
Ejemplo de Creación y Uso de Objetos Result
Constructores
Constructores Result
Destructores
Destructores Result
Modificadores de Acceso
Modificadores de Acceso Result
Ejemplo de Constructor por Defecto
Ejemplo de Constructor por Defecto Result
Ejemplo de Constructor Parametrizado
Ejemplo de Constructor Parametrizado Result
Ejemplo de Constructor de Copia
Ejemplo de Constructor de Copia Result
Ejemplo de Constructor de Movimiento
Ejemplo de Constructor de Movimiento Result
Ejemplo con Lista de Inicialización
Ejemplo con Lista de Inicialización Result
Definición de Atributos Privados
Definición de Atributos Privados Result
Ejemplo de Getters
Ejemplo de Getters Result
Ejemplo de Setters
Ejemplo de Setters Result
Ejemplo Completo
Ejemplo Completo Result
Ejemplo Básico
Ejemplo Básico Result
Ejemplo con Setters y Getters
Ejemplo con Setters y Getters Result
Ejemplo con Herencia
Ejemplo con Herencia Result
Sintaxis del Destructor
Sintaxis del Destructor Result
Ejemplo Básico de Destructor
Ejemplo Básico de Destructor Result
Ejemplo con Recursos Dinámicos
Ejemplo con Recursos Dinámicos Result
Regla de Tres
Regla de Tres Result
Regla de Cinco
Regla de Cinco Result
Ejemplo de Sobrecarga de Operadores
Ejemplo de Sobrecarga de Operadores Result
Ejemplo de Sobrecarga del Operador `*`
Ejemplo de Sobrecarga del Operador `*` Result
Ejemplo de Sobrecarga del Operador `==`
Ejemplo de Sobrecarga del Operador `==` Result
Ejemplo de Sobrecarga del Operador `++`
Ejemplo de Sobrecarga del Operador `++` Result
Ejemplo de Sobrecarga del Operador `[]`
Ejemplo de Sobrecarga del Operador `[]` Result
Ejemplo de Encadenamiento de Métodos
Ejemplo de Encadenamiento de Métodos Result
Ejemplo con Función Constante
Ejemplo con Función Constante Result
Ejemplo de Prevención de Auto-Asignación
Ejemplo de Prevención de Auto-Asignación Result
Ejemplo de Atributos Constantes
Ejemplo de Atributos Constantes Result
Ejemplo de Métodos Constantes
Ejemplo de Métodos Constantes Result
Ejemplo de Const Correctness
Ejemplo de Const Correctness Result
Ejemplo con Puntero `this` en Métodos Constantes
Ejemplo con Puntero `this` en Métodos Constantes Result
Ejemplo de Declaración de Objetos Constantes
Ejemplo de Declaración de Objetos Constantes Result
Ejemplo de Métodos Constantes en Objetos Constantes
Ejemplo de Métodos Constantes en Objetos Constantes Result
Ejemplo de Inicialización de Objetos Constantes
Ejemplo de Inicialización de Objetos Constantes Result
Ejemplo de Puntero a Objeto Constante
Ejemplo de Puntero a Objeto Constante Result
Sintaxis
Sintaxis Result
Sin Constructor Explícito
Sin Constructor Explícito Result
Con Constructor Explícito
Con Constructor Explícito Result
Ejemplo con Conversiones
Ejemplo con Conversiones Result
Constructor Implícito
Constructor Implícito Result
Constructor Explícito
Constructor Explícito Result
Problema de la Copia Superficial
Problema de la Copia Superficial Result
Solución con Constructor de Copia Profunda
Solución con Constructor de Copia Profunda Result
Ejemplo Completo con la Regla de Tres
Ejemplo Completo con la Regla de Tres Result
<---Definición de una Clase--->
```cpp
class NombreClase {
public:
    // Atributos
    tipo_atributo nombre_atributo;

    // Métodos
    tipo_retorno nombre_metodo(parametros);

    // Otros componentes, como constructores, destructores, etc.
};
<---Definición de una Clase Result--->
<---Ejemplo Básico de una Clase--->
```cpp
#include <iostream>
using namespace std;

class Persona {
public:
    // Atributos
    string nombre;
    int edad;

    // Métodos
    void saludar() {
        cout << "Hola, mi nombre es " << nombre << " y tengo " << edad << " años." << endl;
    }
};

int main() {
    // Crear un objeto de la clase Persona
    Persona juan;
    juan.nombre = "Juan";
    juan.edad = 30;

    // Llamar al método saludar
    juan.saludar();

    return 0;
}
<---Ejemplo Básico de una Clase Result--->
<---Creación de Objetos--->
```cpp
NombreClase nombre_objeto;
<---Creación de Objetos Result--->
<---Ejemplo de Creación y Uso de Objetos--->
```cpp
#include <iostream>
using namespace std;

class Coche {
public:
    // Atributos
    string marca;
    string modelo;
    int anio;

    // Métodos
    void mostrarInformacion() {
        cout << "Marca: " << marca << ", Modelo: " << modelo << ", Año: " << anio << endl;
    }
};

int main() {
    // Crear objetos de la clase Coche
    Coche coche1;
    coche1.marca = "Toyota";
    coche1.modelo = "Corolla";
    coche1.anio = 2020;

    Coche coche2;
    coche2.marca = "Honda";
    coche2.modelo = "Civic";
    coche2.anio = 2019;

    // Llamar a los métodos de los objetos
    coche1.mostrarInformacion();
    coche2.mostrarInformacion();

    return 0;
}
<---Ejemplo de Creación y Uso de Objetos Result--->
<---Constructores--->
```cpp
class Persona {
public:
    string nombre;
    int edad;

    // Constructor
    Persona(string n, int e) {
        nombre = n;
        edad = e;
    }

    void saludar() {
        cout << "Hola, mi nombre es " << nombre << " y tengo " << edad << " años." << endl;
    }
};

int main() {
    // Crear un objeto de la clase Persona utilizando el constructor
    Persona juan("Juan", 30);
    juan.saludar();

    return 0;
}
<---Constructores Result--->
<---Destructores--->
```cpp
class Persona {
public:
    string nombre;
    int edad;

    // Constructor
    Persona(string n, int e) {
        nombre = n;
        edad = e;
    }

    // Destructor
    ~Persona() {
        cout << "Destructor llamado para " << nombre << endl;
    }

    void saludar() {
        cout << "Hola, mi nombre es " << nombre << " y tengo " << edad << " años." << endl;
    }
};

int main() {
    // Crear un objeto de la clase Persona
    Persona juan("Juan", 30);
    juan.saludar();

    // El destructor se llamará automáticamente al final del alcance
    return 0;
}
<---Destructores Result--->
<---Modificadores de Acceso--->
```cpp
class Persona {
private:
    string nombre;
    int edad;

public:
    // Constructor
    Persona(string n, int e) : nombre(n), edad(e) {}

    // Métodos para acceder y modificar los atributos
    string getNombre() {
        return nombre;
    }

    void setNombre(string n) {
        nombre = n;
    }

    int getEdad() {
        return edad;
    }

    void setEdad(int e) {
        edad = e;
    }

    void saludar() {
        cout << "Hola, mi nombre es " << nombre << " y tengo " << edad << " años." << endl;
    }
};

int main() {
    Persona juan("Juan", 30);
    juan.saludar();

    juan.setEdad(31);
    cout << "Nueva edad de " << juan.getNombre() << ": " << juan.getEdad() << endl;

    return 0;
}
<---Modificadores de Acceso Result--->
<---Definición de una Clase--->
```cpp
class NombreClase {
public:
    // Atributos
    tipo_atributo nombre_atributo;

    // Métodos
    tipo_retorno nombre_metodo(parametros);

    // Otros componentes, como constructores, destructores, etc.
};
<---Definición de una Clase Result--->
<---Ejemplo Básico de una Clase--->
```cpp
#include <iostream>
using namespace std;

class Persona {
public:
    // Atributos
    string nombre;
    int edad;

    // Métodos
    void saludar() {
        cout << "Hola, mi nombre es " << nombre << " y tengo " << edad << " años." << endl;
    }
};

int main() {
    // Crear un objeto de la clase Persona
    Persona juan;
    juan.nombre = "Juan";
    juan.edad = 30;

    // Llamar al método saludar
    juan.saludar();

    return 0;
}
<---Ejemplo Básico de una Clase Result--->
<---Creación de Objetos--->
```cpp
NombreClase nombre_objeto;
<---Creación de Objetos Result--->
<---Ejemplo de Creación y Uso de Objetos--->
```cpp
#include <iostream>
using namespace std;

class Coche {
public:
    // Atributos
    string marca;
    string modelo;
    int anio;

    // Métodos
    void mostrarInformacion() {
        cout << "Marca: " << marca << ", Modelo: " << modelo << ", Año: " << anio << endl;
    }
};

int main() {
    // Crear objetos de la clase Coche
    Coche coche1;
    coche1.marca = "Toyota";
    coche1.modelo = "Corolla";
    coche1.anio = 2020;

    Coche coche2;
    coche2.marca = "Honda";
    coche2.modelo = "Civic";
    coche2.anio = 2019;

    // Llamar a los métodos de los objetos
    coche1.mostrarInformacion();
    coche2.mostrarInformacion();

    return 0;
}
<---Ejemplo de Creación y Uso de Objetos Result--->
<---Constructores--->
```cpp
class Persona {
public:
    string nombre;
    int edad;

    // Constructor
    Persona(string n, int e) {
        nombre = n;
        edad = e;
    }

    void saludar() {
        cout << "Hola, mi nombre es " << nombre << " y tengo " << edad << " años." << endl;
    }
};

int main() {
    // Crear un objeto de la clase Persona utilizando el constructor
    Persona juan("Juan", 30);
    juan.saludar();

    return 0;
}
<---Constructores Result--->
<---Destructores--->
```cpp
class Persona {
public:
    string nombre;
    int edad;

    // Constructor
    Persona(string n, int e) {
        nombre = n;
        edad = e;
    }

    // Destructor
    ~Persona() {
        cout << "Destructor llamado para " << nombre << endl;
    }

    void saludar() {
        cout << "Hola, mi nombre es " << nombre << " y tengo " << edad << " años." << endl;
    }
};

int main() {
    // Crear un objeto de la clase Persona
    Persona juan("Juan", 30);
    juan.saludar();

    // El destructor se llamará automáticamente al final del alcance
    return 0;
}
<---Destructores Result--->
<---Modificadores de Acceso--->
```cpp
class Persona {
private:
    string nombre;
    int edad;

public:
    // Constructor
    Persona(string n, int e) : nombre(n), edad(e) {}

    // Métodos para acceder y modificar los atributos
    string getNombre() {
        return nombre;
    }

    void setNombre(string n) {
        nombre = n;
    }

    int getEdad() {
        return edad;
    }

    void setEdad(int e) {
        edad = e;
    }

    void saludar() {
        cout << "Hola, mi nombre es " << nombre << " y tengo " << edad << " años." << endl;
    }
};

int main() {
    Persona juan("Juan", 30);
    juan.saludar();

    juan.setEdad(31);
    cout << "Nueva edad de " << juan.getNombre() << ": " << juan.getEdad() << endl;

    return 0;
}
<---Modificadores de Acceso Result--->
<---Ejemplo de Constructor por Defecto--->
```cpp
#include <iostream>
using namespace std;

class Persona {
public:
    string nombre;
    int edad;

    // Constructor por defecto
    Persona() {
        nombre = "Desconocido";
        edad = 0;
    }

    void mostrarInformacion() {
        cout << "Nombre: " << nombre << ", Edad: " << edad << endl;
    }
};

int main() {
    Persona p;  // Llama al constructor por defecto
    p.mostrarInformacion();

    return 0;
}
<---Ejemplo de Constructor por Defecto Result--->
<---Ejemplo de Constructor Parametrizado--->
```cpp
#include <iostream>
using namespace std;

class Persona {
public:
    string nombre;
    int edad;

    // Constructor parametrizado
    Persona(string n, int e) {
        nombre = n;
        edad = e;
    }

    void mostrarInformacion() {
        cout << "Nombre: " << nombre << ", Edad: " << edad << endl;
    }
};

int main() {
    Persona p("Juan", 30);  // Llama al constructor parametrizado
    p.mostrarInformacion();

    return 0;
}
<---Ejemplo de Constructor Parametrizado Result--->
<---Ejemplo de Constructor de Copia--->
```cpp
#include <iostream>
using namespace std;

class Persona {
public:
    string nombre;
    int edad;

    // Constructor parametrizado
    Persona(string n, int e) {
        nombre = n;
        edad = e;
    }

    // Constructor de copia
    Persona(const Persona& p) {
        nombre = p.nombre;
        edad = p.edad;
    }

    void mostrarInformacion() {
        cout << "Nombre: " << nombre << ", Edad: " << edad << endl;
    }
};

int main() {
    Persona p1("Juan", 30);  // Llama al constructor parametrizado
    Persona p2 = p1;         // Llama al constructor de copia
    p2.mostrarInformacion();

    return 0;
}
<---Ejemplo de Constructor de Copia Result--->
<---Ejemplo de Constructor de Movimiento--->
```cpp
#include <iostream>
using namespace std;

class Persona {
public:
    string nombre;
    int edad;

    // Constructor parametrizado
    Persona(string n, int e) : nombre(n), edad(e) {}

    // Constructor de movimiento
    Persona(Persona&& p) noexcept : nombre(move(p.nombre)), edad(p.edad) {
        p.edad = 0; // Opcional: Dejar el objeto fuente en un estado válido
    }

    void mostrarInformacion() {
        cout << "Nombre: " << nombre << ", Edad: " << edad << endl;
    }
};

int main() {
    Persona p1("Juan", 30);  // Llama al constructor parametrizado
    Persona p2 = move(p1);   // Llama al constructor de movimiento
    p2.mostrarInformacion();

    // p1 está en un estado indefinido, pero válido
    cout << "Después de mover, p1: ";
    p1.mostrarInformacion();

    return 0;
}
<---Ejemplo de Constructor de Movimiento Result--->
<---Ejemplo con Lista de Inicialización--->
```cpp
#include <iostream>
using namespace std;

class Punto {
public:
    const int x;
    const int y;

    // Constructor con lista de inicialización
    Punto(int a, int b) : x(a), y(b) {}

    void mostrarInformacion() {
        cout << "Punto(" << x << ", " << y << ")" << endl;
    }
};

int main() {
    Punto p(10, 20);  // Llama al constructor con lista de inicialización
    p.mostrarInformacion();

    return 0;
}
```cpp
#include <iostream>
using namespace std;

class Persona {
private:
    string nombre;
    int edad;

public:
    // Constructor por defecto
    Persona() : nombre("Desconocido"), edad(0) {}

    // Constructor parametrizado
    Persona(string n, int e) : nombre(n), edad(e) {}

    // Constructor de copia
    Persona(const Persona& p) : nombre(p.nombre), edad(p.edad) {}

    // Constructor de movimiento
    Persona(Persona&& p) noexcept : nombre(move(p.nombre)), edad(p.edad) {
        p.edad = 0;
    }

    void mostrarInformacion() {
        cout << "Nombre: " << nombre << ", Edad: " << edad << endl;
    }
};

int main() {
    // Usando el constructor por defecto
    Persona p1;
    p1.mostrarInformacion();

    // Usando el constructor parametrizado
    Persona p2("Juan", 30);
    p2.mostrarInformacion();

    // Usando el constructor de copia
    Persona p3 = p2;
    p3.mostrarInformacion();

    // Usando el constructor de movimiento
    Persona p4 = move(p2);
    p4.mostrarInformacion();

    // Estado después del movimiento
    cout << "Después de mover, p2: ";
    p2.mostrarInformacion();

    return 0;
}
<---Ejemplo con Lista de Inicialización Result--->
<---Definición de una Clase--->
```cpp
class NombreClase {
public:
    // Atributos
    tipo_atributo nombre_atributo;

    // Métodos
    tipo_retorno nombre_metodo(parametros);

    // Otros componentes, como constructores, destructores, etc.
};
<---Definición de una Clase Result--->
<---Ejemplo Básico de una Clase--->
```cpp
#include <iostream>
using namespace std;

class Persona {
public:
    // Atributos
    string nombre;
    int edad;

    // Métodos
    void saludar() {
        cout << "Hola, mi nombre es " << nombre << " y tengo " << edad << " años." << endl;
    }
};

int main() {
    // Crear un objeto de la clase Persona
    Persona juan;
    juan.nombre = "Juan";
    juan.edad = 30;

    // Llamar al método saludar
    juan.saludar();

    return 0;
}
<---Ejemplo Básico de una Clase Result--->
<---Creación de Objetos--->
```cpp
NombreClase nombre_objeto;
<---Creación de Objetos Result--->
<---Ejemplo de Creación y Uso de Objetos--->
```cpp
#include <iostream>
using namespace std;

class Coche {
public:
    // Atributos
    string marca;
    string modelo;
    int anio;

    // Métodos
    void mostrarInformacion() {
        cout << "Marca: " << marca << ", Modelo: " << modelo << ", Año: " << anio << endl;
    }
};

int main() {
    // Crear objetos de la clase Coche
    Coche coche1;
    coche1.marca = "Toyota";
    coche1.modelo = "Corolla";
    coche1.anio = 2020;

    Coche coche2;
    coche2.marca = "Honda";
    coche2.modelo = "Civic";
    coche2.anio = 2019;

    // Llamar a los métodos de los objetos
    coche1.mostrarInformacion();
    coche2.mostrarInformacion();

    return 0;
}
<---Ejemplo de Creación y Uso de Objetos Result--->
<---Constructores--->
```cpp
class Persona {
public:
    string nombre;
    int edad;

    // Constructor
    Persona(string n, int e) {
        nombre = n;
        edad = e;
    }

    void saludar() {
        cout << "Hola, mi nombre es " << nombre << " y tengo " << edad << " años." << endl;
    }
};

int main() {
    // Crear un objeto de la clase Persona utilizando el constructor
    Persona juan("Juan", 30);
    juan.saludar();

    return 0;
}
<---Constructores Result--->
<---Destructores--->
```cpp
class Persona {
public:
    string nombre;
    int edad;

    // Constructor
    Persona(string n, int e) {
        nombre = n;
        edad = e;
    }

    // Destructor
    ~Persona() {
        cout << "Destructor llamado para " << nombre << endl;
    }

    void saludar() {
        cout << "Hola, mi nombre es " << nombre << " y tengo " << edad << " años." << endl;
    }
};

int main() {
    // Crear un objeto de la clase Persona
    Persona juan("Juan", 30);
    juan.saludar();

    // El destructor se llamará automáticamente al final del alcance
    return 0;
}
<---Destructores Result--->
<---Modificadores de Acceso--->
```cpp
class Persona {
private:
    string nombre;
    int edad;

public:
    // Constructor
    Persona(string n, int e) : nombre(n), edad(e) {}

    // Métodos para acceder y modificar los atributos
    string getNombre() {
        return nombre;
    }

    void setNombre(string n) {
        nombre = n;
    }

    int getEdad() {
        return edad;
    }

    void setEdad(int e) {
        edad = e;
    }

    void saludar() {
        cout << "Hola, mi nombre es " << nombre << " y tengo " << edad << " años." << endl;
    }
};

int main() {
    Persona juan("Juan", 30);
    juan.saludar();

    juan.setEdad(31);
    cout << "Nueva edad de " << juan.getNombre() << ": " << juan.getEdad() << endl;

    return 0;
}
<---Modificadores de Acceso Result--->
<---Ejemplo de Constructor por Defecto--->
```cpp
#include <iostream>
using namespace std;

class Persona {
public:
    string nombre;
    int edad;

    // Constructor por defecto
    Persona() {
        nombre = "Desconocido";
        edad = 0;
    }

    void mostrarInformacion() {
        cout << "Nombre: " << nombre << ", Edad: " << edad << endl;
    }
};

int main() {
    Persona p;  // Llama al constructor por defecto
    p.mostrarInformacion();

    return 0;
}
<---Ejemplo de Constructor por Defecto Result--->
<---Ejemplo de Constructor Parametrizado--->
```cpp
#include <iostream>
using namespace std;

class Persona {
public:
    string nombre;
    int edad;

    // Constructor parametrizado
    Persona(string n, int e) {
        nombre = n;
        edad = e;
    }

    void mostrarInformacion() {
        cout << "Nombre: " << nombre << ", Edad: " << edad << endl;
    }
};

int main() {
    Persona p("Juan", 30);  // Llama al constructor parametrizado
    p.mostrarInformacion();

    return 0;
}
<---Ejemplo de Constructor Parametrizado Result--->
<---Ejemplo de Constructor de Copia--->
```cpp
#include <iostream>
using namespace std;

class Persona {
public:
    string nombre;
    int edad;

    // Constructor parametrizado
    Persona(string n, int e) {
        nombre = n;
        edad = e;
    }

    // Constructor de copia
    Persona(const Persona& p) {
        nombre = p.nombre;
        edad = p.edad;
    }

    void mostrarInformacion() {
        cout << "Nombre: " << nombre << ", Edad: " << edad << endl;
    }
};

int main() {
    Persona p1("Juan", 30);  // Llama al constructor parametrizado
    Persona p2 = p1;         // Llama al constructor de copia
    p2.mostrarInformacion();

    return 0;
}
<---Ejemplo de Constructor de Copia Result--->
<---Ejemplo de Constructor de Movimiento--->
```cpp
#include <iostream>
using namespace std;

class Persona {
public:
    string nombre;
    int edad;

    // Constructor parametrizado
    Persona(string n, int e) : nombre(n), edad(e) {}

    // Constructor de movimiento
    Persona(Persona&& p) noexcept : nombre(move(p.nombre)), edad(p.edad) {
        p.edad = 0; // Opcional: Dejar el objeto fuente en un estado válido
    }

    void mostrarInformacion() {
        cout << "Nombre: " << nombre << ", Edad: " << edad << endl;
    }
};

int main() {
    Persona p1("Juan", 30);  // Llama al constructor parametrizado
    Persona p2 = move(p1);   // Llama al constructor de movimiento
    p2.mostrarInformacion();

    // p1 está en un estado indefinido, pero válido
    cout << "Después de mover, p1: ";
    p1.mostrarInformacion();

    return 0;
}
<---Ejemplo de Constructor de Movimiento Result--->
<---Ejemplo con Lista de Inicialización--->
```cpp
#include <iostream>
using namespace std;

class Punto {
public:
    const int x;
    const int y;

    // Constructor con lista de inicialización
    Punto(int a, int b) : x(a), y(b) {}

    void mostrarInformacion() {
        cout << "Punto(" << x << ", " << y << ")" << endl;
    }
};

int main() {
    Punto p(10, 20);  // Llama al constructor con lista de inicialización
    p.mostrarInformacion();

    return 0;
}
```cpp
#include <iostream>
using namespace std;

class Persona {
private:
    string nombre;
    int edad;

public:
    // Constructor por defecto
    Persona() : nombre("Desconocido"), edad(0) {}

    // Constructor parametrizado
    Persona(string n, int e) : nombre(n), edad(e) {}

    // Constructor de copia
    Persona(const Persona& p) : nombre(p.nombre), edad(p.edad) {}

    // Constructor de movimiento
    Persona(Persona&& p) noexcept : nombre(move(p.nombre)), edad(p.edad) {
        p.edad = 0;
    }

    void mostrarInformacion() {
        cout << "Nombre: " << nombre << ", Edad: " << edad << endl;
    }
};

int main() {
    // Usando el constructor por defecto
    Persona p1;
    p1.mostrarInformacion();

    // Usando el constructor parametrizado
    Persona p2("Juan", 30);
    p2.mostrarInformacion();

    // Usando el constructor de copia
    Persona p3 = p2;
    p3.mostrarInformacion();

    // Usando el constructor de movimiento
    Persona p4 = move(p2);
    p4.mostrarInformacion();

    // Estado después del movimiento
    cout << "Después de mover, p2: ";
    p2.mostrarInformacion();

    return 0;
}
<---Ejemplo con Lista de Inicialización Result--->
<---Definición de Atributos Privados--->
```cpp
class Persona {
private:
    string nombre;
    int edad;

public:
    // Métodos públicos
};
<---Definición de Atributos Privados Result--->
<---Ejemplo de Getters--->
```cpp
class Persona {
private:
    string nombre;
    int edad;

public:
    // Constructor
    Persona(string n, int e) : nombre(n), edad(e) {}

    // Getter para el nombre
    string getNombre() const {
        return nombre;
    }

    // Getter para la edad
    int getEdad() const {
        return edad;
    }
};
<---Ejemplo de Getters Result--->
<---Ejemplo de Setters--->
```cpp
class Persona {
private:
    string nombre;
    int edad;

public:
    // Constructor
    Persona(string n, int e) : nombre(n), edad(e) {}

    // Setter para el nombre
    void setNombre(string n) {
        nombre = n;
    }

    // Setter para la edad
    void setEdad(int e) {
        if (e > 0) {  // Validación simple
            edad = e;
        } else {
            cout << "Edad no válida." << endl;
        }
    }

    // Getters
    string getNombre() const {
        return nombre;
    }

    int getEdad() const {
        return edad;
    }
};
<---Ejemplo de Setters Result--->
<---Ejemplo Completo--->
```cpp
#include <iostream>
using namespace std;

class Persona {
private:
    string nombre;
    int edad;

public:
    // Constructor
    Persona(string n, int e) : nombre(n), edad(e) {}

    // Setters
    void setNombre(string n) {
        nombre = n;
    }

    void setEdad(int e) {
        if (e > 0) {
            edad = e;
        } else {
            cout << "Edad no válida." << endl;
        }
    }

    // Getters
    string getNombre() const {
        return nombre;
    }

    int getEdad() const {
        return edad;
    }

    // Método para mostrar información
    void mostrarInformacion() const {
        cout << "Nombre: " << nombre << ", Edad: " << edad << endl;
    }
};

int main() {
    // Crear un objeto de la clase Persona
    Persona juan("Juan", 30);
    juan.mostrarInformacion();

    // Modificar los atributos usando setters
    juan.setNombre("Juan Perez");
    juan.setEdad(31);
    juan.mostrarInformacion();

    // Intentar establecer una edad no válida
    juan.setEdad(-5);
    juan.mostrarInformacion();

    // Acceder a los atributos usando getters
    cout << "Nombre: " << juan.getNombre() << endl;
    cout << "Edad: " << juan.getEdad() << endl;

    return 0;
}
<---Ejemplo Completo Result--->
<---Definición de una Clase--->
```cpp
class NombreClase {
public:
    // Atributos
    tipo_atributo nombre_atributo;

    // Métodos
    tipo_retorno nombre_metodo(parametros);

    // Otros componentes, como constructores, destructores, etc.
};
<---Definición de una Clase Result--->
<---Ejemplo Básico de una Clase--->
```cpp
#include <iostream>
using namespace std;

class Persona {
public:
    // Atributos
    string nombre;
    int edad;

    // Métodos
    void saludar() {
        cout << "Hola, mi nombre es " << nombre << " y tengo " << edad << " años." << endl;
    }
};

int main() {
    // Crear un objeto de la clase Persona
    Persona juan;
    juan.nombre = "Juan";
    juan.edad = 30;

    // Llamar al método saludar
    juan.saludar();

    return 0;
}
<---Ejemplo Básico de una Clase Result--->
<---Creación de Objetos--->
```cpp
NombreClase nombre_objeto;
<---Creación de Objetos Result--->
<---Ejemplo de Creación y Uso de Objetos--->
```cpp
#include <iostream>
using namespace std;

class Coche {
public:
    // Atributos
    string marca;
    string modelo;
    int anio;

    // Métodos
    void mostrarInformacion() {
        cout << "Marca: " << marca << ", Modelo: " << modelo << ", Año: " << anio << endl;
    }
};

int main() {
    // Crear objetos de la clase Coche
    Coche coche1;
    coche1.marca = "Toyota";
    coche1.modelo = "Corolla";
    coche1.anio = 2020;

    Coche coche2;
    coche2.marca = "Honda";
    coche2.modelo = "Civic";
    coche2.anio = 2019;

    // Llamar a los métodos de los objetos
    coche1.mostrarInformacion();
    coche2.mostrarInformacion();

    return 0;
}
<---Ejemplo de Creación y Uso de Objetos Result--->
<---Constructores--->
```cpp
class Persona {
public:
    string nombre;
    int edad;

    // Constructor
    Persona(string n, int e) {
        nombre = n;
        edad = e;
    }

    void saludar() {
        cout << "Hola, mi nombre es " << nombre << " y tengo " << edad << " años." << endl;
    }
};

int main() {
    // Crear un objeto de la clase Persona utilizando el constructor
    Persona juan("Juan", 30);
    juan.saludar();

    return 0;
}
<---Constructores Result--->
<---Destructores--->
```cpp
class Persona {
public:
    string nombre;
    int edad;

    // Constructor
    Persona(string n, int e) {
        nombre = n;
        edad = e;
    }

    // Destructor
    ~Persona() {
        cout << "Destructor llamado para " << nombre << endl;
    }

    void saludar() {
        cout << "Hola, mi nombre es " << nombre << " y tengo " << edad << " años." << endl;
    }
};

int main() {
    // Crear un objeto de la clase Persona
    Persona juan("Juan", 30);
    juan.saludar();

    // El destructor se llamará automáticamente al final del alcance
    return 0;
}
<---Destructores Result--->
<---Modificadores de Acceso--->
```cpp
class Persona {
private:
    string nombre;
    int edad;

public:
    // Constructor
    Persona(string n, int e) : nombre(n), edad(e) {}

    // Métodos para acceder y modificar los atributos
    string getNombre() {
        return nombre;
    }

    void setNombre(string n) {
        nombre = n;
    }

    int getEdad() {
        return edad;
    }

    void setEdad(int e) {
        edad = e;
    }

    void saludar() {
        cout << "Hola, mi nombre es " << nombre << " y tengo " << edad << " años." << endl;
    }
};

int main() {
    Persona juan("Juan", 30);
    juan.saludar();

    juan.setEdad(31);
    cout << "Nueva edad de " << juan.getNombre() << ": " << juan.getEdad() << endl;

    return 0;
}
<---Modificadores de Acceso Result--->
<---Ejemplo de Constructor por Defecto--->
```cpp
#include <iostream>
using namespace std;

class Persona {
public:
    string nombre;
    int edad;

    // Constructor por defecto
    Persona() {
        nombre = "Desconocido";
        edad = 0;
    }

    void mostrarInformacion() {
        cout << "Nombre: " << nombre << ", Edad: " << edad << endl;
    }
};

int main() {
    Persona p;  // Llama al constructor por defecto
    p.mostrarInformacion();

    return 0;
}
<---Ejemplo de Constructor por Defecto Result--->
<---Ejemplo de Constructor Parametrizado--->
```cpp
#include <iostream>
using namespace std;

class Persona {
public:
    string nombre;
    int edad;

    // Constructor parametrizado
    Persona(string n, int e) {
        nombre = n;
        edad = e;
    }

    void mostrarInformacion() {
        cout << "Nombre: " << nombre << ", Edad: " << edad << endl;
    }
};

int main() {
    Persona p("Juan", 30);  // Llama al constructor parametrizado
    p.mostrarInformacion();

    return 0;
}
<---Ejemplo de Constructor Parametrizado Result--->
<---Ejemplo de Constructor de Copia--->
```cpp
#include <iostream>
using namespace std;

class Persona {
public:
    string nombre;
    int edad;

    // Constructor parametrizado
    Persona(string n, int e) {
        nombre = n;
        edad = e;
    }

    // Constructor de copia
    Persona(const Persona& p) {
        nombre = p.nombre;
        edad = p.edad;
    }

    void mostrarInformacion() {
        cout << "Nombre: " << nombre << ", Edad: " << edad << endl;
    }
};

int main() {
    Persona p1("Juan", 30);  // Llama al constructor parametrizado
    Persona p2 = p1;         // Llama al constructor de copia
    p2.mostrarInformacion();

    return 0;
}
<---Ejemplo de Constructor de Copia Result--->
<---Ejemplo de Constructor de Movimiento--->
```cpp
#include <iostream>
using namespace std;

class Persona {
public:
    string nombre;
    int edad;

    // Constructor parametrizado
    Persona(string n, int e) : nombre(n), edad(e) {}

    // Constructor de movimiento
    Persona(Persona&& p) noexcept : nombre(move(p.nombre)), edad(p.edad) {
        p.edad = 0; // Opcional: Dejar el objeto fuente en un estado válido
    }

    void mostrarInformacion() {
        cout << "Nombre: " << nombre << ", Edad: " << edad << endl;
    }
};

int main() {
    Persona p1("Juan", 30);  // Llama al constructor parametrizado
    Persona p2 = move(p1);   // Llama al constructor de movimiento
    p2.mostrarInformacion();

    // p1 está en un estado indefinido, pero válido
    cout << "Después de mover, p1: ";
    p1.mostrarInformacion();

    return 0;
}
<---Ejemplo de Constructor de Movimiento Result--->
<---Ejemplo con Lista de Inicialización--->
```cpp
#include <iostream>
using namespace std;

class Punto {
public:
    const int x;
    const int y;

    // Constructor con lista de inicialización
    Punto(int a, int b) : x(a), y(b) {}

    void mostrarInformacion() {
        cout << "Punto(" << x << ", " << y << ")" << endl;
    }
};

int main() {
    Punto p(10, 20);  // Llama al constructor con lista de inicialización
    p.mostrarInformacion();

    return 0;
}
```cpp
#include <iostream>
using namespace std;

class Persona {
private:
    string nombre;
    int edad;

public:
    // Constructor por defecto
    Persona() : nombre("Desconocido"), edad(0) {}

    // Constructor parametrizado
    Persona(string n, int e) : nombre(n), edad(e) {}

    // Constructor de copia
    Persona(const Persona& p) : nombre(p.nombre), edad(p.edad) {}

    // Constructor de movimiento
    Persona(Persona&& p) noexcept : nombre(move(p.nombre)), edad(p.edad) {
        p.edad = 0;
    }

    void mostrarInformacion() {
        cout << "Nombre: " << nombre << ", Edad: " << edad << endl;
    }
};

int main() {
    // Usando el constructor por defecto
    Persona p1;
    p1.mostrarInformacion();

    // Usando el constructor parametrizado
    Persona p2("Juan", 30);
    p2.mostrarInformacion();

    // Usando el constructor de copia
    Persona p3 = p2;
    p3.mostrarInformacion();

    // Usando el constructor de movimiento
    Persona p4 = move(p2);
    p4.mostrarInformacion();

    // Estado después del movimiento
    cout << "Después de mover, p2: ";
    p2.mostrarInformacion();

    return 0;
}
<---Ejemplo con Lista de Inicialización Result--->
<---Definición de Atributos Privados--->
```cpp
class Persona {
private:
    string nombre;
    int edad;

public:
    // Métodos públicos
};
<---Definición de Atributos Privados Result--->
<---Ejemplo de Getters--->
```cpp
class Persona {
private:
    string nombre;
    int edad;

public:
    // Constructor
    Persona(string n, int e) : nombre(n), edad(e) {}

    // Getter para el nombre
    string getNombre() const {
        return nombre;
    }

    // Getter para la edad
    int getEdad() const {
        return edad;
    }
};
<---Ejemplo de Getters Result--->
<---Ejemplo de Setters--->
```cpp
class Persona {
private:
    string nombre;
    int edad;

public:
    // Constructor
    Persona(string n, int e) : nombre(n), edad(e) {}

    // Setter para el nombre
    void setNombre(string n) {
        nombre = n;
    }

    // Setter para la edad
    void setEdad(int e) {
        if (e > 0) {  // Validación simple
            edad = e;
        } else {
            cout << "Edad no válida." << endl;
        }
    }

    // Getters
    string getNombre() const {
        return nombre;
    }

    int getEdad() const {
        return edad;
    }
};
<---Ejemplo de Setters Result--->
<---Ejemplo Completo--->
```cpp
#include <iostream>
using namespace std;

class Persona {
private:
    string nombre;
    int edad;

public:
    // Constructor
    Persona(string n, int e) : nombre(n), edad(e) {}

    // Setters
    void setNombre(string n) {
        nombre = n;
    }

    void setEdad(int e) {
        if (e > 0) {
            edad = e;
        } else {
            cout << "Edad no válida." << endl;
        }
    }

    // Getters
    string getNombre() const {
        return nombre;
    }

    int getEdad() const {
        return edad;
    }

    // Método para mostrar información
    void mostrarInformacion() const {
        cout << "Nombre: " << nombre << ", Edad: " << edad << endl;
    }
};

int main() {
    // Crear un objeto de la clase Persona
    Persona juan("Juan", 30);
    juan.mostrarInformacion();

    // Modificar los atributos usando setters
    juan.setNombre("Juan Perez");
    juan.setEdad(31);
    juan.mostrarInformacion();

    // Intentar establecer una edad no válida
    juan.setEdad(-5);
    juan.mostrarInformacion();

    // Acceder a los atributos usando getters
    cout << "Nombre: " << juan.getNombre() << endl;
    cout << "Edad: " << juan.getEdad() << endl;

    return 0;
}
<---Ejemplo Completo Result--->
<---Ejemplo Básico--->
```cpp
#include <iostream>
using namespace std;

class Ejemplo {
private:
    int datoPrivado; // Acceso privado

public:
    int datoPublico; // Acceso público

    // Constructor
    Ejemplo(int privado, int publico) : datoPrivado(privado), datoPublico(publico) {}

    // Método público para acceder al dato privado
    int getDatoPrivado() const {
        return datoPrivado;
    }

    // Método público para modificar el dato privado
    void setDatoPrivado(int valor) {
        datoPrivado = valor;
    }
};

int main() {
    Ejemplo obj(10, 20);

    // Acceso al dato público
    cout << "Dato público: " << obj.datoPublico << endl;

    // Acceso al dato privado a través de métodos públicos
    cout << "Dato privado: " << obj.getDatoPrivado() << endl;
    obj.setDatoPrivado(30);
    cout << "Dato privado modificado: " << obj.getDatoPrivado() << endl;

    return 0;
}
<---Ejemplo Básico Result--->
<---Ejemplo con Setters y Getters--->
```cpp
#include <iostream>
using namespace std;

class Persona {
private:
    string nombre;
    int edad;

public:
    // Constructor
    Persona(string n, int e) : nombre(n), edad(e) {}

    // Getter para nombre
    string getNombre() const {
        return nombre;
    }

    // Setter para nombre
    void setNombre(string n) {
        nombre = n;
    }

    // Getter para edad
    int getEdad() const {
        return edad;
    }

    // Setter para edad con validación
    void setEdad(int e) {
        if (e > 0) {
            edad = e;
        } else {
            cout << "Edad no válida" << endl;
        }
    }

    // Método para mostrar información
    void mostrarInformacion() const {
        cout << "Nombre: " << nombre << ", Edad: " << edad << endl;
    }
};

int main() {
    Persona juan("Juan", 30);
    juan.mostrarInformacion();

    // Modificar atributos usando setters
    juan.setNombre("Juan Perez");
    juan.setEdad(31);
    juan.mostrarInformacion();

    // Intentar establecer una edad no válida
    juan.setEdad(-5);
    juan.mostrarInformacion();

    return 0;
}
<---Ejemplo con Setters y Getters Result--->
<---Ejemplo con Herencia--->
```cpp
#include <iostream>
using namespace std;

class Base {
private:
    int datoPrivado;

protected:
    int datoProtegido;

public:
    int datoPublico;

    Base(int priv, int prot, int pub) : datoPrivado(priv), datoProtegido(prot), datoPublico(pub) {}

    int getDatoPrivado() const {
        return datoPrivado;
    }

    int getDatoProtegido() const {
        return datoProtegido;
    }
};

class Derivada : public Base {
public:
    Derivada(int priv, int prot, int pub) : Base(priv, prot, pub) {}

    void mostrarDatos() {
        // cout << "Dato privado: " << getDatoPrivado() << endl; // No se puede acceder directamente
        cout << "Dato protegido: " << getDatoProtegido() << endl;
        cout << "Dato público: " << datoPublico << endl;
    }
};

int main() {
    Derivada obj(1, 2, 3);
    obj.mostrarDatos();

    return 0;
}
<---Ejemplo con Herencia Result--->
<---Definición de una Clase--->
```cpp
class NombreClase {
public:
    // Atributos
    tipo_atributo nombre_atributo;

    // Métodos
    tipo_retorno nombre_metodo(parametros);

    // Otros componentes, como constructores, destructores, etc.
};
<---Definición de una Clase Result--->
<---Ejemplo Básico de una Clase--->
```cpp
#include <iostream>
using namespace std;

class Persona {
public:
    // Atributos
    string nombre;
    int edad;

    // Métodos
    void saludar() {
        cout << "Hola, mi nombre es " << nombre << " y tengo " << edad << " años." << endl;
    }
};

int main() {
    // Crear un objeto de la clase Persona
    Persona juan;
    juan.nombre = "Juan";
    juan.edad = 30;

    // Llamar al método saludar
    juan.saludar();

    return 0;
}
<---Ejemplo Básico de una Clase Result--->
<---Creación de Objetos--->
```cpp
NombreClase nombre_objeto;
<---Creación de Objetos Result--->
<---Ejemplo de Creación y Uso de Objetos--->
```cpp
#include <iostream>
using namespace std;

class Coche {
public:
    // Atributos
    string marca;
    string modelo;
    int anio;

    // Métodos
    void mostrarInformacion() {
        cout << "Marca: " << marca << ", Modelo: " << modelo << ", Año: " << anio << endl;
    }
};

int main() {
    // Crear objetos de la clase Coche
    Coche coche1;
    coche1.marca = "Toyota";
    coche1.modelo = "Corolla";
    coche1.anio = 2020;

    Coche coche2;
    coche2.marca = "Honda";
    coche2.modelo = "Civic";
    coche2.anio = 2019;

    // Llamar a los métodos de los objetos
    coche1.mostrarInformacion();
    coche2.mostrarInformacion();

    return 0;
}
<---Ejemplo de Creación y Uso de Objetos Result--->
<---Constructores--->
```cpp
class Persona {
public:
    string nombre;
    int edad;

    // Constructor
    Persona(string n, int e) {
        nombre = n;
        edad = e;
    }

    void saludar() {
        cout << "Hola, mi nombre es " << nombre << " y tengo " << edad << " años." << endl;
    }
};

int main() {
    // Crear un objeto de la clase Persona utilizando el constructor
    Persona juan("Juan", 30);
    juan.saludar();

    return 0;
}
<---Constructores Result--->
<---Destructores--->
```cpp
class Persona {
public:
    string nombre;
    int edad;

    // Constructor
    Persona(string n, int e) {
        nombre = n;
        edad = e;
    }

    // Destructor
    ~Persona() {
        cout << "Destructor llamado para " << nombre << endl;
    }

    void saludar() {
        cout << "Hola, mi nombre es " << nombre << " y tengo " << edad << " años." << endl;
    }
};

int main() {
    // Crear un objeto de la clase Persona
    Persona juan("Juan", 30);
    juan.saludar();

    // El destructor se llamará automáticamente al final del alcance
    return 0;
}
<---Destructores Result--->
<---Modificadores de Acceso--->
```cpp
class Persona {
private:
    string nombre;
    int edad;

public:
    // Constructor
    Persona(string n, int e) : nombre(n), edad(e) {}

    // Métodos para acceder y modificar los atributos
    string getNombre() {
        return nombre;
    }

    void setNombre(string n) {
        nombre = n;
    }

    int getEdad() {
        return edad;
    }

    void setEdad(int e) {
        edad = e;
    }

    void saludar() {
        cout << "Hola, mi nombre es " << nombre << " y tengo " << edad << " años." << endl;
    }
};

int main() {
    Persona juan("Juan", 30);
    juan.saludar();

    juan.setEdad(31);
    cout << "Nueva edad de " << juan.getNombre() << ": " << juan.getEdad() << endl;

    return 0;
}
<---Modificadores de Acceso Result--->
<---Ejemplo de Constructor por Defecto--->
```cpp
#include <iostream>
using namespace std;

class Persona {
public:
    string nombre;
    int edad;

    // Constructor por defecto
    Persona() {
        nombre = "Desconocido";
        edad = 0;
    }

    void mostrarInformacion() {
        cout << "Nombre: " << nombre << ", Edad: " << edad << endl;
    }
};

int main() {
    Persona p;  // Llama al constructor por defecto
    p.mostrarInformacion();

    return 0;
}
<---Ejemplo de Constructor por Defecto Result--->
<---Ejemplo de Constructor Parametrizado--->
```cpp
#include <iostream>
using namespace std;

class Persona {
public:
    string nombre;
    int edad;

    // Constructor parametrizado
    Persona(string n, int e) {
        nombre = n;
        edad = e;
    }

    void mostrarInformacion() {
        cout << "Nombre: " << nombre << ", Edad: " << edad << endl;
    }
};

int main() {
    Persona p("Juan", 30);  // Llama al constructor parametrizado
    p.mostrarInformacion();

    return 0;
}
<---Ejemplo de Constructor Parametrizado Result--->
<---Ejemplo de Constructor de Copia--->
```cpp
#include <iostream>
using namespace std;

class Persona {
public:
    string nombre;
    int edad;

    // Constructor parametrizado
    Persona(string n, int e) {
        nombre = n;
        edad = e;
    }

    // Constructor de copia
    Persona(const Persona& p) {
        nombre = p.nombre;
        edad = p.edad;
    }

    void mostrarInformacion() {
        cout << "Nombre: " << nombre << ", Edad: " << edad << endl;
    }
};

int main() {
    Persona p1("Juan", 30);  // Llama al constructor parametrizado
    Persona p2 = p1;         // Llama al constructor de copia
    p2.mostrarInformacion();

    return 0;
}
<---Ejemplo de Constructor de Copia Result--->
<---Ejemplo de Constructor de Movimiento--->
```cpp
#include <iostream>
using namespace std;

class Persona {
public:
    string nombre;
    int edad;

    // Constructor parametrizado
    Persona(string n, int e) : nombre(n), edad(e) {}

    // Constructor de movimiento
    Persona(Persona&& p) noexcept : nombre(move(p.nombre)), edad(p.edad) {
        p.edad = 0; // Opcional: Dejar el objeto fuente en un estado válido
    }

    void mostrarInformacion() {
        cout << "Nombre: " << nombre << ", Edad: " << edad << endl;
    }
};

int main() {
    Persona p1("Juan", 30);  // Llama al constructor parametrizado
    Persona p2 = move(p1);   // Llama al constructor de movimiento
    p2.mostrarInformacion();

    // p1 está en un estado indefinido, pero válido
    cout << "Después de mover, p1: ";
    p1.mostrarInformacion();

    return 0;
}
<---Ejemplo de Constructor de Movimiento Result--->
<---Ejemplo con Lista de Inicialización--->
```cpp
#include <iostream>
using namespace std;

class Punto {
public:
    const int x;
    const int y;

    // Constructor con lista de inicialización
    Punto(int a, int b) : x(a), y(b) {}

    void mostrarInformacion() {
        cout << "Punto(" << x << ", " << y << ")" << endl;
    }
};

int main() {
    Punto p(10, 20);  // Llama al constructor con lista de inicialización
    p.mostrarInformacion();

    return 0;
}
```cpp
#include <iostream>
using namespace std;

class Persona {
private:
    string nombre;
    int edad;

public:
    // Constructor por defecto
    Persona() : nombre("Desconocido"), edad(0) {}

    // Constructor parametrizado
    Persona(string n, int e) : nombre(n), edad(e) {}

    // Constructor de copia
    Persona(const Persona& p) : nombre(p.nombre), edad(p.edad) {}

    // Constructor de movimiento
    Persona(Persona&& p) noexcept : nombre(move(p.nombre)), edad(p.edad) {
        p.edad = 0;
    }

    void mostrarInformacion() {
        cout << "Nombre: " << nombre << ", Edad: " << edad << endl;
    }
};

int main() {
    // Usando el constructor por defecto
    Persona p1;
    p1.mostrarInformacion();

    // Usando el constructor parametrizado
    Persona p2("Juan", 30);
    p2.mostrarInformacion();

    // Usando el constructor de copia
    Persona p3 = p2;
    p3.mostrarInformacion();

    // Usando el constructor de movimiento
    Persona p4 = move(p2);
    p4.mostrarInformacion();

    // Estado después del movimiento
    cout << "Después de mover, p2: ";
    p2.mostrarInformacion();

    return 0;
}
<---Ejemplo con Lista de Inicialización Result--->
<---Definición de Atributos Privados--->
```cpp
class Persona {
private:
    string nombre;
    int edad;

public:
    // Métodos públicos
};
<---Definición de Atributos Privados Result--->
<---Ejemplo de Getters--->
```cpp
class Persona {
private:
    string nombre;
    int edad;

public:
    // Constructor
    Persona(string n, int e) : nombre(n), edad(e) {}

    // Getter para el nombre
    string getNombre() const {
        return nombre;
    }

    // Getter para la edad
    int getEdad() const {
        return edad;
    }
};
<---Ejemplo de Getters Result--->
<---Ejemplo de Setters--->
```cpp
class Persona {
private:
    string nombre;
    int edad;

public:
    // Constructor
    Persona(string n, int e) : nombre(n), edad(e) {}

    // Setter para el nombre
    void setNombre(string n) {
        nombre = n;
    }

    // Setter para la edad
    void setEdad(int e) {
        if (e > 0) {  // Validación simple
            edad = e;
        } else {
            cout << "Edad no válida." << endl;
        }
    }

    // Getters
    string getNombre() const {
        return nombre;
    }

    int getEdad() const {
        return edad;
    }
};
<---Ejemplo de Setters Result--->
<---Ejemplo Completo--->
```cpp
#include <iostream>
using namespace std;

class Persona {
private:
    string nombre;
    int edad;

public:
    // Constructor
    Persona(string n, int e) : nombre(n), edad(e) {}

    // Setters
    void setNombre(string n) {
        nombre = n;
    }

    void setEdad(int e) {
        if (e > 0) {
            edad = e;
        } else {
            cout << "Edad no válida." << endl;
        }
    }

    // Getters
    string getNombre() const {
        return nombre;
    }

    int getEdad() const {
        return edad;
    }

    // Método para mostrar información
    void mostrarInformacion() const {
        cout << "Nombre: " << nombre << ", Edad: " << edad << endl;
    }
};

int main() {
    // Crear un objeto de la clase Persona
    Persona juan("Juan", 30);
    juan.mostrarInformacion();

    // Modificar los atributos usando setters
    juan.setNombre("Juan Perez");
    juan.setEdad(31);
    juan.mostrarInformacion();

    // Intentar establecer una edad no válida
    juan.setEdad(-5);
    juan.mostrarInformacion();

    // Acceder a los atributos usando getters
    cout << "Nombre: " << juan.getNombre() << endl;
    cout << "Edad: " << juan.getEdad() << endl;

    return 0;
}
<---Ejemplo Completo Result--->
<---Ejemplo Básico--->
```cpp
#include <iostream>
using namespace std;

class Ejemplo {
private:
    int datoPrivado; // Acceso privado

public:
    int datoPublico; // Acceso público

    // Constructor
    Ejemplo(int privado, int publico) : datoPrivado(privado), datoPublico(publico) {}

    // Método público para acceder al dato privado
    int getDatoPrivado() const {
        return datoPrivado;
    }

    // Método público para modificar el dato privado
    void setDatoPrivado(int valor) {
        datoPrivado = valor;
    }
};

int main() {
    Ejemplo obj(10, 20);

    // Acceso al dato público
    cout << "Dato público: " << obj.datoPublico << endl;

    // Acceso al dato privado a través de métodos públicos
    cout << "Dato privado: " << obj.getDatoPrivado() << endl;
    obj.setDatoPrivado(30);
    cout << "Dato privado modificado: " << obj.getDatoPrivado() << endl;

    return 0;
}
<---Ejemplo Básico Result--->
<---Ejemplo con Setters y Getters--->
```cpp
#include <iostream>
using namespace std;

class Persona {
private:
    string nombre;
    int edad;

public:
    // Constructor
    Persona(string n, int e) : nombre(n), edad(e) {}

    // Getter para nombre
    string getNombre() const {
        return nombre;
    }

    // Setter para nombre
    void setNombre(string n) {
        nombre = n;
    }

    // Getter para edad
    int getEdad() const {
        return edad;
    }

    // Setter para edad con validación
    void setEdad(int e) {
        if (e > 0) {
            edad = e;
        } else {
            cout << "Edad no válida" << endl;
        }
    }

    // Método para mostrar información
    void mostrarInformacion() const {
        cout << "Nombre: " << nombre << ", Edad: " << edad << endl;
    }
};

int main() {
    Persona juan("Juan", 30);
    juan.mostrarInformacion();

    // Modificar atributos usando setters
    juan.setNombre("Juan Perez");
    juan.setEdad(31);
    juan.mostrarInformacion();

    // Intentar establecer una edad no válida
    juan.setEdad(-5);
    juan.mostrarInformacion();

    return 0;
}
<---Ejemplo con Setters y Getters Result--->
<---Ejemplo con Herencia--->
```cpp
#include <iostream>
using namespace std;

class Base {
public:
    // Constructor
    Base() {
        cout << "Constructor de Base" << endl;
    }

    // Destructor virtual
    virtual ~Base() {
        cout << "Destructor de Base" << endl;
    }
};

class Derivada : public Base {
public:
    // Constructor
    Derivada() {
        cout << "Constructor de Derivada" << endl;
    }

    // Destructor
    ~Derivada() {
        cout << "Destructor de Derivada" << endl;
    }
};

int main() {
    Base* obj = new Derivada(); // Crear objeto de clase derivada
    delete obj; // Llamar al destructor virtual

    return 0;
}
<---Ejemplo con Herencia Result--->
<---Sintaxis del Destructor--->
```cpp
class NombreClase {
public:
    // Constructor
    NombreClase();

    // Destructor
    ~NombreClase();

    // Otros métodos y atributos
};
<---Sintaxis del Destructor Result--->
<---Ejemplo Básico de Destructor--->
```cpp
#include <iostream>
using namespace std;

class Persona {
public:
    string nombre;

    // Constructor
    Persona(string n) : nombre(n) {
        cout << "Constructor llamado para " << nombre << endl;
    }

    // Destructor
    ~Persona() {
        cout << "Destructor llamado para " << nombre << endl;
    }
};

int main() {
    Persona juan("Juan");
    {
        Persona maria("Maria");
    } // Destructor llamado para maria aquí

    cout << "Fin del main" << endl;
    return 0; // Destructor llamado para juan aquí
}
<---Ejemplo Básico de Destructor Result--->
<---Ejemplo con Recursos Dinámicos--->
```cpp
#include <iostream>
using namespace std;

class Array {
private:
    int* data;
    int size;

public:
    // Constructor
    Array(int s) : size(s) {
        data = new int[size]; // Asignar memoria dinámica
        cout << "Array de tamaño " << size << " creado." << endl;
    }

    // Destructor
    ~Array() {
        delete[] data; // Liberar memoria dinámica
        cout << "Array de tamaño " << size << " destruido." << endl;
    }

    // Método para establecer un valor en el array
    void setValue(int index, int value) {
        if (index >= 0 && index < size) {
            data[index] = value;
        }
    }

    // Método para obtener un valor del array
    int getValue(int index) const {
        if (index >= 0 && index < size) {
            return data[index];
        }
        return -1; // Valor de error
    }
};

int main() {
    Array arr(5);
    arr.setValue(0, 10);
    arr.setValue(1, 20);
    cout << "Valor en la posición 0: " << arr.getValue(0) << endl;
    cout << "Valor en la posición 1: " << arr.getValue(1) << endl;

    return 0;
}
<---Ejemplo con Recursos Dinámicos Result--->
<---Regla de Tres--->
```cpp
class Ejemplo {
private:
    int* data;

public:
    // Constructor
    Ejemplo(int size) {
        data = new int[size];
    }

    // Destructor
    ~Ejemplo() {
        delete[] data;
    }

    // Constructor de copia
    Ejemplo(const Ejemplo& other) {
        data = new int[other.size];
        // Copiar datos...
    }

    // Operador de asignación de copia
    Ejemplo& operator=(const Ejemplo& other) {
        if (this != &other) {
            delete[] data;
            data = new int[other.size];
            // Copiar datos...
        }
        return *this;
    }
};
<---Regla de Tres Result--->
<---Regla de Cinco--->
```cpp
class Ejemplo {
private:
    int* data;

public:
    // Constructor
    Ejemplo(int size) {
        data = new int[size];
    }

    // Destructor
    ~Ejemplo() {
        delete[] data;
    }

    // Constructor de copia
    Ejemplo(const Ejemplo& other) {
        data = new int[other.size];
        // Copiar datos...
    }

    // Operador de asignación de copia
    Ejemplo& operator=(const Ejemplo& other) {
        if (this != &other) {
            delete[] data;
            data = new int[other.size];
            // Copiar datos...
        }
        return *this;
    }

    // Constructor de movimiento
    Ejemplo(Ejemplo&& other) noexcept : data(other.data) {
        other.data = nullptr;
    }

    // Operador de asignación de movimiento
    Ejemplo& operator=(Ejemplo&& other) noexcept {
        if (this != &other) {
            delete[] data;
            data = other.data;
            other.data = nullptr;
        }
        return *this;
    }
};
<---Regla de Cinco Result--->
<---Definición de una Clase--->
```cpp
class NombreClase {
public:
    // Atributos
    tipo_atributo nombre_atributo;

    // Métodos
    tipo_retorno nombre_metodo(parametros);

    // Otros componentes, como constructores, destructores, etc.
};
<---Definición de una Clase Result--->
<---Ejemplo Básico de una Clase--->
```cpp
#include <iostream>
using namespace std;

class Persona {
public:
    // Atributos
    string nombre;
    int edad;

    // Métodos
    void saludar() {
        cout << "Hola, mi nombre es " << nombre << " y tengo " << edad << " años." << endl;
    }
};

int main() {
    // Crear un objeto de la clase Persona
    Persona juan;
    juan.nombre = "Juan";
    juan.edad = 30;

    // Llamar al método saludar
    juan.saludar();

    return 0;
}
<---Ejemplo Básico de una Clase Result--->
<---Creación de Objetos--->
```cpp
NombreClase nombre_objeto;
<---Creación de Objetos Result--->
<---Ejemplo de Creación y Uso de Objetos--->
```cpp
#include <iostream>
using namespace std;

class Coche {
public:
    // Atributos
    string marca;
    string modelo;
    int anio;

    // Métodos
    void mostrarInformacion() {
        cout << "Marca: " << marca << ", Modelo: " << modelo << ", Año: " << anio << endl;
    }
};

int main() {
    // Crear objetos de la clase Coche
    Coche coche1;
    coche1.marca = "Toyota";
    coche1.modelo = "Corolla";
    coche1.anio = 2020;

    Coche coche2;
    coche2.marca = "Honda";
    coche2.modelo = "Civic";
    coche2.anio = 2019;

    // Llamar a los métodos de los objetos
    coche1.mostrarInformacion();
    coche2.mostrarInformacion();

    return 0;
}
<---Ejemplo de Creación y Uso de Objetos Result--->
<---Constructores--->
```cpp
class Persona {
public:
    string nombre;
    int edad;

    // Constructor
    Persona(string n, int e) {
        nombre = n;
        edad = e;
    }

    void saludar() {
        cout << "Hola, mi nombre es " << nombre << " y tengo " << edad << " años." << endl;
    }
};

int main() {
    // Crear un objeto de la clase Persona utilizando el constructor
    Persona juan("Juan", 30);
    juan.saludar();

    return 0;
}
<---Constructores Result--->
<---Destructores--->
```cpp
class Persona {
public:
    string nombre;
    int edad;

    // Constructor
    Persona(string n, int e) {
        nombre = n;
        edad = e;
    }

    // Destructor
    ~Persona() {
        cout << "Destructor llamado para " << nombre << endl;
    }

    void saludar() {
        cout << "Hola, mi nombre es " << nombre << " y tengo " << edad << " años." << endl;
    }
};

int main() {
    // Crear un objeto de la clase Persona
    Persona juan("Juan", 30);
    juan.saludar();

    // El destructor se llamará automáticamente al final del alcance
    return 0;
}
<---Destructores Result--->
<---Modificadores de Acceso--->
```cpp
class Persona {
private:
    string nombre;
    int edad;

public:
    // Constructor
    Persona(string n, int e) : nombre(n), edad(e) {}

    // Métodos para acceder y modificar los atributos
    string getNombre() {
        return nombre;
    }

    void setNombre(string n) {
        nombre = n;
    }

    int getEdad() {
        return edad;
    }

    void setEdad(int e) {
        edad = e;
    }

    void saludar() {
        cout << "Hola, mi nombre es " << nombre << " y tengo " << edad << " años." << endl;
    }
};

int main() {
    Persona juan("Juan", 30);
    juan.saludar();

    juan.setEdad(31);
    cout << "Nueva edad de " << juan.getNombre() << ": " << juan.getEdad() << endl;

    return 0;
}
<---Modificadores de Acceso Result--->
<---Ejemplo de Constructor por Defecto--->
```cpp
#include <iostream>
using namespace std;

class Persona {
public:
    string nombre;
    int edad;

    // Constructor por defecto
    Persona() {
        nombre = "Desconocido";
        edad = 0;
    }

    void mostrarInformacion() {
        cout << "Nombre: " << nombre << ", Edad: " << edad << endl;
    }
};

int main() {
    Persona p;  // Llama al constructor por defecto
    p.mostrarInformacion();

    return 0;
}
<---Ejemplo de Constructor por Defecto Result--->
<---Ejemplo de Constructor Parametrizado--->
```cpp
#include <iostream>
using namespace std;

class Persona {
public:
    string nombre;
    int edad;

    // Constructor parametrizado
    Persona(string n, int e) {
        nombre = n;
        edad = e;
    }

    void mostrarInformacion() {
        cout << "Nombre: " << nombre << ", Edad: " << edad << endl;
    }
};

int main() {
    Persona p("Juan", 30);  // Llama al constructor parametrizado
    p.mostrarInformacion();

    return 0;
}
<---Ejemplo de Constructor Parametrizado Result--->
<---Ejemplo de Constructor de Copia--->
```cpp
#include <iostream>
using namespace std;

class Persona {
public:
    string nombre;
    int edad;

    // Constructor parametrizado
    Persona(string n, int e) {
        nombre = n;
        edad = e;
    }

    // Constructor de copia
    Persona(const Persona& p) {
        nombre = p.nombre;
        edad = p.edad;
    }

    void mostrarInformacion() {
        cout << "Nombre: " << nombre << ", Edad: " << edad << endl;
    }
};

int main() {
    Persona p1("Juan", 30);  // Llama al constructor parametrizado
    Persona p2 = p1;         // Llama al constructor de copia
    p2.mostrarInformacion();

    return 0;
}
<---Ejemplo de Constructor de Copia Result--->
<---Ejemplo de Constructor de Movimiento--->
```cpp
#include <iostream>
using namespace std;

class Persona {
public:
    string nombre;
    int edad;

    // Constructor parametrizado
    Persona(string n, int e) : nombre(n), edad(e) {}

    // Constructor de movimiento
    Persona(Persona&& p) noexcept : nombre(move(p.nombre)), edad(p.edad) {
        p.edad = 0; // Opcional: Dejar el objeto fuente en un estado válido
    }

    void mostrarInformacion() {
        cout << "Nombre: " << nombre << ", Edad: " << edad << endl;
    }
};

int main() {
    Persona p1("Juan", 30);  // Llama al constructor parametrizado
    Persona p2 = move(p1);   // Llama al constructor de movimiento
    p2.mostrarInformacion();

    // p1 está en un estado indefinido, pero válido
    cout << "Después de mover, p1: ";
    p1.mostrarInformacion();

    return 0;
}
<---Ejemplo de Constructor de Movimiento Result--->
<---Ejemplo con Lista de Inicialización--->
```cpp
#include <iostream>
using namespace std;

class Punto {
public:
    const int x;
    const int y;

    // Constructor con lista de inicialización
    Punto(int a, int b) : x(a), y(b) {}

    void mostrarInformacion() {
        cout << "Punto(" << x << ", " << y << ")" << endl;
    }
};

int main() {
    Punto p(10, 20);  // Llama al constructor con lista de inicialización
    p.mostrarInformacion();

    return 0;
}
```cpp
#include <iostream>
using namespace std;

class Persona {
private:
    string nombre;
    int edad;

public:
    // Constructor por defecto
    Persona() : nombre("Desconocido"), edad(0) {}

    // Constructor parametrizado
    Persona(string n, int e) : nombre(n), edad(e) {}

    // Constructor de copia
    Persona(const Persona& p) : nombre(p.nombre), edad(p.edad) {}

    // Constructor de movimiento
    Persona(Persona&& p) noexcept : nombre(move(p.nombre)), edad(p.edad) {
        p.edad = 0;
    }

    void mostrarInformacion() {
        cout << "Nombre: " << nombre << ", Edad: " << edad << endl;
    }
};

int main() {
    // Usando el constructor por defecto
    Persona p1;
    p1.mostrarInformacion();

    // Usando el constructor parametrizado
    Persona p2("Juan", 30);
    p2.mostrarInformacion();

    // Usando el constructor de copia
    Persona p3 = p2;
    p3.mostrarInformacion();

    // Usando el constructor de movimiento
    Persona p4 = move(p2);
    p4.mostrarInformacion();

    // Estado después del movimiento
    cout << "Después de mover, p2: ";
    p2.mostrarInformacion();

    return 0;
}
<---Ejemplo con Lista de Inicialización Result--->
<---Definición de Atributos Privados--->
```cpp
class Persona {
private:
    string nombre;
    int edad;

public:
    // Métodos públicos
};
<---Definición de Atributos Privados Result--->
<---Ejemplo de Getters--->
```cpp
class Persona {
private:
    string nombre;
    int edad;

public:
    // Constructor
    Persona(string n, int e) : nombre(n), edad(e) {}

    // Getter para el nombre
    string getNombre() const {
        return nombre;
    }

    // Getter para la edad
    int getEdad() const {
        return edad;
    }
};
<---Ejemplo de Getters Result--->
<---Ejemplo de Setters--->
```cpp
class Persona {
private:
    string nombre;
    int edad;

public:
    // Constructor
    Persona(string n, int e) : nombre(n), edad(e) {}

    // Setter para el nombre
    void setNombre(string n) {
        nombre = n;
    }

    // Setter para la edad
    void setEdad(int e) {
        if (e > 0) {  // Validación simple
            edad = e;
        } else {
            cout << "Edad no válida." << endl;
        }
    }

    // Getters
    string getNombre() const {
        return nombre;
    }

    int getEdad() const {
        return edad;
    }
};
<---Ejemplo de Setters Result--->
<---Ejemplo Completo--->
```cpp
#include <iostream>
using namespace std;

class Persona {
private:
    string nombre;
    int edad;

public:
    // Constructor
    Persona(string n, int e) : nombre(n), edad(e) {}

    // Setters
    void setNombre(string n) {
        nombre = n;
    }

    void setEdad(int e) {
        if (e > 0) {
            edad = e;
        } else {
            cout << "Edad no válida." << endl;
        }
    }

    // Getters
    string getNombre() const {
        return nombre;
    }

    int getEdad() const {
        return edad;
    }

    // Método para mostrar información
    void mostrarInformacion() const {
        cout << "Nombre: " << nombre << ", Edad: " << edad << endl;
    }
};

int main() {
    // Crear un objeto de la clase Persona
    Persona juan("Juan", 30);
    juan.mostrarInformacion();

    // Modificar los atributos usando setters
    juan.setNombre("Juan Perez");
    juan.setEdad(31);
    juan.mostrarInformacion();

    // Intentar establecer una edad no válida
    juan.setEdad(-5);
    juan.mostrarInformacion();

    // Acceder a los atributos usando getters
    cout << "Nombre: " << juan.getNombre() << endl;
    cout << "Edad: " << juan.getEdad() << endl;

    return 0;
}
<---Ejemplo Completo Result--->
<---Ejemplo Básico--->
```cpp
#include <iostream>
using namespace std;

class Ejemplo {
private:
    int datoPrivado; // Acceso privado

public:
    int datoPublico; // Acceso público

    // Constructor
    Ejemplo(int privado, int publico) : datoPrivado(privado), datoPublico(publico) {}

    // Método público para acceder al dato privado
    int getDatoPrivado() const {
        return datoPrivado;
    }

    // Método público para modificar el dato privado
    void setDatoPrivado(int valor) {
        datoPrivado = valor;
    }
};

int main() {
    Ejemplo obj(10, 20);

    // Acceso al dato público
    cout << "Dato público: " << obj.datoPublico << endl;

    // Acceso al dato privado a través de métodos públicos
    cout << "Dato privado: " << obj.getDatoPrivado() << endl;
    obj.setDatoPrivado(30);
    cout << "Dato privado modificado: " << obj.getDatoPrivado() << endl;

    return 0;
}
<---Ejemplo Básico Result--->
<---Ejemplo con Setters y Getters--->
```cpp
#include <iostream>
using namespace std;

class Persona {
private:
    string nombre;
    int edad;

public:
    // Constructor
    Persona(string n, int e) : nombre(n), edad(e) {}

    // Getter para nombre
    string getNombre() const {
        return nombre;
    }

    // Setter para nombre
    void setNombre(string n) {
        nombre = n;
    }

    // Getter para edad
    int getEdad() const {
        return edad;
    }

    // Setter para edad con validación
    void setEdad(int e) {
        if (e > 0) {
            edad = e;
        } else {
            cout << "Edad no válida" << endl;
        }
    }

    // Método para mostrar información
    void mostrarInformacion() const {
        cout << "Nombre: " << nombre << ", Edad: " << edad << endl;
    }
};

int main() {
    Persona juan("Juan", 30);
    juan.mostrarInformacion();

    // Modificar atributos usando setters
    juan.setNombre("Juan Perez");
    juan.setEdad(31);
    juan.mostrarInformacion();

    // Intentar establecer una edad no válida
    juan.setEdad(-5);
    juan.mostrarInformacion();

    return 0;
}
<---Ejemplo con Setters y Getters Result--->
<---Ejemplo con Herencia--->
```cpp
#include <iostream>
using namespace std;

class Base {
public:
    // Constructor
    Base() {
        cout << "Constructor de Base" << endl;
    }

    // Destructor virtual
    virtual ~Base() {
        cout << "Destructor de Base" << endl;
    }
};

class Derivada : public Base {
public:
    // Constructor
    Derivada() {
        cout << "Constructor de Derivada" << endl;
    }

    // Destructor
    ~Derivada() {
        cout << "Destructor de Derivada" << endl;
    }
};

int main() {
    Base* obj = new Derivada(); // Crear objeto de clase derivada
    delete obj; // Llamar al destructor virtual

    return 0;
}
<---Ejemplo con Herencia Result--->
<---Sintaxis del Destructor--->
```cpp
class NombreClase {
public:
    // Constructor
    NombreClase();

    // Destructor
    ~NombreClase();

    // Otros métodos y atributos
};
<---Sintaxis del Destructor Result--->
<---Ejemplo Básico de Destructor--->
```cpp
#include <iostream>
using namespace std;

class Persona {
public:
    string nombre;

    // Constructor
    Persona(string n) : nombre(n) {
        cout << "Constructor llamado para " << nombre << endl;
    }

    // Destructor
    ~Persona() {
        cout << "Destructor llamado para " << nombre << endl;
    }
};

int main() {
    Persona juan("Juan");
    {
        Persona maria("Maria");
    } // Destructor llamado para maria aquí

    cout << "Fin del main" << endl;
    return 0; // Destructor llamado para juan aquí
}
<---Ejemplo Básico de Destructor Result--->
<---Ejemplo con Recursos Dinámicos--->
```cpp
#include <iostream>
using namespace std;

class Array {
private:
    int* data;
    int size;

public:
    // Constructor
    Array(int s) : size(s) {
        data = new int[size]; // Asignar memoria dinámica
        cout << "Array de tamaño " << size << " creado." << endl;
    }

    // Destructor
    ~Array() {
        delete[] data; // Liberar memoria dinámica
        cout << "Array de tamaño " << size << " destruido." << endl;
    }

    // Método para establecer un valor en el array
    void setValue(int index, int value) {
        if (index >= 0 && index < size) {
            data[index] = value;
        }
    }

    // Método para obtener un valor del array
    int getValue(int index) const {
        if (index >= 0 && index < size) {
            return data[index];
        }
        return -1; // Valor de error
    }
};

int main() {
    Array arr(5);
    arr.setValue(0, 10);
    arr.setValue(1, 20);
    cout << "Valor en la posición 0: " << arr.getValue(0) << endl;
    cout << "Valor en la posición 1: " << arr.getValue(1) << endl;

    return 0;
}
<---Ejemplo con Recursos Dinámicos Result--->
<---Regla de Tres--->
```cpp
class Ejemplo {
private:
    int* data;

public:
    // Constructor
    Ejemplo(int size) {
        data = new int[size];
    }

    // Destructor
    ~Ejemplo() {
        delete[] data;
    }

    // Constructor de copia
    Ejemplo(const Ejemplo& other) {
        data = new int[other.size];
        // Copiar datos...
    }

    // Operador de asignación de copia
    Ejemplo& operator=(const Ejemplo& other) {
        if (this != &other) {
            delete[] data;
            data = new int[other.size];
            // Copiar datos...
        }
        return *this;
    }
};
<---Regla de Tres Result--->
<---Regla de Cinco--->
```cpp
class Ejemplo {
private:
    int* data;

public:
    // Constructor
    Ejemplo(int size) {
        data = new int[size];
    }

    // Destructor
    ~Ejemplo() {
        delete[] data;
    }

    // Constructor de copia
    Ejemplo(const Ejemplo& other) {
        data = new int[other.size];
        // Copiar datos...
    }

    // Operador de asignación de copia
    Ejemplo& operator=(const Ejemplo& other) {
        if (this != &other) {
            delete[] data;
            data = new int[other.size];
            // Copiar datos...
        }
        return *this;
    }

    // Constructor de movimiento
    Ejemplo(Ejemplo&& other) noexcept : data(other.data) {
        other.data = nullptr;
    }

    // Operador de asignación de movimiento
    Ejemplo& operator=(Ejemplo&& other) noexcept {
        if (this != &other) {
            delete[] data;
            data = other.data;
            other.data = nullptr;
        }
        return *this;
    }
};
<---Regla de Cinco Result--->
<---Ejemplo de Sobrecarga de Operadores--->
```cpp
#include <iostream>
using namespace std;

class Complejo {
private:
    double real;
    double imaginario;

public:
    // Constructor
    Complejo(double r = 0.0, double i = 0.0) : real(r), imaginario(i) {}

    // Sobrecarga del operador +
    Complejo operator+(const Complejo& c) const {
        return Complejo(real + c.real, imaginario + c.imaginario);
    }

    // Sobrecarga del operador <<
    friend ostream& operator<<(ostream& os, const Complejo& c) {
        os << "(" << c.real << " + " << c.imaginario << "i)";
        return os;
    }
};

int main() {
    Complejo c1(3.0, 4.0);
    Complejo c2(1.0, 2.0);

    Complejo c3 = c1 + c2;  // Usando la sobrecarga del operador +

    cout << "c1: " << c1 << endl;
    cout << "c2: " << c2 << endl;
    cout << "c3: " << c3 << endl;  // Usando la sobrecarga del operador <<

    return 0;
}
<---Ejemplo de Sobrecarga de Operadores Result--->
<---Ejemplo de Sobrecarga del Operador `*`--->
```cpp
#include <iostream>
using namespace std;

class Vector {
private:
    double x, y, z;

public:
    // Constructor
    Vector(double x, double y, double z) : x(x), y(y), z(z) {}

    // Sobrecarga del operador *
    Vector operator*(double escalar) const {
        return Vector(x * escalar, y * escalar, z * escalar);
    }

    // Sobrecarga del operador <<
    friend ostream& operator<<(ostream& os, const Vector& v) {
        os << "{" << v.x << ", " << v.y << ", " << v.z << "}";
        return os;
    }
};

int main() {
    Vector v1(1.0, 2.0, 3.0);
    Vector v2 = v1 * 2.0;

    cout << "v1: " << v1 << endl;
    cout << "v2: " << v2 << endl;

    return 0;
}
<---Ejemplo de Sobrecarga del Operador `*` Result--->
<---Ejemplo de Sobrecarga del Operador `==`--->
```cpp
#include <iostream>
using namespace std;

class Punto {
private:
    int x, y;

public:
    // Constructor
    Punto(int x = 0, int y = 0) : x(x), y(y) {}

    // Sobrecarga del operador ==
    bool operator==(const Punto& p) const {
        return (x == p.x && y == p.y);
    }

    // Sobrecarga del operador <<
    friend ostream& operator<<(ostream& os, const Punto& p) {
        os << "(" << p.x << ", " << p.y << ")";
        return os;
    }
};

int main() {
    Punto p1(1, 2);
    Punto p2(1, 2);
    Punto p3(3, 4);

    cout << "p1: " << p1 << endl;
    cout << "p2: " << p2 << endl;
    cout << "p3: " << p3 << endl;

    cout << "p1 == p2: " << (p1 == p2) << endl;
    cout << "p1 == p3: " << (p1 == p3) << endl;

    return 0;
}
<---Ejemplo de Sobrecarga del Operador `==` Result--->
<---Ejemplo de Sobrecarga del Operador `++`--->
```cpp
#include <iostream>
using namespace std;

class Contador {
private:
    int valor;

public:
    // Constructor
    Contador(int v = 0) : valor(v) {}

    // Sobrecarga del operador prefijo ++
    Contador& operator++() {
        ++valor;
        return *this;
    }

    // Sobrecarga del operador postfijo ++
    Contador operator++(int) {
        Contador temp = *this;
        ++valor;
        return temp;
    }

    // Sobrecarga del operador <<
    friend ostream& operator<<(ostream& os, const Contador& c) {
        os << c.valor;
        return os;
    }
};

int main() {
    Contador c(5);

    cout << "Valor inicial: " << c << endl;

    ++c;
    cout << "Después del prefijo ++: " << c << endl;

    c++;
    cout << "Después del postfijo ++: " << c << endl;

    return 0;
}
<---Ejemplo de Sobrecarga del Operador `++` Result--->
<---Ejemplo de Sobrecarga del Operador `[]`--->
```cpp
#include <iostream>
using namespace std;

class Array {
private:
    int* datos;
    int tamano;

public:
    // Constructor
    Array(int tamano) : tamano(tamano) {
        datos = new int[tamano];
        for (int i = 0; i < tamano; ++i) {
            datos[i] = 0;
        }
    }

    // Destructor
    ~Array() {
        delete[] datos;
    }

    // Sobrecarga del operador []
    int& operator[](int indice) {
        if (indice >= 0 && indice < tamano) {
            return datos[indice];
        }
        throw out_of_range("Índice fuera de rango");
    }

    // Sobrecarga del operador <<
    friend ostream& operator<<(ostream& os, const Array& arr) {
        os << "[";
        for (int i = 0; i < arr.tamano; ++i) {
            os << arr.datos[i];
            if (i < arr.tamano - 1) {
                os << ", ";
            }
        }
        os << "]";
        return os;
    }
};

int main() {
    Array arr(5);

    arr[0] = 10;
    arr[1] = 20;
    arr[2] = 30;

    cout << "Array: " << arr << endl;

    try {
        arr[5] = 50;  // Esto lanzará una excepción
    } catch (const out_of_range& e) {
        cout << e.what() << endl;
    }

    return 0;
}
<---Ejemplo de Sobrecarga del Operador `[]` Result--->
<---Definición de una Clase--->
```cpp
class NombreClase {
public:
    // Atributos
    tipo_atributo nombre_atributo;

    // Métodos
    tipo_retorno nombre_metodo(parametros);

    // Otros componentes, como constructores, destructores, etc.
};
<---Definición de una Clase Result--->
<---Ejemplo Básico de una Clase--->
```cpp
#include <iostream>
using namespace std;

class Persona {
public:
    // Atributos
    string nombre;
    int edad;

    // Métodos
    void saludar() {
        cout << "Hola, mi nombre es " << nombre << " y tengo " << edad << " años." << endl;
    }
};

int main() {
    // Crear un objeto de la clase Persona
    Persona juan;
    juan.nombre = "Juan";
    juan.edad = 30;

    // Llamar al método saludar
    juan.saludar();

    return 0;
}
<---Ejemplo Básico de una Clase Result--->
<---Creación de Objetos--->
```cpp
NombreClase nombre_objeto;
<---Creación de Objetos Result--->
<---Ejemplo de Creación y Uso de Objetos--->
```cpp
#include <iostream>
using namespace std;

class Coche {
public:
    // Atributos
    string marca;
    string modelo;
    int anio;

    // Métodos
    void mostrarInformacion() {
        cout << "Marca: " << marca << ", Modelo: " << modelo << ", Año: " << anio << endl;
    }
};

int main() {
    // Crear objetos de la clase Coche
    Coche coche1;
    coche1.marca = "Toyota";
    coche1.modelo = "Corolla";
    coche1.anio = 2020;

    Coche coche2;
    coche2.marca = "Honda";
    coche2.modelo = "Civic";
    coche2.anio = 2019;

    // Llamar a los métodos de los objetos
    coche1.mostrarInformacion();
    coche2.mostrarInformacion();

    return 0;
}
<---Ejemplo de Creación y Uso de Objetos Result--->
<---Constructores--->
```cpp
class Persona {
public:
    string nombre;
    int edad;

    // Constructor
    Persona(string n, int e) {
        nombre = n;
        edad = e;
    }

    void saludar() {
        cout << "Hola, mi nombre es " << nombre << " y tengo " << edad << " años." << endl;
    }
};

int main() {
    // Crear un objeto de la clase Persona utilizando el constructor
    Persona juan("Juan", 30);
    juan.saludar();

    return 0;
}
<---Constructores Result--->
<---Destructores--->
```cpp
class Persona {
public:
    string nombre;
    int edad;

    // Constructor
    Persona(string n, int e) {
        nombre = n;
        edad = e;
    }

    // Destructor
    ~Persona() {
        cout << "Destructor llamado para " << nombre << endl;
    }

    void saludar() {
        cout << "Hola, mi nombre es " << nombre << " y tengo " << edad << " años." << endl;
    }
};

int main() {
    // Crear un objeto de la clase Persona
    Persona juan("Juan", 30);
    juan.saludar();

    // El destructor se llamará automáticamente al final del alcance
    return 0;
}
<---Destructores Result--->
<---Modificadores de Acceso--->
```cpp
class Persona {
private:
    string nombre;
    int edad;

public:
    // Constructor
    Persona(string n, int e) : nombre(n), edad(e) {}

    // Métodos para acceder y modificar los atributos
    string getNombre() {
        return nombre;
    }

    void setNombre(string n) {
        nombre = n;
    }

    int getEdad() {
        return edad;
    }

    void setEdad(int e) {
        edad = e;
    }

    void saludar() {
        cout << "Hola, mi nombre es " << nombre << " y tengo " << edad << " años." << endl;
    }
};

int main() {
    Persona juan("Juan", 30);
    juan.saludar();

    juan.setEdad(31);
    cout << "Nueva edad de " << juan.getNombre() << ": " << juan.getEdad() << endl;

    return 0;
}
<---Modificadores de Acceso Result--->
<---Ejemplo de Constructor por Defecto--->
```cpp
#include <iostream>
using namespace std;

class Persona {
public:
    string nombre;
    int edad;

    // Constructor por defecto
    Persona() {
        nombre = "Desconocido";
        edad = 0;
    }

    void mostrarInformacion() {
        cout << "Nombre: " << nombre << ", Edad: " << edad << endl;
    }
};

int main() {
    Persona p;  // Llama al constructor por defecto
    p.mostrarInformacion();

    return 0;
}
<---Ejemplo de Constructor por Defecto Result--->
<---Ejemplo de Constructor Parametrizado--->
```cpp
#include <iostream>
using namespace std;

class Persona {
public:
    string nombre;
    int edad;

    // Constructor parametrizado
    Persona(string n, int e) {
        nombre = n;
        edad = e;
    }

    void mostrarInformacion() {
        cout << "Nombre: " << nombre << ", Edad: " << edad << endl;
    }
};

int main() {
    Persona p("Juan", 30);  // Llama al constructor parametrizado
    p.mostrarInformacion();

    return 0;
}
<---Ejemplo de Constructor Parametrizado Result--->
<---Ejemplo de Constructor de Copia--->
```cpp
#include <iostream>
using namespace std;

class Persona {
public:
    string nombre;
    int edad;

    // Constructor parametrizado
    Persona(string n, int e) {
        nombre = n;
        edad = e;
    }

    // Constructor de copia
    Persona(const Persona& p) {
        nombre = p.nombre;
        edad = p.edad;
    }

    void mostrarInformacion() {
        cout << "Nombre: " << nombre << ", Edad: " << edad << endl;
    }
};

int main() {
    Persona p1("Juan", 30);  // Llama al constructor parametrizado
    Persona p2 = p1;         // Llama al constructor de copia
    p2.mostrarInformacion();

    return 0;
}
<---Ejemplo de Constructor de Copia Result--->
<---Ejemplo de Constructor de Movimiento--->
```cpp
#include <iostream>
using namespace std;

class Persona {
public:
    string nombre;
    int edad;

    // Constructor parametrizado
    Persona(string n, int e) : nombre(n), edad(e) {}

    // Constructor de movimiento
    Persona(Persona&& p) noexcept : nombre(move(p.nombre)), edad(p.edad) {
        p.edad = 0; // Opcional: Dejar el objeto fuente en un estado válido
    }

    void mostrarInformacion() {
        cout << "Nombre: " << nombre << ", Edad: " << edad << endl;
    }
};

int main() {
    Persona p1("Juan", 30);  // Llama al constructor parametrizado
    Persona p2 = move(p1);   // Llama al constructor de movimiento
    p2.mostrarInformacion();

    // p1 está en un estado indefinido, pero válido
    cout << "Después de mover, p1: ";
    p1.mostrarInformacion();

    return 0;
}
<---Ejemplo de Constructor de Movimiento Result--->
<---Ejemplo con Lista de Inicialización--->
```cpp
#include <iostream>
using namespace std;

class Punto {
public:
    const int x;
    const int y;

    // Constructor con lista de inicialización
    Punto(int a, int b) : x(a), y(b) {}

    void mostrarInformacion() {
        cout << "Punto(" << x << ", " << y << ")" << endl;
    }
};

int main() {
    Punto p(10, 20);  // Llama al constructor con lista de inicialización
    p.mostrarInformacion();

    return 0;
}
```cpp
#include <iostream>
using namespace std;

class Persona {
private:
    string nombre;
    int edad;

public:
    // Constructor por defecto
    Persona() : nombre("Desconocido"), edad(0) {}

    // Constructor parametrizado
    Persona(string n, int e) : nombre(n), edad(e) {}

    // Constructor de copia
    Persona(const Persona& p) : nombre(p.nombre), edad(p.edad) {}

    // Constructor de movimiento
    Persona(Persona&& p) noexcept : nombre(move(p.nombre)), edad(p.edad) {
        p.edad = 0;
    }

    void mostrarInformacion() {
        cout << "Nombre: " << nombre << ", Edad: " << edad << endl;
    }
};

int main() {
    // Usando el constructor por defecto
    Persona p1;
    p1.mostrarInformacion();

    // Usando el constructor parametrizado
    Persona p2("Juan", 30);
    p2.mostrarInformacion();

    // Usando el constructor de copia
    Persona p3 = p2;
    p3.mostrarInformacion();

    // Usando el constructor de movimiento
    Persona p4 = move(p2);
    p4.mostrarInformacion();

    // Estado después del movimiento
    cout << "Después de mover, p2: ";
    p2.mostrarInformacion();

    return 0;
}
<---Ejemplo con Lista de Inicialización Result--->
<---Definición de Atributos Privados--->
```cpp
class Persona {
private:
    string nombre;
    int edad;

public:
    // Métodos públicos
};
<---Definición de Atributos Privados Result--->
<---Ejemplo de Getters--->
```cpp
class Persona {
private:
    string nombre;
    int edad;

public:
    // Constructor
    Persona(string n, int e) : nombre(n), edad(e) {}

    // Getter para el nombre
    string getNombre() const {
        return nombre;
    }

    // Getter para la edad
    int getEdad() const {
        return edad;
    }
};
<---Ejemplo de Getters Result--->
<---Ejemplo de Setters--->
```cpp
class Persona {
private:
    string nombre;
    int edad;

public:
    // Constructor
    Persona(string n, int e) : nombre(n), edad(e) {}

    // Setter para el nombre
    void setNombre(string n) {
        nombre = n;
    }

    // Setter para la edad
    void setEdad(int e) {
        if (e > 0) {  // Validación simple
            edad = e;
        } else {
            cout << "Edad no válida." << endl;
        }
    }

    // Getters
    string getNombre() const {
        return nombre;
    }

    int getEdad() const {
        return edad;
    }
};
<---Ejemplo de Setters Result--->
<---Ejemplo Completo--->
```cpp
#include <iostream>
using namespace std;

class Persona {
private:
    string nombre;
    int edad;

public:
    // Constructor
    Persona(string n, int e) : nombre(n), edad(e) {}

    // Setters
    void setNombre(string n) {
        nombre = n;
    }

    void setEdad(int e) {
        if (e > 0) {
            edad = e;
        } else {
            cout << "Edad no válida." << endl;
        }
    }

    // Getters
    string getNombre() const {
        return nombre;
    }

    int getEdad() const {
        return edad;
    }

    // Método para mostrar información
    void mostrarInformacion() const {
        cout << "Nombre: " << nombre << ", Edad: " << edad << endl;
    }
};

int main() {
    // Crear un objeto de la clase Persona
    Persona juan("Juan", 30);
    juan.mostrarInformacion();

    // Modificar los atributos usando setters
    juan.setNombre("Juan Perez");
    juan.setEdad(31);
    juan.mostrarInformacion();

    // Intentar establecer una edad no válida
    juan.setEdad(-5);
    juan.mostrarInformacion();

    // Acceder a los atributos usando getters
    cout << "Nombre: " << juan.getNombre() << endl;
    cout << "Edad: " << juan.getEdad() << endl;

    return 0;
}
<---Ejemplo Completo Result--->
<---Ejemplo Básico--->
```cpp
#include <iostream>
using namespace std;

class Ejemplo {
private:
    int datoPrivado; // Acceso privado

public:
    int datoPublico; // Acceso público

    // Constructor
    Ejemplo(int privado, int publico) : datoPrivado(privado), datoPublico(publico) {}

    // Método público para acceder al dato privado
    int getDatoPrivado() const {
        return datoPrivado;
    }

    // Método público para modificar el dato privado
    void setDatoPrivado(int valor) {
        datoPrivado = valor;
    }
};

int main() {
    Ejemplo obj(10, 20);

    // Acceso al dato público
    cout << "Dato público: " << obj.datoPublico << endl;

    // Acceso al dato privado a través de métodos públicos
    cout << "Dato privado: " << obj.getDatoPrivado() << endl;
    obj.setDatoPrivado(30);
    cout << "Dato privado modificado: " << obj.getDatoPrivado() << endl;

    return 0;
}
<---Ejemplo Básico Result--->
<---Ejemplo con Setters y Getters--->
```cpp
#include <iostream>
using namespace std;

class Persona {
private:
    string nombre;
    int edad;

public:
    // Constructor
    Persona(string n, int e) : nombre(n), edad(e) {}

    // Getter para nombre
    string getNombre() const {
        return nombre;
    }

    // Setter para nombre
    void setNombre(string n) {
        nombre = n;
    }

    // Getter para edad
    int getEdad() const {
        return edad;
    }

    // Setter para edad con validación
    void setEdad(int e) {
        if (e > 0) {
            edad = e;
        } else {
            cout << "Edad no válida" << endl;
        }
    }

    // Método para mostrar información
    void mostrarInformacion() const {
        cout << "Nombre: " << nombre << ", Edad: " << edad << endl;
    }
};

int main() {
    Persona juan("Juan", 30);
    juan.mostrarInformacion();

    // Modificar atributos usando setters
    juan.setNombre("Juan Perez");
    juan.setEdad(31);
    juan.mostrarInformacion();

    // Intentar establecer una edad no válida
    juan.setEdad(-5);
    juan.mostrarInformacion();

    return 0;
}
<---Ejemplo con Setters y Getters Result--->
<---Ejemplo con Herencia--->
```cpp
#include <iostream>
using namespace std;

class Base {
public:
    // Constructor
    Base() {
        cout << "Constructor de Base" << endl;
    }

    // Destructor virtual
    virtual ~Base() {
        cout << "Destructor de Base" << endl;
    }
};

class Derivada : public Base {
public:
    // Constructor
    Derivada() {
        cout << "Constructor de Derivada" << endl;
    }

    // Destructor
    ~Derivada() {
        cout << "Destructor de Derivada" << endl;
    }
};

int main() {
    Base* obj = new Derivada(); // Crear objeto de clase derivada
    delete obj; // Llamar al destructor virtual

    return 0;
}
<---Ejemplo con Herencia Result--->
<---Sintaxis del Destructor--->
```cpp
class NombreClase {
public:
    // Constructor
    NombreClase();

    // Destructor
    ~NombreClase();

    // Otros métodos y atributos
};
```cpp
#include <iostream>
using namespace std;

class Persona {
public:
    string nombre;

    // Constructor
    Persona(string n) : nombre(n) {
        cout << "Constructor llamado para " << nombre << endl;
    }

    // Destructor
    ~Persona() {
        cout << "Destructor llamado para " << nombre << endl;
    }
};

int main() {
    Persona juan("Juan");
    {
        Persona maria("Maria");
    } // Destructor llamado para maria aquí

    cout << "Fin del main" << endl;
    return 0; // Destructor llamado para juan aquí
}
<---Sintaxis del Destructor Result--->
<---Ejemplo Básico de Destructor--->
```cpp
#include <iostream>
using namespace std;

class Persona {
public:
    string nombre;

    // Constructor
    Persona(string n) : nombre(n) {
        cout << "Constructor llamado para " << nombre << endl;
    }

    // Destructor
    ~Persona() {
        cout << "Destructor llamado para " << nombre << endl;
    }
};

int main() {
    Persona juan("Juan");
    {
        Persona maria("Maria");
    } // Destructor llamado para maria aquí

    cout << "Fin del main" << endl;
    return 0; // Destructor llamado para juan aquí
}
<---Ejemplo Básico de Destructor Result--->
<---Ejemplo con Recursos Dinámicos--->
```cpp
#include <iostream>
using namespace std;

class Array {
private:
    int* data;
    int size;

public:
    // Constructor
    Array(int s) : size(s) {
        data = new int[size]; // Asignar memoria dinámica
        cout << "Array de tamaño " << size << " creado." << endl;
    }

    // Destructor
    ~Array() {
        delete[] data; // Liberar memoria dinámica
        cout << "Array de tamaño " << size << " destruido." << endl;
    }

    // Método para establecer un valor en el array
    void setValue(int index, int value) {
        if (index >= 0 && index < size) {
            data[index] = value;
        }
    }

    // Método para obtener un valor del array
    int getValue(int index) const {
        if (index >= 0 && index < size) {
            return data[index];
        }
        return -1; // Valor de error
    }
};

int main() {
    Array arr(5);
    arr.setValue(0, 10);
    arr.setValue(1, 20);
    cout << "Valor en la posición 0: " << arr.getValue(0) << endl;
    cout << "Valor en la posición 1: " << arr.getValue(1) << endl;

    return 0;
}
<---Ejemplo con Recursos Dinámicos Result--->
<---Regla de Tres--->
```cpp
class Ejemplo {
private:
    int* data;

public:
    // Constructor
    Ejemplo(int size) {
        data = new int[size];
    }

    // Destructor
    ~Ejemplo() {
        delete[] data;
    }

    // Constructor de copia
    Ejemplo(const Ejemplo& other) {
        data = new int[other.size];
        // Copiar datos...
    }

    // Operador de asignación de copia
    Ejemplo& operator=(const Ejemplo& other) {
        if (this != &other) {
            delete[] data;
            data = new int[other.size];
            // Copiar datos...
        }
        return *this;
    }
};
<---Regla de Tres Result--->
<---Regla de Cinco--->
```cpp
class Ejemplo {
private:
    int* data;

public:
    // Constructor
    Ejemplo(int size) {
        data = new int[size];
    }

    // Destructor
    ~Ejemplo() {
        delete[] data;
    }

    // Constructor de copia
    Ejemplo(const Ejemplo& other) {
        data = new int[other.size];
        // Copiar datos...
    }

    // Operador de asignación de copia
    Ejemplo& operator=(const Ejemplo& other) {
        if (this != &other) {
            delete[] data;
            data = new int[other.size];
            // Copiar datos...
        }
        return *this;
    }

    // Constructor de movimiento
    Ejemplo(Ejemplo&& other) noexcept : data(other.data) {
        other.data = nullptr;
    }

    // Operador de asignación de movimiento
    Ejemplo& operator=(Ejemplo&& other) noexcept {
        if (this != &other) {
            delete[] data;
            data = other.data;
            other.data = nullptr;
        }
        return *this;
    }
};
<---Regla de Cinco Result--->
<---Ejemplo de Sobrecarga de Operadores--->
```cpp
#include <iostream>
using namespace std;

class Complejo {
private:
    double real;
    double imaginario;

public:
    // Constructor
    Complejo(double r = 0.0, double i = 0.0) : real(r), imaginario(i) {}

    // Sobrecarga del operador +
    Complejo operator+(const Complejo& c) const {
        return Complejo(real + c.real, imaginario + c.imaginario);
    }

    // Sobrecarga del operador <<
    friend ostream& operator<<(ostream& os, const Complejo& c) {
        os << "(" << c.real << " + " << c.imaginario << "i)";
        return os;
    }
};

int main() {
    Complejo c1(3.0, 4.0);
    Complejo c2(1.0, 2.0);

    Complejo c3 = c1 + c2;  // Usando la sobrecarga del operador +

    cout << "c1: " << c1 << endl;
    cout << "c2: " << c2 << endl;
    cout << "c3: " << c3 << endl;  // Usando la sobrecarga del operador <<

    return 0;
}
<---Ejemplo de Sobrecarga de Operadores Result--->
<---Ejemplo de Sobrecarga del Operador `*`--->
```cpp
#include <iostream>
using namespace std;

class Vector {
private:
    double x, y, z;

public:
    // Constructor
    Vector(double x, double y, double z) : x(x), y(y), z(z) {}

    // Sobrecarga del operador *
    Vector operator*(double escalar) const {
        return Vector(x * escalar, y * escalar, z * escalar);
    }

    // Sobrecarga del operador <<
    friend ostream& operator<<(ostream& os, const Vector& v) {
        os << "{" << v.x << ", " << v.y << ", " << v.z << "}";
        return os;
    }
};

int main() {
    Vector v1(1.0, 2.0, 3.0);
    Vector v2 = v1 * 2.0;

    cout << "v1: " << v1 << endl;
    cout << "v2: " << v2 << endl;

    return 0;
}
<---Ejemplo de Sobrecarga del Operador `*` Result--->
<---Ejemplo de Sobrecarga del Operador `==`--->
```cpp
#include <iostream>
using namespace std;

class Punto {
private:
    int x, y;

public:
    // Constructor
    Punto(int x = 0, int y = 0) : x(x), y(y) {}

    // Sobrecarga del operador ==
    bool operator==(const Punto& p) const {
        return (x == p.x && y == p.y);
    }

    // Sobrecarga del operador <<
    friend ostream& operator<<(ostream& os, const Punto& p) {
        os << "(" << p.x << ", " << p.y << ")";
        return os;
    }
};

int main() {
    Punto p1(1, 2);
    Punto p2(1, 2);
    Punto p3(3, 4);

    cout << "p1: " << p1 << endl;
    cout << "p2: " << p2 << endl;
    cout << "p3: " << p3 << endl;

    cout << "p1 == p2: " << (p1 == p2) << endl;
    cout << "p1 == p3: " << (p1 == p3) << endl;

    return 0;
}
<---Ejemplo de Sobrecarga del Operador `==` Result--->
<---Ejemplo de Sobrecarga del Operador `++`--->
```cpp
#include <iostream>
using namespace std;

class Contador {
private:
    int valor;

public:
    // Constructor
    Contador(int v = 0) : valor(v) {}

    // Sobrecarga del operador prefijo ++
    Contador& operator++() {
        ++valor;
        return *this;
    }

    // Sobrecarga del operador postfijo ++
    Contador operator++(int) {
        Contador temp = *this;
        ++valor;
        return temp;
    }

    // Sobrecarga del operador <<
    friend ostream& operator<<(ostream& os, const Contador& c) {
        os << c.valor;
        return os;
    }
};

int main() {
    Contador c(5);

    cout << "Valor inicial: " << c << endl;

    ++c;
    cout << "Después del prefijo ++: " << c << endl;

    c++;
    cout << "Después del postfijo ++: " << c << endl;

    return 0;
}
<---Ejemplo de Sobrecarga del Operador `++` Result--->
<---Ejemplo de Sobrecarga del Operador `[]`--->
```cpp
#include <iostream>
using namespace std;

class Array {
private:
    int* datos;
    int tamano;

public:
    // Constructor
    Array(int tamano) : tamano(tamano) {
        datos = new int[tamano];
        for (int i = 0; i < tamano; ++i) {
            datos[i] = 0;
        }
    }

    // Destructor
    ~Array() {
        delete[] datos;
    }

    // Sobrecarga del operador []
    int& operator[](int indice) {
        if (indice >= 0 && indice < tamano) {
            return datos[indice];
        }
        throw out_of_range("Índice fuera de rango");
    }

    // Sobrecarga del operador <<
    friend ostream& operator<<(ostream& os, const Array& arr) {
        os << "[";
        for (int i = 0; i < arr.tamano; ++i) {
            os << arr.datos[i];
            if (i < arr.tamano - 1) {
                os << ", ";
            }
        }
        os << "]";
        return os;
    }
};

int main() {
    Array arr(5);

    arr[0] = 10;
    arr[1] = 20;
    arr[2] = 30;

    cout << "Array: " << arr << endl;

    try {
        arr[5] = 50;  // Esto lanzará una excepción
    } catch (const out_of_range& e) {
        cout << e.what() << endl;
    }

    return 0;
}
<---Ejemplo de Sobrecarga del Operador `[]` Result--->
<---Definición de una Clase--->
```cpp
class NombreClase {
public:
    // Atributos
    tipo_atributo nombre_atributo;

    // Métodos
    tipo_retorno nombre_metodo(parametros);

    // Otros componentes, como constructores, destructores, etc.
};
<---Definición de una Clase Result--->
<---Ejemplo Básico de una Clase--->
```cpp
#include <iostream>
using namespace std;

class Persona {
public:
    // Atributos
    string nombre;
    int edad;

    // Métodos
    void saludar() {
        cout << "Hola, mi nombre es " << nombre << " y tengo " << edad << " años." << endl;
    }
};

int main() {
    // Crear un objeto de la clase Persona
    Persona juan;
    juan.nombre = "Juan";
    juan.edad = 30;

    // Llamar al método saludar
    juan.saludar();

    return 0;
}
<---Ejemplo Básico de una Clase Result--->
<---Creación de Objetos--->
```cpp
NombreClase nombre_objeto;
<---Creación de Objetos Result--->
<---Ejemplo de Creación y Uso de Objetos--->
```cpp
#include <iostream>
using namespace std;

class Coche {
public:
    // Atributos
    string marca;
    string modelo;
    int anio;

    // Métodos
    void mostrarInformacion() {
        cout << "Marca: " << marca << ", Modelo: " << modelo << ", Año: " << anio << endl;
    }
};

int main() {
    // Crear objetos de la clase Coche
    Coche coche1;
    coche1.marca = "Toyota";
    coche1.modelo = "Corolla";
    coche1.anio = 2020;

    Coche coche2;
    coche2.marca = "Honda";
    coche2.modelo = "Civic";
    coche2.anio = 2019;

    // Llamar a los métodos de los objetos
    coche1.mostrarInformacion();
    coche2.mostrarInformacion();

    return 0;
}
<---Ejemplo de Creación y Uso de Objetos Result--->
<---Constructores--->
```cpp
class Persona {
public:
    string nombre;
    int edad;

    // Constructor
    Persona(string n, int e) {
        nombre = n;
        edad = e;
    }

    void saludar() {
        cout << "Hola, mi nombre es " << nombre << " y tengo " << edad << " años." << endl;
    }
};

int main() {
    // Crear un objeto de la clase Persona utilizando el constructor
    Persona juan("Juan", 30);
    juan.saludar();

    return 0;
}
<---Constructores Result--->
<---Destructores--->
```cpp
class Persona {
public:
    string nombre;
    int edad;

    // Constructor
    Persona(string n, int e) {
        nombre = n;
        edad = e;
    }

    // Destructor
    ~Persona() {
        cout << "Destructor llamado para " << nombre << endl;
    }

    void saludar() {
        cout << "Hola, mi nombre es " << nombre << " y tengo " << edad << " años." << endl;
    }
};

int main() {
    // Crear un objeto de la clase Persona
    Persona juan("Juan", 30);
    juan.saludar();

    // El destructor se llamará automáticamente al final del alcance
    return 0;
}
<---Destructores Result--->
<---Modificadores de Acceso--->
```cpp
class Persona {
private:
    string nombre;
    int edad;

public:
    // Constructor
    Persona(string n, int e) : nombre(n), edad(e) {}

    // Métodos para acceder y modificar los atributos
    string getNombre() {
        return nombre;
    }

    void setNombre(string n) {
        nombre = n;
    }

    int getEdad() {
        return edad;
    }

    void setEdad(int e) {
        edad = e;
    }

    void saludar() {
        cout << "Hola, mi nombre es " << nombre << " y tengo " << edad << " años." << endl;
    }
};

int main() {
    Persona juan("Juan", 30);
    juan.saludar();

    juan.setEdad(31);
    cout << "Nueva edad de " << juan.getNombre() << ": " << juan.getEdad() << endl;

    return 0;
}
<---Modificadores de Acceso Result--->
<---Ejemplo de Constructor por Defecto--->
```cpp
#include <iostream>
using namespace std;

class Persona {
public:
    string nombre;
    int edad;

    // Constructor por defecto
    Persona() {
        nombre = "Desconocido";
        edad = 0;
    }

    void mostrarInformacion() {
        cout << "Nombre: " << nombre << ", Edad: " << edad << endl;
    }
};

int main() {
    Persona p;  // Llama al constructor por defecto
    p.mostrarInformacion();

    return 0;
}
<---Ejemplo de Constructor por Defecto Result--->
<---Ejemplo de Constructor Parametrizado--->
```cpp
#include <iostream>
using namespace std;

class Persona {
public:
    string nombre;
    int edad;

    // Constructor parametrizado
    Persona(string n, int e) {
        nombre = n;
        edad = e;
    }

    void mostrarInformacion() {
        cout << "Nombre: " << nombre << ", Edad: " << edad << endl;
    }
};

int main() {
    Persona p("Juan", 30);  // Llama al constructor parametrizado
    p.mostrarInformacion();

    return 0;
}
<---Ejemplo de Constructor Parametrizado Result--->
<---Ejemplo de Constructor de Copia--->
```cpp
#include <iostream>
using namespace std;

class Persona {
public:
    string nombre;
    int edad;

    // Constructor parametrizado
    Persona(string n, int e) {
        nombre = n;
        edad = e;
    }

    // Constructor de copia
    Persona(const Persona& p) {
        nombre = p.nombre;
        edad = p.edad;
    }

    void mostrarInformacion() {
        cout << "Nombre: " << nombre << ", Edad: " << edad << endl;
    }
};

int main() {
    Persona p1("Juan", 30);  // Llama al constructor parametrizado
    Persona p2 = p1;         // Llama al constructor de copia
    p2.mostrarInformacion();

    return 0;
}
<---Ejemplo de Constructor de Copia Result--->
<---Ejemplo de Constructor de Movimiento--->
```cpp
#include <iostream>
using namespace std;

class Persona {
public:
    string nombre;
    int edad;

    // Constructor parametrizado
    Persona(string n, int e) : nombre(n), edad(e) {}

    // Constructor de movimiento
    Persona(Persona&& p) noexcept : nombre(move(p.nombre)), edad(p.edad) {
        p.edad = 0; // Opcional: Dejar el objeto fuente en un estado válido
    }

    void mostrarInformacion() {
        cout << "Nombre: " << nombre << ", Edad: " << edad << endl;
    }
};

int main() {
    Persona p1("Juan", 30);  // Llama al constructor parametrizado
    Persona p2 = move(p1);   // Llama al constructor de movimiento
    p2.mostrarInformacion();

    // p1 está en un estado indefinido, pero válido
    cout << "Después de mover, p1: ";
    p1.mostrarInformacion();

    return 0;
}
<---Ejemplo de Constructor de Movimiento Result--->
<---Ejemplo con Lista de Inicialización--->
```cpp
#include <iostream>
using namespace std;

class Punto {
public:
    const int x;
    const int y;

    // Constructor con lista de inicialización
    Punto(int a, int b) : x(a), y(b) {}

    void mostrarInformacion() {
        cout << "Punto(" << x << ", " << y << ")" << endl;
    }
};

int main() {
    Punto p(10, 20);  // Llama al constructor con lista de inicialización
    p.mostrarInformacion();

    return 0;
}
```cpp
#include <iostream>
using namespace std;

class Persona {
private:
    string nombre;
    int edad;

public:
    // Constructor por defecto
    Persona() : nombre("Desconocido"), edad(0) {}

    // Constructor parametrizado
    Persona(string n, int e) : nombre(n), edad(e) {}

    // Constructor de copia
    Persona(const Persona& p) : nombre(p.nombre), edad(p.edad) {}

    // Constructor de movimiento
    Persona(Persona&& p) noexcept : nombre(move(p.nombre)), edad(p.edad) {
        p.edad = 0;
    }

    void mostrarInformacion() {
        cout << "Nombre: " << nombre << ", Edad: " << edad << endl;
    }
};

int main() {
    // Usando el constructor por defecto
    Persona p1;
    p1.mostrarInformacion();

    // Usando el constructor parametrizado
    Persona p2("Juan", 30);
    p2.mostrarInformacion();

    // Usando el constructor de copia
    Persona p3 = p2;
    p3.mostrarInformacion();

    // Usando el constructor de movimiento
    Persona p4 = move(p2);
    p4.mostrarInformacion();

    // Estado después del movimiento
    cout << "Después de mover, p2: ";
    p2.mostrarInformacion();

    return 0;
}
<---Ejemplo con Lista de Inicialización Result--->
<---Definición de Atributos Privados--->
```cpp
class Persona {
private:
    string nombre;
    int edad;

public:
    // Métodos públicos
};
<---Definición de Atributos Privados Result--->
<---Ejemplo de Getters--->
```cpp
class Persona {
private:
    string nombre;
    int edad;

public:
    // Constructor
    Persona(string n, int e) : nombre(n), edad(e) {}

    // Getter para el nombre
    string getNombre() const {
        return nombre;
    }

    // Getter para la edad
    int getEdad() const {
        return edad;
    }
};
<---Ejemplo de Getters Result--->
<---Ejemplo de Setters--->
```cpp
class Persona {
private:
    string nombre;
    int edad;

public:
    // Constructor
    Persona(string n, int e) : nombre(n), edad(e) {}

    // Setter para el nombre
    void setNombre(string n) {
        nombre = n;
    }

    // Setter para la edad
    void setEdad(int e) {
        if (e > 0) {  // Validación simple
            edad = e;
        } else {
            cout << "Edad no válida." << endl;
        }
    }

    // Getters
    string getNombre() const {
        return nombre;
    }

    int getEdad() const {
        return edad;
    }
};
<---Ejemplo de Setters Result--->
<---Ejemplo Completo--->
```cpp
#include <iostream>
using namespace std;

class Persona {
private:
    string nombre;
    int edad;

public:
    // Constructor
    Persona(string n, int e) : nombre(n), edad(e) {}

    // Setters
    void setNombre(string n) {
        nombre = n;
    }

    void setEdad(int e) {
        if (e > 0) {
            edad = e;
        } else {
            cout << "Edad no válida." << endl;
        }
    }

    // Getters
    string getNombre() const {
        return nombre;
    }

    int getEdad() const {
        return edad;
    }

    // Método para mostrar información
    void mostrarInformacion() const {
        cout << "Nombre: " << nombre << ", Edad: " << edad << endl;
    }
};

int main() {
    // Crear un objeto de la clase Persona
    Persona juan("Juan", 30);
    juan.mostrarInformacion();

    // Modificar los atributos usando setters
    juan.setNombre("Juan Perez");
    juan.setEdad(31);
    juan.mostrarInformacion();

    // Intentar establecer una edad no válida
    juan.setEdad(-5);
    juan.mostrarInformacion();

    // Acceder a los atributos usando getters
    cout << "Nombre: " << juan.getNombre() << endl;
    cout << "Edad: " << juan.getEdad() << endl;

    return 0;
}
<---Ejemplo Completo Result--->
<---Ejemplo Básico--->
```cpp
#include <iostream>
using namespace std;

class Ejemplo {
private:
    int datoPrivado; // Acceso privado

public:
    int datoPublico; // Acceso público

    // Constructor
    Ejemplo(int privado, int publico) : datoPrivado(privado), datoPublico(publico) {}

    // Método público para acceder al dato privado
    int getDatoPrivado() const {
        return datoPrivado;
    }

    // Método público para modificar el dato privado
    void setDatoPrivado(int valor) {
        datoPrivado = valor;
    }
};

int main() {
    Ejemplo obj(10, 20);

    // Acceso al dato público
    cout << "Dato público: " << obj.datoPublico << endl;

    // Acceso al dato privado a través de métodos públicos
    cout << "Dato privado: " << obj.getDatoPrivado() << endl;
    obj.setDatoPrivado(30);
    cout << "Dato privado modificado: " << obj.getDatoPrivado() << endl;

    return 0;
}
<---Ejemplo Básico Result--->
<---Ejemplo con Setters y Getters--->
```cpp
#include <iostream>
using namespace std;

class Persona {
private:
    string nombre;
    int edad;

public:
    // Constructor
    Persona(string n, int e) : nombre(n), edad(e) {}

    // Getter para nombre
    string getNombre() const {
        return nombre;
    }

    // Setter para nombre
    void setNombre(string n) {
        nombre = n;
    }

    // Getter para edad
    int getEdad() const {
        return edad;
    }

    // Setter para edad con validación
    void setEdad(int e) {
        if (e > 0) {
            edad = e;
        } else {
            cout << "Edad no válida" << endl;
        }
    }

    // Método para mostrar información
    void mostrarInformacion() const {
        cout << "Nombre: " << nombre << ", Edad: " << edad << endl;
    }
};

int main() {
    Persona juan("Juan", 30);
    juan.mostrarInformacion();

    // Modificar atributos usando setters
    juan.setNombre("Juan Perez");
    juan.setEdad(31);
    juan.mostrarInformacion();

    // Intentar establecer una edad no válida
    juan.setEdad(-5);
    juan.mostrarInformacion();

    return 0;
}
<---Ejemplo con Setters y Getters Result--->
<---Ejemplo con Herencia--->
```cpp
#include <iostream>
using namespace std;

class Base {
public:
    // Constructor
    Base() {
        cout << "Constructor de Base" << endl;
    }

    // Destructor virtual
    virtual ~Base() {
        cout << "Destructor de Base" << endl;
    }
};

class Derivada : public Base {
public:
    // Constructor
    Derivada() {
        cout << "Constructor de Derivada" << endl;
    }

    // Destructor
    ~Derivada() {
        cout << "Destructor de Derivada" << endl;
    }
};

int main() {
    Base* obj = new Derivada(); // Crear objeto de clase derivada
    delete obj; // Llamar al destructor virtual

    return 0;
}
<---Ejemplo con Herencia Result--->
<---Sintaxis del Destructor--->
```cpp
class NombreClase {
public:
    // Constructor
    NombreClase();

    // Destructor
    ~NombreClase();

    // Otros métodos y atributos
};
```cpp
#include <iostream>
using namespace std;

class Persona {
public:
    string nombre;

    // Constructor
    Persona(string n) : nombre(n) {
        cout << "Constructor llamado para " << nombre << endl;
    }

    // Destructor
    ~Persona() {
        cout << "Destructor llamado para " << nombre << endl;
    }
};

int main() {
    Persona juan("Juan");
    {
        Persona maria("Maria");
    } // Destructor llamado para maria aquí

    cout << "Fin del main" << endl;
    return 0; // Destructor llamado para juan aquí
}
<---Sintaxis del Destructor Result--->
<---Ejemplo Básico de Destructor--->
```cpp
#include <iostream>
using namespace std;

class Persona {
public:
    string nombre;

    // Constructor
    Persona(string n) : nombre(n) {
        cout << "Constructor llamado para " << nombre << endl;
    }

    // Destructor
    ~Persona() {
        cout << "Destructor llamado para " << nombre << endl;
    }
};

int main() {
    Persona juan("Juan");
    {
        Persona maria("Maria");
    } // Destructor llamado para maria aquí

    cout << "Fin del main" << endl;
    return 0; // Destructor llamado para juan aquí
}
<---Ejemplo Básico de Destructor Result--->
<---Ejemplo con Recursos Dinámicos--->
```cpp
#include <iostream>
using namespace std;

class Array {
private:
    int* data;
    int size;

public:
    // Constructor
    Array(int s) : size(s) {
        data = new int[size]; // Asignar memoria dinámica
        cout << "Array de tamaño " << size << " creado." << endl;
    }

    // Destructor
    ~Array() {
        delete[] data; // Liberar memoria dinámica
        cout << "Array de tamaño " << size << " destruido." << endl;
    }

    // Método para establecer un valor en el array
    void setValue(int index, int value) {
        if (index >= 0 && index < size) {
            data[index] = value;
        }
    }

    // Método para obtener un valor del array
    int getValue(int index) const {
        if (index >= 0 && index < size) {
            return data[index];
        }
        return -1; // Valor de error
    }
};

int main() {
    Array arr(5);
    arr.setValue(0, 10);
    arr.setValue(1, 20);
    cout << "Valor en la posición 0: " << arr.getValue(0) << endl;
    cout << "Valor en la posición 1: " << arr.getValue(1) << endl;

    return 0;
}
<---Ejemplo con Recursos Dinámicos Result--->
<---Regla de Tres--->
```cpp
class Ejemplo {
private:
    int* data;

public:
    // Constructor
    Ejemplo(int size) {
        data = new int[size];
    }

    // Destructor
    ~Ejemplo() {
        delete[] data;
    }

    // Constructor de copia
    Ejemplo(const Ejemplo& other) {
        data = new int[other.size];
        // Copiar datos...
    }

    // Operador de asignación de copia
    Ejemplo& operator=(const Ejemplo& other) {
        if (this != &other) {
            delete[] data;
            data = new int[other.size];
            // Copiar datos...
        }
        return *this;
    }
};
<---Regla de Tres Result--->
<---Regla de Cinco--->
```cpp
class Ejemplo {
private:
    int* data;

public:
    // Constructor
    Ejemplo(int size) {
        data = new int[size];
    }

    // Destructor
    ~Ejemplo() {
        delete[] data;
    }

    // Constructor de copia
    Ejemplo(const Ejemplo& other) {
        data = new int[other.size];
        // Copiar datos...
    }

    // Operador de asignación de copia
    Ejemplo& operator=(const Ejemplo& other) {
        if (this != &other) {
            delete[] data;
            data = new int[other.size];
            // Copiar datos...
        }
        return *this;
    }

    // Constructor de movimiento
    Ejemplo(Ejemplo&& other) noexcept : data(other.data) {
        other.data = nullptr;
    }

    // Operador de asignación de movimiento
    Ejemplo& operator=(Ejemplo&& other) noexcept {
        if (this != &other) {
            delete[] data;
            data = other.data;
            other.data = nullptr;
        }
        return *this;
    }
};
<---Regla de Cinco Result--->
<---Ejemplo de Sobrecarga de Operadores--->
```cpp
#include <iostream>
using namespace std;

class Complejo {
private:
    double real;
    double imaginario;

public:
    // Constructor
    Complejo(double r = 0.0, double i = 0.0) : real(r), imaginario(i) {}

    // Sobrecarga del operador +
    Complejo operator+(const Complejo& c) const {
        return Complejo(real + c.real, imaginario + c.imaginario);
    }

    // Sobrecarga del operador <<
    friend ostream& operator<<(ostream& os, const Complejo& c) {
        os << "(" << c.real << " + " << c.imaginario << "i)";
        return os;
    }
};

int main() {
    Complejo c1(3.0, 4.0);
    Complejo c2(1.0, 2.0);

    Complejo c3 = c1 + c2;  // Usando la sobrecarga del operador +

    cout << "c1: " << c1 << endl;
    cout << "c2: " << c2 << endl;
    cout << "c3: " << c3 << endl;  // Usando la sobrecarga del operador <<

    return 0;
}
<---Ejemplo de Sobrecarga de Operadores Result--->
<---Ejemplo de Sobrecarga del Operador `*`--->
```cpp
#include <iostream>
using namespace std;

class Vector {
private:
    double x, y, z;

public:
    // Constructor
    Vector(double x, double y, double z) : x(x), y(y), z(z) {}

    // Sobrecarga del operador *
    Vector operator*(double escalar) const {
        return Vector(x * escalar, y * escalar, z * escalar);
    }

    // Sobrecarga del operador <<
    friend ostream& operator<<(ostream& os, const Vector& v) {
        os << "{" << v.x << ", " << v.y << ", " << v.z << "}";
        return os;
    }
};

int main() {
    Vector v1(1.0, 2.0, 3.0);
    Vector v2 = v1 * 2.0;

    cout << "v1: " << v1 << endl;
    cout << "v2: " << v2 << endl;

    return 0;
}
<---Ejemplo de Sobrecarga del Operador `*` Result--->
<---Ejemplo de Sobrecarga del Operador `==`--->
```cpp
#include <iostream>
using namespace std;

class Punto {
private:
    int x, y;

public:
    // Constructor
    Punto(int x = 0, int y = 0) : x(x), y(y) {}

    // Sobrecarga del operador ==
    bool operator==(const Punto& p) const {
        return (x == p.x && y == p.y);
    }

    // Sobrecarga del operador <<
    friend ostream& operator<<(ostream& os, const Punto& p) {
        os << "(" << p.x << ", " << p.y << ")";
        return os;
    }
};

int main() {
    Punto p1(1, 2);
    Punto p2(1, 2);
    Punto p3(3, 4);

    cout << "p1: " << p1 << endl;
    cout << "p2: " << p2 << endl;
    cout << "p3: " << p3 << endl;

    cout << "p1 == p2: " << (p1 == p2) << endl;
    cout << "p1 == p3: " << (p1 == p3) << endl;

    return 0;
}
<---Ejemplo de Sobrecarga del Operador `==` Result--->
<---Ejemplo de Sobrecarga del Operador `++`--->
```cpp
#include <iostream>
using namespace std;

class Contador {
private:
    int valor;

public:
    // Constructor
    Contador(int v = 0) : valor(v) {}

    // Sobrecarga del operador prefijo ++
    Contador& operator++() {
        ++valor;
        return *this;
    }

    // Sobrecarga del operador postfijo ++
    Contador operator++(int) {
        Contador temp = *this;
        ++valor;
        return temp;
    }

    // Sobrecarga del operador <<
    friend ostream& operator<<(ostream& os, const Contador& c) {
        os << c.valor;
        return os;
    }
};

int main() {
    Contador c(5);

    cout << "Valor inicial: " << c << endl;

    ++c;
    cout << "Después del prefijo ++: " << c << endl;

    c++;
    cout << "Después del postfijo ++: " << c << endl;

    return 0;
}
<---Ejemplo de Sobrecarga del Operador `++` Result--->
<---Ejemplo de Sobrecarga del Operador `[]`--->
```cpp
#include <iostream>
using namespace std;

class Array {
private:
    int* datos;
    int tamano;

public:
    // Constructor
    Array(int tamano) : tamano(tamano) {
        datos = new int[tamano];
        for (int i = 0; i < tamano; ++i) {
            datos[i] = 0;
        }
    }

    // Destructor
    ~Array() {
        delete[] datos;
    }

    // Sobrecarga del operador []
    int& operator[](int indice) {
        if (indice >= 0 && indice < tamano) {
            return datos[indice];
        }
        throw out_of_range("Índice fuera de rango");
    }

    // Sobrecarga del operador <<
    friend ostream& operator<<(ostream& os, const Array& arr) {
        os << "[";
        for (int i = 0; i < arr.tamano; ++i) {
            os << arr.datos[i];
            if (i < arr.tamano - 1) {
                os << ", ";
            }
        }
        os << "]";
        return os;
    }
};

int main() {
    Array arr(5);

    arr[0] = 10;
    arr[1] = 20;
    arr[2] = 30;

    cout << "Array: " << arr << endl;

    try {
        arr[5] = 50;  // Esto lanzará una excepción
    } catch (const out_of_range& e) {
        cout << e.what() << endl;
    }

    return 0;
}
<---Ejemplo de Sobrecarga del Operador `[]` Result--->
<---Definición de una Clase--->
```cpp
class NombreClase {
public:
    // Atributos
    tipo_atributo nombre_atributo;

    // Métodos
    tipo_retorno nombre_metodo(parametros);

    // Otros componentes, como constructores, destructores, etc.
};
<---Definición de una Clase Result--->
<---Ejemplo Básico de una Clase--->
```cpp
#include <iostream>
using namespace std;

class Persona {
public:
    // Atributos
    string nombre;
    int edad;

    // Métodos
    void saludar() {
        cout << "Hola, mi nombre es " << nombre << " y tengo " << edad << " años." << endl;
    }
};

int main() {
    // Crear un objeto de la clase Persona
    Persona juan;
    juan.nombre = "Juan";
    juan.edad = 30;

    // Llamar al método saludar
    juan.saludar();

    return 0;
}
<---Ejemplo Básico de una Clase Result--->
<---Creación de Objetos--->
```cpp
NombreClase nombre_objeto;
<---Creación de Objetos Result--->
<---Ejemplo de Creación y Uso de Objetos--->
```cpp
#include <iostream>
using namespace std;

class Coche {
public:
    // Atributos
    string marca;
    string modelo;
    int anio;

    // Métodos
    void mostrarInformacion() {
        cout << "Marca: " << marca << ", Modelo: " << modelo << ", Año: " << anio << endl;
    }
};

int main() {
    // Crear objetos de la clase Coche
    Coche coche1;
    coche1.marca = "Toyota";
    coche1.modelo = "Corolla";
    coche1.anio = 2020;

    Coche coche2;
    coche2.marca = "Honda";
    coche2.modelo = "Civic";
    coche2.anio = 2019;

    // Llamar a los métodos de los objetos
    coche1.mostrarInformacion();
    coche2.mostrarInformacion();

    return 0;
}
<---Ejemplo de Creación y Uso de Objetos Result--->
<---Constructores--->
```cpp
class Persona {
public:
    string nombre;
    int edad;

    // Constructor
    Persona(string n, int e) {
        nombre = n;
        edad = e;
    }

    void saludar() {
        cout << "Hola, mi nombre es " << nombre << " y tengo " << edad << " años." << endl;
    }
};

int main() {
    // Crear un objeto de la clase Persona utilizando el constructor
    Persona juan("Juan", 30);
    juan.saludar();

    return 0;
}
<---Constructores Result--->
<---Destructores--->
```cpp
class Persona {
public:
    string nombre;
    int edad;

    // Constructor
    Persona(string n, int e) {
        nombre = n;
        edad = e;
    }

    // Destructor
    ~Persona() {
        cout << "Destructor llamado para " << nombre << endl;
    }

    void saludar() {
        cout << "Hola, mi nombre es " << nombre << " y tengo " << edad << " años." << endl;
    }
};

int main() {
    // Crear un objeto de la clase Persona
    Persona juan("Juan", 30);
    juan.saludar();

    // El destructor se llamará automáticamente al final del alcance
    return 0;
}
<---Destructores Result--->
<---Modificadores de Acceso--->
```cpp
class Persona {
private:
    string nombre;
    int edad;

public:
    // Constructor
    Persona(string n, int e) : nombre(n), edad(e) {}

    // Métodos para acceder y modificar los atributos
    string getNombre() {
        return nombre;
    }

    void setNombre(string n) {
        nombre = n;
    }

    int getEdad() {
        return edad;
    }

    void setEdad(int e) {
        edad = e;
    }

    void saludar() {
        cout << "Hola, mi nombre es " << nombre << " y tengo " << edad << " años." << endl;
    }
};

int main() {
    Persona juan("Juan", 30);
    juan.saludar();

    juan.setEdad(31);
    cout << "Nueva edad de " << juan.getNombre() << ": " << juan.getEdad() << endl;

    return 0;
}
<---Modificadores de Acceso Result--->
<---Ejemplo de Constructor por Defecto--->
```cpp
#include <iostream>
using namespace std;

class Persona {
public:
    string nombre;
    int edad;

    // Constructor por defecto
    Persona() {
        nombre = "Desconocido";
        edad = 0;
    }

    void mostrarInformacion() {
        cout << "Nombre: " << nombre << ", Edad: " << edad << endl;
    }
};

int main() {
    Persona p;  // Llama al constructor por defecto
    p.mostrarInformacion();

    return 0;
}
<---Ejemplo de Constructor por Defecto Result--->
<---Ejemplo de Constructor Parametrizado--->
```cpp
#include <iostream>
using namespace std;

class Persona {
public:
    string nombre;
    int edad;

    // Constructor parametrizado
    Persona(string n, int e) {
        nombre = n;
        edad = e;
    }

    void mostrarInformacion() {
        cout << "Nombre: " << nombre << ", Edad: " << edad << endl;
    }
};

int main() {
    Persona p("Juan", 30);  // Llama al constructor parametrizado
    p.mostrarInformacion();

    return 0;
}
<---Ejemplo de Constructor Parametrizado Result--->
<---Ejemplo de Constructor de Copia--->
```cpp
#include <iostream>
using namespace std;

class Persona {
public:
    string nombre;
    int edad;

    // Constructor parametrizado
    Persona(string n, int e) {
        nombre = n;
        edad = e;
    }

    // Constructor de copia
    Persona(const Persona& p) {
        nombre = p.nombre;
        edad = p.edad;
    }

    void mostrarInformacion() {
        cout << "Nombre: " << nombre << ", Edad: " << edad << endl;
    }
};

int main() {
    Persona p1("Juan", 30);  // Llama al constructor parametrizado
    Persona p2 = p1;         // Llama al constructor de copia
    p2.mostrarInformacion();

    return 0;
}
<---Ejemplo de Constructor de Copia Result--->
<---Ejemplo de Constructor de Movimiento--->
```cpp
#include <iostream>
using namespace std;

class Persona {
public:
    string nombre;
    int edad;

    // Constructor parametrizado
    Persona(string n, int e) : nombre(n), edad(e) {}

    // Constructor de movimiento
    Persona(Persona&& p) noexcept : nombre(move(p.nombre)), edad(p.edad) {
        p.edad = 0; // Opcional: Dejar el objeto fuente en un estado válido
    }

    void mostrarInformacion() {
        cout << "Nombre: " << nombre << ", Edad: " << edad << endl;
    }
};

int main() {
    Persona p1("Juan", 30);  // Llama al constructor parametrizado
    Persona p2 = move(p1);   // Llama al constructor de movimiento
    p2.mostrarInformacion();

    // p1 está en un estado indefinido, pero válido
    cout << "Después de mover, p1: ";
    p1.mostrarInformacion();

    return 0;
}
<---Ejemplo de Constructor de Movimiento Result--->
<---Ejemplo con Lista de Inicialización--->
```cpp
#include <iostream>
using namespace std;

class Punto {
public:
    const int x;
    const int y;

    // Constructor con lista de inicialización
    Punto(int a, int b) : x(a), y(b) {}

    void mostrarInformacion() {
        cout << "Punto(" << x << ", " << y << ")" << endl;
    }
};

int main() {
    Punto p(10, 20);  // Llama al constructor con lista de inicialización
    p.mostrarInformacion();

    return 0;
}
```cpp
#include <iostream>
using namespace std;

class Persona {
private:
    string nombre;
    int edad;

public:
    // Constructor por defecto
    Persona() : nombre("Desconocido"), edad(0) {}

    // Constructor parametrizado
    Persona(string n, int e) : nombre(n), edad(e) {}

    // Constructor de copia
    Persona(const Persona& p) : nombre(p.nombre), edad(p.edad) {}

    // Constructor de movimiento
    Persona(Persona&& p) noexcept : nombre(move(p.nombre)), edad(p.edad) {
        p.edad = 0;
    }

    void mostrarInformacion() {
        cout << "Nombre: " << nombre << ", Edad: " << edad << endl;
    }
};

int main() {
    // Usando el constructor por defecto
    Persona p1;
    p1.mostrarInformacion();

    // Usando el constructor parametrizado
    Persona p2("Juan", 30);
    p2.mostrarInformacion();

    // Usando el constructor de copia
    Persona p3 = p2;
    p3.mostrarInformacion();

    // Usando el constructor de movimiento
    Persona p4 = move(p2);
    p4.mostrarInformacion();

    // Estado después del movimiento
    cout << "Después de mover, p2: ";
    p2.mostrarInformacion();

    return 0;
}
<---Ejemplo con Lista de Inicialización Result--->
<---Definición de Atributos Privados--->
```cpp
class Persona {
private:
    string nombre;
    int edad;

public:
    // Métodos públicos
};
<---Definición de Atributos Privados Result--->
<---Ejemplo de Getters--->
```cpp
class Persona {
private:
    string nombre;
    int edad;

public:
    // Constructor
    Persona(string n, int e) : nombre(n), edad(e) {}

    // Getter para el nombre
    string getNombre() const {
        return nombre;
    }

    // Getter para la edad
    int getEdad() const {
        return edad;
    }
};
<---Ejemplo de Getters Result--->
<---Ejemplo de Setters--->
```cpp
class Persona {
private:
    string nombre;
    int edad;

public:
    // Constructor
    Persona(string n, int e) : nombre(n), edad(e) {}

    // Setter para el nombre
    void setNombre(string n) {
        nombre = n;
    }

    // Setter para la edad
    void setEdad(int e) {
        if (e > 0) {  // Validación simple
            edad = e;
        } else {
            cout << "Edad no válida." << endl;
        }
    }

    // Getters
    string getNombre() const {
        return nombre;
    }

    int getEdad() const {
        return edad;
    }
};
<---Ejemplo de Setters Result--->
<---Ejemplo Completo--->
```cpp
#include <iostream>
using namespace std;

class Persona {
private:
    string nombre;
    int edad;

public:
    // Constructor
    Persona(string n, int e) : nombre(n), edad(e) {}

    // Setters
    void setNombre(string n) {
        nombre = n;
    }

    void setEdad(int e) {
        if (e > 0) {
            edad = e;
        } else {
            cout << "Edad no válida." << endl;
        }
    }

    // Getters
    string getNombre() const {
        return nombre;
    }

    int getEdad() const {
        return edad;
    }

    // Método para mostrar información
    void mostrarInformacion() const {
        cout << "Nombre: " << nombre << ", Edad: " << edad << endl;
    }
};

int main() {
    // Crear un objeto de la clase Persona
    Persona juan("Juan", 30);
    juan.mostrarInformacion();

    // Modificar los atributos usando setters
    juan.setNombre("Juan Perez");
    juan.setEdad(31);
    juan.mostrarInformacion();

    // Intentar establecer una edad no válida
    juan.setEdad(-5);
    juan.mostrarInformacion();

    // Acceder a los atributos usando getters
    cout << "Nombre: " << juan.getNombre() << endl;
    cout << "Edad: " << juan.getEdad() << endl;

    return 0;
}
<---Ejemplo Completo Result--->
<---Ejemplo Básico--->
```cpp
#include <iostream>
using namespace std;

class Ejemplo {
private:
    int datoPrivado; // Acceso privado

public:
    int datoPublico; // Acceso público

    // Constructor
    Ejemplo(int privado, int publico) : datoPrivado(privado), datoPublico(publico) {}

    // Método público para acceder al dato privado
    int getDatoPrivado() const {
        return datoPrivado;
    }

    // Método público para modificar el dato privado
    void setDatoPrivado(int valor) {
        datoPrivado = valor;
    }
};

int main() {
    Ejemplo obj(10, 20);

    // Acceso al dato público
    cout << "Dato público: " << obj.datoPublico << endl;

    // Acceso al dato privado a través de métodos públicos
    cout << "Dato privado: " << obj.getDatoPrivado() << endl;
    obj.setDatoPrivado(30);
    cout << "Dato privado modificado: " << obj.getDatoPrivado() << endl;

    return 0;
}
<---Ejemplo Básico Result--->
<---Ejemplo con Setters y Getters--->
```cpp
#include <iostream>
using namespace std;

class Persona {
private:
    string nombre;
    int edad;

public:
    // Constructor
    Persona(string n, int e) : nombre(n), edad(e) {}

    // Getter para nombre
    string getNombre() const {
        return nombre;
    }

    // Setter para nombre
    void setNombre(string n) {
        nombre = n;
    }

    // Getter para edad
    int getEdad() const {
        return edad;
    }

    // Setter para edad con validación
    void setEdad(int e) {
        if (e > 0) {
            edad = e;
        } else {
            cout << "Edad no válida" << endl;
        }
    }

    // Método para mostrar información
    void mostrarInformacion() const {
        cout << "Nombre: " << nombre << ", Edad: " << edad << endl;
    }
};

int main() {
    Persona juan("Juan", 30);
    juan.mostrarInformacion();

    // Modificar atributos usando setters
    juan.setNombre("Juan Perez");
    juan.setEdad(31);
    juan.mostrarInformacion();

    // Intentar establecer una edad no válida
    juan.setEdad(-5);
    juan.mostrarInformacion();

    return 0;
}
<---Ejemplo con Setters y Getters Result--->
<---Ejemplo con Herencia--->
```cpp
#include <iostream>
using namespace std;

class Base {
public:
    // Constructor
    Base() {
        cout << "Constructor de Base" << endl;
    }

    // Destructor virtual
    virtual ~Base() {
        cout << "Destructor de Base" << endl;
    }
};

class Derivada : public Base {
public:
    // Constructor
    Derivada() {
        cout << "Constructor de Derivada" << endl;
    }

    // Destructor
    ~Derivada() {
        cout << "Destructor de Derivada" << endl;
    }
};

int main() {
    Base* obj = new Derivada(); // Crear objeto de clase derivada
    delete obj; // Llamar al destructor virtual

    return 0;
}
<---Ejemplo con Herencia Result--->
<---Sintaxis del Destructor--->
```cpp
class NombreClase {
public:
    // Constructor
    NombreClase();

    // Destructor
    ~NombreClase();

    // Otros métodos y atributos
};
```cpp
#include <iostream>
using namespace std;

class Persona {
public:
    string nombre;

    // Constructor
    Persona(string n) : nombre(n) {
        cout << "Constructor llamado para " << nombre << endl;
    }

    // Destructor
    ~Persona() {
        cout << "Destructor llamado para " << nombre << endl;
    }
};

int main() {
    Persona juan("Juan");
    {
        Persona maria("Maria");
    } // Destructor llamado para maria aquí

    cout << "Fin del main" << endl;
    return 0; // Destructor llamado para juan aquí
}
<---Sintaxis del Destructor Result--->
<---Ejemplo Básico de Destructor--->
```cpp
#include <iostream>
using namespace std;

class Persona {
public:
    string nombre;

    // Constructor
    Persona(string n) : nombre(n) {
        cout << "Constructor llamado para " << nombre << endl;
    }

    // Destructor
    ~Persona() {
        cout << "Destructor llamado para " << nombre << endl;
    }
};

int main() {
    Persona juan("Juan");
    {
        Persona maria("Maria");
    } // Destructor llamado para maria aquí

    cout << "Fin del main" << endl;
    return 0; // Destructor llamado para juan aquí
}
<---Ejemplo Básico de Destructor Result--->
<---Ejemplo con Recursos Dinámicos--->
```cpp
#include <iostream>
using namespace std;

class Array {
private:
    int* data;
    int size;

public:
    // Constructor
    Array(int s) : size(s) {
        data = new int[size]; // Asignar memoria dinámica
        cout << "Array de tamaño " << size << " creado." << endl;
    }

    // Destructor
    ~Array() {
        delete[] data; // Liberar memoria dinámica
        cout << "Array de tamaño " << size << " destruido." << endl;
    }

    // Método para establecer un valor en el array
    void setValue(int index, int value) {
        if (index >= 0 && index < size) {
            data[index] = value;
        }
    }

    // Método para obtener un valor del array
    int getValue(int index) const {
        if (index >= 0 && index < size) {
            return data[index];
        }
        return -1; // Valor de error
    }
};

int main() {
    Array arr(5);
    arr.setValue(0, 10);
    arr.setValue(1, 20);
    cout << "Valor en la posición 0: " << arr.getValue(0) << endl;
    cout << "Valor en la posición 1: " << arr.getValue(1) << endl;

    return 0;
}
<---Ejemplo con Recursos Dinámicos Result--->
<---Regla de Tres--->
```cpp
class Ejemplo {
private:
    int* data;

public:
    // Constructor
    Ejemplo(int size) {
        data = new int[size];
    }

    // Destructor
    ~Ejemplo() {
        delete[] data;
    }

    // Constructor de copia
    Ejemplo(const Ejemplo& other) {
        data = new int[other.size];
        // Copiar datos...
    }

    // Operador de asignación de copia
    Ejemplo& operator=(const Ejemplo& other) {
        if (this != &other) {
            delete[] data;
            data = new int[other.size];
            // Copiar datos...
        }
        return *this;
    }
};
<---Regla de Tres Result--->
<---Regla de Cinco--->
```cpp
class Ejemplo {
private:
    int* data;

public:
    // Constructor
    Ejemplo(int size) {
        data = new int[size];
    }

    // Destructor
    ~Ejemplo() {
        delete[] data;
    }

    // Constructor de copia
    Ejemplo(const Ejemplo& other) {
        data = new int[other.size];
        // Copiar datos...
    }

    // Operador de asignación de copia
    Ejemplo& operator=(const Ejemplo& other) {
        if (this != &other) {
            delete[] data;
            data = new int[other.size];
            // Copiar datos...
        }
        return *this;
    }

    // Constructor de movimiento
    Ejemplo(Ejemplo&& other) noexcept : data(other.data) {
        other.data = nullptr;
    }

    // Operador de asignación de movimiento
    Ejemplo& operator=(Ejemplo&& other) noexcept {
        if (this != &other) {
            delete[] data;
            data = other.data;
            other.data = nullptr;
        }
        return *this;
    }
};
<---Regla de Cinco Result--->
<---Ejemplo de Sobrecarga de Operadores--->
```cpp
#include <iostream>
using namespace std;

class Complejo {
private:
    double real;
    double imaginario;

public:
    // Constructor
    Complejo(double r = 0.0, double i = 0.0) : real(r), imaginario(i) {}

    // Sobrecarga del operador +
    Complejo operator+(const Complejo& c) const {
        return Complejo(real + c.real, imaginario + c.imaginario);
    }

    // Sobrecarga del operador <<
    friend ostream& operator<<(ostream& os, const Complejo& c) {
        os << "(" << c.real << " + " << c.imaginario << "i)";
        return os;
    }
};

int main() {
    Complejo c1(3.0, 4.0);
    Complejo c2(1.0, 2.0);

    Complejo c3 = c1 + c2;  // Usando la sobrecarga del operador +

    cout << "c1: " << c1 << endl;
    cout << "c2: " << c2 << endl;
    cout << "c3: " << c3 << endl;  // Usando la sobrecarga del operador <<

    return 0;
}
<---Ejemplo de Sobrecarga de Operadores Result--->
<---Ejemplo de Sobrecarga del Operador `*`--->
```cpp
#include <iostream>
using namespace std;

class Vector {
private:
    double x, y, z;

public:
    // Constructor
    Vector(double x, double y, double z) : x(x), y(y), z(z) {}

    // Sobrecarga del operador *
    Vector operator*(double escalar) const {
        return Vector(x * escalar, y * escalar, z * escalar);
    }

    // Sobrecarga del operador <<
    friend ostream& operator<<(ostream& os, const Vector& v) {
        os << "{" << v.x << ", " << v.y << ", " << v.z << "}";
        return os;
    }
};

int main() {
    Vector v1(1.0, 2.0, 3.0);
    Vector v2 = v1 * 2.0;

    cout << "v1: " << v1 << endl;
    cout << "v2: " << v2 << endl;

    return 0;
}
<---Ejemplo de Sobrecarga del Operador `*` Result--->
<---Ejemplo de Sobrecarga del Operador `==`--->
```cpp
#include <iostream>
using namespace std;

class Punto {
private:
    int x, y;

public:
    // Constructor
    Punto(int x = 0, int y = 0) : x(x), y(y) {}

    // Sobrecarga del operador ==
    bool operator==(const Punto& p) const {
        return (x == p.x && y == p.y);
    }

    // Sobrecarga del operador <<
    friend ostream& operator<<(ostream& os, const Punto& p) {
        os << "(" << p.x << ", " << p.y << ")";
        return os;
    }
};

int main() {
    Punto p1(1, 2);
    Punto p2(1, 2);
    Punto p3(3, 4);

    cout << "p1: " << p1 << endl;
    cout << "p2: " << p2 << endl;
    cout << "p3: " << p3 << endl;

    cout << "p1 == p2: " << (p1 == p2) << endl;
    cout << "p1 == p3: " << (p1 == p3) << endl;

    return 0;
}
<---Ejemplo de Sobrecarga del Operador `==` Result--->
<---Ejemplo de Sobrecarga del Operador `++`--->
```cpp
#include <iostream>
using namespace std;

class Contador {
private:
    int valor;

public:
    // Constructor
    Contador(int v = 0) : valor(v) {}

    // Sobrecarga del operador prefijo ++
    Contador& operator++() {
        ++valor;
        return *this;
    }

    // Sobrecarga del operador postfijo ++
    Contador operator++(int) {
        Contador temp = *this;
        ++valor;
        return temp;
    }

    // Sobrecarga del operador <<
    friend ostream& operator<<(ostream& os, const Contador& c) {
        os << c.valor;
        return os;
    }
};

int main() {
    Contador c(5);

    cout << "Valor inicial: " << c << endl;

    ++c;
    cout << "Después del prefijo ++: " << c << endl;

    c++;
    cout << "Después del postfijo ++: " << c << endl;

    return 0;
}
<---Ejemplo de Sobrecarga del Operador `++` Result--->
<---Ejemplo de Sobrecarga del Operador `[]`--->
```cpp
#include <iostream>
using namespace std;

class Array {
private:
    int* datos;
    int tamano;

public:
    // Constructor
    Array(int tamano) : tamano(tamano) {
        datos = new int[tamano];
        for (int i = 0; i < tamano; ++i) {
            datos[i] = 0;
        }
    }

    // Destructor
    ~Array() {
        delete[] datos;
    }

    // Sobrecarga del operador []
    int& operator[](int indice) {
        if (indice >= 0 && indice < tamano) {
            return datos[indice];
        }
        throw out_of_range("Índice fuera de rango");
    }

    // Sobrecarga del operador <<
    friend ostream& operator<<(ostream& os, const Array& arr) {
        os << "[";
        for (int i = 0; i < arr.tamano; ++i) {
            os << arr.datos[i];
            if (i < arr.tamano - 1) {
                os << ", ";
            }
        }
        os << "]";
        return os;
    }
};

int main() {
    Array arr(5);

    arr[0] = 10;
    arr[1] = 20;
    arr[2] = 30;

    cout << "Array: " << arr << endl;

    try {
        arr[5] = 50;  // Esto lanzará una excepción
    } catch (const out_of_range& e) {
        cout << e.what() << endl;
    }

    return 0;
}
<---Ejemplo de Sobrecarga del Operador `[]` Result--->
<---Definición de una Clase--->
```cpp
class NombreClase {
public:
    // Atributos
    tipo_atributo nombre_atributo;

    // Métodos
    tipo_retorno nombre_metodo(parametros);

    // Otros componentes, como constructores, destructores, etc.
};
<---Definición de una Clase Result--->
<---Ejemplo Básico de una Clase--->
```cpp
#include <iostream>
using namespace std;

class Persona {
public:
    // Atributos
    string nombre;
    int edad;

    // Métodos
    void saludar() {
        cout << "Hola, mi nombre es " << nombre << " y tengo " << edad << " años." << endl;
    }
};

int main() {
    // Crear un objeto de la clase Persona
    Persona juan;
    juan.nombre = "Juan";
    juan.edad = 30;

    // Llamar al método saludar
    juan.saludar();

    return 0;
}
<---Ejemplo Básico de una Clase Result--->
<---Creación de Objetos--->
```cpp
NombreClase nombre_objeto;
<---Creación de Objetos Result--->
<---Ejemplo de Creación y Uso de Objetos--->
```cpp
#include <iostream>
using namespace std;

class Coche {
public:
    // Atributos
    string marca;
    string modelo;
    int anio;

    // Métodos
    void mostrarInformacion() {
        cout << "Marca: " << marca << ", Modelo: " << modelo << ", Año: " << anio << endl;
    }
};

int main() {
    // Crear objetos de la clase Coche
    Coche coche1;
    coche1.marca = "Toyota";
    coche1.modelo = "Corolla";
    coche1.anio = 2020;

    Coche coche2;
    coche2.marca = "Honda";
    coche2.modelo = "Civic";
    coche2.anio = 2019;

    // Llamar a los métodos de los objetos
    coche1.mostrarInformacion();
    coche2.mostrarInformacion();

    return 0;
}
<---Ejemplo de Creación y Uso de Objetos Result--->
<---Constructores--->
```cpp
class Persona {
public:
    string nombre;
    int edad;

    // Constructor
    Persona(string n, int e) {
        nombre = n;
        edad = e;
    }

    void saludar() {
        cout << "Hola, mi nombre es " << nombre << " y tengo " << edad << " años." << endl;
    }
};

int main() {
    // Crear un objeto de la clase Persona utilizando el constructor
    Persona juan("Juan", 30);
    juan.saludar();

    return 0;
}
<---Constructores Result--->
<---Destructores--->
```cpp
class Persona {
public:
    string nombre;
    int edad;

    // Constructor
    Persona(string n, int e) {
        nombre = n;
        edad = e;
    }

    // Destructor
    ~Persona() {
        cout << "Destructor llamado para " << nombre << endl;
    }

    void saludar() {
        cout << "Hola, mi nombre es " << nombre << " y tengo " << edad << " años." << endl;
    }
};

int main() {
    // Crear un objeto de la clase Persona
    Persona juan("Juan", 30);
    juan.saludar();

    // El destructor se llamará automáticamente al final del alcance
    return 0;
}
<---Destructores Result--->
<---Modificadores de Acceso--->
```cpp
class Persona {
private:
    string nombre;
    int edad;

public:
    // Constructor
    Persona(string n, int e) : nombre(n), edad(e) {}

    // Métodos para acceder y modificar los atributos
    string getNombre() {
        return nombre;
    }

    void setNombre(string n) {
        nombre = n;
    }

    int getEdad() {
        return edad;
    }

    void setEdad(int e) {
        edad = e;
    }

    void saludar() {
        cout << "Hola, mi nombre es " << nombre << " y tengo " << edad << " años." << endl;
    }
};

int main() {
    Persona juan("Juan", 30);
    juan.saludar();

    juan.setEdad(31);
    cout << "Nueva edad de " << juan.getNombre() << ": " << juan.getEdad() << endl;

    return 0;
}
<---Modificadores de Acceso Result--->
<---Ejemplo de Constructor por Defecto--->
```cpp
#include <iostream>
using namespace std;

class Persona {
public:
    string nombre;
    int edad;

    // Constructor por defecto
    Persona() {
        nombre = "Desconocido";
        edad = 0;
    }

    void mostrarInformacion() {
        cout << "Nombre: " << nombre << ", Edad: " << edad << endl;
    }
};

int main() {
    Persona p;  // Llama al constructor por defecto
    p.mostrarInformacion();

    return 0;
}
<---Ejemplo de Constructor por Defecto Result--->
<---Ejemplo de Constructor Parametrizado--->
```cpp
#include <iostream>
using namespace std;

class Persona {
public:
    string nombre;
    int edad;

    // Constructor parametrizado
    Persona(string n, int e) {
        nombre = n;
        edad = e;
    }

    void mostrarInformacion() {
        cout << "Nombre: " << nombre << ", Edad: " << edad << endl;
    }
};

int main() {
    Persona p("Juan", 30);  // Llama al constructor parametrizado
    p.mostrarInformacion();

    return 0;
}
<---Ejemplo de Constructor Parametrizado Result--->
<---Ejemplo de Constructor de Copia--->
```cpp
#include <iostream>
using namespace std;

class Persona {
public:
    string nombre;
    int edad;

    // Constructor parametrizado
    Persona(string n, int e) {
        nombre = n;
        edad = e;
    }

    // Constructor de copia
    Persona(const Persona& p) {
        nombre = p.nombre;
        edad = p.edad;
    }

    void mostrarInformacion() {
        cout << "Nombre: " << nombre << ", Edad: " << edad << endl;
    }
};

int main() {
    Persona p1("Juan", 30);  // Llama al constructor parametrizado
    Persona p2 = p1;         // Llama al constructor de copia
    p2.mostrarInformacion();

    return 0;
}
<---Ejemplo de Constructor de Copia Result--->
<---Ejemplo de Constructor de Movimiento--->
```cpp
#include <iostream>
using namespace std;

class Persona {
public:
    string nombre;
    int edad;

    // Constructor parametrizado
    Persona(string n, int e) : nombre(n), edad(e) {}

    // Constructor de movimiento
    Persona(Persona&& p) noexcept : nombre(move(p.nombre)), edad(p.edad) {
        p.edad = 0; // Opcional: Dejar el objeto fuente en un estado válido
    }

    void mostrarInformacion() {
        cout << "Nombre: " << nombre << ", Edad: " << edad << endl;
    }
};

int main() {
    Persona p1("Juan", 30);  // Llama al constructor parametrizado
    Persona p2 = move(p1);   // Llama al constructor de movimiento
    p2.mostrarInformacion();

    // p1 está en un estado indefinido, pero válido
    cout << "Después de mover, p1: ";
    p1.mostrarInformacion();

    return 0;
}
<---Ejemplo de Constructor de Movimiento Result--->
<---Ejemplo con Lista de Inicialización--->
```cpp
#include <iostream>
using namespace std;

class Punto {
public:
    const int x;
    const int y;

    // Constructor con lista de inicialización
    Punto(int a, int b) : x(a), y(b) {}

    void mostrarInformacion() {
        cout << "Punto(" << x << ", " << y << ")" << endl;
    }
};

int main() {
    Punto p(10, 20);  // Llama al constructor con lista de inicialización
    p.mostrarInformacion();

    return 0;
}
```cpp
#include <iostream>
using namespace std;

class Persona {
private:
    string nombre;
    int edad;

public:
    // Constructor por defecto
    Persona() : nombre("Desconocido"), edad(0) {}

    // Constructor parametrizado
    Persona(string n, int e) : nombre(n), edad(e) {}

    // Constructor de copia
    Persona(const Persona& p) : nombre(p.nombre), edad(p.edad) {}

    // Constructor de movimiento
    Persona(Persona&& p) noexcept : nombre(move(p.nombre)), edad(p.edad) {
        p.edad = 0;
    }

    void mostrarInformacion() {
        cout << "Nombre: " << nombre << ", Edad: " << edad << endl;
    }
};

int main() {
    // Usando el constructor por defecto
    Persona p1;
    p1.mostrarInformacion();

    // Usando el constructor parametrizado
    Persona p2("Juan", 30);
    p2.mostrarInformacion();

    // Usando el constructor de copia
    Persona p3 = p2;
    p3.mostrarInformacion();

    // Usando el constructor de movimiento
    Persona p4 = move(p2);
    p4.mostrarInformacion();

    // Estado después del movimiento
    cout << "Después de mover, p2: ";
    p2.mostrarInformacion();

    return 0;
}
<---Ejemplo con Lista de Inicialización Result--->
<---Definición de Atributos Privados--->
```cpp
class Persona {
private:
    string nombre;
    int edad;

public:
    // Métodos públicos
};
<---Definición de Atributos Privados Result--->
<---Ejemplo de Getters--->
```cpp
class Persona {
private:
    string nombre;
    int edad;

public:
    // Constructor
    Persona(string n, int e) : nombre(n), edad(e) {}

    // Getter para el nombre
    string getNombre() const {
        return nombre;
    }

    // Getter para la edad
    int getEdad() const {
        return edad;
    }
};
<---Ejemplo de Getters Result--->
<---Ejemplo de Setters--->
```cpp
class Persona {
private:
    string nombre;
    int edad;

public:
    // Constructor
    Persona(string n, int e) : nombre(n), edad(e) {}

    // Setter para el nombre
    void setNombre(string n) {
        nombre = n;
    }

    // Setter para la edad
    void setEdad(int e) {
        if (e > 0) {  // Validación simple
            edad = e;
        } else {
            cout << "Edad no válida." << endl;
        }
    }

    // Getters
    string getNombre() const {
        return nombre;
    }

    int getEdad() const {
        return edad;
    }
};
<---Ejemplo de Setters Result--->
<---Ejemplo Completo--->
```cpp
#include <iostream>
using namespace std;

class Persona {
private:
    string nombre;
    int edad;

public:
    // Constructor
    Persona(string n, int e) : nombre(n), edad(e) {}

    // Setters
    void setNombre(string n) {
        nombre = n;
    }

    void setEdad(int e) {
        if (e > 0) {
            edad = e;
        } else {
            cout << "Edad no válida." << endl;
        }
    }

    // Getters
    string getNombre() const {
        return nombre;
    }

    int getEdad() const {
        return edad;
    }

    // Método para mostrar información
    void mostrarInformacion() const {
        cout << "Nombre: " << nombre << ", Edad: " << edad << endl;
    }
};

int main() {
    // Crear un objeto de la clase Persona
    Persona juan("Juan", 30);
    juan.mostrarInformacion();

    // Modificar los atributos usando setters
    juan.setNombre("Juan Perez");
    juan.setEdad(31);
    juan.mostrarInformacion();

    // Intentar establecer una edad no válida
    juan.setEdad(-5);
    juan.mostrarInformacion();

    // Acceder a los atributos usando getters
    cout << "Nombre: " << juan.getNombre() << endl;
    cout << "Edad: " << juan.getEdad() << endl;

    return 0;
}
<---Ejemplo Completo Result--->
<---Ejemplo Básico--->
```cpp
#include <iostream>
using namespace std;

class Punto {
private:
    int x, y;

public:
    // Constructor
    Punto(int x = 0, int y = 0) : x(x), y(y) {}

    // Función para establecer valores usando this
    void setXY(int x, int y) {
        this->x = x;  // Acceso a miembro de la clase
        this->y = y;  // Acceso a miembro de la clase
    }

    // Función para mostrar valores
    void mostrar() const {
        cout << "Punto(" << x << ", " << y << ")" << endl;
    }
};

int main() {
    Punto p(10, 20);
    p.mostrar();

    p.setXY(30, 40);
    p.mostrar();

    return 0;
}
<---Ejemplo Básico Result--->
<---Ejemplo con Setters y Getters--->
```cpp
#include <iostream>
using namespace std;

class Persona {
private:
    string nombre;
    int edad;

public:
    // Constructor
    Persona(string n, int e) : nombre(n), edad(e) {}

    // Getter para nombre
    string getNombre() const {
        return nombre;
    }

    // Setter para nombre
    void setNombre(string n) {
        nombre = n;
    }

    // Getter para edad
    int getEdad() const {
        return edad;
    }

    // Setter para edad con validación
    void setEdad(int e) {
        if (e > 0) {
            edad = e;
        } else {
            cout << "Edad no válida" << endl;
        }
    }

    // Método para mostrar información
    void mostrarInformacion() const {
        cout << "Nombre: " << nombre << ", Edad: " << edad << endl;
    }
};

int main() {
    Persona juan("Juan", 30);
    juan.mostrarInformacion();

    // Modificar atributos usando setters
    juan.setNombre("Juan Perez");
    juan.setEdad(31);
    juan.mostrarInformacion();

    // Intentar establecer una edad no válida
    juan.setEdad(-5);
    juan.mostrarInformacion();

    return 0;
}
<---Ejemplo con Setters y Getters Result--->
<---Ejemplo con Herencia--->
```cpp
#include <iostream>
using namespace std;

class Base {
public:
    // Constructor
    Base() {
        cout << "Constructor de Base" << endl;
    }

    // Destructor virtual
    virtual ~Base() {
        cout << "Destructor de Base" << endl;
    }
};

class Derivada : public Base {
public:
    // Constructor
    Derivada() {
        cout << "Constructor de Derivada" << endl;
    }

    // Destructor
    ~Derivada() {
        cout << "Destructor de Derivada" << endl;
    }
};

int main() {
    Base* obj = new Derivada(); // Crear objeto de clase derivada
    delete obj; // Llamar al destructor virtual

    return 0;
}
<---Ejemplo con Herencia Result--->
<---Sintaxis del Destructor--->
```cpp
class NombreClase {
public:
    // Constructor
    NombreClase();

    // Destructor
    ~NombreClase();

    // Otros métodos y atributos
};
```cpp
#include <iostream>
using namespace std;

class Persona {
public:
    string nombre;

    // Constructor
    Persona(string n) : nombre(n) {
        cout << "Constructor llamado para " << nombre << endl;
    }

    // Destructor
    ~Persona() {
        cout << "Destructor llamado para " << nombre << endl;
    }
};

int main() {
    Persona juan("Juan");
    {
        Persona maria("Maria");
    } // Destructor llamado para maria aquí

    cout << "Fin del main" << endl;
    return 0; // Destructor llamado para juan aquí
}
<---Sintaxis del Destructor Result--->
<---Ejemplo Básico de Destructor--->
```cpp
#include <iostream>
using namespace std;

class Persona {
public:
    string nombre;

    // Constructor
    Persona(string n) : nombre(n) {
        cout << "Constructor llamado para " << nombre << endl;
    }

    // Destructor
    ~Persona() {
        cout << "Destructor llamado para " << nombre << endl;
    }
};

int main() {
    Persona juan("Juan");
    {
        Persona maria("Maria");
    } // Destructor llamado para maria aquí

    cout << "Fin del main" << endl;
    return 0; // Destructor llamado para juan aquí
}
<---Ejemplo Básico de Destructor Result--->
<---Ejemplo con Recursos Dinámicos--->
```cpp
#include <iostream>
using namespace std;

class Array {
private:
    int* data;
    int size;

public:
    // Constructor
    Array(int s) : size(s) {
        data = new int[size]; // Asignar memoria dinámica
        cout << "Array de tamaño " << size << " creado." << endl;
    }

    // Destructor
    ~Array() {
        delete[] data; // Liberar memoria dinámica
        cout << "Array de tamaño " << size << " destruido." << endl;
    }

    // Método para establecer un valor en el array
    void setValue(int index, int value) {
        if (index >= 0 && index < size) {
            data[index] = value;
        }
    }

    // Método para obtener un valor del array
    int getValue(int index) const {
        if (index >= 0 && index < size) {
            return data[index];
        }
        return -1; // Valor de error
    }
};

int main() {
    Array arr(5);
    arr.setValue(0, 10);
    arr.setValue(1, 20);
    cout << "Valor en la posición 0: " << arr.getValue(0) << endl;
    cout << "Valor en la posición 1: " << arr.getValue(1) << endl;

    return 0;
}
<---Ejemplo con Recursos Dinámicos Result--->
<---Regla de Tres--->
```cpp
class Ejemplo {
private:
    int* data;

public:
    // Constructor
    Ejemplo(int size) {
        data = new int[size];
    }

    // Destructor
    ~Ejemplo() {
        delete[] data;
    }

    // Constructor de copia
    Ejemplo(const Ejemplo& other) {
        data = new int[other.size];
        // Copiar datos...
    }

    // Operador de asignación de copia
    Ejemplo& operator=(const Ejemplo& other) {
        if (this != &other) {
            delete[] data;
            data = new int[other.size];
            // Copiar datos...
        }
        return *this;
    }
};
<---Regla de Tres Result--->
<---Regla de Cinco--->
```cpp
class Ejemplo {
private:
    int* data;

public:
    // Constructor
    Ejemplo(int size) {
        data = new int[size];
    }

    // Destructor
    ~Ejemplo() {
        delete[] data;
    }

    // Constructor de copia
    Ejemplo(const Ejemplo& other) {
        data = new int[other.size];
        // Copiar datos...
    }

    // Operador de asignación de copia
    Ejemplo& operator=(const Ejemplo& other) {
        if (this != &other) {
            delete[] data;
            data = new int[other.size];
            // Copiar datos...
        }
        return *this;
    }

    // Constructor de movimiento
    Ejemplo(Ejemplo&& other) noexcept : data(other.data) {
        other.data = nullptr;
    }

    // Operador de asignación de movimiento
    Ejemplo& operator=(Ejemplo&& other) noexcept {
        if (this != &other) {
            delete[] data;
            data = other.data;
            other.data = nullptr;
        }
        return *this;
    }
};
<---Regla de Cinco Result--->
<---Ejemplo de Sobrecarga de Operadores--->
```cpp
#include <iostream>
using namespace std;

class Complejo {
private:
    double real;
    double imaginario;

public:
    // Constructor
    Complejo(double r = 0.0, double i = 0.0) : real(r), imaginario(i) {}

    // Sobrecarga del operador +
    Complejo operator+(const Complejo& c) const {
        return Complejo(real + c.real, imaginario + c.imaginario);
    }

    // Sobrecarga del operador <<
    friend ostream& operator<<(ostream& os, const Complejo& c) {
        os << "(" << c.real << " + " << c.imaginario << "i)";
        return os;
    }
};

int main() {
    Complejo c1(3.0, 4.0);
    Complejo c2(1.0, 2.0);

    Complejo c3 = c1 + c2;  // Usando la sobrecarga del operador +

    cout << "c1: " << c1 << endl;
    cout << "c2: " << c2 << endl;
    cout << "c3: " << c3 << endl;  // Usando la sobrecarga del operador <<

    return 0;
}
<---Ejemplo de Sobrecarga de Operadores Result--->
<---Ejemplo de Sobrecarga del Operador `*`--->
```cpp
#include <iostream>
using namespace std;

class Vector {
private:
    double x, y, z;

public:
    // Constructor
    Vector(double x, double y, double z) : x(x), y(y), z(z) {}

    // Sobrecarga del operador *
    Vector operator*(double escalar) const {
        return Vector(x * escalar, y * escalar, z * escalar);
    }

    // Sobrecarga del operador <<
    friend ostream& operator<<(ostream& os, const Vector& v) {
        os << "{" << v.x << ", " << v.y << ", " << v.z << "}";
        return os;
    }
};

int main() {
    Vector v1(1.0, 2.0, 3.0);
    Vector v2 = v1 * 2.0;

    cout << "v1: " << v1 << endl;
    cout << "v2: " << v2 << endl;

    return 0;
}
<---Ejemplo de Sobrecarga del Operador `*` Result--->
<---Ejemplo de Sobrecarga del Operador `==`--->
```cpp
#include <iostream>
using namespace std;

class Punto {
private:
    int x, y;

public:
    // Constructor
    Punto(int x = 0, int y = 0) : x(x), y(y) {}

    // Sobrecarga del operador ==
    bool operator==(const Punto& p) const {
        return (x == p.x && y == p.y);
    }

    // Sobrecarga del operador <<
    friend ostream& operator<<(ostream& os, const Punto& p) {
        os << "(" << p.x << ", " << p.y << ")";
        return os;
    }
};

int main() {
    Punto p1(1, 2);
    Punto p2(1, 2);
    Punto p3(3, 4);

    cout << "p1: " << p1 << endl;
    cout << "p2: " << p2 << endl;
    cout << "p3: " << p3 << endl;

    cout << "p1 == p2: " << (p1 == p2) << endl;
    cout << "p1 == p3: " << (p1 == p3) << endl;

    return 0;
}
<---Ejemplo de Sobrecarga del Operador `==` Result--->
<---Ejemplo de Sobrecarga del Operador `++`--->
```cpp
#include <iostream>
using namespace std;

class Contador {
private:
    int valor;

public:
    // Constructor
    Contador(int v = 0) : valor(v) {}

    // Sobrecarga del operador prefijo ++
    Contador& operator++() {
        ++valor;
        return *this;
    }

    // Sobrecarga del operador postfijo ++
    Contador operator++(int) {
        Contador temp = *this;
        ++valor;
        return temp;
    }

    // Sobrecarga del operador <<
    friend ostream& operator<<(ostream& os, const Contador& c) {
        os << c.valor;
        return os;
    }
};

int main() {
    Contador c(5);

    cout << "Valor inicial: " << c << endl;

    ++c;
    cout << "Después del prefijo ++: " << c << endl;

    c++;
    cout << "Después del postfijo ++: " << c << endl;

    return 0;
}
<---Ejemplo de Sobrecarga del Operador `++` Result--->
<---Ejemplo de Sobrecarga del Operador `[]`--->
```cpp
#include <iostream>
using namespace std;

class Array {
private:
    int* datos;
    int tamano;

public:
    // Constructor
    Array(int tamano) : tamano(tamano) {
        datos = new int[tamano];
        for (int i = 0; i < tamano; ++i) {
            datos[i] = 0;
        }
    }

    // Destructor
    ~Array() {
        delete[] datos;
    }

    // Sobrecarga del operador []
    int& operator[](int indice) {
        if (indice >= 0 && indice < tamano) {
            return datos[indice];
        }
        throw out_of_range("Índice fuera de rango");
    }

    // Sobrecarga del operador <<
    friend ostream& operator<<(ostream& os, const Array& arr) {
        os << "[";
        for (int i = 0; i < arr.tamano; ++i) {
            os << arr.datos[i];
            if (i < arr.tamano - 1) {
                os << ", ";
            }
        }
        os << "]";
        return os;
    }
};

int main() {
    Array arr(5);

    arr[0] = 10;
    arr[1] = 20;
    arr[2] = 30;

    cout << "Array: " << arr << endl;

    try {
        arr[5] = 50;  // Esto lanzará una excepción
    } catch (const out_of_range& e) {
        cout << e.what() << endl;
    }

    return 0;
}
<---Ejemplo de Sobrecarga del Operador `[]` Result--->
<---Ejemplo de Encadenamiento de Métodos--->
```cpp
#include <iostream>
using namespace std;

class Rectangulo {
private:
    int ancho, alto;

public:
    // Constructor
    Rectangulo(int ancho = 0, int alto = 0) : ancho(ancho), alto(alto) {}

    // Métodos para establecer valores con encadenamiento
    Rectangulo& setAncho(int ancho) {
        this->ancho = ancho;
        return *this;
    }

    Rectangulo& setAlto(int alto) {
        this->alto = alto;
        return *this;
    }

    // Función para mostrar valores
    void mostrar() const {
        cout << "Rectangulo(" << ancho << ", " << alto << ")" << endl;
    }
};

int main() {
    Rectangulo r;
    r.setAncho(10).setAlto(20);  // Encadenamiento de métodos
    r.mostrar();

    return 0;
}
<---Ejemplo de Encadenamiento de Métodos Result--->
<---Ejemplo con Función Constante--->
```cpp
#include <iostream>
using namespace std;

class Circulo {
private:
    double radio;

public:
    // Constructor
    Circulo(double radio = 0) : radio(radio) {}

    // Método constante
    double getRadio() const {
        return this->radio;  // `this` es un puntero a un objeto constante
    }

    // Método para establecer el radio
    void setRadio(double radio) {
        this->radio = radio;
    }

    // Función para mostrar el radio
    void mostrar() const {
        cout << "Circulo con radio: " << this->getRadio() << endl;
    }
};

int main() {
    Circulo c(5.0);
    c.mostrar();

    c.setRadio(10.0);
    c.mostrar();

    return 0;
}
<---Ejemplo con Función Constante Result--->
<---Ejemplo de Prevención de Auto-Asignación--->
```cpp
#include <iostream>
#include <cstring>
using namespace std;

class Cadena {
private:
    char* str;

public:
    // Constructor
    Cadena(const char* s) {
        str = new char[strlen(s) + 1];
        strcpy(str, s);
    }

    // Destructor
    ~Cadena() {
        delete[] str;
    }

    // Constructor de copia
    Cadena(const Cadena& other) {
        str = new char[strlen(other.str) + 1];
        strcpy(str, other.str);
    }

    // Operador de asignación sobrecargado
    Cadena& operator=(const Cadena& other) {
        if (this != &other) {  // Prevención de auto-asignación
            delete[] str;
            str = new char[strlen(other.str) + 1];
            strcpy(str, other.str);
        }
        return *this;
    }

    // Función para mostrar la cadena
    void mostrar() const {
        cout << "Cadena: " << str << endl;
    }
};

int main() {
    Cadena c1("Hola");
    Cadena c2("Mundo");

    c1.mostrar();
    c2.mostrar();

    c2 = c1;  // Usando el operador de asignación sobrecargado
    c2.mostrar();

    return 0;
}
<---Ejemplo de Prevención de Auto-Asignación Result--->
<---Definición de una Clase--->
```cpp
class NombreClase {
public:
    // Atributos
    tipo_atributo nombre_atributo;

    // Métodos
    tipo_retorno nombre_metodo(parametros);

    // Otros componentes, como constructores, destructores, etc.
};
<---Definición de una Clase Result--->
<---Ejemplo Básico de una Clase--->
```cpp
#include <iostream>
using namespace std;

class Persona {
public:
    // Atributos
    string nombre;
    int edad;

    // Métodos
    void saludar() {
        cout << "Hola, mi nombre es " << nombre << " y tengo " << edad << " años." << endl;
    }
};

int main() {
    // Crear un objeto de la clase Persona
    Persona juan;
    juan.nombre = "Juan";
    juan.edad = 30;

    // Llamar al método saludar
    juan.saludar();

    return 0;
}
<---Ejemplo Básico de una Clase Result--->
<---Creación de Objetos--->
```cpp
NombreClase nombre_objeto;
<---Creación de Objetos Result--->
<---Ejemplo de Creación y Uso de Objetos--->
```cpp
#include <iostream>
using namespace std;

class Coche {
public:
    // Atributos
    string marca;
    string modelo;
    int anio;

    // Métodos
    void mostrarInformacion() {
        cout << "Marca: " << marca << ", Modelo: " << modelo << ", Año: " << anio << endl;
    }
};

int main() {
    // Crear objetos de la clase Coche
    Coche coche1;
    coche1.marca = "Toyota";
    coche1.modelo = "Corolla";
    coche1.anio = 2020;

    Coche coche2;
    coche2.marca = "Honda";
    coche2.modelo = "Civic";
    coche2.anio = 2019;

    // Llamar a los métodos de los objetos
    coche1.mostrarInformacion();
    coche2.mostrarInformacion();

    return 0;
}
<---Ejemplo de Creación y Uso de Objetos Result--->
<---Constructores--->
```cpp
class Persona {
public:
    string nombre;
    int edad;

    // Constructor
    Persona(string n, int e) {
        nombre = n;
        edad = e;
    }

    void saludar() {
        cout << "Hola, mi nombre es " << nombre << " y tengo " << edad << " años." << endl;
    }
};

int main() {
    // Crear un objeto de la clase Persona utilizando el constructor
    Persona juan("Juan", 30);
    juan.saludar();

    return 0;
}
<---Constructores Result--->
<---Destructores--->
```cpp
class Persona {
public:
    string nombre;
    int edad;

    // Constructor
    Persona(string n, int e) {
        nombre = n;
        edad = e;
    }

    // Destructor
    ~Persona() {
        cout << "Destructor llamado para " << nombre << endl;
    }

    void saludar() {
        cout << "Hola, mi nombre es " << nombre << " y tengo " << edad << " años." << endl;
    }
};

int main() {
    // Crear un objeto de la clase Persona
    Persona juan("Juan", 30);
    juan.saludar();

    // El destructor se llamará automáticamente al final del alcance
    return 0;
}
<---Destructores Result--->
<---Modificadores de Acceso--->
```cpp
class Persona {
private:
    string nombre;
    int edad;

public:
    // Constructor
    Persona(string n, int e) : nombre(n), edad(e) {}

    // Métodos para acceder y modificar los atributos
    string getNombre() {
        return nombre;
    }

    void setNombre(string n) {
        nombre = n;
    }

    int getEdad() {
        return edad;
    }

    void setEdad(int e) {
        edad = e;
    }

    void saludar() {
        cout << "Hola, mi nombre es " << nombre << " y tengo " << edad << " años." << endl;
    }
};

int main() {
    Persona juan("Juan", 30);
    juan.saludar();

    juan.setEdad(31);
    cout << "Nueva edad de " << juan.getNombre() << ": " << juan.getEdad() << endl;

    return 0;
}
<---Modificadores de Acceso Result--->
<---Ejemplo de Constructor por Defecto--->
```cpp
#include <iostream>
using namespace std;

class Persona {
public:
    string nombre;
    int edad;

    // Constructor por defecto
    Persona() {
        nombre = "Desconocido";
        edad = 0;
    }

    void mostrarInformacion() {
        cout << "Nombre: " << nombre << ", Edad: " << edad << endl;
    }
};

int main() {
    Persona p;  // Llama al constructor por defecto
    p.mostrarInformacion();

    return 0;
}
<---Ejemplo de Constructor por Defecto Result--->
<---Ejemplo de Constructor Parametrizado--->
```cpp
#include <iostream>
using namespace std;

class Persona {
public:
    string nombre;
    int edad;

    // Constructor parametrizado
    Persona(string n, int e) {
        nombre = n;
        edad = e;
    }

    void mostrarInformacion() {
        cout << "Nombre: " << nombre << ", Edad: " << edad << endl;
    }
};

int main() {
    Persona p("Juan", 30);  // Llama al constructor parametrizado
    p.mostrarInformacion();

    return 0;
}
<---Ejemplo de Constructor Parametrizado Result--->
<---Ejemplo de Constructor de Copia--->
```cpp
#include <iostream>
using namespace std;

class Persona {
public:
    string nombre;
    int edad;

    // Constructor parametrizado
    Persona(string n, int e) {
        nombre = n;
        edad = e;
    }

    // Constructor de copia
    Persona(const Persona& p) {
        nombre = p.nombre;
        edad = p.edad;
    }

    void mostrarInformacion() {
        cout << "Nombre: " << nombre << ", Edad: " << edad << endl;
    }
};

int main() {
    Persona p1("Juan", 30);  // Llama al constructor parametrizado
    Persona p2 = p1;         // Llama al constructor de copia
    p2.mostrarInformacion();

    return 0;
}
<---Ejemplo de Constructor de Copia Result--->
<---Ejemplo de Constructor de Movimiento--->
```cpp
#include <iostream>
using namespace std;

class Persona {
public:
    string nombre;
    int edad;

    // Constructor parametrizado
    Persona(string n, int e) : nombre(n), edad(e) {}

    // Constructor de movimiento
    Persona(Persona&& p) noexcept : nombre(move(p.nombre)), edad(p.edad) {
        p.edad = 0; // Opcional: Dejar el objeto fuente en un estado válido
    }

    void mostrarInformacion() {
        cout << "Nombre: " << nombre << ", Edad: " << edad << endl;
    }
};

int main() {
    Persona p1("Juan", 30);  // Llama al constructor parametrizado
    Persona p2 = move(p1);   // Llama al constructor de movimiento
    p2.mostrarInformacion();

    // p1 está en un estado indefinido, pero válido
    cout << "Después de mover, p1: ";
    p1.mostrarInformacion();

    return 0;
}
<---Ejemplo de Constructor de Movimiento Result--->
<---Ejemplo con Lista de Inicialización--->
```cpp
#include <iostream>
using namespace std;

class Punto {
public:
    const int x;
    const int y;

    // Constructor con lista de inicialización
    Punto(int a, int b) : x(a), y(b) {}

    void mostrarInformacion() {
        cout << "Punto(" << x << ", " << y << ")" << endl;
    }
};

int main() {
    Punto p(10, 20);  // Llama al constructor con lista de inicialización
    p.mostrarInformacion();

    return 0;
}
```cpp
#include <iostream>
using namespace std;

class Persona {
private:
    string nombre;
    int edad;

public:
    // Constructor por defecto
    Persona() : nombre("Desconocido"), edad(0) {}

    // Constructor parametrizado
    Persona(string n, int e) : nombre(n), edad(e) {}

    // Constructor de copia
    Persona(const Persona& p) : nombre(p.nombre), edad(p.edad) {}

    // Constructor de movimiento
    Persona(Persona&& p) noexcept : nombre(move(p.nombre)), edad(p.edad) {
        p.edad = 0;
    }

    void mostrarInformacion() {
        cout << "Nombre: " << nombre << ", Edad: " << edad << endl;
    }
};

int main() {
    // Usando el constructor por defecto
    Persona p1;
    p1.mostrarInformacion();

    // Usando el constructor parametrizado
    Persona p2("Juan", 30);
    p2.mostrarInformacion();

    // Usando el constructor de copia
    Persona p3 = p2;
    p3.mostrarInformacion();

    // Usando el constructor de movimiento
    Persona p4 = move(p2);
    p4.mostrarInformacion();

    // Estado después del movimiento
    cout << "Después de mover, p2: ";
    p2.mostrarInformacion();

    return 0;
}
<---Ejemplo con Lista de Inicialización Result--->
<---Definición de Atributos Privados--->
```cpp
class Persona {
private:
    string nombre;
    int edad;

public:
    // Métodos públicos
};
<---Definición de Atributos Privados Result--->
<---Ejemplo de Getters--->
```cpp
class Persona {
private:
    string nombre;
    int edad;

public:
    // Constructor
    Persona(string n, int e) : nombre(n), edad(e) {}

    // Getter para el nombre
    string getNombre() const {
        return nombre;
    }

    // Getter para la edad
    int getEdad() const {
        return edad;
    }
};
<---Ejemplo de Getters Result--->
<---Ejemplo de Setters--->
```cpp
class Persona {
private:
    string nombre;
    int edad;

public:
    // Constructor
    Persona(string n, int e) : nombre(n), edad(e) {}

    // Setter para el nombre
    void setNombre(string n) {
        nombre = n;
    }

    // Setter para la edad
    void setEdad(int e) {
        if (e > 0) {  // Validación simple
            edad = e;
        } else {
            cout << "Edad no válida." << endl;
        }
    }

    // Getters
    string getNombre() const {
        return nombre;
    }

    int getEdad() const {
        return edad;
    }
};
<---Ejemplo de Setters Result--->
<---Ejemplo Completo--->
```cpp
#include <iostream>
using namespace std;

class Persona {
private:
    string nombre;
    int edad;

public:
    // Constructor
    Persona(string n, int e) : nombre(n), edad(e) {}

    // Setters
    void setNombre(string n) {
        nombre = n;
    }

    void setEdad(int e) {
        if (e > 0) {
            edad = e;
        } else {
            cout << "Edad no válida." << endl;
        }
    }

    // Getters
    string getNombre() const {
        return nombre;
    }

    int getEdad() const {
        return edad;
    }

    // Método para mostrar información
    void mostrarInformacion() const {
        cout << "Nombre: " << nombre << ", Edad: " << edad << endl;
    }
};

int main() {
    // Crear un objeto de la clase Persona
    Persona juan("Juan", 30);
    juan.mostrarInformacion();

    // Modificar los atributos usando setters
    juan.setNombre("Juan Perez");
    juan.setEdad(31);
    juan.mostrarInformacion();

    // Intentar establecer una edad no válida
    juan.setEdad(-5);
    juan.mostrarInformacion();

    // Acceder a los atributos usando getters
    cout << "Nombre: " << juan.getNombre() << endl;
    cout << "Edad: " << juan.getEdad() << endl;

    return 0;
}
<---Ejemplo Completo Result--->
<---Ejemplo Básico--->
```cpp
#include <iostream>
using namespace std;

class Punto {
private:
    int x, y;

public:
    // Constructor
    Punto(int x = 0, int y = 0) : x(x), y(y) {}

    // Función para establecer valores usando this
    void setXY(int x, int y) {
        this->x = x;  // Acceso a miembro de la clase
        this->y = y;  // Acceso a miembro de la clase
    }

    // Función para mostrar valores
    void mostrar() const {
        cout << "Punto(" << x << ", " << y << ")" << endl;
    }
};

int main() {
    Punto p(10, 20);
    p.mostrar();

    p.setXY(30, 40);
    p.mostrar();

    return 0;
}
<---Ejemplo Básico Result--->
<---Ejemplo con Setters y Getters--->
```cpp
#include <iostream>
using namespace std;

class Persona {
private:
    string nombre;
    int edad;

public:
    // Constructor
    Persona(string n, int e) : nombre(n), edad(e) {}

    // Getter para nombre
    string getNombre() const {
        return nombre;
    }

    // Setter para nombre
    void setNombre(string n) {
        nombre = n;
    }

    // Getter para edad
    int getEdad() const {
        return edad;
    }

    // Setter para edad con validación
    void setEdad(int e) {
        if (e > 0) {
            edad = e;
        } else {
            cout << "Edad no válida" << endl;
        }
    }

    // Método para mostrar información
    void mostrarInformacion() const {
        cout << "Nombre: " << nombre << ", Edad: " << edad << endl;
    }
};

int main() {
    Persona juan("Juan", 30);
    juan.mostrarInformacion();

    // Modificar atributos usando setters
    juan.setNombre("Juan Perez");
    juan.setEdad(31);
    juan.mostrarInformacion();

    // Intentar establecer una edad no válida
    juan.setEdad(-5);
    juan.mostrarInformacion();

    return 0;
}
<---Ejemplo con Setters y Getters Result--->
<---Ejemplo con Herencia--->
```cpp
#include <iostream>
using namespace std;

class Base {
public:
    // Constructor
    Base() {
        cout << "Constructor de Base" << endl;
    }

    // Destructor virtual
    virtual ~Base() {
        cout << "Destructor de Base" << endl;
    }
};

class Derivada : public Base {
public:
    // Constructor
    Derivada() {
        cout << "Constructor de Derivada" << endl;
    }

    // Destructor
    ~Derivada() {
        cout << "Destructor de Derivada" << endl;
    }
};

int main() {
    Base* obj = new Derivada(); // Crear objeto de clase derivada
    delete obj; // Llamar al destructor virtual

    return 0;
}
<---Ejemplo con Herencia Result--->
<---Sintaxis del Destructor--->
```cpp
class NombreClase {
public:
    // Constructor
    NombreClase();

    // Destructor
    ~NombreClase();

    // Otros métodos y atributos
};
```cpp
#include <iostream>
using namespace std;

class Persona {
public:
    string nombre;

    // Constructor
    Persona(string n) : nombre(n) {
        cout << "Constructor llamado para " << nombre << endl;
    }

    // Destructor
    ~Persona() {
        cout << "Destructor llamado para " << nombre << endl;
    }
};

int main() {
    Persona juan("Juan");
    {
        Persona maria("Maria");
    } // Destructor llamado para maria aquí

    cout << "Fin del main" << endl;
    return 0; // Destructor llamado para juan aquí
}
<---Sintaxis del Destructor Result--->
<---Ejemplo Básico de Destructor--->
```cpp
#include <iostream>
using namespace std;

class Persona {
public:
    string nombre;

    // Constructor
    Persona(string n) : nombre(n) {
        cout << "Constructor llamado para " << nombre << endl;
    }

    // Destructor
    ~Persona() {
        cout << "Destructor llamado para " << nombre << endl;
    }
};

int main() {
    Persona juan("Juan");
    {
        Persona maria("Maria");
    } // Destructor llamado para maria aquí

    cout << "Fin del main" << endl;
    return 0; // Destructor llamado para juan aquí
}
<---Ejemplo Básico de Destructor Result--->
<---Ejemplo con Recursos Dinámicos--->
```cpp
#include <iostream>
using namespace std;

class Array {
private:
    int* data;
    int size;

public:
    // Constructor
    Array(int s) : size(s) {
        data = new int[size]; // Asignar memoria dinámica
        cout << "Array de tamaño " << size << " creado." << endl;
    }

    // Destructor
    ~Array() {
        delete[] data; // Liberar memoria dinámica
        cout << "Array de tamaño " << size << " destruido." << endl;
    }

    // Método para establecer un valor en el array
    void setValue(int index, int value) {
        if (index >= 0 && index < size) {
            data[index] = value;
        }
    }

    // Método para obtener un valor del array
    int getValue(int index) const {
        if (index >= 0 && index < size) {
            return data[index];
        }
        return -1; // Valor de error
    }
};

int main() {
    Array arr(5);
    arr.setValue(0, 10);
    arr.setValue(1, 20);
    cout << "Valor en la posición 0: " << arr.getValue(0) << endl;
    cout << "Valor en la posición 1: " << arr.getValue(1) << endl;

    return 0;
}
<---Ejemplo con Recursos Dinámicos Result--->
<---Regla de Tres--->
```cpp
class Ejemplo {
private:
    int* data;

public:
    // Constructor
    Ejemplo(int size) {
        data = new int[size];
    }

    // Destructor
    ~Ejemplo() {
        delete[] data;
    }

    // Constructor de copia
    Ejemplo(const Ejemplo& other) {
        data = new int[other.size];
        // Copiar datos...
    }

    // Operador de asignación de copia
    Ejemplo& operator=(const Ejemplo& other) {
        if (this != &other) {
            delete[] data;
            data = new int[other.size];
            // Copiar datos...
        }
        return *this;
    }
};
<---Regla de Tres Result--->
<---Regla de Cinco--->
```cpp
class Ejemplo {
private:
    int* data;

public:
    // Constructor
    Ejemplo(int size) {
        data = new int[size];
    }

    // Destructor
    ~Ejemplo() {
        delete[] data;
    }

    // Constructor de copia
    Ejemplo(const Ejemplo& other) {
        data = new int[other.size];
        // Copiar datos...
    }

    // Operador de asignación de copia
    Ejemplo& operator=(const Ejemplo& other) {
        if (this != &other) {
            delete[] data;
            data = new int[other.size];
            // Copiar datos...
        }
        return *this;
    }

    // Constructor de movimiento
    Ejemplo(Ejemplo&& other) noexcept : data(other.data) {
        other.data = nullptr;
    }

    // Operador de asignación de movimiento
    Ejemplo& operator=(Ejemplo&& other) noexcept {
        if (this != &other) {
            delete[] data;
            data = other.data;
            other.data = nullptr;
        }
        return *this;
    }
};
<---Regla de Cinco Result--->
<---Ejemplo de Sobrecarga de Operadores--->
```cpp
#include <iostream>
using namespace std;

class Complejo {
private:
    double real;
    double imaginario;

public:
    // Constructor
    Complejo(double r = 0.0, double i = 0.0) : real(r), imaginario(i) {}

    // Sobrecarga del operador +
    Complejo operator+(const Complejo& c) const {
        return Complejo(real + c.real, imaginario + c.imaginario);
    }

    // Sobrecarga del operador <<
    friend ostream& operator<<(ostream& os, const Complejo& c) {
        os << "(" << c.real << " + " << c.imaginario << "i)";
        return os;
    }
};

int main() {
    Complejo c1(3.0, 4.0);
    Complejo c2(1.0, 2.0);

    Complejo c3 = c1 + c2;  // Usando la sobrecarga del operador +

    cout << "c1: " << c1 << endl;
    cout << "c2: " << c2 << endl;
    cout << "c3: " << c3 << endl;  // Usando la sobrecarga del operador <<

    return 0;
}
<---Ejemplo de Sobrecarga de Operadores Result--->
<---Ejemplo de Sobrecarga del Operador `*`--->
```cpp
#include <iostream>
using namespace std;

class Vector {
private:
    double x, y, z;

public:
    // Constructor
    Vector(double x, double y, double z) : x(x), y(y), z(z) {}

    // Sobrecarga del operador *
    Vector operator*(double escalar) const {
        return Vector(x * escalar, y * escalar, z * escalar);
    }

    // Sobrecarga del operador <<
    friend ostream& operator<<(ostream& os, const Vector& v) {
        os << "{" << v.x << ", " << v.y << ", " << v.z << "}";
        return os;
    }
};

int main() {
    Vector v1(1.0, 2.0, 3.0);
    Vector v2 = v1 * 2.0;

    cout << "v1: " << v1 << endl;
    cout << "v2: " << v2 << endl;

    return 0;
}
<---Ejemplo de Sobrecarga del Operador `*` Result--->
<---Ejemplo de Sobrecarga del Operador `==`--->
```cpp
#include <iostream>
using namespace std;

class Punto {
private:
    int x, y;

public:
    // Constructor
    Punto(int x = 0, int y = 0) : x(x), y(y) {}

    // Sobrecarga del operador ==
    bool operator==(const Punto& p) const {
        return (x == p.x && y == p.y);
    }

    // Sobrecarga del operador <<
    friend ostream& operator<<(ostream& os, const Punto& p) {
        os << "(" << p.x << ", " << p.y << ")";
        return os;
    }
};

int main() {
    Punto p1(1, 2);
    Punto p2(1, 2);
    Punto p3(3, 4);

    cout << "p1: " << p1 << endl;
    cout << "p2: " << p2 << endl;
    cout << "p3: " << p3 << endl;

    cout << "p1 == p2: " << (p1 == p2) << endl;
    cout << "p1 == p3: " << (p1 == p3) << endl;

    return 0;
}
<---Ejemplo de Sobrecarga del Operador `==` Result--->
<---Ejemplo de Sobrecarga del Operador `++`--->
```cpp
#include <iostream>
using namespace std;

class Contador {
private:
    int valor;

public:
    // Constructor
    Contador(int v = 0) : valor(v) {}

    // Sobrecarga del operador prefijo ++
    Contador& operator++() {
        ++valor;
        return *this;
    }

    // Sobrecarga del operador postfijo ++
    Contador operator++(int) {
        Contador temp = *this;
        ++valor;
        return temp;
    }

    // Sobrecarga del operador <<
    friend ostream& operator<<(ostream& os, const Contador& c) {
        os << c.valor;
        return os;
    }
};

int main() {
    Contador c(5);

    cout << "Valor inicial: " << c << endl;

    ++c;
    cout << "Después del prefijo ++: " << c << endl;

    c++;
    cout << "Después del postfijo ++: " << c << endl;

    return 0;
}
<---Ejemplo de Sobrecarga del Operador `++` Result--->
<---Ejemplo de Sobrecarga del Operador `[]`--->
```cpp
#include <iostream>
using namespace std;

class Array {
private:
    int* datos;
    int tamano;

public:
    // Constructor
    Array(int tamano) : tamano(tamano) {
        datos = new int[tamano];
        for (int i = 0; i < tamano; ++i) {
            datos[i] = 0;
        }
    }

    // Destructor
    ~Array() {
        delete[] datos;
    }

    // Sobrecarga del operador []
    int& operator[](int indice) {
        if (indice >= 0 && indice < tamano) {
            return datos[indice];
        }
        throw out_of_range("Índice fuera de rango");
    }

    // Sobrecarga del operador <<
    friend ostream& operator<<(ostream& os, const Array& arr) {
        os << "[";
        for (int i = 0; i < arr.tamano; ++i) {
            os << arr.datos[i];
            if (i < arr.tamano - 1) {
                os << ", ";
            }
        }
        os << "]";
        return os;
    }
};

int main() {
    Array arr(5);

    arr[0] = 10;
    arr[1] = 20;
    arr[2] = 30;

    cout << "Array: " << arr << endl;

    try {
        arr[5] = 50;  // Esto lanzará una excepción
    } catch (const out_of_range& e) {
        cout << e.what() << endl;
    }

    return 0;
}
<---Ejemplo de Sobrecarga del Operador `[]` Result--->
<---Ejemplo de Encadenamiento de Métodos--->
```cpp
#include <iostream>
using namespace std;

class Rectangulo {
private:
    int ancho, alto;

public:
    // Constructor
    Rectangulo(int ancho = 0, int alto = 0) : ancho(ancho), alto(alto) {}

    // Métodos para establecer valores con encadenamiento
    Rectangulo& setAncho(int ancho) {
        this->ancho = ancho;
        return *this;
    }

    Rectangulo& setAlto(int alto) {
        this->alto = alto;
        return *this;
    }

    // Función para mostrar valores
    void mostrar() const {
        cout << "Rectangulo(" << ancho << ", " << alto << ")" << endl;
    }
};

int main() {
    Rectangulo r;
    r.setAncho(10).setAlto(20);  // Encadenamiento de métodos
    r.mostrar();

    return 0;
}
<---Ejemplo de Encadenamiento de Métodos Result--->
<---Ejemplo con Función Constante--->
```cpp
#include <iostream>
using namespace std;

class Circulo {
private:
    double radio;

public:
    // Constructor
    Circulo(double radio = 0) : radio(radio) {}

    // Método constante
    double getRadio() const {
        return this->radio;  // `this` es un puntero a un objeto constante
    }

    // Método para establecer el radio
    void setRadio(double radio) {
        this->radio = radio;
    }

    // Función para mostrar el radio
    void mostrar() const {
        cout << "Circulo con radio: " << this->getRadio() << endl;
    }
};

int main() {
    Circulo c(5.0);
    c.mostrar();

    c.setRadio(10.0);
    c.mostrar();

    return 0;
}
<---Ejemplo con Función Constante Result--->
<---Ejemplo de Prevención de Auto-Asignación--->
```cpp
#include <iostream>
#include <cstring>
using namespace std;

class Cadena {
private:
    char* str;

public:
    // Constructor
    Cadena(const char* s) {
        str = new char[strlen(s) + 1];
        strcpy(str, s);
    }

    // Destructor
    ~Cadena() {
        delete[] str;
    }

    // Constructor de copia
    Cadena(const Cadena& other) {
        str = new char[strlen(other.str) + 1];
        strcpy(str, other.str);
    }

    // Operador de asignación sobrecargado
    Cadena& operator=(const Cadena& other) {
        if (this != &other) {  // Prevención de auto-asignación
            delete[] str;
            str = new char[strlen(other.str) + 1];
            strcpy(str, other.str);
        }
        return *this;
    }

    // Función para mostrar la cadena
    void mostrar() const {
        cout << "Cadena: " << str << endl;
    }
};

int main() {
    Cadena c1("Hola");
    Cadena c2("Mundo");

    c1.mostrar();
    c2.mostrar();

    c2 = c1;  // Usando el operador de asignación sobrecargado
    c2.mostrar();

    return 0;
}
<---Ejemplo de Prevención de Auto-Asignación Result--->
<---Ejemplo de Atributos Constantes--->
```cpp
#include <iostream>
using namespace std;

class Punto {
private:
    const int x;
    const int y;

public:
    // Constructor con lista de inicialización
    Punto(int x, int y) : x(x), y(y) {}

    // Métodos para obtener los valores de los atributos
    int getX() const {
        return x;
    }

    int getY() const {
        return y;
    }

    // Método para mostrar los valores
    void mostrar() const {
        cout << "Punto(" << x << ", " << y << ")" << endl;
    }
};

int main() {
    Punto p(10, 20);
    p.mostrar();

    // p.x = 30; // Error: no se puede modificar un miembro constante
    // p.y = 40; // Error: no se puede modificar un miembro constante

    return 0;
}
<---Ejemplo de Atributos Constantes Result--->
<---Ejemplo de Métodos Constantes--->
```cpp
#include <iostream>
using namespace std;

class Circulo {
private:
    double radio;

public:
    // Constructor
    Circulo(double r) : radio(r) {}

    // Método constante para obtener el radio
    double getRadio() const {
        return radio;
    }

    // Método constante para calcular el área
    double area() const {
        return 3.14159 * radio * radio;
    }

    // Método constante para mostrar el radio
    void mostrar() const {
        cout << "Circulo con radio: " << radio << " y área: " << area() << endl;
    }
};

int main() {
    Circulo c(5.0);
    c.mostrar();

    // c.radio = 10.0; // Error: no se puede acceder a un miembro privado

    return 0;
}
<---Ejemplo de Métodos Constantes Result--->
<---Ejemplo de Const Correctness--->
```cpp
#include <iostream>
using namespace std;

class Rectangulo {
private:
    double ancho;
    double alto;

public:
    // Constructor
    Rectangulo(double a, double h) : ancho(a), alto(h) {}

    // Método constante para obtener el ancho
    double getAncho() const {
        return ancho;
    }

    // Método constante para obtener el alto
    double getAlto() const {
        return alto;
    }

    // Método constante para calcular el área
    double area() const {
        return ancho * alto;
    }

    // Método para cambiar el tamaño del rectángulo
    void cambiarTamano(double a, double h) {
        ancho = a;
        alto = h;
    }

    // Método constante para mostrar el rectángulo
    void mostrar() const {
        cout << "Rectangulo de ancho: " << ancho << ", alto: " << alto << ", área: " << area() << endl;
    }
};

int main() {
    const Rectangulo r(10.0, 5.0);
    r.mostrar();

    // r.cambiarTamano(15.0, 7.5); // Error: no se puede llamar a un método no constante en un objeto constante

    return 0;
}
<---Ejemplo de Const Correctness Result--->
<---Ejemplo con Puntero `this` en Métodos Constantes--->
```cpp
#include <iostream>
using namespace std;

class Triangulo {
private:
    double base;
    double altura;

public:
    // Constructor
    Triangulo(double b, double h) : base(b), altura(h) {}

    // Método constante para obtener la base
    double getBase() const {
        return this->base;
    }

    // Método constante para obtener la altura
    double getAltura() const {
        return this->altura;
    }

    // Método constante para calcular el área
    double area() const {
        return 0.5 * this->base * this->altura;
    }

    // Método constante para mostrar el triángulo
    void mostrar() const {
        cout << "Triangulo de base: " << this->getBase() << ", altura: " << this->getAltura() << ", área: " << this->area() << endl;
    }
};

int main() {
    Triangulo t(10.0, 5.0);
    t.mostrar();

    return 0;
}
<---Ejemplo con Puntero `this` en Métodos Constantes Result--->
<---Definición de una Clase--->
```cpp
class NombreClase {
public:
    // Atributos
    tipo_atributo nombre_atributo;

    // Métodos
    tipo_retorno nombre_metodo(parametros);

    // Otros componentes, como constructores, destructores, etc.
};
<---Definición de una Clase Result--->
<---Ejemplo Básico de una Clase--->
```cpp
#include <iostream>
using namespace std;

class Persona {
public:
    // Atributos
    string nombre;
    int edad;

    // Métodos
    void saludar() {
        cout << "Hola, mi nombre es " << nombre << " y tengo " << edad << " años." << endl;
    }
};

int main() {
    // Crear un objeto de la clase Persona
    Persona juan;
    juan.nombre = "Juan";
    juan.edad = 30;

    // Llamar al método saludar
    juan.saludar();

    return 0;
}
<---Ejemplo Básico de una Clase Result--->
<---Creación de Objetos--->
```cpp
NombreClase nombre_objeto;
<---Creación de Objetos Result--->
<---Ejemplo de Creación y Uso de Objetos--->
```cpp
#include <iostream>
using namespace std;

class Coche {
public:
    // Atributos
    string marca;
    string modelo;
    int anio;

    // Métodos
    void mostrarInformacion() {
        cout << "Marca: " << marca << ", Modelo: " << modelo << ", Año: " << anio << endl;
    }
};

int main() {
    // Crear objetos de la clase Coche
    Coche coche1;
    coche1.marca = "Toyota";
    coche1.modelo = "Corolla";
    coche1.anio = 2020;

    Coche coche2;
    coche2.marca = "Honda";
    coche2.modelo = "Civic";
    coche2.anio = 2019;

    // Llamar a los métodos de los objetos
    coche1.mostrarInformacion();
    coche2.mostrarInformacion();

    return 0;
}
<---Ejemplo de Creación y Uso de Objetos Result--->
<---Constructores--->
```cpp
class Persona {
public:
    string nombre;
    int edad;

    // Constructor
    Persona(string n, int e) {
        nombre = n;
        edad = e;
    }

    void saludar() {
        cout << "Hola, mi nombre es " << nombre << " y tengo " << edad << " años." << endl;
    }
};

int main() {
    // Crear un objeto de la clase Persona utilizando el constructor
    Persona juan("Juan", 30);
    juan.saludar();

    return 0;
}
<---Constructores Result--->
<---Destructores--->
```cpp
class Persona {
public:
    string nombre;
    int edad;

    // Constructor
    Persona(string n, int e) {
        nombre = n;
        edad = e;
    }

    // Destructor
    ~Persona() {
        cout << "Destructor llamado para " << nombre << endl;
    }

    void saludar() {
        cout << "Hola, mi nombre es " << nombre << " y tengo " << edad << " años." << endl;
    }
};

int main() {
    // Crear un objeto de la clase Persona
    Persona juan("Juan", 30);
    juan.saludar();

    // El destructor se llamará automáticamente al final del alcance
    return 0;
}
<---Destructores Result--->
<---Modificadores de Acceso--->
```cpp
class Persona {
private:
    string nombre;
    int edad;

public:
    // Constructor
    Persona(string n, int e) : nombre(n), edad(e) {}

    // Métodos para acceder y modificar los atributos
    string getNombre() {
        return nombre;
    }

    void setNombre(string n) {
        nombre = n;
    }

    int getEdad() {
        return edad;
    }

    void setEdad(int e) {
        edad = e;
    }

    void saludar() {
        cout << "Hola, mi nombre es " << nombre << " y tengo " << edad << " años." << endl;
    }
};

int main() {
    Persona juan("Juan", 30);
    juan.saludar();

    juan.setEdad(31);
    cout << "Nueva edad de " << juan.getNombre() << ": " << juan.getEdad() << endl;

    return 0;
}
<---Modificadores de Acceso Result--->
<---Ejemplo de Constructor por Defecto--->
```cpp
#include <iostream>
using namespace std;

class Persona {
public:
    string nombre;
    int edad;

    // Constructor por defecto
    Persona() {
        nombre = "Desconocido";
        edad = 0;
    }

    void mostrarInformacion() {
        cout << "Nombre: " << nombre << ", Edad: " << edad << endl;
    }
};

int main() {
    Persona p;  // Llama al constructor por defecto
    p.mostrarInformacion();

    return 0;
}
<---Ejemplo de Constructor por Defecto Result--->
<---Ejemplo de Constructor Parametrizado--->
```cpp
#include <iostream>
using namespace std;

class Persona {
public:
    string nombre;
    int edad;

    // Constructor parametrizado
    Persona(string n, int e) {
        nombre = n;
        edad = e;
    }

    void mostrarInformacion() {
        cout << "Nombre: " << nombre << ", Edad: " << edad << endl;
    }
};

int main() {
    Persona p("Juan", 30);  // Llama al constructor parametrizado
    p.mostrarInformacion();

    return 0;
}
<---Ejemplo de Constructor Parametrizado Result--->
<---Ejemplo de Constructor de Copia--->
```cpp
#include <iostream>
using namespace std;

class Persona {
public:
    string nombre;
    int edad;

    // Constructor parametrizado
    Persona(string n, int e) {
        nombre = n;
        edad = e;
    }

    // Constructor de copia
    Persona(const Persona& p) {
        nombre = p.nombre;
        edad = p.edad;
    }

    void mostrarInformacion() {
        cout << "Nombre: " << nombre << ", Edad: " << edad << endl;
    }
};

int main() {
    Persona p1("Juan", 30);  // Llama al constructor parametrizado
    Persona p2 = p1;         // Llama al constructor de copia
    p2.mostrarInformacion();

    return 0;
}
<---Ejemplo de Constructor de Copia Result--->
<---Ejemplo de Constructor de Movimiento--->
```cpp
#include <iostream>
using namespace std;

class Persona {
public:
    string nombre;
    int edad;

    // Constructor parametrizado
    Persona(string n, int e) : nombre(n), edad(e) {}

    // Constructor de movimiento
    Persona(Persona&& p) noexcept : nombre(move(p.nombre)), edad(p.edad) {
        p.edad = 0; // Opcional: Dejar el objeto fuente en un estado válido
    }

    void mostrarInformacion() {
        cout << "Nombre: " << nombre << ", Edad: " << edad << endl;
    }
};

int main() {
    Persona p1("Juan", 30);  // Llama al constructor parametrizado
    Persona p2 = move(p1);   // Llama al constructor de movimiento
    p2.mostrarInformacion();

    // p1 está en un estado indefinido, pero válido
    cout << "Después de mover, p1: ";
    p1.mostrarInformacion();

    return 0;
}
<---Ejemplo de Constructor de Movimiento Result--->
<---Ejemplo con Lista de Inicialización--->
```cpp
#include <iostream>
using namespace std;

class Punto {
public:
    const int x;
    const int y;

    // Constructor con lista de inicialización
    Punto(int a, int b) : x(a), y(b) {}

    void mostrarInformacion() {
        cout << "Punto(" << x << ", " << y << ")" << endl;
    }
};

int main() {
    Punto p(10, 20);  // Llama al constructor con lista de inicialización
    p.mostrarInformacion();

    return 0;
}
```cpp
#include <iostream>
using namespace std;

class Persona {
private:
    string nombre;
    int edad;

public:
    // Constructor por defecto
    Persona() : nombre("Desconocido"), edad(0) {}

    // Constructor parametrizado
    Persona(string n, int e) : nombre(n), edad(e) {}

    // Constructor de copia
    Persona(const Persona& p) : nombre(p.nombre), edad(p.edad) {}

    // Constructor de movimiento
    Persona(Persona&& p) noexcept : nombre(move(p.nombre)), edad(p.edad) {
        p.edad = 0;
    }

    void mostrarInformacion() {
        cout << "Nombre: " << nombre << ", Edad: " << edad << endl;
    }
};

int main() {
    // Usando el constructor por defecto
    Persona p1;
    p1.mostrarInformacion();

    // Usando el constructor parametrizado
    Persona p2("Juan", 30);
    p2.mostrarInformacion();

    // Usando el constructor de copia
    Persona p3 = p2;
    p3.mostrarInformacion();

    // Usando el constructor de movimiento
    Persona p4 = move(p2);
    p4.mostrarInformacion();

    // Estado después del movimiento
    cout << "Después de mover, p2: ";
    p2.mostrarInformacion();

    return 0;
}
<---Ejemplo con Lista de Inicialización Result--->
<---Definición de Atributos Privados--->
```cpp
class Persona {
private:
    string nombre;
    int edad;

public:
    // Métodos públicos
};
<---Definición de Atributos Privados Result--->
<---Ejemplo de Getters--->
```cpp
class Persona {
private:
    string nombre;
    int edad;

public:
    // Constructor
    Persona(string n, int e) : nombre(n), edad(e) {}

    // Getter para el nombre
    string getNombre() const {
        return nombre;
    }

    // Getter para la edad
    int getEdad() const {
        return edad;
    }
};
<---Ejemplo de Getters Result--->
<---Ejemplo de Setters--->
```cpp
class Persona {
private:
    string nombre;
    int edad;

public:
    // Constructor
    Persona(string n, int e) : nombre(n), edad(e) {}

    // Setter para el nombre
    void setNombre(string n) {
        nombre = n;
    }

    // Setter para la edad
    void setEdad(int e) {
        if (e > 0) {  // Validación simple
            edad = e;
        } else {
            cout << "Edad no válida." << endl;
        }
    }

    // Getters
    string getNombre() const {
        return nombre;
    }

    int getEdad() const {
        return edad;
    }
};
<---Ejemplo de Setters Result--->
<---Ejemplo Completo--->
```cpp
#include <iostream>
using namespace std;

class Persona {
private:
    string nombre;
    int edad;

public:
    // Constructor
    Persona(string n, int e) : nombre(n), edad(e) {}

    // Setters
    void setNombre(string n) {
        nombre = n;
    }

    void setEdad(int e) {
        if (e > 0) {
            edad = e;
        } else {
            cout << "Edad no válida." << endl;
        }
    }

    // Getters
    string getNombre() const {
        return nombre;
    }

    int getEdad() const {
        return edad;
    }

    // Método para mostrar información
    void mostrarInformacion() const {
        cout << "Nombre: " << nombre << ", Edad: " << edad << endl;
    }
};

int main() {
    // Crear un objeto de la clase Persona
    Persona juan("Juan", 30);
    juan.mostrarInformacion();

    // Modificar los atributos usando setters
    juan.setNombre("Juan Perez");
    juan.setEdad(31);
    juan.mostrarInformacion();

    // Intentar establecer una edad no válida
    juan.setEdad(-5);
    juan.mostrarInformacion();

    // Acceder a los atributos usando getters
    cout << "Nombre: " << juan.getNombre() << endl;
    cout << "Edad: " << juan.getEdad() << endl;

    return 0;
}
<---Ejemplo Completo Result--->
<---Ejemplo Básico--->
```cpp
#include <iostream>
using namespace std;

class Punto {
private:
    int x, y;

public:
    // Constructor
    Punto(int x = 0, int y = 0) : x(x), y(y) {}

    // Función para establecer valores usando this
    void setXY(int x, int y) {
        this->x = x;  // Acceso a miembro de la clase
        this->y = y;  // Acceso a miembro de la clase
    }

    // Función para mostrar valores
    void mostrar() const {
        cout << "Punto(" << x << ", " << y << ")" << endl;
    }
};

int main() {
    Punto p(10, 20);
    p.mostrar();

    p.setXY(30, 40);
    p.mostrar();

    return 0;
}
<---Ejemplo Básico Result--->
<---Ejemplo con Setters y Getters--->
```cpp
#include <iostream>
using namespace std;

class Persona {
private:
    string nombre;
    int edad;

public:
    // Constructor
    Persona(string n, int e) : nombre(n), edad(e) {}

    // Getter para nombre
    string getNombre() const {
        return nombre;
    }

    // Setter para nombre
    void setNombre(string n) {
        nombre = n;
    }

    // Getter para edad
    int getEdad() const {
        return edad;
    }

    // Setter para edad con validación
    void setEdad(int e) {
        if (e > 0) {
            edad = e;
        } else {
            cout << "Edad no válida" << endl;
        }
    }

    // Método para mostrar información
    void mostrarInformacion() const {
        cout << "Nombre: " << nombre << ", Edad: " << edad << endl;
    }
};

int main() {
    Persona juan("Juan", 30);
    juan.mostrarInformacion();

    // Modificar atributos usando setters
    juan.setNombre("Juan Perez");
    juan.setEdad(31);
    juan.mostrarInformacion();

    // Intentar establecer una edad no válida
    juan.setEdad(-5);
    juan.mostrarInformacion();

    return 0;
}
<---Ejemplo con Setters y Getters Result--->
<---Ejemplo con Herencia--->
```cpp
#include <iostream>
using namespace std;

class Base {
public:
    // Constructor
    Base() {
        cout << "Constructor de Base" << endl;
    }

    // Destructor virtual
    virtual ~Base() {
        cout << "Destructor de Base" << endl;
    }
};

class Derivada : public Base {
public:
    // Constructor
    Derivada() {
        cout << "Constructor de Derivada" << endl;
    }

    // Destructor
    ~Derivada() {
        cout << "Destructor de Derivada" << endl;
    }
};

int main() {
    Base* obj = new Derivada(); // Crear objeto de clase derivada
    delete obj; // Llamar al destructor virtual

    return 0;
}
<---Ejemplo con Herencia Result--->
<---Sintaxis del Destructor--->
```cpp
class NombreClase {
public:
    // Constructor
    NombreClase();

    // Destructor
    ~NombreClase();

    // Otros métodos y atributos
};
```cpp
#include <iostream>
using namespace std;

class Persona {
public:
    string nombre;

    // Constructor
    Persona(string n) : nombre(n) {
        cout << "Constructor llamado para " << nombre << endl;
    }

    // Destructor
    ~Persona() {
        cout << "Destructor llamado para " << nombre << endl;
    }
};

int main() {
    Persona juan("Juan");
    {
        Persona maria("Maria");
    } // Destructor llamado para maria aquí

    cout << "Fin del main" << endl;
    return 0; // Destructor llamado para juan aquí
}
<---Sintaxis del Destructor Result--->
<---Ejemplo Básico de Destructor--->
```cpp
#include <iostream>
using namespace std;

class Persona {
public:
    string nombre;

    // Constructor
    Persona(string n) : nombre(n) {
        cout << "Constructor llamado para " << nombre << endl;
    }

    // Destructor
    ~Persona() {
        cout << "Destructor llamado para " << nombre << endl;
    }
};

int main() {
    Persona juan("Juan");
    {
        Persona maria("Maria");
    } // Destructor llamado para maria aquí

    cout << "Fin del main" << endl;
    return 0; // Destructor llamado para juan aquí
}
<---Ejemplo Básico de Destructor Result--->
<---Ejemplo con Recursos Dinámicos--->
```cpp
#include <iostream>
using namespace std;

class Array {
private:
    int* data;
    int size;

public:
    // Constructor
    Array(int s) : size(s) {
        data = new int[size]; // Asignar memoria dinámica
        cout << "Array de tamaño " << size << " creado." << endl;
    }

    // Destructor
    ~Array() {
        delete[] data; // Liberar memoria dinámica
        cout << "Array de tamaño " << size << " destruido." << endl;
    }

    // Método para establecer un valor en el array
    void setValue(int index, int value) {
        if (index >= 0 && index < size) {
            data[index] = value;
        }
    }

    // Método para obtener un valor del array
    int getValue(int index) const {
        if (index >= 0 && index < size) {
            return data[index];
        }
        return -1; // Valor de error
    }
};

int main() {
    Array arr(5);
    arr.setValue(0, 10);
    arr.setValue(1, 20);
    cout << "Valor en la posición 0: " << arr.getValue(0) << endl;
    cout << "Valor en la posición 1: " << arr.getValue(1) << endl;

    return 0;
}
<---Ejemplo con Recursos Dinámicos Result--->
<---Regla de Tres--->
```cpp
class Ejemplo {
private:
    int* data;

public:
    // Constructor
    Ejemplo(int size) {
        data = new int[size];
    }

    // Destructor
    ~Ejemplo() {
        delete[] data;
    }

    // Constructor de copia
    Ejemplo(const Ejemplo& other) {
        data = new int[other.size];
        // Copiar datos...
    }

    // Operador de asignación de copia
    Ejemplo& operator=(const Ejemplo& other) {
        if (this != &other) {
            delete[] data;
            data = new int[other.size];
            // Copiar datos...
        }
        return *this;
    }
};
<---Regla de Tres Result--->
<---Regla de Cinco--->
```cpp
class Ejemplo {
private:
    int* data;

public:
    // Constructor
    Ejemplo(int size) {
        data = new int[size];
    }

    // Destructor
    ~Ejemplo() {
        delete[] data;
    }

    // Constructor de copia
    Ejemplo(const Ejemplo& other) {
        data = new int[other.size];
        // Copiar datos...
    }

    // Operador de asignación de copia
    Ejemplo& operator=(const Ejemplo& other) {
        if (this != &other) {
            delete[] data;
            data = new int[other.size];
            // Copiar datos...
        }
        return *this;
    }

    // Constructor de movimiento
    Ejemplo(Ejemplo&& other) noexcept : data(other.data) {
        other.data = nullptr;
    }

    // Operador de asignación de movimiento
    Ejemplo& operator=(Ejemplo&& other) noexcept {
        if (this != &other) {
            delete[] data;
            data = other.data;
            other.data = nullptr;
        }
        return *this;
    }
};
<---Regla de Cinco Result--->
<---Ejemplo de Sobrecarga de Operadores--->
```cpp
#include <iostream>
using namespace std;

class Complejo {
private:
    double real;
    double imaginario;

public:
    // Constructor
    Complejo(double r = 0.0, double i = 0.0) : real(r), imaginario(i) {}

    // Sobrecarga del operador +
    Complejo operator+(const Complejo& c) const {
        return Complejo(real + c.real, imaginario + c.imaginario);
    }

    // Sobrecarga del operador <<
    friend ostream& operator<<(ostream& os, const Complejo& c) {
        os << "(" << c.real << " + " << c.imaginario << "i)";
        return os;
    }
};

int main() {
    Complejo c1(3.0, 4.0);
    Complejo c2(1.0, 2.0);

    Complejo c3 = c1 + c2;  // Usando la sobrecarga del operador +

    cout << "c1: " << c1 << endl;
    cout << "c2: " << c2 << endl;
    cout << "c3: " << c3 << endl;  // Usando la sobrecarga del operador <<

    return 0;
}
<---Ejemplo de Sobrecarga de Operadores Result--->
<---Ejemplo de Sobrecarga del Operador `*`--->
```cpp
#include <iostream>
using namespace std;

class Vector {
private:
    double x, y, z;

public:
    // Constructor
    Vector(double x, double y, double z) : x(x), y(y), z(z) {}

    // Sobrecarga del operador *
    Vector operator*(double escalar) const {
        return Vector(x * escalar, y * escalar, z * escalar);
    }

    // Sobrecarga del operador <<
    friend ostream& operator<<(ostream& os, const Vector& v) {
        os << "{" << v.x << ", " << v.y << ", " << v.z << "}";
        return os;
    }
};

int main() {
    Vector v1(1.0, 2.0, 3.0);
    Vector v2 = v1 * 2.0;

    cout << "v1: " << v1 << endl;
    cout << "v2: " << v2 << endl;

    return 0;
}
<---Ejemplo de Sobrecarga del Operador `*` Result--->
<---Ejemplo de Sobrecarga del Operador `==`--->
```cpp
#include <iostream>
using namespace std;

class Punto {
private:
    int x, y;

public:
    // Constructor
    Punto(int x = 0, int y = 0) : x(x), y(y) {}

    // Sobrecarga del operador ==
    bool operator==(const Punto& p) const {
        return (x == p.x && y == p.y);
    }

    // Sobrecarga del operador <<
    friend ostream& operator<<(ostream& os, const Punto& p) {
        os << "(" << p.x << ", " << p.y << ")";
        return os;
    }
};

int main() {
    Punto p1(1, 2);
    Punto p2(1, 2);
    Punto p3(3, 4);

    cout << "p1: " << p1 << endl;
    cout << "p2: " << p2 << endl;
    cout << "p3: " << p3 << endl;

    cout << "p1 == p2: " << (p1 == p2) << endl;
    cout << "p1 == p3: " << (p1 == p3) << endl;

    return 0;
}
<---Ejemplo de Sobrecarga del Operador `==` Result--->
<---Ejemplo de Sobrecarga del Operador `++`--->
```cpp
#include <iostream>
using namespace std;

class Contador {
private:
    int valor;

public:
    // Constructor
    Contador(int v = 0) : valor(v) {}

    // Sobrecarga del operador prefijo ++
    Contador& operator++() {
        ++valor;
        return *this;
    }

    // Sobrecarga del operador postfijo ++
    Contador operator++(int) {
        Contador temp = *this;
        ++valor;
        return temp;
    }

    // Sobrecarga del operador <<
    friend ostream& operator<<(ostream& os, const Contador& c) {
        os << c.valor;
        return os;
    }
};

int main() {
    Contador c(5);

    cout << "Valor inicial: " << c << endl;

    ++c;
    cout << "Después del prefijo ++: " << c << endl;

    c++;
    cout << "Después del postfijo ++: " << c << endl;

    return 0;
}
<---Ejemplo de Sobrecarga del Operador `++` Result--->
<---Ejemplo de Sobrecarga del Operador `[]`--->
```cpp
#include <iostream>
using namespace std;

class Array {
private:
    int* datos;
    int tamano;

public:
    // Constructor
    Array(int tamano) : tamano(tamano) {
        datos = new int[tamano];
        for (int i = 0; i < tamano; ++i) {
            datos[i] = 0;
        }
    }

    // Destructor
    ~Array() {
        delete[] datos;
    }

    // Sobrecarga del operador []
    int& operator[](int indice) {
        if (indice >= 0 && indice < tamano) {
            return datos[indice];
        }
        throw out_of_range("Índice fuera de rango");
    }

    // Sobrecarga del operador <<
    friend ostream& operator<<(ostream& os, const Array& arr) {
        os << "[";
        for (int i = 0; i < arr.tamano; ++i) {
            os << arr.datos[i];
            if (i < arr.tamano - 1) {
                os << ", ";
            }
        }
        os << "]";
        return os;
    }
};

int main() {
    Array arr(5);

    arr[0] = 10;
    arr[1] = 20;
    arr[2] = 30;

    cout << "Array: " << arr << endl;

    try {
        arr[5] = 50;  // Esto lanzará una excepción
    } catch (const out_of_range& e) {
        cout << e.what() << endl;
    }

    return 0;
}
<---Ejemplo de Sobrecarga del Operador `[]` Result--->
<---Ejemplo de Encadenamiento de Métodos--->
```cpp
#include <iostream>
using namespace std;

class Rectangulo {
private:
    int ancho, alto;

public:
    // Constructor
    Rectangulo(int ancho = 0, int alto = 0) : ancho(ancho), alto(alto) {}

    // Métodos para establecer valores con encadenamiento
    Rectangulo& setAncho(int ancho) {
        this->ancho = ancho;
        return *this;
    }

    Rectangulo& setAlto(int alto) {
        this->alto = alto;
        return *this;
    }

    // Función para mostrar valores
    void mostrar() const {
        cout << "Rectangulo(" << ancho << ", " << alto << ")" << endl;
    }
};

int main() {
    Rectangulo r;
    r.setAncho(10).setAlto(20);  // Encadenamiento de métodos
    r.mostrar();

    return 0;
}
<---Ejemplo de Encadenamiento de Métodos Result--->
<---Ejemplo con Función Constante--->
```cpp
#include <iostream>
using namespace std;

class Circulo {
private:
    double radio;

public:
    // Constructor
    Circulo(double radio = 0) : radio(radio) {}

    // Método constante
    double getRadio() const {
        return this->radio;  // `this` es un puntero a un objeto constante
    }

    // Método para establecer el radio
    void setRadio(double radio) {
        this->radio = radio;
    }

    // Función para mostrar el radio
    void mostrar() const {
        cout << "Circulo con radio: " << this->getRadio() << endl;
    }
};

int main() {
    Circulo c(5.0);
    c.mostrar();

    c.setRadio(10.0);
    c.mostrar();

    return 0;
}
<---Ejemplo con Función Constante Result--->
<---Ejemplo de Prevención de Auto-Asignación--->
```cpp
#include <iostream>
#include <cstring>
using namespace std;

class Cadena {
private:
    char* str;

public:
    // Constructor
    Cadena(const char* s) {
        str = new char[strlen(s) + 1];
        strcpy(str, s);
    }

    // Destructor
    ~Cadena() {
        delete[] str;
    }

    // Constructor de copia
    Cadena(const Cadena& other) {
        str = new char[strlen(other.str) + 1];
        strcpy(str, other.str);
    }

    // Operador de asignación sobrecargado
    Cadena& operator=(const Cadena& other) {
        if (this != &other) {  // Prevención de auto-asignación
            delete[] str;
            str = new char[strlen(other.str) + 1];
            strcpy(str, other.str);
        }
        return *this;
    }

    // Función para mostrar la cadena
    void mostrar() const {
        cout << "Cadena: " << str << endl;
    }
};

int main() {
    Cadena c1("Hola");
    Cadena c2("Mundo");

    c1.mostrar();
    c2.mostrar();

    c2 = c1;  // Usando el operador de asignación sobrecargado
    c2.mostrar();

    return 0;
}
<---Ejemplo de Prevención de Auto-Asignación Result--->
<---Ejemplo de Atributos Constantes--->
```cpp
#include <iostream>
using namespace std;

class Punto {
private:
    const int x;
    const int y;

public:
    // Constructor con lista de inicialización
    Punto(int x, int y) : x(x), y(y) {}

    // Métodos para obtener los valores de los atributos
    int getX() const {
        return x;
    }

    int getY() const {
        return y;
    }

    // Método para mostrar los valores
    void mostrar() const {
        cout << "Punto(" << x << ", " << y << ")" << endl;
    }
};

int main() {
    Punto p(10, 20);
    p.mostrar();

    // p.x = 30; // Error: no se puede modificar un miembro constante
    // p.y = 40; // Error: no se puede modificar un miembro constante

    return 0;
}
<---Ejemplo de Atributos Constantes Result--->
<---Ejemplo de Métodos Constantes--->
```cpp
#include <iostream>
using namespace std;

class Circulo {
private:
    double radio;

public:
    // Constructor
    Circulo(double r) : radio(r) {}

    // Método constante para obtener el radio
    double getRadio() const {
        return radio;
    }

    // Método constante para calcular el área
    double area() const {
        return 3.14159 * radio * radio;
    }

    // Método constante para mostrar el radio
    void mostrar() const {
        cout << "Circulo con radio: " << radio << " y área: " << area() << endl;
    }
};

int main() {
    Circulo c(5.0);
    c.mostrar();

    // c.radio = 10.0; // Error: no se puede acceder a un miembro privado

    return 0;
}
<---Ejemplo de Métodos Constantes Result--->
<---Ejemplo de Const Correctness--->
```cpp
#include <iostream>
using namespace std;

class Rectangulo {
private:
    double ancho;
    double alto;

public:
    // Constructor
    Rectangulo(double a, double h) : ancho(a), alto(h) {}

    // Método constante para obtener el ancho
    double getAncho() const {
        return ancho;
    }

    // Método constante para obtener el alto
    double getAlto() const {
        return alto;
    }

    // Método constante para calcular el área
    double area() const {
        return ancho * alto;
    }

    // Método para cambiar el tamaño del rectángulo
    void cambiarTamano(double a, double h) {
        ancho = a;
        alto = h;
    }

    // Método constante para mostrar el rectángulo
    void mostrar() const {
        cout << "Rectangulo de ancho: " << ancho << ", alto: " << alto << ", área: " << area() << endl;
    }
};

int main() {
    const Rectangulo r(10.0, 5.0);
    r.mostrar();

    // r.cambiarTamano(15.0, 7.5); // Error: no se puede llamar a un método no constante en un objeto constante

    return 0;
}
<---Ejemplo de Const Correctness Result--->
<---Ejemplo con Puntero `this` en Métodos Constantes--->
```cpp
#include <iostream>
using namespace std;

class Triangulo {
private:
    double base;
    double altura;

public:
    // Constructor
    Triangulo(double b, double h) : base(b), altura(h) {}

    // Método constante para obtener la base
    double getBase() const {
        return this->base;
    }

    // Método constante para obtener la altura
    double getAltura() const {
        return this->altura;
    }

    // Método constante para calcular el área
    double area() const {
        return 0.5 * this->base * this->altura;
    }

    // Método constante para mostrar el triángulo
    void mostrar() const {
        cout << "Triangulo de base: " << this->getBase() << ", altura: " << this->getAltura() << ", área: " << this->area() << endl;
    }
};

int main() {
    Triangulo t(10.0, 5.0);
    t.mostrar();

    return 0;
}
<---Ejemplo con Puntero `this` en Métodos Constantes Result--->
<---Ejemplo de Declaración de Objetos Constantes--->
```cpp
#include <iostream>
using namespace std;

class Punto {
private:
    int x, y;

public:
    // Constructor
    Punto(int x = 0, int y = 0) : x(x), y(y) {}

    // Métodos para obtener los valores de los atributos
    int getX() const {
        return x;
    }

    int getY() const {
        return y;
    }

    // Método para establecer los valores de los atributos
    void setXY(int x, int y) {
        this->x = x;
        this->y = y;
    }

    // Método para mostrar los valores
    void mostrar() const {
        cout << "Punto(" << x << ", " << y << ")" << endl;
    }
};

int main() {
    const Punto p(10, 20);
    p.mostrar();

    // p.setXY(30, 40); // Error: no se puede llamar a un método no constante en un objeto constante

    cout << "X: " << p.getX() << ", Y: " << p.getY() << endl;

    return 0;
}
<---Ejemplo de Declaración de Objetos Constantes Result--->
<---Ejemplo de Métodos Constantes en Objetos Constantes--->
```cpp
#include <iostream>
using namespace std;

class Circulo {
private:
    double radio;

public:
    // Constructor
    Circulo(double r) : radio(r) {}

    // Método constante para obtener el radio
    double getRadio() const {
        return radio;
    }

    // Método constante para calcular el área
    double area() const {
        return 3.14159 * radio * radio;
    }

    // Método constante para mostrar el radio
    void mostrar() const {
        cout << "Circulo con radio: " << radio << " y área: " << area() << endl;
    }
};

int main() {
    const Circulo c(5.0);
    c.mostrar();

    // c.setRadio(10.0); // Error: no se puede llamar a un método no constante en un objeto constante

    cout << "Radio: " << c.getRadio() << endl;
    cout << "Área: " << c.area() << endl;

    return 0;
}
<---Ejemplo de Métodos Constantes en Objetos Constantes Result--->
<---Ejemplo de Inicialización de Objetos Constantes--->
```cpp
#include <iostream>
using namespace std;

class Rectangulo {
private:
    double ancho, alto;

public:
    // Constructor
    Rectangulo(double a, double h) : ancho(a), alto(h) {}

    // Método constante para obtener el ancho
    double getAncho() const {
        return ancho;
    }

    // Método constante para obtener el alto
    double getAlto() const {
        return alto;
    }

    // Método constante para calcular el área
    double area() const {
        return ancho * alto;
    }

    // Método constante para mostrar el rectángulo
    void mostrar() const {
        cout << "Rectangulo de ancho: " << ancho << ", alto: " << alto << ", área: " << area() << endl;
    }
};

int main() {
    const Rectangulo r(10.0, 5.0);
    r.mostrar();

    // r.cambiarTamano(15.0, 7.5); // Error: no se puede llamar a un método no constante en un objeto constante

    cout << "Ancho: " << r.getAncho() << endl;
    cout << "Alto: " << r.getAlto() << endl;
    cout << "Área: " << r.area() << endl;

    return 0;
}
<---Ejemplo de Inicialización de Objetos Constantes Result--->
<---Ejemplo de Puntero a Objeto Constante--->
```cpp
#include <iostream>
using namespace std;

class Triangulo {
private:
    double base, altura;

public:
    // Constructor
    Triangulo(double b, double h) : base(b), altura(h) {}

    // Método constante para obtener la base
    double getBase() const {
        return base;
    }

    // Método constante para obtener la altura
    double getAltura() const {
        return altura;
    }

    // Método constante para calcular el área
    double area() const {
        return 0.5 * base * altura;
    }

    // Método constante para mostrar el triángulo
    void mostrar() const {
        cout << "Triangulo de base: " << base << ", altura: " << altura << ", área: " << area() << endl;
    }
};

int main() {
    const Triangulo t(10.0, 5.0);
    const Triangulo* pt = &t;

    pt->mostrar();

    // pt->setBase(15.0); // Error: no se puede llamar a un método no constante en un objeto constante

    cout << "Base: " << pt->getBase() << endl;
    cout << "Altura: " << pt->getAltura() << endl;
    cout << "Área: " << pt->area() << endl;

    return 0;
}
<---Ejemplo de Puntero a Objeto Constante Result--->
<---Definición de una Clase--->
```cpp
class NombreClase {
public:
    // Atributos
    tipo_atributo nombre_atributo;

    // Métodos
    tipo_retorno nombre_metodo(parametros);

    // Otros componentes, como constructores, destructores, etc.
};
<---Definición de una Clase Result--->
<---Ejemplo Básico de una Clase--->
```cpp
#include <iostream>
using namespace std;

class Persona {
public:
    // Atributos
    string nombre;
    int edad;

    // Métodos
    void saludar() {
        cout << "Hola, mi nombre es " << nombre << " y tengo " << edad << " años." << endl;
    }
};

int main() {
    // Crear un objeto de la clase Persona
    Persona juan;
    juan.nombre = "Juan";
    juan.edad = 30;

    // Llamar al método saludar
    juan.saludar();

    return 0;
}
<---Ejemplo Básico de una Clase Result--->
<---Creación de Objetos--->
```cpp
NombreClase nombre_objeto;
<---Creación de Objetos Result--->
<---Ejemplo de Creación y Uso de Objetos--->
```cpp
#include <iostream>
using namespace std;

class Coche {
public:
    // Atributos
    string marca;
    string modelo;
    int anio;

    // Métodos
    void mostrarInformacion() {
        cout << "Marca: " << marca << ", Modelo: " << modelo << ", Año: " << anio << endl;
    }
};

int main() {
    // Crear objetos de la clase Coche
    Coche coche1;
    coche1.marca = "Toyota";
    coche1.modelo = "Corolla";
    coche1.anio = 2020;

    Coche coche2;
    coche2.marca = "Honda";
    coche2.modelo = "Civic";
    coche2.anio = 2019;

    // Llamar a los métodos de los objetos
    coche1.mostrarInformacion();
    coche2.mostrarInformacion();

    return 0;
}
<---Ejemplo de Creación y Uso de Objetos Result--->
<---Constructores--->
```cpp
class Persona {
public:
    string nombre;
    int edad;

    // Constructor
    Persona(string n, int e) {
        nombre = n;
        edad = e;
    }

    void saludar() {
        cout << "Hola, mi nombre es " << nombre << " y tengo " << edad << " años." << endl;
    }
};

int main() {
    // Crear un objeto de la clase Persona utilizando el constructor
    Persona juan("Juan", 30);
    juan.saludar();

    return 0;
}
<---Constructores Result--->
<---Destructores--->
```cpp
class Persona {
public:
    string nombre;
    int edad;

    // Constructor
    Persona(string n, int e) {
        nombre = n;
        edad = e;
    }

    // Destructor
    ~Persona() {
        cout << "Destructor llamado para " << nombre << endl;
    }

    void saludar() {
        cout << "Hola, mi nombre es " << nombre << " y tengo " << edad << " años." << endl;
    }
};

int main() {
    // Crear un objeto de la clase Persona
    Persona juan("Juan", 30);
    juan.saludar();

    // El destructor se llamará automáticamente al final del alcance
    return 0;
}
<---Destructores Result--->
<---Modificadores de Acceso--->
```cpp
class Persona {
private:
    string nombre;
    int edad;

public:
    // Constructor
    Persona(string n, int e) : nombre(n), edad(e) {}

    // Métodos para acceder y modificar los atributos
    string getNombre() {
        return nombre;
    }

    void setNombre(string n) {
        nombre = n;
    }

    int getEdad() {
        return edad;
    }

    void setEdad(int e) {
        edad = e;
    }

    void saludar() {
        cout << "Hola, mi nombre es " << nombre << " y tengo " << edad << " años." << endl;
    }
};

int main() {
    Persona juan("Juan", 30);
    juan.saludar();

    juan.setEdad(31);
    cout << "Nueva edad de " << juan.getNombre() << ": " << juan.getEdad() << endl;

    return 0;
}
<---Modificadores de Acceso Result--->
<---Ejemplo de Constructor por Defecto--->
```cpp
#include <iostream>
using namespace std;

class Persona {
public:
    string nombre;
    int edad;

    // Constructor por defecto
    Persona() {
        nombre = "Desconocido";
        edad = 0;
    }

    void mostrarInformacion() {
        cout << "Nombre: " << nombre << ", Edad: " << edad << endl;
    }
};

int main() {
    Persona p;  // Llama al constructor por defecto
    p.mostrarInformacion();

    return 0;
}
<---Ejemplo de Constructor por Defecto Result--->
<---Ejemplo de Constructor Parametrizado--->
```cpp
#include <iostream>
using namespace std;

class Persona {
public:
    string nombre;
    int edad;

    // Constructor parametrizado
    Persona(string n, int e) {
        nombre = n;
        edad = e;
    }

    void mostrarInformacion() {
        cout << "Nombre: " << nombre << ", Edad: " << edad << endl;
    }
};

int main() {
    Persona p("Juan", 30);  // Llama al constructor parametrizado
    p.mostrarInformacion();

    return 0;
}
<---Ejemplo de Constructor Parametrizado Result--->
<---Ejemplo de Constructor de Copia--->
```cpp
#include <iostream>
using namespace std;

class Persona {
public:
    string nombre;
    int edad;

    // Constructor parametrizado
    Persona(string n, int e) {
        nombre = n;
        edad = e;
    }

    // Constructor de copia
    Persona(const Persona& p) {
        nombre = p.nombre;
        edad = p.edad;
    }

    void mostrarInformacion() {
        cout << "Nombre: " << nombre << ", Edad: " << edad << endl;
    }
};

int main() {
    Persona p1("Juan", 30);  // Llama al constructor parametrizado
    Persona p2 = p1;         // Llama al constructor de copia
    p2.mostrarInformacion();

    return 0;
}
<---Ejemplo de Constructor de Copia Result--->
<---Ejemplo de Constructor de Movimiento--->
```cpp
#include <iostream>
using namespace std;

class Persona {
public:
    string nombre;
    int edad;

    // Constructor parametrizado
    Persona(string n, int e) : nombre(n), edad(e) {}

    // Constructor de movimiento
    Persona(Persona&& p) noexcept : nombre(move(p.nombre)), edad(p.edad) {
        p.edad = 0; // Opcional: Dejar el objeto fuente en un estado válido
    }

    void mostrarInformacion() {
        cout << "Nombre: " << nombre << ", Edad: " << edad << endl;
    }
};

int main() {
    Persona p1("Juan", 30);  // Llama al constructor parametrizado
    Persona p2 = move(p1);   // Llama al constructor de movimiento
    p2.mostrarInformacion();

    // p1 está en un estado indefinido, pero válido
    cout << "Después de mover, p1: ";
    p1.mostrarInformacion();

    return 0;
}
<---Ejemplo de Constructor de Movimiento Result--->
<---Ejemplo con Lista de Inicialización--->
```cpp
#include <iostream>
using namespace std;

class Punto {
public:
    const int x;
    const int y;

    // Constructor con lista de inicialización
    Punto(int a, int b) : x(a), y(b) {}

    void mostrarInformacion() {
        cout << "Punto(" << x << ", " << y << ")" << endl;
    }
};

int main() {
    Punto p(10, 20);  // Llama al constructor con lista de inicialización
    p.mostrarInformacion();

    return 0;
}
```cpp
#include <iostream>
using namespace std;

class Persona {
private:
    string nombre;
    int edad;

public:
    // Constructor por defecto
    Persona() : nombre("Desconocido"), edad(0) {}

    // Constructor parametrizado
    Persona(string n, int e) : nombre(n), edad(e) {}

    // Constructor de copia
    Persona(const Persona& p) : nombre(p.nombre), edad(p.edad) {}

    // Constructor de movimiento
    Persona(Persona&& p) noexcept : nombre(move(p.nombre)), edad(p.edad) {
        p.edad = 0;
    }

    void mostrarInformacion() {
        cout << "Nombre: " << nombre << ", Edad: " << edad << endl;
    }
};

int main() {
    // Usando el constructor por defecto
    Persona p1;
    p1.mostrarInformacion();

    // Usando el constructor parametrizado
    Persona p2("Juan", 30);
    p2.mostrarInformacion();

    // Usando el constructor de copia
    Persona p3 = p2;
    p3.mostrarInformacion();

    // Usando el constructor de movimiento
    Persona p4 = move(p2);
    p4.mostrarInformacion();

    // Estado después del movimiento
    cout << "Después de mover, p2: ";
    p2.mostrarInformacion();

    return 0;
}
<---Ejemplo con Lista de Inicialización Result--->
<---Definición de Atributos Privados--->
```cpp
class Persona {
private:
    string nombre;
    int edad;

public:
    // Métodos públicos
};
<---Definición de Atributos Privados Result--->
<---Ejemplo de Getters--->
```cpp
class Persona {
private:
    string nombre;
    int edad;

public:
    // Constructor
    Persona(string n, int e) : nombre(n), edad(e) {}

    // Getter para el nombre
    string getNombre() const {
        return nombre;
    }

    // Getter para la edad
    int getEdad() const {
        return edad;
    }
};
<---Ejemplo de Getters Result--->
<---Ejemplo de Setters--->
```cpp
class Persona {
private:
    string nombre;
    int edad;

public:
    // Constructor
    Persona(string n, int e) : nombre(n), edad(e) {}

    // Setter para el nombre
    void setNombre(string n) {
        nombre = n;
    }

    // Setter para la edad
    void setEdad(int e) {
        if (e > 0) {  // Validación simple
            edad = e;
        } else {
            cout << "Edad no válida." << endl;
        }
    }

    // Getters
    string getNombre() const {
        return nombre;
    }

    int getEdad() const {
        return edad;
    }
};
<---Ejemplo de Setters Result--->
<---Ejemplo Completo--->
```cpp
#include <iostream>
using namespace std;

class Persona {
private:
    string nombre;
    int edad;

public:
    // Constructor
    Persona(string n, int e) : nombre(n), edad(e) {}

    // Setters
    void setNombre(string n) {
        nombre = n;
    }

    void setEdad(int e) {
        if (e > 0) {
            edad = e;
        } else {
            cout << "Edad no válida." << endl;
        }
    }

    // Getters
    string getNombre() const {
        return nombre;
    }

    int getEdad() const {
        return edad;
    }

    // Método para mostrar información
    void mostrarInformacion() const {
        cout << "Nombre: " << nombre << ", Edad: " << edad << endl;
    }
};

int main() {
    // Crear un objeto de la clase Persona
    Persona juan("Juan", 30);
    juan.mostrarInformacion();

    // Modificar los atributos usando setters
    juan.setNombre("Juan Perez");
    juan.setEdad(31);
    juan.mostrarInformacion();

    // Intentar establecer una edad no válida
    juan.setEdad(-5);
    juan.mostrarInformacion();

    // Acceder a los atributos usando getters
    cout << "Nombre: " << juan.getNombre() << endl;
    cout << "Edad: " << juan.getEdad() << endl;

    return 0;
}
<---Ejemplo Completo Result--->
<---Ejemplo Básico--->
```cpp
#include <iostream>
using namespace std;

class Punto {
private:
    int x, y;

public:
    // Constructor
    Punto(int x = 0, int y = 0) : x(x), y(y) {}

    // Función para establecer valores usando this
    void setXY(int x, int y) {
        this->x = x;  // Acceso a miembro de la clase
        this->y = y;  // Acceso a miembro de la clase
    }

    // Función para mostrar valores
    void mostrar() const {
        cout << "Punto(" << x << ", " << y << ")" << endl;
    }
};

int main() {
    Punto p(10, 20);
    p.mostrar();

    p.setXY(30, 40);
    p.mostrar();

    return 0;
}
<---Ejemplo Básico Result--->
<---Ejemplo con Setters y Getters--->
```cpp
#include <iostream>
using namespace std;

class Persona {
private:
    string nombre;
    int edad;

public:
    // Constructor
    Persona(string n, int e) : nombre(n), edad(e) {}

    // Getter para nombre
    string getNombre() const {
        return nombre;
    }

    // Setter para nombre
    void setNombre(string n) {
        nombre = n;
    }

    // Getter para edad
    int getEdad() const {
        return edad;
    }

    // Setter para edad con validación
    void setEdad(int e) {
        if (e > 0) {
            edad = e;
        } else {
            cout << "Edad no válida" << endl;
        }
    }

    // Método para mostrar información
    void mostrarInformacion() const {
        cout << "Nombre: " << nombre << ", Edad: " << edad << endl;
    }
};

int main() {
    Persona juan("Juan", 30);
    juan.mostrarInformacion();

    // Modificar atributos usando setters
    juan.setNombre("Juan Perez");
    juan.setEdad(31);
    juan.mostrarInformacion();

    // Intentar establecer una edad no válida
    juan.setEdad(-5);
    juan.mostrarInformacion();

    return 0;
}
<---Ejemplo con Setters y Getters Result--->
<---Ejemplo con Herencia--->
```cpp
#include <iostream>
using namespace std;

class Base {
public:
    // Constructor
    Base() {
        cout << "Constructor de Base" << endl;
    }

    // Destructor virtual
    virtual ~Base() {
        cout << "Destructor de Base" << endl;
    }
};

class Derivada : public Base {
public:
    // Constructor
    Derivada() {
        cout << "Constructor de Derivada" << endl;
    }

    // Destructor
    ~Derivada() {
        cout << "Destructor de Derivada" << endl;
    }
};

int main() {
    Base* obj = new Derivada(); // Crear objeto de clase derivada
    delete obj; // Llamar al destructor virtual

    return 0;
}
<---Ejemplo con Herencia Result--->
<---Sintaxis del Destructor--->
```cpp
class NombreClase {
public:
    // Constructor
    NombreClase();

    // Destructor
    ~NombreClase();

    // Otros métodos y atributos
};
```cpp
#include <iostream>
using namespace std;

class Persona {
public:
    string nombre;

    // Constructor
    Persona(string n) : nombre(n) {
        cout << "Constructor llamado para " << nombre << endl;
    }

    // Destructor
    ~Persona() {
        cout << "Destructor llamado para " << nombre << endl;
    }
};

int main() {
    Persona juan("Juan");
    {
        Persona maria("Maria");
    } // Destructor llamado para maria aquí

    cout << "Fin del main" << endl;
    return 0; // Destructor llamado para juan aquí
}
<---Sintaxis del Destructor Result--->
<---Ejemplo Básico de Destructor--->
```cpp
#include <iostream>
using namespace std;

class Persona {
public:
    string nombre;

    // Constructor
    Persona(string n) : nombre(n) {
        cout << "Constructor llamado para " << nombre << endl;
    }

    // Destructor
    ~Persona() {
        cout << "Destructor llamado para " << nombre << endl;
    }
};

int main() {
    Persona juan("Juan");
    {
        Persona maria("Maria");
    } // Destructor llamado para maria aquí

    cout << "Fin del main" << endl;
    return 0; // Destructor llamado para juan aquí
}
<---Ejemplo Básico de Destructor Result--->
<---Ejemplo con Recursos Dinámicos--->
```cpp
#include <iostream>
using namespace std;

class Array {
private:
    int* data;
    int size;

public:
    // Constructor
    Array(int s) : size(s) {
        data = new int[size]; // Asignar memoria dinámica
        cout << "Array de tamaño " << size << " creado." << endl;
    }

    // Destructor
    ~Array() {
        delete[] data; // Liberar memoria dinámica
        cout << "Array de tamaño " << size << " destruido." << endl;
    }

    // Método para establecer un valor en el array
    void setValue(int index, int value) {
        if (index >= 0 && index < size) {
            data[index] = value;
        }
    }

    // Método para obtener un valor del array
    int getValue(int index) const {
        if (index >= 0 && index < size) {
            return data[index];
        }
        return -1; // Valor de error
    }
};

int main() {
    Array arr(5);
    arr.setValue(0, 10);
    arr.setValue(1, 20);
    cout << "Valor en la posición 0: " << arr.getValue(0) << endl;
    cout << "Valor en la posición 1: " << arr.getValue(1) << endl;

    return 0;
}
<---Ejemplo con Recursos Dinámicos Result--->
<---Regla de Tres--->
```cpp
class Ejemplo {
private:
    int* data;

public:
    // Constructor
    Ejemplo(int size) {
        data = new int[size];
    }

    // Destructor
    ~Ejemplo() {
        delete[] data;
    }

    // Constructor de copia
    Ejemplo(const Ejemplo& other) {
        data = new int[other.size];
        // Copiar datos...
    }

    // Operador de asignación de copia
    Ejemplo& operator=(const Ejemplo& other) {
        if (this != &other) {
            delete[] data;
            data = new int[other.size];
            // Copiar datos...
        }
        return *this;
    }
};
<---Regla de Tres Result--->
<---Regla de Cinco--->
```cpp
class Ejemplo {
private:
    int* data;

public:
    // Constructor
    Ejemplo(int size) {
        data = new int[size];
    }

    // Destructor
    ~Ejemplo() {
        delete[] data;
    }

    // Constructor de copia
    Ejemplo(const Ejemplo& other) {
        data = new int[other.size];
        // Copiar datos...
    }

    // Operador de asignación de copia
    Ejemplo& operator=(const Ejemplo& other) {
        if (this != &other) {
            delete[] data;
            data = new int[other.size];
            // Copiar datos...
        }
        return *this;
    }

    // Constructor de movimiento
    Ejemplo(Ejemplo&& other) noexcept : data(other.data) {
        other.data = nullptr;
    }

    // Operador de asignación de movimiento
    Ejemplo& operator=(Ejemplo&& other) noexcept {
        if (this != &other) {
            delete[] data;
            data = other.data;
            other.data = nullptr;
        }
        return *this;
    }
};
<---Regla de Cinco Result--->
<---Ejemplo de Sobrecarga de Operadores--->
```cpp
#include <iostream>
using namespace std;

class Complejo {
private:
    double real;
    double imaginario;

public:
    // Constructor
    Complejo(double r = 0.0, double i = 0.0) : real(r), imaginario(i) {}

    // Sobrecarga del operador +
    Complejo operator+(const Complejo& c) const {
        return Complejo(real + c.real, imaginario + c.imaginario);
    }

    // Sobrecarga del operador <<
    friend ostream& operator<<(ostream& os, const Complejo& c) {
        os << "(" << c.real << " + " << c.imaginario << "i)";
        return os;
    }
};

int main() {
    Complejo c1(3.0, 4.0);
    Complejo c2(1.0, 2.0);

    Complejo c3 = c1 + c2;  // Usando la sobrecarga del operador +

    cout << "c1: " << c1 << endl;
    cout << "c2: " << c2 << endl;
    cout << "c3: " << c3 << endl;  // Usando la sobrecarga del operador <<

    return 0;
}
<---Ejemplo de Sobrecarga de Operadores Result--->
<---Ejemplo de Sobrecarga del Operador `*`--->
```cpp
#include <iostream>
using namespace std;

class Vector {
private:
    double x, y, z;

public:
    // Constructor
    Vector(double x, double y, double z) : x(x), y(y), z(z) {}

    // Sobrecarga del operador *
    Vector operator*(double escalar) const {
        return Vector(x * escalar, y * escalar, z * escalar);
    }

    // Sobrecarga del operador <<
    friend ostream& operator<<(ostream& os, const Vector& v) {
        os << "{" << v.x << ", " << v.y << ", " << v.z << "}";
        return os;
    }
};

int main() {
    Vector v1(1.0, 2.0, 3.0);
    Vector v2 = v1 * 2.0;

    cout << "v1: " << v1 << endl;
    cout << "v2: " << v2 << endl;

    return 0;
}
<---Ejemplo de Sobrecarga del Operador `*` Result--->
<---Ejemplo de Sobrecarga del Operador `==`--->
```cpp
#include <iostream>
using namespace std;

class Punto {
private:
    int x, y;

public:
    // Constructor
    Punto(int x = 0, int y = 0) : x(x), y(y) {}

    // Sobrecarga del operador ==
    bool operator==(const Punto& p) const {
        return (x == p.x && y == p.y);
    }

    // Sobrecarga del operador <<
    friend ostream& operator<<(ostream& os, const Punto& p) {
        os << "(" << p.x << ", " << p.y << ")";
        return os;
    }
};

int main() {
    Punto p1(1, 2);
    Punto p2(1, 2);
    Punto p3(3, 4);

    cout << "p1: " << p1 << endl;
    cout << "p2: " << p2 << endl;
    cout << "p3: " << p3 << endl;

    cout << "p1 == p2: " << (p1 == p2) << endl;
    cout << "p1 == p3: " << (p1 == p3) << endl;

    return 0;
}
<---Ejemplo de Sobrecarga del Operador `==` Result--->
<---Ejemplo de Sobrecarga del Operador `++`--->
```cpp
#include <iostream>
using namespace std;

class Contador {
private:
    int valor;

public:
    // Constructor
    Contador(int v = 0) : valor(v) {}

    // Sobrecarga del operador prefijo ++
    Contador& operator++() {
        ++valor;
        return *this;
    }

    // Sobrecarga del operador postfijo ++
    Contador operator++(int) {
        Contador temp = *this;
        ++valor;
        return temp;
    }

    // Sobrecarga del operador <<
    friend ostream& operator<<(ostream& os, const Contador& c) {
        os << c.valor;
        return os;
    }
};

int main() {
    Contador c(5);

    cout << "Valor inicial: " << c << endl;

    ++c;
    cout << "Después del prefijo ++: " << c << endl;

    c++;
    cout << "Después del postfijo ++: " << c << endl;

    return 0;
}
<---Ejemplo de Sobrecarga del Operador `++` Result--->
<---Ejemplo de Sobrecarga del Operador `[]`--->
```cpp
#include <iostream>
using namespace std;

class Array {
private:
    int* datos;
    int tamano;

public:
    // Constructor
    Array(int tamano) : tamano(tamano) {
        datos = new int[tamano];
        for (int i = 0; i < tamano; ++i) {
            datos[i] = 0;
        }
    }

    // Destructor
    ~Array() {
        delete[] datos;
    }

    // Sobrecarga del operador []
    int& operator[](int indice) {
        if (indice >= 0 && indice < tamano) {
            return datos[indice];
        }
        throw out_of_range("Índice fuera de rango");
    }

    // Sobrecarga del operador <<
    friend ostream& operator<<(ostream& os, const Array& arr) {
        os << "[";
        for (int i = 0; i < arr.tamano; ++i) {
            os << arr.datos[i];
            if (i < arr.tamano - 1) {
                os << ", ";
            }
        }
        os << "]";
        return os;
    }
};

int main() {
    Array arr(5);

    arr[0] = 10;
    arr[1] = 20;
    arr[2] = 30;

    cout << "Array: " << arr << endl;

    try {
        arr[5] = 50;  // Esto lanzará una excepción
    } catch (const out_of_range& e) {
        cout << e.what() << endl;
    }

    return 0;
}
<---Ejemplo de Sobrecarga del Operador `[]` Result--->
<---Ejemplo de Encadenamiento de Métodos--->
```cpp
#include <iostream>
using namespace std;

class Rectangulo {
private:
    int ancho, alto;

public:
    // Constructor
    Rectangulo(int ancho = 0, int alto = 0) : ancho(ancho), alto(alto) {}

    // Métodos para establecer valores con encadenamiento
    Rectangulo& setAncho(int ancho) {
        this->ancho = ancho;
        return *this;
    }

    Rectangulo& setAlto(int alto) {
        this->alto = alto;
        return *this;
    }

    // Función para mostrar valores
    void mostrar() const {
        cout << "Rectangulo(" << ancho << ", " << alto << ")" << endl;
    }
};

int main() {
    Rectangulo r;
    r.setAncho(10).setAlto(20);  // Encadenamiento de métodos
    r.mostrar();

    return 0;
}
<---Ejemplo de Encadenamiento de Métodos Result--->
<---Ejemplo con Función Constante--->
```cpp
#include <iostream>
using namespace std;

class Circulo {
private:
    double radio;

public:
    // Constructor
    Circulo(double radio = 0) : radio(radio) {}

    // Método constante
    double getRadio() const {
        return this->radio;  // `this` es un puntero a un objeto constante
    }

    // Método para establecer el radio
    void setRadio(double radio) {
        this->radio = radio;
    }

    // Función para mostrar el radio
    void mostrar() const {
        cout << "Circulo con radio: " << this->getRadio() << endl;
    }
};

int main() {
    Circulo c(5.0);
    c.mostrar();

    c.setRadio(10.0);
    c.mostrar();

    return 0;
}
<---Ejemplo con Función Constante Result--->
<---Ejemplo de Prevención de Auto-Asignación--->
```cpp
#include <iostream>
#include <cstring>
using namespace std;

class Cadena {
private:
    char* str;

public:
    // Constructor
    Cadena(const char* s) {
        str = new char[strlen(s) + 1];
        strcpy(str, s);
    }

    // Destructor
    ~Cadena() {
        delete[] str;
    }

    // Constructor de copia
    Cadena(const Cadena& other) {
        str = new char[strlen(other.str) + 1];
        strcpy(str, other.str);
    }

    // Operador de asignación sobrecargado
    Cadena& operator=(const Cadena& other) {
        if (this != &other) {  // Prevención de auto-asignación
            delete[] str;
            str = new char[strlen(other.str) + 1];
            strcpy(str, other.str);
        }
        return *this;
    }

    // Función para mostrar la cadena
    void mostrar() const {
        cout << "Cadena: " << str << endl;
    }
};

int main() {
    Cadena c1("Hola");
    Cadena c2("Mundo");

    c1.mostrar();
    c2.mostrar();

    c2 = c1;  // Usando el operador de asignación sobrecargado
    c2.mostrar();

    return 0;
}
<---Ejemplo de Prevención de Auto-Asignación Result--->
<---Ejemplo de Atributos Constantes--->
```cpp
#include <iostream>
using namespace std;

class Punto {
private:
    const int x;
    const int y;

public:
    // Constructor con lista de inicialización
    Punto(int x, int y) : x(x), y(y) {}

    // Métodos para obtener los valores de los atributos
    int getX() const {
        return x;
    }

    int getY() const {
        return y;
    }

    // Método para mostrar los valores
    void mostrar() const {
        cout << "Punto(" << x << ", " << y << ")" << endl;
    }
};

int main() {
    Punto p(10, 20);
    p.mostrar();

    // p.x = 30; // Error: no se puede modificar un miembro constante
    // p.y = 40; // Error: no se puede modificar un miembro constante

    return 0;
}
<---Ejemplo de Atributos Constantes Result--->
<---Ejemplo de Métodos Constantes--->
```cpp
#include <iostream>
using namespace std;

class Circulo {
private:
    double radio;

public:
    // Constructor
    Circulo(double r) : radio(r) {}

    // Método constante para obtener el radio
    double getRadio() const {
        return radio;
    }

    // Método constante para calcular el área
    double area() const {
        return 3.14159 * radio * radio;
    }

    // Método constante para mostrar el radio
    void mostrar() const {
        cout << "Circulo con radio: " << radio << " y área: " << area() << endl;
    }
};

int main() {
    Circulo c(5.0);
    c.mostrar();

    // c.radio = 10.0; // Error: no se puede acceder a un miembro privado

    return 0;
}
<---Ejemplo de Métodos Constantes Result--->
<---Ejemplo de Const Correctness--->
```cpp
#include <iostream>
using namespace std;

class Rectangulo {
private:
    double ancho;
    double alto;

public:
    // Constructor
    Rectangulo(double a, double h) : ancho(a), alto(h) {}

    // Método constante para obtener el ancho
    double getAncho() const {
        return ancho;
    }

    // Método constante para obtener el alto
    double getAlto() const {
        return alto;
    }

    // Método constante para calcular el área
    double area() const {
        return ancho * alto;
    }

    // Método para cambiar el tamaño del rectángulo
    void cambiarTamano(double a, double h) {
        ancho = a;
        alto = h;
    }

    // Método constante para mostrar el rectángulo
    void mostrar() const {
        cout << "Rectangulo de ancho: " << ancho << ", alto: " << alto << ", área: " << area() << endl;
    }
};

int main() {
    const Rectangulo r(10.0, 5.0);
    r.mostrar();

    // r.cambiarTamano(15.0, 7.5); // Error: no se puede llamar a un método no constante en un objeto constante

    return 0;
}
<---Ejemplo de Const Correctness Result--->
<---Ejemplo con Puntero `this` en Métodos Constantes--->
```cpp
#include <iostream>
using namespace std;

class Triangulo {
private:
    double base;
    double altura;

public:
    // Constructor
    Triangulo(double b, double h) : base(b), altura(h) {}

    // Método constante para obtener la base
    double getBase() const {
        return this->base;
    }

    // Método constante para obtener la altura
    double getAltura() const {
        return this->altura;
    }

    // Método constante para calcular el área
    double area() const {
        return 0.5 * this->base * this->altura;
    }

    // Método constante para mostrar el triángulo
    void mostrar() const {
        cout << "Triangulo de base: " << this->getBase() << ", altura: " << this->getAltura() << ", área: " << this->area() << endl;
    }
};

int main() {
    Triangulo t(10.0, 5.0);
    t.mostrar();

    return 0;
}
<---Ejemplo con Puntero `this` en Métodos Constantes Result--->
<---Ejemplo de Declaración de Objetos Constantes--->
```cpp
#include <iostream>
using namespace std;

class Punto {
private:
    int x, y;

public:
    // Constructor
    Punto(int x = 0, int y = 0) : x(x), y(y) {}

    // Métodos para obtener los valores de los atributos
    int getX() const {
        return x;
    }

    int getY() const {
        return y;
    }

    // Método para establecer los valores de los atributos
    void setXY(int x, int y) {
        this->x = x;
        this->y = y;
    }

    // Método para mostrar los valores
    void mostrar() const {
        cout << "Punto(" << x << ", " << y << ")" << endl;
    }
};

int main() {
    const Punto p(10, 20);
    p.mostrar();

    // p.setXY(30, 40); // Error: no se puede llamar a un método no constante en un objeto constante

    cout << "X: " << p.getX() << ", Y: " << p.getY() << endl;

    return 0;
}
<---Ejemplo de Declaración de Objetos Constantes Result--->
<---Ejemplo de Métodos Constantes en Objetos Constantes--->
```cpp
#include <iostream>
using namespace std;

class Circulo {
private:
    double radio;

public:
    // Constructor
    Circulo(double r) : radio(r) {}

    // Método constante para obtener el radio
    double getRadio() const {
        return radio;
    }

    // Método constante para calcular el área
    double area() const {
        return 3.14159 * radio * radio;
    }

    // Método constante para mostrar el radio
    void mostrar() const {
        cout << "Circulo con radio: " << radio << " y área: " << area() << endl;
    }
};

int main() {
    const Circulo c(5.0);
    c.mostrar();

    // c.setRadio(10.0); // Error: no se puede llamar a un método no constante en un objeto constante

    cout << "Radio: " << c.getRadio() << endl;
    cout << "Área: " << c.area() << endl;

    return 0;
}
<---Ejemplo de Métodos Constantes en Objetos Constantes Result--->
<---Ejemplo de Inicialización de Objetos Constantes--->
```cpp
#include <iostream>
using namespace std;

class Rectangulo {
private:
    double ancho, alto;

public:
    // Constructor
    Rectangulo(double a, double h) : ancho(a), alto(h) {}

    // Método constante para obtener el ancho
    double getAncho() const {
        return ancho;
    }

    // Método constante para obtener el alto
    double getAlto() const {
        return alto;
    }

    // Método constante para calcular el área
    double area() const {
        return ancho * alto;
    }

    // Método constante para mostrar el rectángulo
    void mostrar() const {
        cout << "Rectangulo de ancho: " << ancho << ", alto: " << alto << ", área: " << area() << endl;
    }
};

int main() {
    const Rectangulo r(10.0, 5.0);
    r.mostrar();

    // r.cambiarTamano(15.0, 7.5); // Error: no se puede llamar a un método no constante en un objeto constante

    cout << "Ancho: " << r.getAncho() << endl;
    cout << "Alto: " << r.getAlto() << endl;
    cout << "Área: " << r.area() << endl;

    return 0;
}
<---Ejemplo de Inicialización de Objetos Constantes Result--->
<---Ejemplo de Puntero a Objeto Constante--->
```cpp
#include <iostream>
using namespace std;

class Triangulo {
private:
    double base, altura;

public:
    // Constructor
    Triangulo(double b, double h) : base(b), altura(h) {}

    // Método constante para obtener la base
    double getBase() const {
        return base;
    }

    // Método constante para obtener la altura
    double getAltura() const {
        return altura;
    }

    // Método constante para calcular el área
    double area() const {
        return 0.5 * base * altura;
    }

    // Método constante para mostrar el triángulo
    void mostrar() const {
        cout << "Triangulo de base: " << base << ", altura: " << altura << ", área: " << area() << endl;
    }
};

int main() {
    const Triangulo t(10.0, 5.0);
    const Triangulo* pt = &t;

    pt->mostrar();

    // pt->setBase(15.0); // Error: no se puede llamar a un método no constante en un objeto constante

    cout << "Base: " << pt->getBase() << endl;
    cout << "Altura: " << pt->getAltura() << endl;
    cout << "Área: " << pt->area() << endl;

    return 0;
}
<---Ejemplo de Puntero a Objeto Constante Result--->
<---Sintaxis--->
```cpp
class Clase {
public:
    explicit Clase(Tipo parametro);
    // Otros miembros...
};
<---Sintaxis Result--->
<---Sin Constructor Explícito--->
```cpp
#include <iostream>
using namespace std;

class Tiempo {
private:
    int minutos;

public:
    // Constructor
    Tiempo(int m) : minutos(m) {}

    // Método para mostrar el tiempo
    void mostrar() const {
        cout << "Tiempo: " << minutos << " minutos" << endl;
    }
};

void imprimirTiempo(const Tiempo& t) {
    t.mostrar();
}

int main() {
    Tiempo t1 = 120;  // Conversión implícita
    t1.mostrar();

    imprimirTiempo(90);  // Conversión implícita

    return 0;
}
<---Sin Constructor Explícito Result--->
<---Con Constructor Explícito--->
```cpp
#include <iostream>
using namespace std;

class Tiempo {
private:
    int minutos;

public:
    // Constructor explícito
    explicit Tiempo(int m) : minutos(m) {}

    // Método para mostrar el tiempo
    void mostrar() const {
        cout << "Tiempo: " << minutos << " minutos" << endl;
    }
};

void imprimirTiempo(const Tiempo& t) {
    t.mostrar();
}

int main() {
    // Tiempo t1 = 120;  // Error: conversión implícita no permitida
    Tiempo t1(120);  // Correcto: conversión explícita
    t1.mostrar();

    // imprimirTiempo(90);  // Error: conversión implícita no permitida
    imprimirTiempo(Tiempo(90));  // Correcto: conversión explícita

    return 0;
}
<---Con Constructor Explícito Result--->
<---Ejemplo con Conversiones--->
```cpp
#include <iostream>
#include <string>
using namespace std;

class Cadena {
private:
    string valor;

public:
    // Constructor explícito
    explicit Cadena(const char* s) : valor(s) {}

    // Método para mostrar la cadena
    void mostrar() const {
        cout << "Cadena: " << valor << endl;
    }
};

void imprimirCadena(const Cadena& c) {
    c.mostrar();
}

int main() {
    // Cadena c1 = "Hola";  // Error: conversión implícita no permitida
    Cadena c1("Hola");  // Correcto: conversión explícita
    c1.mostrar();

    // imprimirCadena("Mundo");  // Error: conversión implícita no permitida
    imprimirCadena(Cadena("Mundo"));  // Correcto: conversión explícita

    return 0;
}
<---Ejemplo con Conversiones Result--->
<---Constructor Implícito--->
```cpp
class Impl {
public:
    Impl(int) {}
};

void f(Impl) {}

int main() {
    f(42);  // Correcto: conversión implícita permitida
    return 0;
}
<---Constructor Implícito Result--->
<---Constructor Explícito--->
```cpp
class Expl {
public:
    explicit Expl(int) {}
};

void f(Expl) {}

int main() {
    // f(42);  // Error: conversión implícita no permitida
    f(Expl(42));  // Correcto: conversión explícita
    return 0;
}
<---Constructor Explícito Result--->
<---Definición de una Clase--->
```cpp
class NombreClase {
public:
    // Atributos
    tipo_atributo nombre_atributo;

    // Métodos
    tipo_retorno nombre_metodo(parametros);

    // Otros componentes, como constructores, destructores, etc.
};
<---Definición de una Clase Result--->
<---Ejemplo Básico de una Clase--->
```cpp
#include <iostream>
using namespace std;

class Persona {
public:
    // Atributos
    string nombre;
    int edad;

    // Métodos
    void saludar() {
        cout << "Hola, mi nombre es " << nombre << " y tengo " << edad << " años." << endl;
    }
};

int main() {
    // Crear un objeto de la clase Persona
    Persona juan;
    juan.nombre = "Juan";
    juan.edad = 30;

    // Llamar al método saludar
    juan.saludar();

    return 0;
}
<---Ejemplo Básico de una Clase Result--->
<---Creación de Objetos--->
```cpp
NombreClase nombre_objeto;
<---Creación de Objetos Result--->
<---Ejemplo de Creación y Uso de Objetos--->
```cpp
#include <iostream>
using namespace std;

class Coche {
public:
    // Atributos
    string marca;
    string modelo;
    int anio;

    // Métodos
    void mostrarInformacion() {
        cout << "Marca: " << marca << ", Modelo: " << modelo << ", Año: " << anio << endl;
    }
};

int main() {
    // Crear objetos de la clase Coche
    Coche coche1;
    coche1.marca = "Toyota";
    coche1.modelo = "Corolla";
    coche1.anio = 2020;

    Coche coche2;
    coche2.marca = "Honda";
    coche2.modelo = "Civic";
    coche2.anio = 2019;

    // Llamar a los métodos de los objetos
    coche1.mostrarInformacion();
    coche2.mostrarInformacion();

    return 0;
}
<---Ejemplo de Creación y Uso de Objetos Result--->
<---Constructores--->
```cpp
class Persona {
public:
    string nombre;
    int edad;

    // Constructor
    Persona(string n, int e) {
        nombre = n;
        edad = e;
    }

    void saludar() {
        cout << "Hola, mi nombre es " << nombre << " y tengo " << edad << " años." << endl;
    }
};

int main() {
    // Crear un objeto de la clase Persona utilizando el constructor
    Persona juan("Juan", 30);
    juan.saludar();

    return 0;
}
<---Constructores Result--->
<---Destructores--->
```cpp
class Persona {
public:
    string nombre;
    int edad;

    // Constructor
    Persona(string n, int e) {
        nombre = n;
        edad = e;
    }

    // Destructor
    ~Persona() {
        cout << "Destructor llamado para " << nombre << endl;
    }

    void saludar() {
        cout << "Hola, mi nombre es " << nombre << " y tengo " << edad << " años." << endl;
    }
};

int main() {
    // Crear un objeto de la clase Persona
    Persona juan("Juan", 30);
    juan.saludar();

    // El destructor se llamará automáticamente al final del alcance
    return 0;
}
<---Destructores Result--->
<---Modificadores de Acceso--->
```cpp
class Persona {
private:
    string nombre;
    int edad;

public:
    // Constructor
    Persona(string n, int e) : nombre(n), edad(e) {}

    // Métodos para acceder y modificar los atributos
    string getNombre() {
        return nombre;
    }

    void setNombre(string n) {
        nombre = n;
    }

    int getEdad() {
        return edad;
    }

    void setEdad(int e) {
        edad = e;
    }

    void saludar() {
        cout << "Hola, mi nombre es " << nombre << " y tengo " << edad << " años." << endl;
    }
};

int main() {
    Persona juan("Juan", 30);
    juan.saludar();

    juan.setEdad(31);
    cout << "Nueva edad de " << juan.getNombre() << ": " << juan.getEdad() << endl;

    return 0;
}
<---Modificadores de Acceso Result--->
<---Ejemplo de Constructor por Defecto--->
```cpp
#include <iostream>
using namespace std;

class Persona {
public:
    string nombre;
    int edad;

    // Constructor por defecto
    Persona() {
        nombre = "Desconocido";
        edad = 0;
    }

    void mostrarInformacion() {
        cout << "Nombre: " << nombre << ", Edad: " << edad << endl;
    }
};

int main() {
    Persona p;  // Llama al constructor por defecto
    p.mostrarInformacion();

    return 0;
}
<---Ejemplo de Constructor por Defecto Result--->
<---Ejemplo de Constructor Parametrizado--->
```cpp
#include <iostream>
using namespace std;

class Persona {
public:
    string nombre;
    int edad;

    // Constructor parametrizado
    Persona(string n, int e) {
        nombre = n;
        edad = e;
    }

    void mostrarInformacion() {
        cout << "Nombre: " << nombre << ", Edad: " << edad << endl;
    }
};

int main() {
    Persona p("Juan", 30);  // Llama al constructor parametrizado
    p.mostrarInformacion();

    return 0;
}
<---Ejemplo de Constructor Parametrizado Result--->
<---Ejemplo de Constructor de Copia--->
```cpp
#include <iostream>
using namespace std;

class Persona {
public:
    string nombre;
    int edad;

    // Constructor parametrizado
    Persona(string n, int e) {
        nombre = n;
        edad = e;
    }

    // Constructor de copia
    Persona(const Persona& p) {
        nombre = p.nombre;
        edad = p.edad;
    }

    void mostrarInformacion() {
        cout << "Nombre: " << nombre << ", Edad: " << edad << endl;
    }
};

int main() {
    Persona p1("Juan", 30);  // Llama al constructor parametrizado
    Persona p2 = p1;         // Llama al constructor de copia
    p2.mostrarInformacion();

    return 0;
}
<---Ejemplo de Constructor de Copia Result--->
<---Ejemplo de Constructor de Movimiento--->
```cpp
#include <iostream>
using namespace std;

class Persona {
public:
    string nombre;
    int edad;

    // Constructor parametrizado
    Persona(string n, int e) : nombre(n), edad(e) {}

    // Constructor de movimiento
    Persona(Persona&& p) noexcept : nombre(move(p.nombre)), edad(p.edad) {
        p.edad = 0; // Opcional: Dejar el objeto fuente en un estado válido
    }

    void mostrarInformacion() {
        cout << "Nombre: " << nombre << ", Edad: " << edad << endl;
    }
};

int main() {
    Persona p1("Juan", 30);  // Llama al constructor parametrizado
    Persona p2 = move(p1);   // Llama al constructor de movimiento
    p2.mostrarInformacion();

    // p1 está en un estado indefinido, pero válido
    cout << "Después de mover, p1: ";
    p1.mostrarInformacion();

    return 0;
}
<---Ejemplo de Constructor de Movimiento Result--->
<---Ejemplo con Lista de Inicialización--->
```cpp
#include <iostream>
using namespace std;

class Punto {
public:
    const int x;
    const int y;

    // Constructor con lista de inicialización
    Punto(int a, int b) : x(a), y(b) {}

    void mostrarInformacion() {
        cout << "Punto(" << x << ", " << y << ")" << endl;
    }
};

int main() {
    Punto p(10, 20);  // Llama al constructor con lista de inicialización
    p.mostrarInformacion();

    return 0;
}
```cpp
#include <iostream>
using namespace std;

class Persona {
private:
    string nombre;
    int edad;

public:
    // Constructor por defecto
    Persona() : nombre("Desconocido"), edad(0) {}

    // Constructor parametrizado
    Persona(string n, int e) : nombre(n), edad(e) {}

    // Constructor de copia
    Persona(const Persona& p) : nombre(p.nombre), edad(p.edad) {}

    // Constructor de movimiento
    Persona(Persona&& p) noexcept : nombre(move(p.nombre)), edad(p.edad) {
        p.edad = 0;
    }

    void mostrarInformacion() {
        cout << "Nombre: " << nombre << ", Edad: " << edad << endl;
    }
};

int main() {
    // Usando el constructor por defecto
    Persona p1;
    p1.mostrarInformacion();

    // Usando el constructor parametrizado
    Persona p2("Juan", 30);
    p2.mostrarInformacion();

    // Usando el constructor de copia
    Persona p3 = p2;
    p3.mostrarInformacion();

    // Usando el constructor de movimiento
    Persona p4 = move(p2);
    p4.mostrarInformacion();

    // Estado después del movimiento
    cout << "Después de mover, p2: ";
    p2.mostrarInformacion();

    return 0;
}
<---Ejemplo con Lista de Inicialización Result--->
<---Definición de Atributos Privados--->
```cpp
class Persona {
private:
    string nombre;
    int edad;

public:
    // Métodos públicos
};
<---Definición de Atributos Privados Result--->
<---Ejemplo de Getters--->
```cpp
class Persona {
private:
    string nombre;
    int edad;

public:
    // Constructor
    Persona(string n, int e) : nombre(n), edad(e) {}

    // Getter para el nombre
    string getNombre() const {
        return nombre;
    }

    // Getter para la edad
    int getEdad() const {
        return edad;
    }
};
<---Ejemplo de Getters Result--->
<---Ejemplo de Setters--->
```cpp
class Persona {
private:
    string nombre;
    int edad;

public:
    // Constructor
    Persona(string n, int e) : nombre(n), edad(e) {}

    // Setter para el nombre
    void setNombre(string n) {
        nombre = n;
    }

    // Setter para la edad
    void setEdad(int e) {
        if (e > 0) {  // Validación simple
            edad = e;
        } else {
            cout << "Edad no válida." << endl;
        }
    }

    // Getters
    string getNombre() const {
        return nombre;
    }

    int getEdad() const {
        return edad;
    }
};
<---Ejemplo de Setters Result--->
<---Ejemplo Completo--->
```cpp
#include <iostream>
using namespace std;

class Persona {
private:
    string nombre;
    int edad;

public:
    // Constructor
    Persona(string n, int e) : nombre(n), edad(e) {}

    // Setters
    void setNombre(string n) {
        nombre = n;
    }

    void setEdad(int e) {
        if (e > 0) {
            edad = e;
        } else {
            cout << "Edad no válida." << endl;
        }
    }

    // Getters
    string getNombre() const {
        return nombre;
    }

    int getEdad() const {
        return edad;
    }

    // Método para mostrar información
    void mostrarInformacion() const {
        cout << "Nombre: " << nombre << ", Edad: " << edad << endl;
    }
};

int main() {
    // Crear un objeto de la clase Persona
    Persona juan("Juan", 30);
    juan.mostrarInformacion();

    // Modificar los atributos usando setters
    juan.setNombre("Juan Perez");
    juan.setEdad(31);
    juan.mostrarInformacion();

    // Intentar establecer una edad no válida
    juan.setEdad(-5);
    juan.mostrarInformacion();

    // Acceder a los atributos usando getters
    cout << "Nombre: " << juan.getNombre() << endl;
    cout << "Edad: " << juan.getEdad() << endl;

    return 0;
}
<---Ejemplo Completo Result--->
<---Ejemplo Básico--->
```cpp
#include <iostream>
using namespace std;

class Punto {
private:
    int x, y;

public:
    // Constructor
    Punto(int x = 0, int y = 0) : x(x), y(y) {}

    // Función para establecer valores usando this
    void setXY(int x, int y) {
        this->x = x;  // Acceso a miembro de la clase
        this->y = y;  // Acceso a miembro de la clase
    }

    // Función para mostrar valores
    void mostrar() const {
        cout << "Punto(" << x << ", " << y << ")" << endl;
    }
};

int main() {
    Punto p(10, 20);
    p.mostrar();

    p.setXY(30, 40);
    p.mostrar();

    return 0;
}
<---Ejemplo Básico Result--->
<---Ejemplo con Setters y Getters--->
```cpp
#include <iostream>
using namespace std;

class Persona {
private:
    string nombre;
    int edad;

public:
    // Constructor
    Persona(string n, int e) : nombre(n), edad(e) {}

    // Getter para nombre
    string getNombre() const {
        return nombre;
    }

    // Setter para nombre
    void setNombre(string n) {
        nombre = n;
    }

    // Getter para edad
    int getEdad() const {
        return edad;
    }

    // Setter para edad con validación
    void setEdad(int e) {
        if (e > 0) {
            edad = e;
        } else {
            cout << "Edad no válida" << endl;
        }
    }

    // Método para mostrar información
    void mostrarInformacion() const {
        cout << "Nombre: " << nombre << ", Edad: " << edad << endl;
    }
};

int main() {
    Persona juan("Juan", 30);
    juan.mostrarInformacion();

    // Modificar atributos usando setters
    juan.setNombre("Juan Perez");
    juan.setEdad(31);
    juan.mostrarInformacion();

    // Intentar establecer una edad no válida
    juan.setEdad(-5);
    juan.mostrarInformacion();

    return 0;
}
<---Ejemplo con Setters y Getters Result--->
<---Ejemplo con Herencia--->
```cpp
#include <iostream>
using namespace std;

class Base {
public:
    // Constructor
    Base() {
        cout << "Constructor de Base" << endl;
    }

    // Destructor virtual
    virtual ~Base() {
        cout << "Destructor de Base" << endl;
    }
};

class Derivada : public Base {
public:
    // Constructor
    Derivada() {
        cout << "Constructor de Derivada" << endl;
    }

    // Destructor
    ~Derivada() {
        cout << "Destructor de Derivada" << endl;
    }
};

int main() {
    Base* obj = new Derivada(); // Crear objeto de clase derivada
    delete obj; // Llamar al destructor virtual

    return 0;
}
<---Ejemplo con Herencia Result--->
<---Sintaxis del Destructor--->
```cpp
class NombreClase {
public:
    // Constructor
    NombreClase();

    // Destructor
    ~NombreClase();

    // Otros métodos y atributos
};
```cpp
#include <iostream>
using namespace std;

class Persona {
public:
    string nombre;

    // Constructor
    Persona(string n) : nombre(n) {
        cout << "Constructor llamado para " << nombre << endl;
    }

    // Destructor
    ~Persona() {
        cout << "Destructor llamado para " << nombre << endl;
    }
};

int main() {
    Persona juan("Juan");
    {
        Persona maria("Maria");
    } // Destructor llamado para maria aquí

    cout << "Fin del main" << endl;
    return 0; // Destructor llamado para juan aquí
}
<---Sintaxis del Destructor Result--->
<---Ejemplo Básico de Destructor--->
```cpp
#include <iostream>
using namespace std;

class Persona {
public:
    string nombre;

    // Constructor
    Persona(string n) : nombre(n) {
        cout << "Constructor llamado para " << nombre << endl;
    }

    // Destructor
    ~Persona() {
        cout << "Destructor llamado para " << nombre << endl;
    }
};

int main() {
    Persona juan("Juan");
    {
        Persona maria("Maria");
    } // Destructor llamado para maria aquí

    cout << "Fin del main" << endl;
    return 0; // Destructor llamado para juan aquí
}
<---Ejemplo Básico de Destructor Result--->
<---Ejemplo con Recursos Dinámicos--->
```cpp
#include <iostream>
using namespace std;

class Array {
private:
    int* data;
    int size;

public:
    // Constructor
    Array(int s) : size(s) {
        data = new int[size]; // Asignar memoria dinámica
        cout << "Array de tamaño " << size << " creado." << endl;
    }

    // Destructor
    ~Array() {
        delete[] data; // Liberar memoria dinámica
        cout << "Array de tamaño " << size << " destruido." << endl;
    }

    // Método para establecer un valor en el array
    void setValue(int index, int value) {
        if (index >= 0 && index < size) {
            data[index] = value;
        }
    }

    // Método para obtener un valor del array
    int getValue(int index) const {
        if (index >= 0 && index < size) {
            return data[index];
        }
        return -1; // Valor de error
    }
};

int main() {
    Array arr(5);
    arr.setValue(0, 10);
    arr.setValue(1, 20);
    cout << "Valor en la posición 0: " << arr.getValue(0) << endl;
    cout << "Valor en la posición 1: " << arr.getValue(1) << endl;

    return 0;
}
<---Ejemplo con Recursos Dinámicos Result--->
<---Regla de Tres--->
```cpp
class Ejemplo {
private:
    int* data;

public:
    // Constructor
    Ejemplo(int size) {
        data = new int[size];
    }

    // Destructor
    ~Ejemplo() {
        delete[] data;
    }

    // Constructor de copia
    Ejemplo(const Ejemplo& other) {
        data = new int[other.size];
        // Copiar datos...
    }

    // Operador de asignación de copia
    Ejemplo& operator=(const Ejemplo& other) {
        if (this != &other) {
            delete[] data;
            data = new int[other.size];
            // Copiar datos...
        }
        return *this;
    }
};
<---Regla de Tres Result--->
<---Regla de Cinco--->
```cpp
class Ejemplo {
private:
    int* data;

public:
    // Constructor
    Ejemplo(int size) {
        data = new int[size];
    }

    // Destructor
    ~Ejemplo() {
        delete[] data;
    }

    // Constructor de copia
    Ejemplo(const Ejemplo& other) {
        data = new int[other.size];
        // Copiar datos...
    }

    // Operador de asignación de copia
    Ejemplo& operator=(const Ejemplo& other) {
        if (this != &other) {
            delete[] data;
            data = new int[other.size];
            // Copiar datos...
        }
        return *this;
    }

    // Constructor de movimiento
    Ejemplo(Ejemplo&& other) noexcept : data(other.data) {
        other.data = nullptr;
    }

    // Operador de asignación de movimiento
    Ejemplo& operator=(Ejemplo&& other) noexcept {
        if (this != &other) {
            delete[] data;
            data = other.data;
            other.data = nullptr;
        }
        return *this;
    }
};
<---Regla de Cinco Result--->
<---Ejemplo de Sobrecarga de Operadores--->
```cpp
#include <iostream>
using namespace std;

class Complejo {
private:
    double real;
    double imaginario;

public:
    // Constructor
    Complejo(double r = 0.0, double i = 0.0) : real(r), imaginario(i) {}

    // Sobrecarga del operador +
    Complejo operator+(const Complejo& c) const {
        return Complejo(real + c.real, imaginario + c.imaginario);
    }

    // Sobrecarga del operador <<
    friend ostream& operator<<(ostream& os, const Complejo& c) {
        os << "(" << c.real << " + " << c.imaginario << "i)";
        return os;
    }
};

int main() {
    Complejo c1(3.0, 4.0);
    Complejo c2(1.0, 2.0);

    Complejo c3 = c1 + c2;  // Usando la sobrecarga del operador +

    cout << "c1: " << c1 << endl;
    cout << "c2: " << c2 << endl;
    cout << "c3: " << c3 << endl;  // Usando la sobrecarga del operador <<

    return 0;
}
<---Ejemplo de Sobrecarga de Operadores Result--->
<---Ejemplo de Sobrecarga del Operador `*`--->
```cpp
#include <iostream>
using namespace std;

class Vector {
private:
    double x, y, z;

public:
    // Constructor
    Vector(double x, double y, double z) : x(x), y(y), z(z) {}

    // Sobrecarga del operador *
    Vector operator*(double escalar) const {
        return Vector(x * escalar, y * escalar, z * escalar);
    }

    // Sobrecarga del operador <<
    friend ostream& operator<<(ostream& os, const Vector& v) {
        os << "{" << v.x << ", " << v.y << ", " << v.z << "}";
        return os;
    }
};

int main() {
    Vector v1(1.0, 2.0, 3.0);
    Vector v2 = v1 * 2.0;

    cout << "v1: " << v1 << endl;
    cout << "v2: " << v2 << endl;

    return 0;
}
<---Ejemplo de Sobrecarga del Operador `*` Result--->
<---Ejemplo de Sobrecarga del Operador `==`--->
```cpp
#include <iostream>
using namespace std;

class Punto {
private:
    int x, y;

public:
    // Constructor
    Punto(int x = 0, int y = 0) : x(x), y(y) {}

    // Sobrecarga del operador ==
    bool operator==(const Punto& p) const {
        return (x == p.x && y == p.y);
    }

    // Sobrecarga del operador <<
    friend ostream& operator<<(ostream& os, const Punto& p) {
        os << "(" << p.x << ", " << p.y << ")";
        return os;
    }
};

int main() {
    Punto p1(1, 2);
    Punto p2(1, 2);
    Punto p3(3, 4);

    cout << "p1: " << p1 << endl;
    cout << "p2: " << p2 << endl;
    cout << "p3: " << p3 << endl;

    cout << "p1 == p2: " << (p1 == p2) << endl;
    cout << "p1 == p3: " << (p1 == p3) << endl;

    return 0;
}
<---Ejemplo de Sobrecarga del Operador `==` Result--->
<---Ejemplo de Sobrecarga del Operador `++`--->
```cpp
#include <iostream>
using namespace std;

class Contador {
private:
    int valor;

public:
    // Constructor
    Contador(int v = 0) : valor(v) {}

    // Sobrecarga del operador prefijo ++
    Contador& operator++() {
        ++valor;
        return *this;
    }

    // Sobrecarga del operador postfijo ++
    Contador operator++(int) {
        Contador temp = *this;
        ++valor;
        return temp;
    }

    // Sobrecarga del operador <<
    friend ostream& operator<<(ostream& os, const Contador& c) {
        os << c.valor;
        return os;
    }
};

int main() {
    Contador c(5);

    cout << "Valor inicial: " << c << endl;

    ++c;
    cout << "Después del prefijo ++: " << c << endl;

    c++;
    cout << "Después del postfijo ++: " << c << endl;

    return 0;
}
<---Ejemplo de Sobrecarga del Operador `++` Result--->
<---Ejemplo de Sobrecarga del Operador `[]`--->
```cpp
#include <iostream>
using namespace std;

class Array {
private:
    int* datos;
    int tamano;

public:
    // Constructor
    Array(int tamano) : tamano(tamano) {
        datos = new int[tamano];
        for (int i = 0; i < tamano; ++i) {
            datos[i] = 0;
        }
    }

    // Destructor
    ~Array() {
        delete[] datos;
    }

    // Sobrecarga del operador []
    int& operator[](int indice) {
        if (indice >= 0 && indice < tamano) {
            return datos[indice];
        }
        throw out_of_range("Índice fuera de rango");
    }

    // Sobrecarga del operador <<
    friend ostream& operator<<(ostream& os, const Array& arr) {
        os << "[";
        for (int i = 0; i < arr.tamano; ++i) {
            os << arr.datos[i];
            if (i < arr.tamano - 1) {
                os << ", ";
            }
        }
        os << "]";
        return os;
    }
};

int main() {
    Array arr(5);

    arr[0] = 10;
    arr[1] = 20;
    arr[2] = 30;

    cout << "Array: " << arr << endl;

    try {
        arr[5] = 50;  // Esto lanzará una excepción
    } catch (const out_of_range& e) {
        cout << e.what() << endl;
    }

    return 0;
}
<---Ejemplo de Sobrecarga del Operador `[]` Result--->
<---Ejemplo de Encadenamiento de Métodos--->
```cpp
#include <iostream>
using namespace std;

class Rectangulo {
private:
    int ancho, alto;

public:
    // Constructor
    Rectangulo(int ancho = 0, int alto = 0) : ancho(ancho), alto(alto) {}

    // Métodos para establecer valores con encadenamiento
    Rectangulo& setAncho(int ancho) {
        this->ancho = ancho;
        return *this;
    }

    Rectangulo& setAlto(int alto) {
        this->alto = alto;
        return *this;
    }

    // Función para mostrar valores
    void mostrar() const {
        cout << "Rectangulo(" << ancho << ", " << alto << ")" << endl;
    }
};

int main() {
    Rectangulo r;
    r.setAncho(10).setAlto(20);  // Encadenamiento de métodos
    r.mostrar();

    return 0;
}
<---Ejemplo de Encadenamiento de Métodos Result--->
<---Ejemplo con Función Constante--->
```cpp
#include <iostream>
using namespace std;

class Circulo {
private:
    double radio;

public:
    // Constructor
    Circulo(double radio = 0) : radio(radio) {}

    // Método constante
    double getRadio() const {
        return this->radio;  // `this` es un puntero a un objeto constante
    }

    // Método para establecer el radio
    void setRadio(double radio) {
        this->radio = radio;
    }

    // Función para mostrar el radio
    void mostrar() const {
        cout << "Circulo con radio: " << this->getRadio() << endl;
    }
};

int main() {
    Circulo c(5.0);
    c.mostrar();

    c.setRadio(10.0);
    c.mostrar();

    return 0;
}
<---Ejemplo con Función Constante Result--->
<---Ejemplo de Prevención de Auto-Asignación--->
```cpp
#include <iostream>
#include <cstring>
using namespace std;

class Cadena {
private:
    char* str;

public:
    // Constructor
    Cadena(const char* s) {
        str = new char[strlen(s) + 1];
        strcpy(str, s);
    }

    // Destructor
    ~Cadena() {
        delete[] str;
    }

    // Constructor de copia
    Cadena(const Cadena& other) {
        str = new char[strlen(other.str) + 1];
        strcpy(str, other.str);
    }

    // Operador de asignación sobrecargado
    Cadena& operator=(const Cadena& other) {
        if (this != &other) {  // Prevención de auto-asignación
            delete[] str;
            str = new char[strlen(other.str) + 1];
            strcpy(str, other.str);
        }
        return *this;
    }

    // Función para mostrar la cadena
    void mostrar() const {
        cout << "Cadena: " << str << endl;
    }
};

int main() {
    Cadena c1("Hola");
    Cadena c2("Mundo");

    c1.mostrar();
    c2.mostrar();

    c2 = c1;  // Usando el operador de asignación sobrecargado
    c2.mostrar();

    return 0;
}
<---Ejemplo de Prevención de Auto-Asignación Result--->
<---Ejemplo de Atributos Constantes--->
```cpp
#include <iostream>
using namespace std;

class Punto {
private:
    const int x;
    const int y;

public:
    // Constructor con lista de inicialización
    Punto(int x, int y) : x(x), y(y) {}

    // Métodos para obtener los valores de los atributos
    int getX() const {
        return x;
    }

    int getY() const {
        return y;
    }

    // Método para mostrar los valores
    void mostrar() const {
        cout << "Punto(" << x << ", " << y << ")" << endl;
    }
};

int main() {
    Punto p(10, 20);
    p.mostrar();

    // p.x = 30; // Error: no se puede modificar un miembro constante
    // p.y = 40; // Error: no se puede modificar un miembro constante

    return 0;
}
<---Ejemplo de Atributos Constantes Result--->
<---Ejemplo de Métodos Constantes--->
```cpp
#include <iostream>
using namespace std;

class Circulo {
private:
    double radio;

public:
    // Constructor
    Circulo(double r) : radio(r) {}

    // Método constante para obtener el radio
    double getRadio() const {
        return radio;
    }

    // Método constante para calcular el área
    double area() const {
        return 3.14159 * radio * radio;
    }

    // Método constante para mostrar el radio
    void mostrar() const {
        cout << "Circulo con radio: " << radio << " y área: " << area() << endl;
    }
};

int main() {
    Circulo c(5.0);
    c.mostrar();

    // c.radio = 10.0; // Error: no se puede acceder a un miembro privado

    return 0;
}
<---Ejemplo de Métodos Constantes Result--->
<---Ejemplo de Const Correctness--->
```cpp
#include <iostream>
using namespace std;

class Rectangulo {
private:
    double ancho;
    double alto;

public:
    // Constructor
    Rectangulo(double a, double h) : ancho(a), alto(h) {}

    // Método constante para obtener el ancho
    double getAncho() const {
        return ancho;
    }

    // Método constante para obtener el alto
    double getAlto() const {
        return alto;
    }

    // Método constante para calcular el área
    double area() const {
        return ancho * alto;
    }

    // Método para cambiar el tamaño del rectángulo
    void cambiarTamano(double a, double h) {
        ancho = a;
        alto = h;
    }

    // Método constante para mostrar el rectángulo
    void mostrar() const {
        cout << "Rectangulo de ancho: " << ancho << ", alto: " << alto << ", área: " << area() << endl;
    }
};

int main() {
    const Rectangulo r(10.0, 5.0);
    r.mostrar();

    // r.cambiarTamano(15.0, 7.5); // Error: no se puede llamar a un método no constante en un objeto constante

    return 0;
}
<---Ejemplo de Const Correctness Result--->
<---Ejemplo con Puntero `this` en Métodos Constantes--->
```cpp
#include <iostream>
using namespace std;

class Triangulo {
private:
    double base;
    double altura;

public:
    // Constructor
    Triangulo(double b, double h) : base(b), altura(h) {}

    // Método constante para obtener la base
    double getBase() const {
        return this->base;
    }

    // Método constante para obtener la altura
    double getAltura() const {
        return this->altura;
    }

    // Método constante para calcular el área
    double area() const {
        return 0.5 * this->base * this->altura;
    }

    // Método constante para mostrar el triángulo
    void mostrar() const {
        cout << "Triangulo de base: " << this->getBase() << ", altura: " << this->getAltura() << ", área: " << this->area() << endl;
    }
};

int main() {
    Triangulo t(10.0, 5.0);
    t.mostrar();

    return 0;
}
<---Ejemplo con Puntero `this` en Métodos Constantes Result--->
<---Ejemplo de Declaración de Objetos Constantes--->
```cpp
#include <iostream>
using namespace std;

class Punto {
private:
    int x, y;

public:
    // Constructor
    Punto(int x = 0, int y = 0) : x(x), y(y) {}

    // Métodos para obtener los valores de los atributos
    int getX() const {
        return x;
    }

    int getY() const {
        return y;
    }

    // Método para establecer los valores de los atributos
    void setXY(int x, int y) {
        this->x = x;
        this->y = y;
    }

    // Método para mostrar los valores
    void mostrar() const {
        cout << "Punto(" << x << ", " << y << ")" << endl;
    }
};

int main() {
    const Punto p(10, 20);
    p.mostrar();

    // p.setXY(30, 40); // Error: no se puede llamar a un método no constante en un objeto constante

    cout << "X: " << p.getX() << ", Y: " << p.getY() << endl;

    return 0;
}
<---Ejemplo de Declaración de Objetos Constantes Result--->
<---Ejemplo de Métodos Constantes en Objetos Constantes--->
```cpp
#include <iostream>
using namespace std;

class Circulo {
private:
    double radio;

public:
    // Constructor
    Circulo(double r) : radio(r) {}

    // Método constante para obtener el radio
    double getRadio() const {
        return radio;
    }

    // Método constante para calcular el área
    double area() const {
        return 3.14159 * radio * radio;
    }

    // Método constante para mostrar el radio
    void mostrar() const {
        cout << "Circulo con radio: " << radio << " y área: " << area() << endl;
    }
};

int main() {
    const Circulo c(5.0);
    c.mostrar();

    // c.setRadio(10.0); // Error: no se puede llamar a un método no constante en un objeto constante

    cout << "Radio: " << c.getRadio() << endl;
    cout << "Área: " << c.area() << endl;

    return 0;
}
<---Ejemplo de Métodos Constantes en Objetos Constantes Result--->
<---Ejemplo de Inicialización de Objetos Constantes--->
```cpp
#include <iostream>
using namespace std;

class Rectangulo {
private:
    double ancho, alto;

public:
    // Constructor
    Rectangulo(double a, double h) : ancho(a), alto(h) {}

    // Método constante para obtener el ancho
    double getAncho() const {
        return ancho;
    }

    // Método constante para obtener el alto
    double getAlto() const {
        return alto;
    }

    // Método constante para calcular el área
    double area() const {
        return ancho * alto;
    }

    // Método constante para mostrar el rectángulo
    void mostrar() const {
        cout << "Rectangulo de ancho: " << ancho << ", alto: " << alto << ", área: " << area() << endl;
    }
};

int main() {
    const Rectangulo r(10.0, 5.0);
    r.mostrar();

    // r.cambiarTamano(15.0, 7.5); // Error: no se puede llamar a un método no constante en un objeto constante

    cout << "Ancho: " << r.getAncho() << endl;
    cout << "Alto: " << r.getAlto() << endl;
    cout << "Área: " << r.area() << endl;

    return 0;
}
<---Ejemplo de Inicialización de Objetos Constantes Result--->
<---Ejemplo de Puntero a Objeto Constante--->
```cpp
#include <iostream>
using namespace std;

class Triangulo {
private:
    double base, altura;

public:
    // Constructor
    Triangulo(double b, double h) : base(b), altura(h) {}

    // Método constante para obtener la base
    double getBase() const {
        return base;
    }

    // Método constante para obtener la altura
    double getAltura() const {
        return altura;
    }

    // Método constante para calcular el área
    double area() const {
        return 0.5 * base * altura;
    }

    // Método constante para mostrar el triángulo
    void mostrar() const {
        cout << "Triangulo de base: " << base << ", altura: " << altura << ", área: " << area() << endl;
    }
};

int main() {
    const Triangulo t(10.0, 5.0);
    const Triangulo* pt = &t;

    pt->mostrar();

    // pt->setBase(15.0); // Error: no se puede llamar a un método no constante en un objeto constante

    cout << "Base: " << pt->getBase() << endl;
    cout << "Altura: " << pt->getAltura() << endl;
    cout << "Área: " << pt->area() << endl;

    return 0;
}
<---Ejemplo de Puntero a Objeto Constante Result--->
<---Sintaxis--->
```cpp
class Clase {
public:
    explicit Clase(Tipo parametro);
    // Otros miembros...
};
<---Sintaxis Result--->
<---Sin Constructor Explícito--->
```cpp
#include <iostream>
using namespace std;

class Tiempo {
private:
    int minutos;

public:
    // Constructor
    Tiempo(int m) : minutos(m) {}

    // Método para mostrar el tiempo
    void mostrar() const {
        cout << "Tiempo: " << minutos << " minutos" << endl;
    }
};

void imprimirTiempo(const Tiempo& t) {
    t.mostrar();
}

int main() {
    Tiempo t1 = 120;  // Conversión implícita
    t1.mostrar();

    imprimirTiempo(90);  // Conversión implícita

    return 0;
}
<---Sin Constructor Explícito Result--->
<---Con Constructor Explícito--->
```cpp
#include <iostream>
using namespace std;

class Tiempo {
private:
    int minutos;

public:
    // Constructor explícito
    explicit Tiempo(int m) : minutos(m) {}

    // Método para mostrar el tiempo
    void mostrar() const {
        cout << "Tiempo: " << minutos << " minutos" << endl;
    }
};

void imprimirTiempo(const Tiempo& t) {
    t.mostrar();
}

int main() {
    // Tiempo t1 = 120;  // Error: conversión implícita no permitida
    Tiempo t1(120);  // Correcto: conversión explícita
    t1.mostrar();

    // imprimirTiempo(90);  // Error: conversión implícita no permitida
    imprimirTiempo(Tiempo(90));  // Correcto: conversión explícita

    return 0;
}
<---Con Constructor Explícito Result--->
<---Ejemplo con Conversiones--->
```cpp
#include <iostream>
#include <string>
using namespace std;

class Cadena {
private:
    string valor;

public:
    // Constructor explícito
    explicit Cadena(const char* s) : valor(s) {}

    // Método para mostrar la cadena
    void mostrar() const {
        cout << "Cadena: " << valor << endl;
    }
};

void imprimirCadena(const Cadena& c) {
    c.mostrar();
}

int main() {
    // Cadena c1 = "Hola";  // Error: conversión implícita no permitida
    Cadena c1("Hola");  // Correcto: conversión explícita
    c1.mostrar();

    // imprimirCadena("Mundo");  // Error: conversión implícita no permitida
    imprimirCadena(Cadena("Mundo"));  // Correcto: conversión explícita

    return 0;
}
<---Ejemplo con Conversiones Result--->
<---Constructor Implícito--->
```cpp
class Impl {
public:
    Impl(int) {}
};

void f(Impl) {}

int main() {
    f(42);  // Correcto: conversión implícita permitida
    return 0;
}
<---Constructor Implícito Result--->
<---Constructor Explícito--->
```cpp
class Expl {
public:
    explicit Expl(int) {}
};

void f(Expl) {}

int main() {
    // f(42);  // Error: conversión implícita no permitida
    f(Expl(42));  // Correcto: conversión explícita
    return 0;
}
<---Constructor Explícito Result--->
<---Problema de la Copia Superficial--->
```cpp
class Cadena {
private:
    char* str;

public:
    // Constructor parametrizado
    Cadena(const char* s) {
        str = new char[strlen(s) + 1];
        strcpy(str, s);
    }

    // Destructor
    ~Cadena() {
        delete[] str;
    }

    // Constructor de copia por defecto (copia superficial)
    // Cadena(const Cadena& other) = default;

    // Método para mostrar la cadena
    void mostrar() const {
        cout << str << endl;
    }
};

int main() {
    Cadena c1("Hola");
    Cadena c2 = c1; // Copia superficial

    c1.mostrar();
    c2.mostrar();

    return 0;
}
<---Problema de la Copia Superficial Result--->
<---Solución con Constructor de Copia Profunda--->
```cpp
class Cadena {
private:
    char* str;

public:
    // Constructor parametrizado
    Cadena(const char* s) {
        str = new char[strlen(s) + 1];
        strcpy(str, s);
    }

    // Destructor
    ~Cadena() {
        delete[] str;
    }

    // Constructor de copia (copia profunda)
    Cadena(const Cadena& other) {
        str = new char[strlen(other.str) + 1];
        strcpy(str, other.str);
    }

    // Método para mostrar la cadena
    void mostrar() const {
        cout << str << endl;
    }
};

int main() {
    Cadena c1("Hola");
    Cadena c2 = c1; // Copia profunda

    c1.mostrar();
    c2.mostrar();

    return 0;
}
<---Solución con Constructor de Copia Profunda Result--->
<---Ejemplo Completo con la Regla de Tres--->
```cpp
class Recurso {
private:
    int* data;

public:
    // Constructor parametrizado
    Recurso(int valor) {
        data = new int(valor);
    }

    // Destructor
    ~Recurso() {
        delete data;
    }

    // Constructor de copia
    Recurso(const Recurso& other) {
        data = new int(*other.data);
    }

    // Operador de asignación de copia
    Recurso& operator=(const Recurso& other) {
        if (this != &other) {
            delete data;
            data = new int(*other.data);
        }
        return *this;
    }

    // Método para mostrar el valor
    void mostrar() const {
        cout << "Valor: " << *data << endl;
    }
};

int main() {
    Recurso r1(10);
    Recurso r2 = r1; // Llamada al constructor de copia
    Recurso r3(20);
    r3 = r1; // Llamada al operador de asignación de copia

    r1.mostrar();
    r2.mostrar();
    r3.mostrar();

    return 0;
}
<---Ejemplo Completo con la Regla de Tres Result--->
