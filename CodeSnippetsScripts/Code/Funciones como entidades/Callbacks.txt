<---EXPLANATION--->
### Callbacks en C++

En programación, un **callback** es una función que se pasa como argumento a otra función, y que se espera que se ejecute en algún punto posterior. Los callbacks son fundamentales para la programación asíncrona, el manejo de eventos, y para proporcionar una forma de personalizar el comportamiento de las funciones.

En C++, los callbacks se pueden implementar de varias maneras: usando punteros a funciones, funtores (objetos de función), y expresiones lambda. Cada método tiene sus propias ventajas y desventajas.

#### Callbacks Usando Punteros a Funciones

##### Ejemplo Básico

```cpp
#include <iostream>

// Definición de un callback como un puntero a función
void miCallback(int valor) {
    std::cout << "Callback llamado con valor: " << valor << std::endl;
}

// Función que toma un callback
void llamarCallback(void (*callback)(int), int valor) {
    callback(valor);  // Llama al callback con el valor proporcionado
}

int main() {
    llamarCallback(miCallback, 42);  // Llama a miCallback con el valor 42
    return 0;
}
```

En este ejemplo:
- `miCallback` es una función que toma un `int` como argumento.
- `llamarCallback` toma un puntero a una función y un `int`, llamando a la función proporcionada con el `int` dado.

#### Callbacks Usando Funtores

Los funtores pueden ser utilizados como callbacks, ofreciendo la ventaja de poder mantener estado interno.

##### Ejemplo con Funtor

```cpp
#include <iostream>

// Definición de un functor
class MiFunctor {
public:
    void operator()(int valor) const {
        std::cout << "Functor llamado con valor: " << valor << std::endl;
    }
};

// Función que toma un callback como functor
template <typename Callback>
void llamarCallback(Callback callback, int valor) {
    callback(valor);  // Llama al callback con el valor proporcionado
}

int main() {
    MiFunctor functor;
    llamarCallback(functor, 42);  // Llama al functor con el valor 42
    return 0;
}
```

En este ejemplo:
- `MiFunctor` es un objeto de función (functor) que puede ser utilizado como un callback.
- `llamarCallback` es una función plantilla que acepta cualquier tipo de callback que soporte la sintaxis de llamada a función.

#### Callbacks Usando Lambdas

Las expresiones lambda proporcionan una forma concisa y flexible de definir callbacks en línea.

##### Ejemplo con Lambda

```cpp
#include <iostream>
#include <functional>  // Para std::function

// Función que toma un callback como std::function
void llamarCallback(const std::function<void(int)>& callback, int valor) {
    callback(valor);  // Llama al callback con el valor proporcionado
}

int main() {
    auto lambda = [](int valor) {
        std::cout << "Lambda llamada con valor: " << valor << std::endl;
    };

    llamarCallback(lambda, 42);  // Llama a la lambda con el valor 42
    return 0;
}
```

En este ejemplo:
- `lambda` es una expresión lambda que toma un `int` y lo imprime.
- `llamarCallback` toma un `std::function<void(int)>`, lo que permite pasar cualquier callable compatible, incluyendo lambdas, funtores, y punteros a funciones.

### Ventajas y Desventajas de Cada Método

#### Punteros a Funciones

- **Ventajas:**
  - Sencillez y eficiencia.
  - Adecuado para callbacks simples.

- **Desventajas:**
  - No pueden mantener estado.
  - Menos flexibles que otras alternativas.

#### Funtores

- **Ventajas:**
  - Pueden mantener estado interno.
  - Flexibles y reutilizables.

- **Desventajas:**
  - Más verbosos que las lambdas.
  - Pueden ser menos intuitivos de usar.

#### Lambdas

- **Ventajas:**
  - Concisos y fáciles de leer.
  - Pueden capturar variables del entorno.
  - Muy flexibles.

- **Desventajas:**
  - Puede ser menos eficiente que punteros a funciones simples debido a la necesidad de gestionar la captura de variables.

### Uso de `std::function` para Mayor Flexibilidad

`std::function` proporciona una forma unificada de manejar cualquier tipo de callable (punteros a funciones, funtores, lambdas) y es especialmente útil cuando se necesita almacenar y pasar callbacks flexibles.

##### Ejemplo con `std::function`

```cpp
#include <iostream>
#include <functional>
#include <vector>

// Función que toma un std::function
void ejecutarCallbacks(const std::vector<std::function<void(int)>>& callbacks, int valor) {
    for (const auto& callback : callbacks) {
        callback(valor);
    }
}

int main() {
    std::vector<std::function<void(int)>> callbacks;

    // Agregar un puntero a función
    callbacks.push_back([](int valor) {
        std::cout << "Lambda llamada con valor: " << valor << std::endl;
    });

    // Agregar un functor
    class MiFunctor {
    public:
        void operator()(int valor) const {
            std::cout << "Functor llamado con valor: " << valor << std::endl;
        }
    };
    callbacks.push_back(MiFunctor());

    ejecutarCallbacks(callbacks, 42);  // Ejecuta todos los callbacks con el valor 42

    return 0;
}
```

En este ejemplo:
- `ejecutarCallbacks` toma un `std::vector` de `std::function<void(int)>` y llama a cada callback en el vector.
- Se agregan tanto una lambda como un functor al vector de callbacks, demostrando la flexibilidad de `std::function`.

### Conclusión

Los callbacks en C++ son una herramienta poderosa para manejar eventos y programación asíncrona. Pueden ser implementados usando punteros a funciones, funtores y lambdas, cada uno con sus propias ventajas y desventajas. El uso de `std::function` proporciona una forma unificada y flexible de manejar diferentes tipos de callables, facilitando el diseño de interfaces y la gestión de eventos en aplicaciones complejas. Comprender y utilizar estos mecanismos permite escribir código C++ más flexible y eficiente.
<---FILES--->
Ejemplo Básico
Ejemplo Básico Result
Ejemplo con Funtor
Ejemplo con Funtor Result
Ejemplo con Lambda
Ejemplo con Lambda Result
Ejemplo con `std::function`
Ejemplo con `std::function` Result
<---Ejemplo Básico--->
```cpp
#include <iostream>

// Definición de un callback como un puntero a función
void miCallback(int valor) {
    std::cout << "Callback llamado con valor: " << valor << std::endl;
}

// Función que toma un callback
void llamarCallback(void (*callback)(int), int valor) {
    callback(valor);  // Llama al callback con el valor proporcionado
}

int main() {
    llamarCallback(miCallback, 42);  // Llama a miCallback con el valor 42
    return 0;
}
<---Ejemplo Básico Result--->
<---Ejemplo con Funtor--->
```cpp
#include <iostream>

// Definición de un functor
class MiFunctor {
public:
    void operator()(int valor) const {
        std::cout << "Functor llamado con valor: " << valor << std::endl;
    }
};

// Función que toma un callback como functor
template <typename Callback>
void llamarCallback(Callback callback, int valor) {
    callback(valor);  // Llama al callback con el valor proporcionado
}

int main() {
    MiFunctor functor;
    llamarCallback(functor, 42);  // Llama al functor con el valor 42
    return 0;
}
<---Ejemplo con Funtor Result--->
<---Ejemplo con Lambda--->
```cpp
#include <iostream>
#include <functional>  // Para std::function

// Función que toma un callback como std::function
void llamarCallback(const std::function<void(int)>& callback, int valor) {
    callback(valor);  // Llama al callback con el valor proporcionado
}

int main() {
    auto lambda = [](int valor) {
        std::cout << "Lambda llamada con valor: " << valor << std::endl;
    };

    llamarCallback(lambda, 42);  // Llama a la lambda con el valor 42
    return 0;
}
<---Ejemplo con Lambda Result--->
<---Ejemplo con `std::function`--->
```cpp
#include <iostream>
#include <functional>
#include <vector>

// Función que toma un std::function
void ejecutarCallbacks(const std::vector<std::function<void(int)>>& callbacks, int valor) {
    for (const auto& callback : callbacks) {
        callback(valor);
    }
}

int main() {
    std::vector<std::function<void(int)>> callbacks;

    // Agregar un puntero a función
    callbacks.push_back([](int valor) {
        std::cout << "Lambda llamada con valor: " << valor << std::endl;
    });

    // Agregar un functor
    class MiFunctor {
    public:
        void operator()(int valor) const {
            std::cout << "Functor llamado con valor: " << valor << std::endl;
        }
    };
    callbacks.push_back(MiFunctor());

    ejecutarCallbacks(callbacks, 42);  // Ejecuta todos los callbacks con el valor 42

    return 0;
}
<---Ejemplo con `std::function` Result--->
