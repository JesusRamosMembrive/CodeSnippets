<---EXPLANATION--->
### Funtores en C++

Un functor, también conocido como función objeto (function object), es cualquier objeto en C++ que puede ser llamado usando la sintaxis de llamada a función. Los funtores son útiles porque pueden almacenar estado y proporcionar una mayor flexibilidad y reutilización que las funciones ordinarias. En C++, los funtores se implementan sobrecargando el operador de llamada a función `operator()` en una clase.

#### Definición y Uso de Funtores

Un functor es una clase que sobrecarga el operador `()` para que sus instancias puedan ser usadas como funciones.

##### Ejemplo Básico de Functor

```cpp
#include <iostream>

// Definición de un functor
class Incrementador {
public:
    // Constructor que toma el incremento
    Incrementador(int inc) : incremento(inc) {}

    // Sobrecarga del operador ()
    int operator()(int x) const {
        return x + incremento;
    }

private:
    int incremento;
};

int main() {
    Incrementador inc5(5);  // Crea un functor que incrementa por 5
    int resultado = inc5(10);  // Llama al functor con el valor 10
    std::cout << "Resultado: " << resultado << std::endl;  // Muestra: Resultado: 15

    return 0;
}
```

En este ejemplo:
- `Incrementador` es un functor que incrementa un valor dado por una cantidad específica.
- El operador `()` está sobrecargado para realizar la operación de incremento.

#### Ventajas de Usar Funtores

1. **Estado Interno:** Pueden almacenar estado interno, lo que no es posible con las funciones normales.
2. **Mayor Flexibilidad:** Pueden ser usados en lugar de funciones como argumentos de otras funciones, especialmente en algoritmos de la biblioteca estándar.
3. **Reutilización:** Facilitan la reutilización del código, ya que los mismos funtores pueden ser usados en diferentes contextos.

#### Funtores con Parámetros de Plantilla

Los funtores también pueden ser plantillas, lo que permite su uso con diferentes tipos de datos.

##### Ejemplo de Functor Plantilla

```cpp
#include <iostream>

// Definición de un functor plantilla
template <typename T>
class Multiplicador {
public:
    // Constructor que toma el factor de multiplicación
    Multiplicador(T factor) : factor(factor) {}

    // Sobrecarga del operador ()
    T operator()(T x) const {
        return x * factor;
    }

private:
    T factor;
};

int main() {
    Multiplicador<int> multiplicarPor2(2);  // Crea un functor que multiplica por 2
    std::cout << "Resultado: " << multiplicarPor2(10) << std::endl;  // Muestra: Resultado: 20

    Multiplicador<double> multiplicarPor3(3.0);  // Crea un functor que multiplica por 3.0
    std::cout << "Resultado: " << multiplicarPor3(1.5) << std::endl;  // Muestra: Resultado: 4.5

    return 0;
}
```

En este ejemplo:
- `Multiplicador` es un functor plantilla que puede multiplicar valores de diferentes tipos por un factor específico.

#### Funtores en la Biblioteca Estándar

La biblioteca estándar de C++ incluye varios funtores predefinidos en el encabezado `<functional>`, como `std::plus`, `std::minus`, `std::multiplies`, etc.

##### Ejemplo con Funtores de la Biblioteca Estándar

```cpp
#include <iostream>
#include <functional>
#include <vector>
#include <algorithm>

int main() {
    std::vector<int> vec = {1, 2, 3, 4, 5};
    std::vector<int> resultado(vec.size());

    // Usar std::multiplies para multiplicar cada elemento por 2
    std::transform(vec.begin(), vec.end(), resultado.begin(), std::bind(std::multiplies<int>(), std::placeholders::_1, 2));

    for (int x : resultado) {
        std::cout << x << " ";  // Muestra: 2 4 6 8 10
    }
    std::cout << std::endl;

    return 0;
}
```

En este ejemplo:
- `std::multiplies<int>()` es un functor predefinido que multiplica dos números.
- `std::transform` utiliza este functor para multiplicar cada elemento del vector por 2.

### Conclusión

Los funtores en C++ proporcionan una forma flexible y potente de encapsular operaciones que se pueden llamar como funciones. Permiten almacenar estado interno, ser utilizados en algoritmos de la biblioteca estándar, y ofrecen una mayor reutilización del código. Además, los funtores pueden ser plantillas, lo que permite su uso con diferentes tipos de datos, y se integran bien con los funtores predefinidos en la biblioteca estándar. Comprender y utilizar funtores adecuadamente es esencial para aprovechar al máximo las capacidades de C++ en la programación orientada a objetos y genérica.
### Funtores con Lambdas en C++

Las expresiones lambda en C++ son una forma concisa y poderosa de crear funtores. Introducidas en C++11, las lambdas permiten definir funciones anónimas en línea que pueden capturar variables del ámbito circundante. Son especialmente útiles en algoritmos de la biblioteca estándar y en casos donde se necesitan funciones ligeras y rápidas.

#### Definición y Uso de Lambdas

Una lambda en C++ se define utilizando la siguiente sintaxis básica:

```cpp
[captures](parameters) -> return_type { body }
```

- **captures:** Especifica qué variables del ámbito circundante se capturan y cómo (por valor `[=]` o por referencia `[&]`).
- **parameters:** Lista de parámetros de la lambda (puede ser omitida si no hay parámetros).
- **return_type:** Tipo de retorno de la lambda (puede deducirse automáticamente y, por tanto, omitirse en la mayoría de los casos).
- **body:** El cuerpo de la lambda.

##### Ejemplo Básico de Lambda

```cpp
#include <iostream>

int main() {
    auto sumar = [](int a, int b) {
        return a + b;
    };

    std::cout << "Resultado: " << sumar(3, 4) << std::endl;  // Muestra: Resultado: 7

    return 0;
}
```

En este ejemplo:
- `sumar` es una lambda que toma dos enteros y devuelve su suma.

#### Captura de Variables en Lambdas

Las lambdas pueden capturar variables del ámbito circundante, lo que las hace muy flexibles.

##### Ejemplo de Captura por Valor y por Referencia

```cpp
#include <iostream>

int main() {
    int x = 10;
    int y = 20;

    auto capturarPorValor = [=]() {
        return x + y;
    };

    auto capturarPorReferencia = [&]() {
        x *= 2;
        y *= 2;
    };

    std::cout << "Suma por valor: " << capturarPorValor() << std::endl;  // Muestra: Suma por valor: 30
    capturarPorReferencia();
    std::cout << "x: " << x << ", y: " << y << std::endl;  // Muestra: x: 20, y: 40

    return 0;
}
```

En este ejemplo:
- `capturarPorValor` captura `x` y `y` por valor.
- `capturarPorReferencia` captura `x` y `y` por referencia, permitiendo modificarlos.

#### Uso de Lambdas en Algoritmos de la Biblioteca Estándar

Las lambdas son especialmente útiles en combinación con algoritmos de la biblioteca estándar como `std::sort`, `std::for_each`, `std::transform`, etc.

##### Ejemplo con `std::sort`

```cpp
#include <iostream>
#include <vector>
#include <algorithm>

int main() {
    std::vector<int> vec = {5, 2, 8, 1, 3};

    std::sort(vec.begin(), vec.end(), [](int a, int b) {
        return a < b;
    });

    for (int x : vec) {
        std::cout << x << " ";  // Muestra: 1 2 3 5 8
    }
    std::cout << std::endl;

    return 0;
}
```

En este ejemplo:
- Se utiliza una lambda como comparador en `std::sort` para ordenar el vector en orden ascendente.

##### Ejemplo con `std::for_each`

```cpp
#include <iostream>
#include <vector>
#include <algorithm>

int main() {
    std::vector<int> vec = {1, 2, 3, 4, 5};

    std::for_each(vec.begin(), vec.end(), [](int& n) {
        n *= 2;
    });

    for (int x : vec) {
        std::cout << x << " ";  // Muestra: 2 4 6 8 10
    }
    std::cout << std::endl;

    return 0;
}
```

En este ejemplo:
- Se utiliza una lambda para multiplicar cada elemento del vector por 2 en `std::for_each`.

#### Lambdas con Parámetros de Plantilla

Las lambdas pueden ser genéricas, utilizando la sintaxis de plantillas.

##### Ejemplo de Lambda Genérica

```cpp
#include <iostream>
#include <vector>
#include <algorithm>

int main() {
    auto multiplicar = [](auto a, auto b) {
        return a * b;
    };

    std::cout << "Multiplicar enteros: " << multiplicar(3, 4) << std::endl;  // Muestra: Multiplicar enteros: 12
    std::cout << "Multiplicar doubles: " << multiplicar(3.5, 2.0) << std::endl;  // Muestra: Multiplicar doubles: 7.0

    return 0;
}
```

En este ejemplo:
- `multiplicar` es una lambda genérica que puede multiplicar valores de cualquier tipo compatible.

### Conclusión

Las lambdas en C++ son una herramienta poderosa para crear funtores ligeros y flexibles. Permiten definir funciones anónimas en línea, capturar variables del ámbito circundante y utilizarlas en algoritmos de la biblioteca estándar. Además, las lambdas pueden ser genéricas, lo que aumenta su versatilidad. Comprender y utilizar lambdas adecuadamente es esencial para aprovechar al máximo las capacidades de C++ moderno, facilitando la escritura de código más limpio y eficiente.
<---FILES--->
Ejemplo Básico de Functor
Ejemplo Básico de Functor Result
Ejemplo de Functor Plantilla
Ejemplo de Functor Plantilla Result
Ejemplo con Funtores de la Biblioteca Estándar
Ejemplo con Funtores de la Biblioteca Estándar Result
Ejemplo Básico de Functor
Ejemplo Básico de Functor Result
Ejemplo de Functor Plantilla
Ejemplo de Functor Plantilla Result
Ejemplo con Funtores de la Biblioteca Estándar
Ejemplo con Funtores de la Biblioteca Estándar Result
Ejemplo Básico de Lambda
Ejemplo Básico de Lambda Result
Ejemplo de Captura por Valor y por Referencia
Ejemplo de Captura por Valor y por Referencia Result
Ejemplo con `std::sort`
Ejemplo con `std::sort` Result
Ejemplo con `std::for_each`
Ejemplo con `std::for_each` Result
Ejemplo de Lambda Genérica
Ejemplo de Lambda Genérica Result
<---Ejemplo Básico de Functor--->
```cpp
#include <iostream>

// Definición de un functor
class Incrementador {
public:
    // Constructor que toma el incremento
    Incrementador(int inc) : incremento(inc) {}

    // Sobrecarga del operador ()
    int operator()(int x) const {
        return x + incremento;
    }

private:
    int incremento;
};

int main() {
    Incrementador inc5(5);  // Crea un functor que incrementa por 5
    int resultado = inc5(10);  // Llama al functor con el valor 10
    std::cout << "Resultado: " << resultado << std::endl;  // Muestra: Resultado: 15

    return 0;
}
<---Ejemplo Básico de Functor Result--->
<---Ejemplo de Functor Plantilla--->
```cpp
#include <iostream>

// Definición de un functor plantilla
template <typename T>
class Multiplicador {
public:
    // Constructor que toma el factor de multiplicación
    Multiplicador(T factor) : factor(factor) {}

    // Sobrecarga del operador ()
    T operator()(T x) const {
        return x * factor;
    }

private:
    T factor;
};

int main() {
    Multiplicador<int> multiplicarPor2(2);  // Crea un functor que multiplica por 2
    std::cout << "Resultado: " << multiplicarPor2(10) << std::endl;  // Muestra: Resultado: 20

    Multiplicador<double> multiplicarPor3(3.0);  // Crea un functor que multiplica por 3.0
    std::cout << "Resultado: " << multiplicarPor3(1.5) << std::endl;  // Muestra: Resultado: 4.5

    return 0;
}
<---Ejemplo de Functor Plantilla Result--->
<---Ejemplo con Funtores de la Biblioteca Estándar--->
```cpp
#include <iostream>
#include <functional>
#include <vector>
#include <algorithm>

int main() {
    std::vector<int> vec = {1, 2, 3, 4, 5};
    std::vector<int> resultado(vec.size());

    // Usar std::multiplies para multiplicar cada elemento por 2
    std::transform(vec.begin(), vec.end(), resultado.begin(), std::bind(std::multiplies<int>(), std::placeholders::_1, 2));

    for (int x : resultado) {
        std::cout << x << " ";  // Muestra: 2 4 6 8 10
    }
    std::cout << std::endl;

    return 0;
}
<---Ejemplo con Funtores de la Biblioteca Estándar Result--->
<---Ejemplo Básico de Functor--->
```cpp
#include <iostream>

// Definición de un functor
class Incrementador {
public:
    // Constructor que toma el incremento
    Incrementador(int inc) : incremento(inc) {}

    // Sobrecarga del operador ()
    int operator()(int x) const {
        return x + incremento;
    }

private:
    int incremento;
};

int main() {
    Incrementador inc5(5);  // Crea un functor que incrementa por 5
    int resultado = inc5(10);  // Llama al functor con el valor 10
    std::cout << "Resultado: " << resultado << std::endl;  // Muestra: Resultado: 15

    return 0;
}
<---Ejemplo Básico de Functor Result--->
<---Ejemplo de Functor Plantilla--->
```cpp
#include <iostream>

// Definición de un functor plantilla
template <typename T>
class Multiplicador {
public:
    // Constructor que toma el factor de multiplicación
    Multiplicador(T factor) : factor(factor) {}

    // Sobrecarga del operador ()
    T operator()(T x) const {
        return x * factor;
    }

private:
    T factor;
};

int main() {
    Multiplicador<int> multiplicarPor2(2);  // Crea un functor que multiplica por 2
    std::cout << "Resultado: " << multiplicarPor2(10) << std::endl;  // Muestra: Resultado: 20

    Multiplicador<double> multiplicarPor3(3.0);  // Crea un functor que multiplica por 3.0
    std::cout << "Resultado: " << multiplicarPor3(1.5) << std::endl;  // Muestra: Resultado: 4.5

    return 0;
}
<---Ejemplo de Functor Plantilla Result--->
<---Ejemplo con Funtores de la Biblioteca Estándar--->
```cpp
#include <iostream>
#include <functional>
#include <vector>
#include <algorithm>

int main() {
    std::vector<int> vec = {1, 2, 3, 4, 5};
    std::vector<int> resultado(vec.size());

    // Usar std::multiplies para multiplicar cada elemento por 2
    std::transform(vec.begin(), vec.end(), resultado.begin(), std::bind(std::multiplies<int>(), std::placeholders::_1, 2));

    for (int x : resultado) {
        std::cout << x << " ";  // Muestra: 2 4 6 8 10
    }
    std::cout << std::endl;

    return 0;
}
<---Ejemplo con Funtores de la Biblioteca Estándar Result--->
<---Ejemplo Básico de Lambda--->
```cpp
#include <iostream>

int main() {
    auto sumar = [](int a, int b) {
        return a + b;
    };

    std::cout << "Resultado: " << sumar(3, 4) << std::endl;  // Muestra: Resultado: 7

    return 0;
}
<---Ejemplo Básico de Lambda Result--->
<---Ejemplo de Captura por Valor y por Referencia--->
```cpp
#include <iostream>

int main() {
    int x = 10;
    int y = 20;

    auto capturarPorValor = [=]() {
        return x + y;
    };

    auto capturarPorReferencia = [&]() {
        x *= 2;
        y *= 2;
    };

    std::cout << "Suma por valor: " << capturarPorValor() << std::endl;  // Muestra: Suma por valor: 30
    capturarPorReferencia();
    std::cout << "x: " << x << ", y: " << y << std::endl;  // Muestra: x: 20, y: 40

    return 0;
}
<---Ejemplo de Captura por Valor y por Referencia Result--->
<---Ejemplo con `std::sort`--->
```cpp
#include <iostream>
#include <vector>
#include <algorithm>

int main() {
    std::vector<int> vec = {5, 2, 8, 1, 3};

    std::sort(vec.begin(), vec.end(), [](int a, int b) {
        return a < b;
    });

    for (int x : vec) {
        std::cout << x << " ";  // Muestra: 1 2 3 5 8
    }
    std::cout << std::endl;

    return 0;
}
<---Ejemplo con `std::sort` Result--->
<---Ejemplo con `std::for_each`--->
```cpp
#include <iostream>
#include <vector>
#include <algorithm>

int main() {
    std::vector<int> vec = {1, 2, 3, 4, 5};

    std::for_each(vec.begin(), vec.end(), [](int& n) {
        n *= 2;
    });

    for (int x : vec) {
        std::cout << x << " ";  // Muestra: 2 4 6 8 10
    }
    std::cout << std::endl;

    return 0;
}
<---Ejemplo con `std::for_each` Result--->
<---Ejemplo de Lambda Genérica--->
```cpp
#include <iostream>
#include <vector>
#include <algorithm>

int main() {
    auto multiplicar = [](auto a, auto b) {
        return a * b;
    };

    std::cout << "Multiplicar enteros: " << multiplicar(3, 4) << std::endl;  // Muestra: Multiplicar enteros: 12
    std::cout << "Multiplicar doubles: " << multiplicar(3.5, 2.0) << std::endl;  // Muestra: Multiplicar doubles: 7.0

    return 0;
}
<---Ejemplo de Lambda Genérica Result--->
