<---EXPLANATION--->
### Estructuras de Datos: Listas y Colas en C++

Las listas y las colas son estructuras de datos fundamentales que permiten almacenar y manipular colecciones de elementos de manera eficiente. En C++, estas estructuras se implementan comúnmente utilizando la biblioteca estándar (STL).

#### Listas

Una lista es una estructura de datos lineal que permite la inserción y eliminación de elementos en cualquier punto de la secuencia. La STL proporciona la clase `std::list` para manejar listas doblemente enlazadas.

##### Características de `std::list`

- **Doble Enlazado:** Cada elemento tiene un puntero al elemento anterior y al siguiente.
- **Inserción/Eiminación Eficiente:** Las operaciones de inserción y eliminación en cualquier posición son eficientes (O(1)).
- **Acceso Secuencial:** El acceso a elementos es secuencial, lo que significa que encontrar un elemento específico es O(n).

##### Ejemplo de Uso de `std::list`

```cpp
#include <iostream>
#include <list>
using namespace std;

int main() {
    // Declaración e inicialización de una lista
    list<int> miLista = {10, 20, 30, 40};

    // Inserción de elementos
    miLista.push_back(50);  // Añade al final
    miLista.push_front(5);  // Añade al inicio

    // Iteración y acceso a los elementos
    for (int elemento : miLista) {
        cout << elemento << " ";
    }
    cout << endl;

    // Eliminación de elementos
    miLista.pop_back();  // Elimina el último elemento
    miLista.pop_front(); // Elimina el primer elemento

    // Iteración y acceso a los elementos después de la eliminación
    for (int elemento : miLista) {
        cout << elemento << " ";
    }
    cout << endl;

    return 0;
}
```

### Operaciones Comunes en `std::list`

- **`push_back(valor)`**: Añade un elemento al final de la lista.
- **`push_front(valor)`**: Añade un elemento al inicio de la lista.
- **`pop_back()`**: Elimina el último elemento de la lista.
- **`pop_front()`**: Elimina el primer elemento de la lista.
- **`insert(it, valor)`**: Inserta un elemento en la posición indicada por el iterador `it`.
- **`erase(it)`**: Elimina el elemento en la posición indicada por el iterador `it`.
- **`size()`**: Devuelve el número de elementos en la lista.

### Colas

Una cola es una estructura de datos lineal que sigue el principio FIFO (First In, First Out), donde el primer elemento en entrar es el primero en salir. La STL proporciona la clase `std::queue` para manejar colas.

##### Características de `std::queue`

- **FIFO:** Los elementos se insertan por un extremo (trasero) y se eliminan por el otro extremo (frontal).
- **Acceso Restricto:** Solo se puede acceder al primer y al último elemento.

##### Ejemplo de Uso de `std::queue`

```cpp
#include <iostream>
#include <queue>
using namespace std;

int main() {
    // Declaración e inicialización de una cola
    queue<int> miCola;

    // Inserción de elementos
    miCola.push(10);
    miCola.push(20);
    miCola.push(30);

    // Acceso al primer y último elemento
    cout << "Frente: " << miCola.front() << endl;
    cout << "Final: " << miCola.back() << endl;

    // Eliminación de elementos
    miCola.pop(); // Elimina el primer elemento (10)

    // Acceso después de la eliminación
    cout << "Frente después de pop: " << miCola.front() << endl;

    return 0;
}
```

### Operaciones Comunes en `std::queue`

- **`push(valor)`**: Añade un elemento al final de la cola.
- **`pop()`**: Elimina el primer elemento de la cola.
- **`front()`**: Devuelve una referencia al primer elemento de la cola.
- **`back()`**: Devuelve una referencia al último elemento de la cola.
- **`size()`**: Devuelve el número de elementos en la cola.
- **`empty()`**: Devuelve `true` si la cola está vacía.

### Ejemplo Completo

A continuación, un ejemplo que combina el uso de listas y colas para ilustrar sus diferencias y usos comunes:

```cpp
#include <iostream>
#include <list>
#include <queue>
using namespace std;

int main() {
    // Uso de std::list
    list<int> miLista = {1, 2, 3, 4, 5};
    miLista.push_back(6);
    miLista.push_front(0);

    cout << "Lista: ";
    for (int elemento : miLista) {
        cout << elemento << " ";
    }
    cout << endl;

    miLista.pop_back();
    miLista.pop_front();

    cout << "Lista después de pop: ";
    for (int elemento : miLista) {
        cout << elemento << " ";
    }
    cout << endl;

    // Uso de std::queue
    queue<int> miCola;
    miCola.push(10);
    miCola.push(20);
    miCola.push(30);

    cout << "Cola frente: " << miCola.front() << ", final: " << miCola.back() << endl;
    miCola.pop();
    cout << "Cola frente después de pop: " << miCola.front() << endl;

    return 0;
}
```

### Conclusión

Las listas y las colas son estructuras de datos esenciales en C++ que proporcionan flexibilidad y eficiencia para diferentes tipos de operaciones. Las listas permiten inserciones y eliminaciones eficientes en cualquier posición, mientras que las colas facilitan un acceso ordenado y secuencial siguiendo el principio FIFO. Conocer cómo y cuándo usar cada estructura de datos es fundamental para escribir programas eficientes y bien estructurados en C++.
### Estructuras de Datos: Pilas y Conjuntos en C++

Las pilas y los conjuntos son estructuras de datos fundamentales en C++ que permiten almacenar y manipular colecciones de elementos de manera específica. En C++, estas estructuras se implementan comúnmente utilizando la biblioteca estándar (STL).

#### Pilas

Una pila (stack) es una estructura de datos lineal que sigue el principio LIFO (Last In, First Out), donde el último elemento en entrar es el primero en salir. La STL proporciona la clase `std::stack` para manejar pilas.

##### Características de `std::stack`

- **LIFO:** Los elementos se insertan y se eliminan desde el mismo extremo.
- **Acceso Restringido:** Solo se puede acceder al elemento en la parte superior de la pila.

##### Ejemplo de Uso de `std::stack`

```cpp
#include <iostream>
#include <stack>
using namespace std;

int main() {
    // Declaración e inicialización de una pila
    stack<int> miPila;

    // Inserción de elementos
    miPila.push(10);
    miPila.push(20);
    miPila.push(30);

    // Acceso al elemento superior
    cout << "Elemento superior: " << miPila.top() << endl;

    // Eliminación de elementos
    miPila.pop(); // Elimina el elemento superior (30)

    // Acceso después de la eliminación
    cout << "Elemento superior después de pop: " << miPila.top() << endl;

    return 0;
}
```

### Operaciones Comunes en `std::stack`

- **`push(valor)`**: Añade un elemento al tope de la pila.
- **`pop()`**: Elimina el elemento en el tope de la pila.
- **`top()`**: Devuelve una referencia al elemento en el tope de la pila.
- **`size()`**: Devuelve el número de elementos en la pila.
- **`empty()`**: Devuelve `true` si la pila está vacía.

### Conjuntos

Un conjunto (set) es una estructura de datos que almacena elementos únicos en orden. La STL proporciona la clase `std::set` para manejar conjuntos.

##### Características de `std::set`

- **Elementos Únicos:** No se permiten duplicados.
- **Ordenado:** Los elementos se almacenan en orden ascendente.
- **Operaciones Eficientes:** Inserción, eliminación y búsqueda en O(log n).

##### Ejemplo de Uso de `std::set`

```cpp
#include <iostream>
#include <set>
using namespace std;

int main() {
    // Declaración e inicialización de un conjunto
    set<int> miConjunto = {30, 10, 20, 40};

    // Inserción de elementos
    miConjunto.insert(50);
    miConjunto.insert(20); // No se añade ya que 20 ya existe

    // Iteración y acceso a los elementos
    cout << "Conjunto: ";
    for (int elemento : miConjunto) {
        cout << elemento << " ";
    }
    cout << endl;

    // Eliminación de un elemento
    miConjunto.erase(30);

    // Iteración y acceso a los elementos después de la eliminación
    cout << "Conjunto después de erase: ";
    for (int elemento : miConjunto) {
        cout << elemento << " ";
    }
    cout << endl;

    return 0;
}
```

### Operaciones Comunes en `std::set`

- **`insert(valor)`**: Añade un elemento al conjunto.
- **`erase(valor)`**: Elimina un elemento del conjunto.
- **`find(valor)`**: Devuelve un iterador al elemento si se encuentra, o `end()` si no.
- **`size()`**: Devuelve el número de elementos en el conjunto.
- **`empty()`**: Devuelve `true` si el conjunto está vacío.

### Comparación de Pilas y Conjuntos

| Característica     | Pila (`std::stack`)                  | Conjunto (`std::set`)                 |
|--------------------|--------------------------------------|---------------------------------------|
| Orden              | LIFO (Last In, First Out)            | Orden ascendente                      |
| Duplicados         | Permitidos                           | No permitidos                         |
| Acceso a Elementos | Solo al elemento superior            | A cualquier elemento usando iteradores|
| Complejidad        | O(1) para `push` y `pop`             | O(log n) para `insert`, `erase` y `find` |

### Ejemplo Completo

A continuación, un ejemplo que utiliza tanto pilas como conjuntos para ilustrar sus diferencias y usos comunes:

```cpp
#include <iostream>
#include <stack>
#include <set>
using namespace std;

int main() {
    // Uso de std::stack
    stack<int> miPila;
    miPila.push(10);
    miPila.push(20);
    miPila.push(30);
    cout << "Pila elemento superior: " << miPila.top() << endl;
    miPila.pop();
    cout << "Pila elemento superior después de pop: " << miPila.top() << endl;

    // Uso de std::set
    set<int> miConjunto = {30, 10, 20, 40};
    miConjunto.insert(50);
    cout << "Conjunto: ";
    for (int elemento : miConjunto) {
        cout << elemento << " ";
    }
    cout << endl;
    miConjunto.erase(30);
    cout << "Conjunto después de erase: ";
    for (int elemento : miConjunto) {
        cout << elemento << " ";
    }
    cout << endl;

    return 0;
}
```

### Conclusión

Las pilas y los conjuntos son estructuras de datos esenciales en C++ que proporcionan soluciones eficientes para diferentes tipos de problemas. Las pilas siguen el principio LIFO y son útiles para tareas como la evaluación de expresiones y el seguimiento de contexto. Los conjuntos garantizan la unicidad de los elementos y mantienen el orden, siendo útiles para tareas de búsqueda y eliminación de duplicados. Comprender cómo y cuándo usar estas estructuras de datos es fundamental para escribir programas eficientes y bien estructurados en C++.
<---FILES--->
Características de `std::list`
Características de `std::list` Result
Ejemplo de Uso de `std::list`
Ejemplo de Uso de `std::list` Result
Características de `std::queue`
Características de `std::queue` Result
Ejemplo de Uso de `std::queue`
Ejemplo de Uso de `std::queue` Result
Características de `std::list`
Características de `std::list` Result
Ejemplo de Uso de `std::list`
Ejemplo de Uso de `std::list` Result
Características de `std::queue`
Características de `std::queue` Result
Ejemplo de Uso de `std::queue`
Ejemplo de Uso de `std::queue` Result
Características de `std::stack`
Características de `std::stack` Result
Ejemplo de Uso de `std::stack`
Ejemplo de Uso de `std::stack` Result
Características de `std::set`
Características de `std::set` Result
Ejemplo de Uso de `std::set`
Ejemplo de Uso de `std::set` Result
<---Características de `std::list`--->
<---Características de `std::list` Result--->
<---Ejemplo de Uso de `std::list`--->
```cpp
#include <iostream>
#include <list>
using namespace std;

int main() {
    // Declaración e inicialización de una lista
    list<int> miLista = {10, 20, 30, 40};

    // Inserción de elementos
    miLista.push_back(50);  // Añade al final
    miLista.push_front(5);  // Añade al inicio

    // Iteración y acceso a los elementos
    for (int elemento : miLista) {
        cout << elemento << " ";
    }
    cout << endl;

    // Eliminación de elementos
    miLista.pop_back();  // Elimina el último elemento
    miLista.pop_front(); // Elimina el primer elemento

    // Iteración y acceso a los elementos después de la eliminación
    for (int elemento : miLista) {
        cout << elemento << " ";
    }
    cout << endl;

    return 0;
}
<---Ejemplo de Uso de `std::list` Result--->
<---Características de `std::queue`--->
<---Características de `std::queue` Result--->
<---Ejemplo de Uso de `std::queue`--->
```cpp
#include <iostream>
#include <queue>
using namespace std;

int main() {
    // Declaración e inicialización de una cola
    queue<int> miCola;

    // Inserción de elementos
    miCola.push(10);
    miCola.push(20);
    miCola.push(30);

    // Acceso al primer y último elemento
    cout << "Frente: " << miCola.front() << endl;
    cout << "Final: " << miCola.back() << endl;

    // Eliminación de elementos
    miCola.pop(); // Elimina el primer elemento (10)

    // Acceso después de la eliminación
    cout << "Frente después de pop: " << miCola.front() << endl;

    return 0;
}
```cpp
#include <iostream>
#include <list>
#include <queue>
using namespace std;

int main() {
    // Uso de std::list
    list<int> miLista = {1, 2, 3, 4, 5};
    miLista.push_back(6);
    miLista.push_front(0);

    cout << "Lista: ";
    for (int elemento : miLista) {
        cout << elemento << " ";
    }
    cout << endl;

    miLista.pop_back();
    miLista.pop_front();

    cout << "Lista después de pop: ";
    for (int elemento : miLista) {
        cout << elemento << " ";
    }
    cout << endl;

    // Uso de std::queue
    queue<int> miCola;
    miCola.push(10);
    miCola.push(20);
    miCola.push(30);

    cout << "Cola frente: " << miCola.front() << ", final: " << miCola.back() << endl;
    miCola.pop();
    cout << "Cola frente después de pop: " << miCola.front() << endl;

    return 0;
}
<---Ejemplo de Uso de `std::queue` Result--->
<---Características de `std::list`--->
<---Características de `std::list` Result--->
<---Ejemplo de Uso de `std::list`--->
```cpp
#include <iostream>
#include <list>
using namespace std;

int main() {
    // Declaración e inicialización de una lista
    list<int> miLista = {10, 20, 30, 40};

    // Inserción de elementos
    miLista.push_back(50);  // Añade al final
    miLista.push_front(5);  // Añade al inicio

    // Iteración y acceso a los elementos
    for (int elemento : miLista) {
        cout << elemento << " ";
    }
    cout << endl;

    // Eliminación de elementos
    miLista.pop_back();  // Elimina el último elemento
    miLista.pop_front(); // Elimina el primer elemento

    // Iteración y acceso a los elementos después de la eliminación
    for (int elemento : miLista) {
        cout << elemento << " ";
    }
    cout << endl;

    return 0;
}
<---Ejemplo de Uso de `std::list` Result--->
<---Características de `std::queue`--->
<---Características de `std::queue` Result--->
<---Ejemplo de Uso de `std::queue`--->
```cpp
#include <iostream>
#include <queue>
using namespace std;

int main() {
    // Declaración e inicialización de una cola
    queue<int> miCola;

    // Inserción de elementos
    miCola.push(10);
    miCola.push(20);
    miCola.push(30);

    // Acceso al primer y último elemento
    cout << "Frente: " << miCola.front() << endl;
    cout << "Final: " << miCola.back() << endl;

    // Eliminación de elementos
    miCola.pop(); // Elimina el primer elemento (10)

    // Acceso después de la eliminación
    cout << "Frente después de pop: " << miCola.front() << endl;

    return 0;
}
```cpp
#include <iostream>
#include <list>
#include <queue>
using namespace std;

int main() {
    // Uso de std::list
    list<int> miLista = {1, 2, 3, 4, 5};
    miLista.push_back(6);
    miLista.push_front(0);

    cout << "Lista: ";
    for (int elemento : miLista) {
        cout << elemento << " ";
    }
    cout << endl;

    miLista.pop_back();
    miLista.pop_front();

    cout << "Lista después de pop: ";
    for (int elemento : miLista) {
        cout << elemento << " ";
    }
    cout << endl;

    // Uso de std::queue
    queue<int> miCola;
    miCola.push(10);
    miCola.push(20);
    miCola.push(30);

    cout << "Cola frente: " << miCola.front() << ", final: " << miCola.back() << endl;
    miCola.pop();
    cout << "Cola frente después de pop: " << miCola.front() << endl;

    return 0;
}
<---Ejemplo de Uso de `std::queue` Result--->
<---Características de `std::stack`--->
<---Características de `std::stack` Result--->
<---Ejemplo de Uso de `std::stack`--->
```cpp
#include <iostream>
#include <stack>
using namespace std;

int main() {
    // Declaración e inicialización de una pila
    stack<int> miPila;

    // Inserción de elementos
    miPila.push(10);
    miPila.push(20);
    miPila.push(30);

    // Acceso al elemento superior
    cout << "Elemento superior: " << miPila.top() << endl;

    // Eliminación de elementos
    miPila.pop(); // Elimina el elemento superior (30)

    // Acceso después de la eliminación
    cout << "Elemento superior después de pop: " << miPila.top() << endl;

    return 0;
}
<---Ejemplo de Uso de `std::stack` Result--->
<---Características de `std::set`--->
<---Características de `std::set` Result--->
<---Ejemplo de Uso de `std::set`--->
```cpp
#include <iostream>
#include <set>
using namespace std;

int main() {
    // Declaración e inicialización de un conjunto
    set<int> miConjunto = {30, 10, 20, 40};

    // Inserción de elementos
    miConjunto.insert(50);
    miConjunto.insert(20); // No se añade ya que 20 ya existe

    // Iteración y acceso a los elementos
    cout << "Conjunto: ";
    for (int elemento : miConjunto) {
        cout << elemento << " ";
    }
    cout << endl;

    // Eliminación de un elemento
    miConjunto.erase(30);

    // Iteración y acceso a los elementos después de la eliminación
    cout << "Conjunto después de erase: ";
    for (int elemento : miConjunto) {
        cout << elemento << " ";
    }
    cout << endl;

    return 0;
}
```cpp
#include <iostream>
#include <stack>
#include <set>
using namespace std;

int main() {
    // Uso de std::stack
    stack<int> miPila;
    miPila.push(10);
    miPila.push(20);
    miPila.push(30);
    cout << "Pila elemento superior: " << miPila.top() << endl;
    miPila.pop();
    cout << "Pila elemento superior después de pop: " << miPila.top() << endl;

    // Uso de std::set
    set<int> miConjunto = {30, 10, 20, 40};
    miConjunto.insert(50);
    cout << "Conjunto: ";
    for (int elemento : miConjunto) {
        cout << elemento << " ";
    }
    cout << endl;
    miConjunto.erase(30);
    cout << "Conjunto después de erase: ";
    for (int elemento : miConjunto) {
        cout << elemento << " ";
    }
    cout << endl;

    return 0;
}
<---Ejemplo de Uso de `std::set` Result--->
