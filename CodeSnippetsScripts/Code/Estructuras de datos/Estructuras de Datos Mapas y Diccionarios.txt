<---EXPLANATION--->
### Estructuras de Datos: Listas y Colas en C++

Las listas y las colas son estructuras de datos fundamentales que permiten almacenar y manipular colecciones de elementos de manera eficiente. En C++, estas estructuras se implementan comúnmente utilizando la biblioteca estándar (STL).

#### Listas

Una lista es una estructura de datos lineal que permite la inserción y eliminación de elementos en cualquier punto de la secuencia. La STL proporciona la clase `std::list` para manejar listas doblemente enlazadas.

##### Características de `std::list`

- **Doble Enlazado:** Cada elemento tiene un puntero al elemento anterior y al siguiente.
- **Inserción/Eiminación Eficiente:** Las operaciones de inserción y eliminación en cualquier posición son eficientes (O(1)).
- **Acceso Secuencial:** El acceso a elementos es secuencial, lo que significa que encontrar un elemento específico es O(n).

##### Ejemplo de Uso de `std::list`

```cpp
#include <iostream>
#include <list>
using namespace std;

int main() {
    // Declaración e inicialización de una lista
    list<int> miLista = {10, 20, 30, 40};

    // Inserción de elementos
    miLista.push_back(50);  // Añade al final
    miLista.push_front(5);  // Añade al inicio

    // Iteración y acceso a los elementos
    for (int elemento : miLista) {
        cout << elemento << " ";
    }
    cout << endl;

    // Eliminación de elementos
    miLista.pop_back();  // Elimina el último elemento
    miLista.pop_front(); // Elimina el primer elemento

    // Iteración y acceso a los elementos después de la eliminación
    for (int elemento : miLista) {
        cout << elemento << " ";
    }
    cout << endl;

    return 0;
}
```

### Operaciones Comunes en `std::list`

- **`push_back(valor)`**: Añade un elemento al final de la lista.
- **`push_front(valor)`**: Añade un elemento al inicio de la lista.
- **`pop_back()`**: Elimina el último elemento de la lista.
- **`pop_front()`**: Elimina el primer elemento de la lista.
- **`insert(it, valor)`**: Inserta un elemento en la posición indicada por el iterador `it`.
- **`erase(it)`**: Elimina el elemento en la posición indicada por el iterador `it`.
- **`size()`**: Devuelve el número de elementos en la lista.

### Colas

Una cola es una estructura de datos lineal que sigue el principio FIFO (First In, First Out), donde el primer elemento en entrar es el primero en salir. La STL proporciona la clase `std::queue` para manejar colas.

##### Características de `std::queue`

- **FIFO:** Los elementos se insertan por un extremo (trasero) y se eliminan por el otro extremo (frontal).
- **Acceso Restricto:** Solo se puede acceder al primer y al último elemento.

##### Ejemplo de Uso de `std::queue`

```cpp
#include <iostream>
#include <queue>
using namespace std;

int main() {
    // Declaración e inicialización de una cola
    queue<int> miCola;

    // Inserción de elementos
    miCola.push(10);
    miCola.push(20);
    miCola.push(30);

    // Acceso al primer y último elemento
    cout << "Frente: " << miCola.front() << endl;
    cout << "Final: " << miCola.back() << endl;

    // Eliminación de elementos
    miCola.pop(); // Elimina el primer elemento (10)

    // Acceso después de la eliminación
    cout << "Frente después de pop: " << miCola.front() << endl;

    return 0;
}
```

### Operaciones Comunes en `std::queue`

- **`push(valor)`**: Añade un elemento al final de la cola.
- **`pop()`**: Elimina el primer elemento de la cola.
- **`front()`**: Devuelve una referencia al primer elemento de la cola.
- **`back()`**: Devuelve una referencia al último elemento de la cola.
- **`size()`**: Devuelve el número de elementos en la cola.
- **`empty()`**: Devuelve `true` si la cola está vacía.

### Ejemplo Completo

A continuación, un ejemplo que combina el uso de listas y colas para ilustrar sus diferencias y usos comunes:

```cpp
#include <iostream>
#include <list>
#include <queue>
using namespace std;

int main() {
    // Uso de std::list
    list<int> miLista = {1, 2, 3, 4, 5};
    miLista.push_back(6);
    miLista.push_front(0);

    cout << "Lista: ";
    for (int elemento : miLista) {
        cout << elemento << " ";
    }
    cout << endl;

    miLista.pop_back();
    miLista.pop_front();

    cout << "Lista después de pop: ";
    for (int elemento : miLista) {
        cout << elemento << " ";
    }
    cout << endl;

    // Uso de std::queue
    queue<int> miCola;
    miCola.push(10);
    miCola.push(20);
    miCola.push(30);

    cout << "Cola frente: " << miCola.front() << ", final: " << miCola.back() << endl;
    miCola.pop();
    cout << "Cola frente después de pop: " << miCola.front() << endl;

    return 0;
}
```

### Conclusión

Las listas y las colas son estructuras de datos esenciales en C++ que proporcionan flexibilidad y eficiencia para diferentes tipos de operaciones. Las listas permiten inserciones y eliminaciones eficientes en cualquier posición, mientras que las colas facilitan un acceso ordenado y secuencial siguiendo el principio FIFO. Conocer cómo y cuándo usar cada estructura de datos es fundamental para escribir programas eficientes y bien estructurados en C++.
### Estructuras de Datos: Pilas y Conjuntos en C++

Las pilas y los conjuntos son estructuras de datos fundamentales en C++ que permiten almacenar y manipular colecciones de elementos de manera específica. En C++, estas estructuras se implementan comúnmente utilizando la biblioteca estándar (STL).

#### Pilas

Una pila (stack) es una estructura de datos lineal que sigue el principio LIFO (Last In, First Out), donde el último elemento en entrar es el primero en salir. La STL proporciona la clase `std::stack` para manejar pilas.

##### Características de `std::stack`

- **LIFO:** Los elementos se insertan y se eliminan desde el mismo extremo.
- **Acceso Restringido:** Solo se puede acceder al elemento en la parte superior de la pila.

##### Ejemplo de Uso de `std::stack`

```cpp
#include <iostream>
#include <stack>
using namespace std;

int main() {
    // Declaración e inicialización de una pila
    stack<int> miPila;

    // Inserción de elementos
    miPila.push(10);
    miPila.push(20);
    miPila.push(30);

    // Acceso al elemento superior
    cout << "Elemento superior: " << miPila.top() << endl;

    // Eliminación de elementos
    miPila.pop(); // Elimina el elemento superior (30)

    // Acceso después de la eliminación
    cout << "Elemento superior después de pop: " << miPila.top() << endl;

    return 0;
}
```

### Operaciones Comunes en `std::stack`

- **`push(valor)`**: Añade un elemento al tope de la pila.
- **`pop()`**: Elimina el elemento en el tope de la pila.
- **`top()`**: Devuelve una referencia al elemento en el tope de la pila.
- **`size()`**: Devuelve el número de elementos en la pila.
- **`empty()`**: Devuelve `true` si la pila está vacía.

### Conjuntos

Un conjunto (set) es una estructura de datos que almacena elementos únicos en orden. La STL proporciona la clase `std::set` para manejar conjuntos.

##### Características de `std::set`

- **Elementos Únicos:** No se permiten duplicados.
- **Ordenado:** Los elementos se almacenan en orden ascendente.
- **Operaciones Eficientes:** Inserción, eliminación y búsqueda en O(log n).

##### Ejemplo de Uso de `std::set`

```cpp
#include <iostream>
#include <set>
using namespace std;

int main() {
    // Declaración e inicialización de un conjunto
    set<int> miConjunto = {30, 10, 20, 40};

    // Inserción de elementos
    miConjunto.insert(50);
    miConjunto.insert(20); // No se añade ya que 20 ya existe

    // Iteración y acceso a los elementos
    cout << "Conjunto: ";
    for (int elemento : miConjunto) {
        cout << elemento << " ";
    }
    cout << endl;

    // Eliminación de un elemento
    miConjunto.erase(30);

    // Iteración y acceso a los elementos después de la eliminación
    cout << "Conjunto después de erase: ";
    for (int elemento : miConjunto) {
        cout << elemento << " ";
    }
    cout << endl;

    return 0;
}
```

### Operaciones Comunes en `std::set`

- **`insert(valor)`**: Añade un elemento al conjunto.
- **`erase(valor)`**: Elimina un elemento del conjunto.
- **`find(valor)`**: Devuelve un iterador al elemento si se encuentra, o `end()` si no.
- **`size()`**: Devuelve el número de elementos en el conjunto.
- **`empty()`**: Devuelve `true` si el conjunto está vacío.

### Comparación de Pilas y Conjuntos

| Característica     | Pila (`std::stack`)                  | Conjunto (`std::set`)                 |
|--------------------|--------------------------------------|---------------------------------------|
| Orden              | LIFO (Last In, First Out)            | Orden ascendente                      |
| Duplicados         | Permitidos                           | No permitidos                         |
| Acceso a Elementos | Solo al elemento superior            | A cualquier elemento usando iteradores|
| Complejidad        | O(1) para `push` y `pop`             | O(log n) para `insert`, `erase` y `find` |

### Ejemplo Completo

A continuación, un ejemplo que utiliza tanto pilas como conjuntos para ilustrar sus diferencias y usos comunes:

```cpp
#include <iostream>
#include <stack>
#include <set>
using namespace std;

int main() {
    // Uso de std::stack
    stack<int> miPila;
    miPila.push(10);
    miPila.push(20);
    miPila.push(30);
    cout << "Pila elemento superior: " << miPila.top() << endl;
    miPila.pop();
    cout << "Pila elemento superior después de pop: " << miPila.top() << endl;

    // Uso de std::set
    set<int> miConjunto = {30, 10, 20, 40};
    miConjunto.insert(50);
    cout << "Conjunto: ";
    for (int elemento : miConjunto) {
        cout << elemento << " ";
    }
    cout << endl;
    miConjunto.erase(30);
    cout << "Conjunto después de erase: ";
    for (int elemento : miConjunto) {
        cout << elemento << " ";
    }
    cout << endl;

    return 0;
}
```

### Conclusión

Las pilas y los conjuntos son estructuras de datos esenciales en C++ que proporcionan soluciones eficientes para diferentes tipos de problemas. Las pilas siguen el principio LIFO y son útiles para tareas como la evaluación de expresiones y el seguimiento de contexto. Los conjuntos garantizan la unicidad de los elementos y mantienen el orden, siendo útiles para tareas de búsqueda y eliminación de duplicados. Comprender cómo y cuándo usar estas estructuras de datos es fundamental para escribir programas eficientes y bien estructurados en C++.
### Estructuras de Datos: Mapas y Diccionarios en C++

En C++, los mapas y diccionarios son estructuras de datos que permiten almacenar pares de clave-valor, facilitando la búsqueda, inserción y eliminación de elementos basados en claves únicas. La biblioteca estándar de C++ (STL) proporciona dos tipos principales de mapas: `std::map` y `std::unordered_map`.

#### Mapas (`std::map`)

Un `std::map` es una estructura de datos asociativa ordenada que almacena elementos en pares de clave-valor, donde las claves son únicas y los elementos se almacenan en orden ascendente según las claves.

##### Características de `std::map`

- **Ordenado:** Los elementos se almacenan en orden ascendente de las claves.
- **Claves Únicas:** Cada clave en el mapa es única.
- **Acceso Logarítmico:** Las operaciones de búsqueda, inserción y eliminación tienen una complejidad O(log n) debido a su implementación basada en árboles binarios balanceados.

##### Ejemplo de Uso de `std::map`

```cpp
#include <iostream>
#include <map>
using namespace std;

int main() {
    // Declaración e inicialización de un mapa
    map<string, int> edades;
    edades["Juan"] = 30;
    edades["Maria"] = 25;
    edades["Pedro"] = 35;

    // Iteración y acceso a los elementos
    for (const auto& par : edades) {
        cout << par.first << " tiene " << par.second << " años." << endl;
    }

    // Acceso a un valor específico
    cout << "La edad de Maria es: " << edades["Maria"] << endl;

    // Modificación de un valor
    edades["Maria"] = 26;
    cout << "La nueva edad de Maria es: " << edades["Maria"] << endl;

    // Eliminación de un elemento
    edades.erase("Pedro");

    // Iteración después de la eliminación
    for (const auto& par : edades) {
        cout << par.first << " tiene " << par.second << " años." << endl;
    }

    return 0;
}
```

### Operaciones Comunes en `std::map`

- **`operator[]`**: Accede o inserta un valor asociado a una clave.
- **`insert(par)`**: Inserta un nuevo par clave-valor.
- **`erase(clave)`**: Elimina el par asociado a la clave.
- **`find(clave)`**: Devuelve un iterador al par si se encuentra, o `end()` si no.
- **`size()`**: Devuelve el número de elementos en el mapa.
- **`empty()`**: Devuelve `true` si el mapa está vacío.

#### Mapas No Ordenados (`std::unordered_map`)

Un `std::unordered_map` es una estructura de datos asociativa que almacena elementos en pares de clave-valor utilizando una tabla hash, lo que permite operaciones de búsqueda, inserción y eliminación en promedio constante O(1).

##### Características de `std::unordered_map`

- **No Ordenado:** Los elementos no se almacenan en un orden específico.
- **Claves Únicas:** Cada clave en el mapa es única.
- **Acceso Constante Promedio:** Las operaciones tienen una complejidad promedio O(1) debido a su implementación basada en tablas hash.

##### Ejemplo de Uso de `std::unordered_map`

```cpp
#include <iostream>
#include <unordered_map>
using namespace std;

int main() {
    // Declaración e inicialización de un unordered_map
    unordered_map<string, int> edades;
    edades["Juan"] = 30;
    edades["Maria"] = 25;
    edades["Pedro"] = 35;

    // Iteración y acceso a los elementos
    for (const auto& par : edades) {
        cout << par.first << " tiene " << par.second << " años." << endl;
    }

    // Acceso a un valor específico
    cout << "La edad de Maria es: " << edades["Maria"] << endl;

    // Modificación de un valor
    edades["Maria"] = 26;
    cout << "La nueva edad de Maria es: " << edades["Maria"] << endl;

    // Eliminación de un elemento
    edades.erase("Pedro");

    // Iteración después de la eliminación
    for (const auto& par : edades) {
        cout << par.first << " tiene " << par.second << " años." << endl;
    }

    return 0;
}
```

### Operaciones Comunes en `std::unordered_map`

- **`operator[]`**: Accede o inserta un valor asociado a una clave.
- **`insert(par)`**: Inserta un nuevo par clave-valor.
- **`erase(clave)`**: Elimina el par asociado a la clave.
- **`find(clave)`**: Devuelve un iterador al par si se encuentra, o `end()` si no.
- **`size()`**: Devuelve el número de elementos en el mapa.
- **`empty()`**: Devuelve `true` si el mapa está vacío.

### Comparación entre `std::map` y `std::unordered_map`

| Característica            | `std::map`                           | `std::unordered_map`                 |
|---------------------------|--------------------------------------|--------------------------------------|
| Orden                     | Ordenado por claves                  | No ordenado                          |
| Complejidad de Acceso     | O(log n)                             | Promedio O(1)                        |
| Estructura Subyacente     | Árbol binario balanceado (RB-tree)   | Tabla hash                           |
| Uso de Memoria            | Mayor eficiencia de memoria          | Puede utilizar más memoria           |
| Iteración                 | Ordenada por clave                   | No garantiza un orden específico     |

### Ejemplo Completo

A continuación, un ejemplo que utiliza tanto `std::map` como `std::unordered_map` para ilustrar sus diferencias y usos comunes:

```cpp
#include <iostream>
#include <map>
#include <unordered_map>
using namespace std;

int main() {
    // Uso de std::map
    map<string, int> mapaOrdenado;
    mapaOrdenado["Juan"] = 30;
    mapaOrdenado["Maria"] = 25;
    mapaOrdenado["Pedro"] = 35;

    cout << "Mapa ordenado:" << endl;
    for (const auto& par : mapaOrdenado) {
        cout << par.first << " tiene " << par.second << " años." << endl;
    }

    // Uso de std::unordered_map
    unordered_map<string, int> mapaNoOrdenado;
    mapaNoOrdenado["Juan"] = 30;
    mapaNoOrdenado["Maria"] = 25;
    mapaNoOrdenado["Pedro"] = 35;

    cout << "\nMapa no ordenado:" << endl;
    for (const auto& par : mapaNoOrdenado) {
        cout << par.first << " tiene " << par.second << " años." << endl;
    }

    return 0;
}
```

### Conclusión

Los mapas y diccionarios son estructuras de datos clave en C++ que permiten el almacenamiento y la manipulación eficiente de pares de clave-valor. `std::map` proporciona una estructura ordenada con complejidad logarítmica, mientras que `std::unordered_map` ofrece una estructura no ordenada con acceso promedio constante. Conocer las diferencias entre estas estructuras y cuándo usar cada una es esencial para escribir programas eficientes y bien organizados en C++.
<---FILES--->
Características de `std::list`
Características de `std::list` Result
Ejemplo de Uso de `std::list`
Ejemplo de Uso de `std::list` Result
Características de `std::queue`
Características de `std::queue` Result
Ejemplo de Uso de `std::queue`
Ejemplo de Uso de `std::queue` Result
Características de `std::list`
Características de `std::list` Result
Ejemplo de Uso de `std::list`
Ejemplo de Uso de `std::list` Result
Características de `std::queue`
Características de `std::queue` Result
Ejemplo de Uso de `std::queue`
Ejemplo de Uso de `std::queue` Result
Características de `std::stack`
Características de `std::stack` Result
Ejemplo de Uso de `std::stack`
Ejemplo de Uso de `std::stack` Result
Características de `std::set`
Características de `std::set` Result
Ejemplo de Uso de `std::set`
Ejemplo de Uso de `std::set` Result
Características de `std::list`
Características de `std::list` Result
Ejemplo de Uso de `std::list`
Ejemplo de Uso de `std::list` Result
Características de `std::queue`
Características de `std::queue` Result
Ejemplo de Uso de `std::queue`
Ejemplo de Uso de `std::queue` Result
Características de `std::stack`
Características de `std::stack` Result
Ejemplo de Uso de `std::stack`
Ejemplo de Uso de `std::stack` Result
Características de `std::set`
Características de `std::set` Result
Ejemplo de Uso de `std::set`
Ejemplo de Uso de `std::set` Result
Características de `std::map`
Características de `std::map` Result
Ejemplo de Uso de `std::map`
Ejemplo de Uso de `std::map` Result
Características de `std::unordered_map`
Características de `std::unordered_map` Result
Ejemplo de Uso de `std::unordered_map`
Ejemplo de Uso de `std::unordered_map` Result
<---Características de `std::list`--->
<---Características de `std::list` Result--->
<---Ejemplo de Uso de `std::list`--->
```cpp
#include <iostream>
#include <list>
using namespace std;

int main() {
    // Declaración e inicialización de una lista
    list<int> miLista = {10, 20, 30, 40};

    // Inserción de elementos
    miLista.push_back(50);  // Añade al final
    miLista.push_front(5);  // Añade al inicio

    // Iteración y acceso a los elementos
    for (int elemento : miLista) {
        cout << elemento << " ";
    }
    cout << endl;

    // Eliminación de elementos
    miLista.pop_back();  // Elimina el último elemento
    miLista.pop_front(); // Elimina el primer elemento

    // Iteración y acceso a los elementos después de la eliminación
    for (int elemento : miLista) {
        cout << elemento << " ";
    }
    cout << endl;

    return 0;
}
<---Ejemplo de Uso de `std::list` Result--->
<---Características de `std::queue`--->
<---Características de `std::queue` Result--->
<---Ejemplo de Uso de `std::queue`--->
```cpp
#include <iostream>
#include <queue>
using namespace std;

int main() {
    // Declaración e inicialización de una cola
    queue<int> miCola;

    // Inserción de elementos
    miCola.push(10);
    miCola.push(20);
    miCola.push(30);

    // Acceso al primer y último elemento
    cout << "Frente: " << miCola.front() << endl;
    cout << "Final: " << miCola.back() << endl;

    // Eliminación de elementos
    miCola.pop(); // Elimina el primer elemento (10)

    // Acceso después de la eliminación
    cout << "Frente después de pop: " << miCola.front() << endl;

    return 0;
}
```cpp
#include <iostream>
#include <list>
#include <queue>
using namespace std;

int main() {
    // Uso de std::list
    list<int> miLista = {1, 2, 3, 4, 5};
    miLista.push_back(6);
    miLista.push_front(0);

    cout << "Lista: ";
    for (int elemento : miLista) {
        cout << elemento << " ";
    }
    cout << endl;

    miLista.pop_back();
    miLista.pop_front();

    cout << "Lista después de pop: ";
    for (int elemento : miLista) {
        cout << elemento << " ";
    }
    cout << endl;

    // Uso de std::queue
    queue<int> miCola;
    miCola.push(10);
    miCola.push(20);
    miCola.push(30);

    cout << "Cola frente: " << miCola.front() << ", final: " << miCola.back() << endl;
    miCola.pop();
    cout << "Cola frente después de pop: " << miCola.front() << endl;

    return 0;
}
<---Ejemplo de Uso de `std::queue` Result--->
<---Características de `std::list`--->
<---Características de `std::list` Result--->
<---Ejemplo de Uso de `std::list`--->
```cpp
#include <iostream>
#include <list>
using namespace std;

int main() {
    // Declaración e inicialización de una lista
    list<int> miLista = {10, 20, 30, 40};

    // Inserción de elementos
    miLista.push_back(50);  // Añade al final
    miLista.push_front(5);  // Añade al inicio

    // Iteración y acceso a los elementos
    for (int elemento : miLista) {
        cout << elemento << " ";
    }
    cout << endl;

    // Eliminación de elementos
    miLista.pop_back();  // Elimina el último elemento
    miLista.pop_front(); // Elimina el primer elemento

    // Iteración y acceso a los elementos después de la eliminación
    for (int elemento : miLista) {
        cout << elemento << " ";
    }
    cout << endl;

    return 0;
}
<---Ejemplo de Uso de `std::list` Result--->
<---Características de `std::queue`--->
<---Características de `std::queue` Result--->
<---Ejemplo de Uso de `std::queue`--->
```cpp
#include <iostream>
#include <queue>
using namespace std;

int main() {
    // Declaración e inicialización de una cola
    queue<int> miCola;

    // Inserción de elementos
    miCola.push(10);
    miCola.push(20);
    miCola.push(30);

    // Acceso al primer y último elemento
    cout << "Frente: " << miCola.front() << endl;
    cout << "Final: " << miCola.back() << endl;

    // Eliminación de elementos
    miCola.pop(); // Elimina el primer elemento (10)

    // Acceso después de la eliminación
    cout << "Frente después de pop: " << miCola.front() << endl;

    return 0;
}
```cpp
#include <iostream>
#include <list>
#include <queue>
using namespace std;

int main() {
    // Uso de std::list
    list<int> miLista = {1, 2, 3, 4, 5};
    miLista.push_back(6);
    miLista.push_front(0);

    cout << "Lista: ";
    for (int elemento : miLista) {
        cout << elemento << " ";
    }
    cout << endl;

    miLista.pop_back();
    miLista.pop_front();

    cout << "Lista después de pop: ";
    for (int elemento : miLista) {
        cout << elemento << " ";
    }
    cout << endl;

    // Uso de std::queue
    queue<int> miCola;
    miCola.push(10);
    miCola.push(20);
    miCola.push(30);

    cout << "Cola frente: " << miCola.front() << ", final: " << miCola.back() << endl;
    miCola.pop();
    cout << "Cola frente después de pop: " << miCola.front() << endl;

    return 0;
}
<---Ejemplo de Uso de `std::queue` Result--->
<---Características de `std::stack`--->
<---Características de `std::stack` Result--->
<---Ejemplo de Uso de `std::stack`--->
```cpp
#include <iostream>
#include <stack>
using namespace std;

int main() {
    // Declaración e inicialización de una pila
    stack<int> miPila;

    // Inserción de elementos
    miPila.push(10);
    miPila.push(20);
    miPila.push(30);

    // Acceso al elemento superior
    cout << "Elemento superior: " << miPila.top() << endl;

    // Eliminación de elementos
    miPila.pop(); // Elimina el elemento superior (30)

    // Acceso después de la eliminación
    cout << "Elemento superior después de pop: " << miPila.top() << endl;

    return 0;
}
<---Ejemplo de Uso de `std::stack` Result--->
<---Características de `std::set`--->
<---Características de `std::set` Result--->
<---Ejemplo de Uso de `std::set`--->
```cpp
#include <iostream>
#include <set>
using namespace std;

int main() {
    // Declaración e inicialización de un conjunto
    set<int> miConjunto = {30, 10, 20, 40};

    // Inserción de elementos
    miConjunto.insert(50);
    miConjunto.insert(20); // No se añade ya que 20 ya existe

    // Iteración y acceso a los elementos
    cout << "Conjunto: ";
    for (int elemento : miConjunto) {
        cout << elemento << " ";
    }
    cout << endl;

    // Eliminación de un elemento
    miConjunto.erase(30);

    // Iteración y acceso a los elementos después de la eliminación
    cout << "Conjunto después de erase: ";
    for (int elemento : miConjunto) {
        cout << elemento << " ";
    }
    cout << endl;

    return 0;
}
```cpp
#include <iostream>
#include <stack>
#include <set>
using namespace std;

int main() {
    // Uso de std::stack
    stack<int> miPila;
    miPila.push(10);
    miPila.push(20);
    miPila.push(30);
    cout << "Pila elemento superior: " << miPila.top() << endl;
    miPila.pop();
    cout << "Pila elemento superior después de pop: " << miPila.top() << endl;

    // Uso de std::set
    set<int> miConjunto = {30, 10, 20, 40};
    miConjunto.insert(50);
    cout << "Conjunto: ";
    for (int elemento : miConjunto) {
        cout << elemento << " ";
    }
    cout << endl;
    miConjunto.erase(30);
    cout << "Conjunto después de erase: ";
    for (int elemento : miConjunto) {
        cout << elemento << " ";
    }
    cout << endl;

    return 0;
}
<---Ejemplo de Uso de `std::set` Result--->
<---Características de `std::list`--->
<---Características de `std::list` Result--->
<---Ejemplo de Uso de `std::list`--->
```cpp
#include <iostream>
#include <list>
using namespace std;

int main() {
    // Declaración e inicialización de una lista
    list<int> miLista = {10, 20, 30, 40};

    // Inserción de elementos
    miLista.push_back(50);  // Añade al final
    miLista.push_front(5);  // Añade al inicio

    // Iteración y acceso a los elementos
    for (int elemento : miLista) {
        cout << elemento << " ";
    }
    cout << endl;

    // Eliminación de elementos
    miLista.pop_back();  // Elimina el último elemento
    miLista.pop_front(); // Elimina el primer elemento

    // Iteración y acceso a los elementos después de la eliminación
    for (int elemento : miLista) {
        cout << elemento << " ";
    }
    cout << endl;

    return 0;
}
<---Ejemplo de Uso de `std::list` Result--->
<---Características de `std::queue`--->
<---Características de `std::queue` Result--->
<---Ejemplo de Uso de `std::queue`--->
```cpp
#include <iostream>
#include <queue>
using namespace std;

int main() {
    // Declaración e inicialización de una cola
    queue<int> miCola;

    // Inserción de elementos
    miCola.push(10);
    miCola.push(20);
    miCola.push(30);

    // Acceso al primer y último elemento
    cout << "Frente: " << miCola.front() << endl;
    cout << "Final: " << miCola.back() << endl;

    // Eliminación de elementos
    miCola.pop(); // Elimina el primer elemento (10)

    // Acceso después de la eliminación
    cout << "Frente después de pop: " << miCola.front() << endl;

    return 0;
}
```cpp
#include <iostream>
#include <list>
#include <queue>
using namespace std;

int main() {
    // Uso de std::list
    list<int> miLista = {1, 2, 3, 4, 5};
    miLista.push_back(6);
    miLista.push_front(0);

    cout << "Lista: ";
    for (int elemento : miLista) {
        cout << elemento << " ";
    }
    cout << endl;

    miLista.pop_back();
    miLista.pop_front();

    cout << "Lista después de pop: ";
    for (int elemento : miLista) {
        cout << elemento << " ";
    }
    cout << endl;

    // Uso de std::queue
    queue<int> miCola;
    miCola.push(10);
    miCola.push(20);
    miCola.push(30);

    cout << "Cola frente: " << miCola.front() << ", final: " << miCola.back() << endl;
    miCola.pop();
    cout << "Cola frente después de pop: " << miCola.front() << endl;

    return 0;
}
<---Ejemplo de Uso de `std::queue` Result--->
<---Características de `std::stack`--->
<---Características de `std::stack` Result--->
<---Ejemplo de Uso de `std::stack`--->
```cpp
#include <iostream>
#include <stack>
using namespace std;

int main() {
    // Declaración e inicialización de una pila
    stack<int> miPila;

    // Inserción de elementos
    miPila.push(10);
    miPila.push(20);
    miPila.push(30);

    // Acceso al elemento superior
    cout << "Elemento superior: " << miPila.top() << endl;

    // Eliminación de elementos
    miPila.pop(); // Elimina el elemento superior (30)

    // Acceso después de la eliminación
    cout << "Elemento superior después de pop: " << miPila.top() << endl;

    return 0;
}
<---Ejemplo de Uso de `std::stack` Result--->
<---Características de `std::set`--->
<---Características de `std::set` Result--->
<---Ejemplo de Uso de `std::set`--->
```cpp
#include <iostream>
#include <set>
using namespace std;

int main() {
    // Declaración e inicialización de un conjunto
    set<int> miConjunto = {30, 10, 20, 40};

    // Inserción de elementos
    miConjunto.insert(50);
    miConjunto.insert(20); // No se añade ya que 20 ya existe

    // Iteración y acceso a los elementos
    cout << "Conjunto: ";
    for (int elemento : miConjunto) {
        cout << elemento << " ";
    }
    cout << endl;

    // Eliminación de un elemento
    miConjunto.erase(30);

    // Iteración y acceso a los elementos después de la eliminación
    cout << "Conjunto después de erase: ";
    for (int elemento : miConjunto) {
        cout << elemento << " ";
    }
    cout << endl;

    return 0;
}
```cpp
#include <iostream>
#include <stack>
#include <set>
using namespace std;

int main() {
    // Uso de std::stack
    stack<int> miPila;
    miPila.push(10);
    miPila.push(20);
    miPila.push(30);
    cout << "Pila elemento superior: " << miPila.top() << endl;
    miPila.pop();
    cout << "Pila elemento superior después de pop: " << miPila.top() << endl;

    // Uso de std::set
    set<int> miConjunto = {30, 10, 20, 40};
    miConjunto.insert(50);
    cout << "Conjunto: ";
    for (int elemento : miConjunto) {
        cout << elemento << " ";
    }
    cout << endl;
    miConjunto.erase(30);
    cout << "Conjunto después de erase: ";
    for (int elemento : miConjunto) {
        cout << elemento << " ";
    }
    cout << endl;

    return 0;
}
<---Ejemplo de Uso de `std::set` Result--->
<---Características de `std::map`--->
<---Características de `std::map` Result--->
<---Ejemplo de Uso de `std::map`--->
```cpp
#include <iostream>
#include <map>
using namespace std;

int main() {
    // Declaración e inicialización de un mapa
    map<string, int> edades;
    edades["Juan"] = 30;
    edades["Maria"] = 25;
    edades["Pedro"] = 35;

    // Iteración y acceso a los elementos
    for (const auto& par : edades) {
        cout << par.first << " tiene " << par.second << " años." << endl;
    }

    // Acceso a un valor específico
    cout << "La edad de Maria es: " << edades["Maria"] << endl;

    // Modificación de un valor
    edades["Maria"] = 26;
    cout << "La nueva edad de Maria es: " << edades["Maria"] << endl;

    // Eliminación de un elemento
    edades.erase("Pedro");

    // Iteración después de la eliminación
    for (const auto& par : edades) {
        cout << par.first << " tiene " << par.second << " años." << endl;
    }

    return 0;
}
<---Ejemplo de Uso de `std::map` Result--->
<---Características de `std::unordered_map`--->
<---Características de `std::unordered_map` Result--->
<---Ejemplo de Uso de `std::unordered_map`--->
```cpp
#include <iostream>
#include <unordered_map>
using namespace std;

int main() {
    // Declaración e inicialización de un unordered_map
    unordered_map<string, int> edades;
    edades["Juan"] = 30;
    edades["Maria"] = 25;
    edades["Pedro"] = 35;

    // Iteración y acceso a los elementos
    for (const auto& par : edades) {
        cout << par.first << " tiene " << par.second << " años." << endl;
    }

    // Acceso a un valor específico
    cout << "La edad de Maria es: " << edades["Maria"] << endl;

    // Modificación de un valor
    edades["Maria"] = 26;
    cout << "La nueva edad de Maria es: " << edades["Maria"] << endl;

    // Eliminación de un elemento
    edades.erase("Pedro");

    // Iteración después de la eliminación
    for (const auto& par : edades) {
        cout << par.first << " tiene " << par.second << " años." << endl;
    }

    return 0;
}
```cpp
#include <iostream>
#include <map>
#include <unordered_map>
using namespace std;

int main() {
    // Uso de std::map
    map<string, int> mapaOrdenado;
    mapaOrdenado["Juan"] = 30;
    mapaOrdenado["Maria"] = 25;
    mapaOrdenado["Pedro"] = 35;

    cout << "Mapa ordenado:" << endl;
    for (const auto& par : mapaOrdenado) {
        cout << par.first << " tiene " << par.second << " años." << endl;
    }

    // Uso de std::unordered_map
    unordered_map<string, int> mapaNoOrdenado;
    mapaNoOrdenado["Juan"] = 30;
    mapaNoOrdenado["Maria"] = 25;
    mapaNoOrdenado["Pedro"] = 35;

    cout << "\nMapa no ordenado:" << endl;
    for (const auto& par : mapaNoOrdenado) {
        cout << par.first << " tiene " << par.second << " años." << endl;
    }

    return 0;
}
<---Ejemplo de Uso de `std::unordered_map` Result--->
