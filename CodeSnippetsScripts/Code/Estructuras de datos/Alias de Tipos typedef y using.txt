<---EXPLANATION--->
### Estructuras de Datos: Listas y Colas en C++

Las listas y las colas son estructuras de datos fundamentales que permiten almacenar y manipular colecciones de elementos de manera eficiente. En C++, estas estructuras se implementan comúnmente utilizando la biblioteca estándar (STL).

#### Listas

Una lista es una estructura de datos lineal que permite la inserción y eliminación de elementos en cualquier punto de la secuencia. La STL proporciona la clase `std::list` para manejar listas doblemente enlazadas.

##### Características de `std::list`

- **Doble Enlazado:** Cada elemento tiene un puntero al elemento anterior y al siguiente.
- **Inserción/Eiminación Eficiente:** Las operaciones de inserción y eliminación en cualquier posición son eficientes (O(1)).
- **Acceso Secuencial:** El acceso a elementos es secuencial, lo que significa que encontrar un elemento específico es O(n).

##### Ejemplo de Uso de `std::list`

```cpp
#include <iostream>
#include <list>
using namespace std;

int main() {
    // Declaración e inicialización de una lista
    list<int> miLista = {10, 20, 30, 40};

    // Inserción de elementos
    miLista.push_back(50);  // Añade al final
    miLista.push_front(5);  // Añade al inicio

    // Iteración y acceso a los elementos
    for (int elemento : miLista) {
        cout << elemento << " ";
    }
    cout << endl;

    // Eliminación de elementos
    miLista.pop_back();  // Elimina el último elemento
    miLista.pop_front(); // Elimina el primer elemento

    // Iteración y acceso a los elementos después de la eliminación
    for (int elemento : miLista) {
        cout << elemento << " ";
    }
    cout << endl;

    return 0;
}
```

### Operaciones Comunes en `std::list`

- **`push_back(valor)`**: Añade un elemento al final de la lista.
- **`push_front(valor)`**: Añade un elemento al inicio de la lista.
- **`pop_back()`**: Elimina el último elemento de la lista.
- **`pop_front()`**: Elimina el primer elemento de la lista.
- **`insert(it, valor)`**: Inserta un elemento en la posición indicada por el iterador `it`.
- **`erase(it)`**: Elimina el elemento en la posición indicada por el iterador `it`.
- **`size()`**: Devuelve el número de elementos en la lista.

### Colas

Una cola es una estructura de datos lineal que sigue el principio FIFO (First In, First Out), donde el primer elemento en entrar es el primero en salir. La STL proporciona la clase `std::queue` para manejar colas.

##### Características de `std::queue`

- **FIFO:** Los elementos se insertan por un extremo (trasero) y se eliminan por el otro extremo (frontal).
- **Acceso Restricto:** Solo se puede acceder al primer y al último elemento.

##### Ejemplo de Uso de `std::queue`

```cpp
#include <iostream>
#include <queue>
using namespace std;

int main() {
    // Declaración e inicialización de una cola
    queue<int> miCola;

    // Inserción de elementos
    miCola.push(10);
    miCola.push(20);
    miCola.push(30);

    // Acceso al primer y último elemento
    cout << "Frente: " << miCola.front() << endl;
    cout << "Final: " << miCola.back() << endl;

    // Eliminación de elementos
    miCola.pop(); // Elimina el primer elemento (10)

    // Acceso después de la eliminación
    cout << "Frente después de pop: " << miCola.front() << endl;

    return 0;
}
```

### Operaciones Comunes en `std::queue`

- **`push(valor)`**: Añade un elemento al final de la cola.
- **`pop()`**: Elimina el primer elemento de la cola.
- **`front()`**: Devuelve una referencia al primer elemento de la cola.
- **`back()`**: Devuelve una referencia al último elemento de la cola.
- **`size()`**: Devuelve el número de elementos en la cola.
- **`empty()`**: Devuelve `true` si la cola está vacía.

### Ejemplo Completo

A continuación, un ejemplo que combina el uso de listas y colas para ilustrar sus diferencias y usos comunes:

```cpp
#include <iostream>
#include <list>
#include <queue>
using namespace std;

int main() {
    // Uso de std::list
    list<int> miLista = {1, 2, 3, 4, 5};
    miLista.push_back(6);
    miLista.push_front(0);

    cout << "Lista: ";
    for (int elemento : miLista) {
        cout << elemento << " ";
    }
    cout << endl;

    miLista.pop_back();
    miLista.pop_front();

    cout << "Lista después de pop: ";
    for (int elemento : miLista) {
        cout << elemento << " ";
    }
    cout << endl;

    // Uso de std::queue
    queue<int> miCola;
    miCola.push(10);
    miCola.push(20);
    miCola.push(30);

    cout << "Cola frente: " << miCola.front() << ", final: " << miCola.back() << endl;
    miCola.pop();
    cout << "Cola frente después de pop: " << miCola.front() << endl;

    return 0;
}
```

### Conclusión

Las listas y las colas son estructuras de datos esenciales en C++ que proporcionan flexibilidad y eficiencia para diferentes tipos de operaciones. Las listas permiten inserciones y eliminaciones eficientes en cualquier posición, mientras que las colas facilitan un acceso ordenado y secuencial siguiendo el principio FIFO. Conocer cómo y cuándo usar cada estructura de datos es fundamental para escribir programas eficientes y bien estructurados en C++.
### Estructuras de Datos: Pilas y Conjuntos en C++

Las pilas y los conjuntos son estructuras de datos fundamentales en C++ que permiten almacenar y manipular colecciones de elementos de manera específica. En C++, estas estructuras se implementan comúnmente utilizando la biblioteca estándar (STL).

#### Pilas

Una pila (stack) es una estructura de datos lineal que sigue el principio LIFO (Last In, First Out), donde el último elemento en entrar es el primero en salir. La STL proporciona la clase `std::stack` para manejar pilas.

##### Características de `std::stack`

- **LIFO:** Los elementos se insertan y se eliminan desde el mismo extremo.
- **Acceso Restringido:** Solo se puede acceder al elemento en la parte superior de la pila.

##### Ejemplo de Uso de `std::stack`

```cpp
#include <iostream>
#include <stack>
using namespace std;

int main() {
    // Declaración e inicialización de una pila
    stack<int> miPila;

    // Inserción de elementos
    miPila.push(10);
    miPila.push(20);
    miPila.push(30);

    // Acceso al elemento superior
    cout << "Elemento superior: " << miPila.top() << endl;

    // Eliminación de elementos
    miPila.pop(); // Elimina el elemento superior (30)

    // Acceso después de la eliminación
    cout << "Elemento superior después de pop: " << miPila.top() << endl;

    return 0;
}
```

### Operaciones Comunes en `std::stack`

- **`push(valor)`**: Añade un elemento al tope de la pila.
- **`pop()`**: Elimina el elemento en el tope de la pila.
- **`top()`**: Devuelve una referencia al elemento en el tope de la pila.
- **`size()`**: Devuelve el número de elementos en la pila.
- **`empty()`**: Devuelve `true` si la pila está vacía.

### Conjuntos

Un conjunto (set) es una estructura de datos que almacena elementos únicos en orden. La STL proporciona la clase `std::set` para manejar conjuntos.

##### Características de `std::set`

- **Elementos Únicos:** No se permiten duplicados.
- **Ordenado:** Los elementos se almacenan en orden ascendente.
- **Operaciones Eficientes:** Inserción, eliminación y búsqueda en O(log n).

##### Ejemplo de Uso de `std::set`

```cpp
#include <iostream>
#include <set>
using namespace std;

int main() {
    // Declaración e inicialización de un conjunto
    set<int> miConjunto = {30, 10, 20, 40};

    // Inserción de elementos
    miConjunto.insert(50);
    miConjunto.insert(20); // No se añade ya que 20 ya existe

    // Iteración y acceso a los elementos
    cout << "Conjunto: ";
    for (int elemento : miConjunto) {
        cout << elemento << " ";
    }
    cout << endl;

    // Eliminación de un elemento
    miConjunto.erase(30);

    // Iteración y acceso a los elementos después de la eliminación
    cout << "Conjunto después de erase: ";
    for (int elemento : miConjunto) {
        cout << elemento << " ";
    }
    cout << endl;

    return 0;
}
```

### Operaciones Comunes en `std::set`

- **`insert(valor)`**: Añade un elemento al conjunto.
- **`erase(valor)`**: Elimina un elemento del conjunto.
- **`find(valor)`**: Devuelve un iterador al elemento si se encuentra, o `end()` si no.
- **`size()`**: Devuelve el número de elementos en el conjunto.
- **`empty()`**: Devuelve `true` si el conjunto está vacío.

### Comparación de Pilas y Conjuntos

| Característica     | Pila (`std::stack`)                  | Conjunto (`std::set`)                 |
|--------------------|--------------------------------------|---------------------------------------|
| Orden              | LIFO (Last In, First Out)            | Orden ascendente                      |
| Duplicados         | Permitidos                           | No permitidos                         |
| Acceso a Elementos | Solo al elemento superior            | A cualquier elemento usando iteradores|
| Complejidad        | O(1) para `push` y `pop`             | O(log n) para `insert`, `erase` y `find` |

### Ejemplo Completo

A continuación, un ejemplo que utiliza tanto pilas como conjuntos para ilustrar sus diferencias y usos comunes:

```cpp
#include <iostream>
#include <stack>
#include <set>
using namespace std;

int main() {
    // Uso de std::stack
    stack<int> miPila;
    miPila.push(10);
    miPila.push(20);
    miPila.push(30);
    cout << "Pila elemento superior: " << miPila.top() << endl;
    miPila.pop();
    cout << "Pila elemento superior después de pop: " << miPila.top() << endl;

    // Uso de std::set
    set<int> miConjunto = {30, 10, 20, 40};
    miConjunto.insert(50);
    cout << "Conjunto: ";
    for (int elemento : miConjunto) {
        cout << elemento << " ";
    }
    cout << endl;
    miConjunto.erase(30);
    cout << "Conjunto después de erase: ";
    for (int elemento : miConjunto) {
        cout << elemento << " ";
    }
    cout << endl;

    return 0;
}
```

### Conclusión

Las pilas y los conjuntos son estructuras de datos esenciales en C++ que proporcionan soluciones eficientes para diferentes tipos de problemas. Las pilas siguen el principio LIFO y son útiles para tareas como la evaluación de expresiones y el seguimiento de contexto. Los conjuntos garantizan la unicidad de los elementos y mantienen el orden, siendo útiles para tareas de búsqueda y eliminación de duplicados. Comprender cómo y cuándo usar estas estructuras de datos es fundamental para escribir programas eficientes y bien estructurados en C++.
### Estructuras de Datos: Mapas y Diccionarios en C++

En C++, los mapas y diccionarios son estructuras de datos que permiten almacenar pares de clave-valor, facilitando la búsqueda, inserción y eliminación de elementos basados en claves únicas. La biblioteca estándar de C++ (STL) proporciona dos tipos principales de mapas: `std::map` y `std::unordered_map`.

#### Mapas (`std::map`)

Un `std::map` es una estructura de datos asociativa ordenada que almacena elementos en pares de clave-valor, donde las claves son únicas y los elementos se almacenan en orden ascendente según las claves.

##### Características de `std::map`

- **Ordenado:** Los elementos se almacenan en orden ascendente de las claves.
- **Claves Únicas:** Cada clave en el mapa es única.
- **Acceso Logarítmico:** Las operaciones de búsqueda, inserción y eliminación tienen una complejidad O(log n) debido a su implementación basada en árboles binarios balanceados.

##### Ejemplo de Uso de `std::map`

```cpp
#include <iostream>
#include <map>
using namespace std;

int main() {
    // Declaración e inicialización de un mapa
    map<string, int> edades;
    edades["Juan"] = 30;
    edades["Maria"] = 25;
    edades["Pedro"] = 35;

    // Iteración y acceso a los elementos
    for (const auto& par : edades) {
        cout << par.first << " tiene " << par.second << " años." << endl;
    }

    // Acceso a un valor específico
    cout << "La edad de Maria es: " << edades["Maria"] << endl;

    // Modificación de un valor
    edades["Maria"] = 26;
    cout << "La nueva edad de Maria es: " << edades["Maria"] << endl;

    // Eliminación de un elemento
    edades.erase("Pedro");

    // Iteración después de la eliminación
    for (const auto& par : edades) {
        cout << par.first << " tiene " << par.second << " años." << endl;
    }

    return 0;
}
```

### Operaciones Comunes en `std::map`

- **`operator[]`**: Accede o inserta un valor asociado a una clave.
- **`insert(par)`**: Inserta un nuevo par clave-valor.
- **`erase(clave)`**: Elimina el par asociado a la clave.
- **`find(clave)`**: Devuelve un iterador al par si se encuentra, o `end()` si no.
- **`size()`**: Devuelve el número de elementos en el mapa.
- **`empty()`**: Devuelve `true` si el mapa está vacío.

#### Mapas No Ordenados (`std::unordered_map`)

Un `std::unordered_map` es una estructura de datos asociativa que almacena elementos en pares de clave-valor utilizando una tabla hash, lo que permite operaciones de búsqueda, inserción y eliminación en promedio constante O(1).

##### Características de `std::unordered_map`

- **No Ordenado:** Los elementos no se almacenan en un orden específico.
- **Claves Únicas:** Cada clave en el mapa es única.
- **Acceso Constante Promedio:** Las operaciones tienen una complejidad promedio O(1) debido a su implementación basada en tablas hash.

##### Ejemplo de Uso de `std::unordered_map`

```cpp
#include <iostream>
#include <unordered_map>
using namespace std;

int main() {
    // Declaración e inicialización de un unordered_map
    unordered_map<string, int> edades;
    edades["Juan"] = 30;
    edades["Maria"] = 25;
    edades["Pedro"] = 35;

    // Iteración y acceso a los elementos
    for (const auto& par : edades) {
        cout << par.first << " tiene " << par.second << " años." << endl;
    }

    // Acceso a un valor específico
    cout << "La edad de Maria es: " << edades["Maria"] << endl;

    // Modificación de un valor
    edades["Maria"] = 26;
    cout << "La nueva edad de Maria es: " << edades["Maria"] << endl;

    // Eliminación de un elemento
    edades.erase("Pedro");

    // Iteración después de la eliminación
    for (const auto& par : edades) {
        cout << par.first << " tiene " << par.second << " años." << endl;
    }

    return 0;
}
```

### Operaciones Comunes en `std::unordered_map`

- **`operator[]`**: Accede o inserta un valor asociado a una clave.
- **`insert(par)`**: Inserta un nuevo par clave-valor.
- **`erase(clave)`**: Elimina el par asociado a la clave.
- **`find(clave)`**: Devuelve un iterador al par si se encuentra, o `end()` si no.
- **`size()`**: Devuelve el número de elementos en el mapa.
- **`empty()`**: Devuelve `true` si el mapa está vacío.

### Comparación entre `std::map` y `std::unordered_map`

| Característica            | `std::map`                           | `std::unordered_map`                 |
|---------------------------|--------------------------------------|--------------------------------------|
| Orden                     | Ordenado por claves                  | No ordenado                          |
| Complejidad de Acceso     | O(log n)                             | Promedio O(1)                        |
| Estructura Subyacente     | Árbol binario balanceado (RB-tree)   | Tabla hash                           |
| Uso de Memoria            | Mayor eficiencia de memoria          | Puede utilizar más memoria           |
| Iteración                 | Ordenada por clave                   | No garantiza un orden específico     |

### Ejemplo Completo

A continuación, un ejemplo que utiliza tanto `std::map` como `std::unordered_map` para ilustrar sus diferencias y usos comunes:

```cpp
#include <iostream>
#include <map>
#include <unordered_map>
using namespace std;

int main() {
    // Uso de std::map
    map<string, int> mapaOrdenado;
    mapaOrdenado["Juan"] = 30;
    mapaOrdenado["Maria"] = 25;
    mapaOrdenado["Pedro"] = 35;

    cout << "Mapa ordenado:" << endl;
    for (const auto& par : mapaOrdenado) {
        cout << par.first << " tiene " << par.second << " años." << endl;
    }

    // Uso de std::unordered_map
    unordered_map<string, int> mapaNoOrdenado;
    mapaNoOrdenado["Juan"] = 30;
    mapaNoOrdenado["Maria"] = 25;
    mapaNoOrdenado["Pedro"] = 35;

    cout << "\nMapa no ordenado:" << endl;
    for (const auto& par : mapaNoOrdenado) {
        cout << par.first << " tiene " << par.second << " años." << endl;
    }

    return 0;
}
```

### Conclusión

Los mapas y diccionarios son estructuras de datos clave en C++ que permiten el almacenamiento y la manipulación eficiente de pares de clave-valor. `std::map` proporciona una estructura ordenada con complejidad logarítmica, mientras que `std::unordered_map` ofrece una estructura no ordenada con acceso promedio constante. Conocer las diferencias entre estas estructuras y cuándo usar cada una es esencial para escribir programas eficientes y bien organizados en C++.
### Arrays Multidimensionales en C++

Los arrays multidimensionales son arrays que contienen otros arrays como elementos, permitiendo almacenar datos en una estructura en varias dimensiones, como matrices (2D), cubos (3D), etc. Los más comunes son los arrays bidimensionales, que se utilizan para representar tablas o matrices.

#### Declaración y Uso de Arrays Bidimensionales

Un array bidimensional se puede declarar especificando el tamaño en ambas dimensiones. Por ejemplo, un array 3x3 se declara de la siguiente manera:

```cpp
#include <iostream>
using namespace std;

int main() {
    // Declaración de un array 3x3
    int matriz[3][3] = {
        {1, 2, 3},
        {4, 5, 6},
        {7, 8, 9}
    };

    // Acceso a los elementos del array bidimensional
    for (int i = 0; i < 3; ++i) {
        for (int j = 0; j < 3; ++j) {
            cout << "Elemento [" << i << "][" << j << "]: " << matriz[i][j] << endl;
        }
    }

    return 0;
}
```

### Inicialización de Arrays Multidimensionales

Los arrays multidimensionales se pueden inicializar en el momento de su declaración, como se muestra en el ejemplo anterior. También se pueden inicializar dinámicamente.

##### Inicialización Estática

```cpp
int matriz[2][3] = {
    {1, 2, 3},
    {4, 5, 6}
};
```

##### Inicialización Dinámica

Para inicializar arrays multidimensionales dinámicamente, es necesario usar punteros y asignar memoria en el montón (`heap`).

```cpp
#include <iostream>
using namespace std;

int main() {
    int filas = 3;
    int columnas = 3;

    // Declaración de un puntero a puntero
    int** matriz = new int*[filas];

    // Asignación de memoria para cada fila
    for (int i = 0; i < filas; ++i) {
        matriz[i] = new int[columnas];
    }

    // Inicialización de la matriz
    int contador = 1;
    for (int i = 0; i < filas; ++i) {
        for (int j = 0; j < columnas; ++j) {
            matriz[i][j] = contador++;
        }
    }

    // Acceso a los elementos de la matriz
    for (int i = 0; i < filas; ++i) {
        for (int j = 0; j < columnas; ++j) {
            cout << "Elemento [" << i << "][" << j << "]: " << matriz[i][j] << endl;
        }
    }

    // Liberación de la memoria
    for (int i = 0; i < filas; ++i) {
        delete[] matriz[i];
    }
    delete[] matriz;

    return 0;
}
```

### Arrays Multidimensionales de Mayor Dimensión

C++ permite la declaración de arrays de más de dos dimensiones de forma similar a los bidimensionales.

##### Ejemplo de Array Tridimensional

```cpp
#include <iostream>
using namespace std;

int main() {
    // Declaración de un array 2x2x2
    int cubo[2][2][2] = {
        {
            {1, 2},
            {3, 4}
        },
        {
            {5, 6},
            {7, 8}
        }
    };

    // Acceso a los elementos del array tridimensional
    for (int i = 0; i < 2; ++i) {
        for (int j = 0; j < 2; ++j) {
            for (int k = 0; k < 2; ++k) {
                cout << "Elemento [" << i << "][" << j << "][" << k << "]: " << cubo[i][j][k] << endl;
            }
        }
    }

    return 0;
}
```

### Usos Comunes de Arrays Multidimensionales

1. **Matrices:** Utilizados en álgebra lineal, gráficos por computadora, y procesamiento de imágenes.
2. **Tablas de Datos:** Representación de datos tabulares, como tablas de multiplicar o tablas de búsqueda.
3. **Mallas y Redes:** Modelado de mallas en gráficos 3D y simulaciones.
4. **Juegos de Mesa:** Representación de tableros de juegos como el ajedrez o el Sudoku.

### Consideraciones y Buenas Prácticas

- **Tamaño Fijo:** Los arrays multidimensionales tienen un tamaño fijo, lo que puede ser una limitación si se necesita un tamaño dinámico.
- **Uso de Memoria:** Pueden consumir mucha memoria, especialmente los de dimensiones altas.
- **Eficiencia:** Son eficientes en términos de acceso debido a la contigüidad de la memoria, pero pueden ser menos flexibles que otras estructuras de datos como los vectores de vectores.
- **Liberación de Memoria:** Cuando se asigna memoria dinámicamente, es crucial liberar la memoria para evitar fugas.

### Ejemplo Completo

A continuación, un ejemplo completo que muestra la creación, inicialización, acceso y liberación de un array bidimensional dinámico:

```cpp
#include <iostream>
using namespace std;

int main() {
    int filas = 3;
    int columnas = 3;

    // Declaración de un puntero a puntero
    int** matriz = new int*[filas];

    // Asignación de memoria para cada fila
    for (int i = 0; i < filas; ++i) {
        matriz[i] = new int[columnas];
    }

    // Inicialización de la matriz
    int contador = 1;
    for (int i = 0; i < filas; ++i) {
        for (int j = 0; j < columnas; ++j) {
            matriz[i][j] = contador++;
        }
    }

    // Acceso a los elementos de la matriz
    cout << "Matriz inicializada:" << endl;
    for (int i = 0; i < filas; ++i) {
        for (int j = 0; j < columnas; ++j) {
            cout << matriz[i][j] << " ";
        }
        cout << endl;
    }

    // Liberación de la memoria
    for (int i = 0; i < filas; ++i) {
        delete[] matriz[i];
    }
    delete[] matriz;

    return 0;
}
```

### Conclusión

Los arrays multidimensionales son una herramienta poderosa en C++ para manejar datos estructurados en múltiples dimensiones. Permiten una representación clara y eficiente de datos como matrices y tablas, aunque su uso debe ser cuidadosamente gestionado para evitar problemas de memoria y flexibilidad. Comprender cómo declararlos, inicializarlos y acceder a ellos es esencial para aprovechar al máximo esta estructura de datos en aplicaciones complejas.
### C-Strings en C++

Los C-Strings, también conocidos como cadenas de caracteres en C, son arrays de caracteres terminados con un carácter nulo (`'\0'`). Aunque C++ proporciona la clase `std::string` que facilita el manejo de cadenas de caracteres, los C-Strings aún son ampliamente utilizados debido a su compatibilidad con el lenguaje C y su eficiencia en ciertas aplicaciones.

#### Declaración y Inicialización de C-Strings

Los C-Strings se pueden declarar e inicializar de varias maneras.

##### Declaración Básica

```cpp
char cadena[6] = {'H', 'o', 'l', 'a', '\0'};
```

##### Declaración y Inicialización Simplificada

```cpp
char cadena[] = "Hola";
```

En este caso, el compilador agrega automáticamente el carácter nulo al final de la cadena.

##### Ejemplo Completo de Declaración y Inicialización

```cpp
#include <iostream>
using namespace std;

int main() {
    char saludo1[] = "Hola";
    char saludo2[6] = {'H', 'o', 'l', 'a', '\0'};

    cout << saludo1 << endl;
    cout << saludo2 << endl;

    return 0;
}
```

#### Manipulación de C-Strings

C++ proporciona una serie de funciones en la biblioteca `<cstring>` para manipular C-Strings. Estas funciones incluyen `strcpy`, `strcat`, `strlen`, `strcmp`, entre otras.

##### Copia de Cadenas: `strcpy`

```cpp
#include <iostream>
#include <cstring>
using namespace std;

int main() {
    char destino[20];
    const char* origen = "Hola Mundo";

    strcpy(destino, origen);

    cout << "Destino: " << destino << endl;

    return 0;
}
```

##### Concatenación de Cadenas: `strcat`

```cpp
#include <iostream>
#include <cstring>
using namespace std;

int main() {
    char saludo[20] = "Hola, ";
    const char* nombre = "Mundo";

    strcat(saludo, nombre);

    cout << "Saludo completo: " << saludo << endl;

    return 0;
}
```

##### Longitud de la Cadena: `strlen`

```cpp
#include <iostream>
#include <cstring>
using namespace std;

int main() {
    const char* cadena = "Hola Mundo";
    size_t longitud = strlen(cadena);

    cout << "Longitud de la cadena: " << longitud << endl;

    return 0;
}
```

##### Comparación de Cadenas: `strcmp`

```cpp
#include <iostream>
#include <cstring>
using namespace std;

int main() {
    const char* cadena1 = "Hola";
    const char* cadena2 = "Mundo";

    int resultado = strcmp(cadena1, cadena2);

    if (resultado == 0) {
        cout << "Las cadenas son iguales." << endl;
    } else if (resultado < 0) {
        cout << "cadena1 es menor que cadena2." << endl;
    } else {
        cout << "cadena1 es mayor que cadena2." << endl;
    }

    return 0;
}
```

#### Entrada y Salida con C-Strings

Se pueden utilizar las funciones estándar de entrada y salida para manejar C-Strings.

##### Lectura de C-Strings con `cin`

```cpp
#include <iostream>
using namespace std;

int main() {
    char nombre[50];

    cout << "Introduce tu nombre: ";
    cin >> nombre;

    cout << "Hola, " << nombre << "!" << endl;

    return 0;
}
```

##### Lectura de Cadenas con Espacios usando `cin.getline`

```cpp
#include <iostream>
using namespace std;

int main() {
    char frase[100];

    cout << "Introduce una frase: ";
    cin.getline(frase, 100);

    cout << "Tu frase: " << frase << endl;

    return 0;
}
```

### Consideraciones y Buenas Prácticas

- **Terminación Nula:** Siempre asegúrate de que las C-Strings terminen con un carácter nulo (`'\0'`) para evitar comportamientos inesperados.
- **Tamaño del Array:** Declara arrays de caracteres lo suficientemente grandes para almacenar la cadena más el carácter nulo.
- **Seguridad:** Usa funciones seguras como `strncpy` y `strncat` para evitar desbordamientos de buffer.
- **Uso de `std::string`:** Siempre que sea posible, considera usar `std::string` de la STL de C++, ya que maneja muchos problemas de gestión de memoria automáticamente y proporciona una interfaz más segura y fácil de usar.

### Ejemplo Completo

A continuación, un ejemplo completo que demuestra varias operaciones con C-Strings:

```cpp
#include <iostream>
#include <cstring>
using namespace std;

int main() {
    // Declaración e inicialización
    char saludo[50] = "Hola";
    const char* mundo = " Mundo";

    // Concatenación
    strcat(saludo, mundo);
    cout << "Concatenación: " << saludo << endl;

    // Copia
    char copia[50];
    strcpy(copia, saludo);
    cout << "Copia: " << copia << endl;

    // Longitud
    size_t longitud = strlen(copia);
    cout << "Longitud de la copia: " << longitud << endl;

    // Comparación
    const char* otraCadena = "Hola Mundo";
    if (strcmp(copia, otraCadena) == 0) {
        cout << "Las cadenas son iguales." << endl;
    } else {
        cout << "Las cadenas son diferentes." << endl;
    }

    // Entrada de C-Strings
    char entrada[50];
    cout << "Introduce una palabra: ";
    cin >> entrada;
    cout << "Palabra introducida: " << entrada << endl;

    return 0;
}
```

### Conclusión

Los C-Strings son una estructura de datos fundamental en C++ para manejar cadenas de caracteres de manera eficiente. Aunque `std::string` es más conveniente y seguro para la mayoría de los casos, comprender y saber usar C-Strings es esencial para trabajar con bibliotecas y aplicaciones que requieren interoperabilidad con C y un control más fino sobre la gestión de la memoria.
### `struct` en C++

En C++, `struct` es una estructura de datos que permite agrupar diferentes tipos de datos bajo un mismo nombre, proporcionando una manera de manejar datos relacionados de forma cohesiva. Aunque `struct` es similar a la clase (`class`), existen algunas diferencias clave en su uso y sintaxis.

#### Definición de `struct`

Una estructura (`struct`) en C++ se define utilizando la palabra clave `struct` seguida del nombre de la estructura y el bloque de miembros.

##### Sintaxis

```cpp
struct NombreEstructura {
    tipo_dato1 miembro1;
    tipo_dato2 miembro2;
    // Otros miembros
};
```

##### Ejemplo Básico

```cpp
#include <iostream>
using namespace std;

struct Persona {
    string nombre;
    int edad;
    float altura;
};

int main() {
    // Declaración e inicialización de una estructura
    Persona juan = {"Juan", 30, 1.75f};

    // Acceso a los miembros de la estructura
    cout << "Nombre: " << juan.nombre << endl;
    cout << "Edad: " << juan.edad << endl;
    cout << "Altura: " << juan.altura << " metros" << endl;

    return 0;
}
```

En este ejemplo, `Persona` es una estructura que contiene tres miembros: `nombre`, `edad` y `altura`.

#### Inicialización de `struct`

Existen varias maneras de inicializar una estructura en C++.

##### Inicialización de Lista

```cpp
Persona maria = {"Maria", 25, 1.65f};
```

##### Inicialización Miembro por Miembro

```cpp
Persona pedro;
pedro.nombre = "Pedro";
pedro.edad = 28;
pedro.altura = 1.80f;
```

#### Operaciones con `struct`

Las estructuras pueden ser manipuladas de diversas maneras, como copiar, pasar como argumentos a funciones, y retornarlas desde funciones.

##### Copia de Estructuras

```cpp
Persona juan = {"Juan", 30, 1.75f};
Persona copiaJuan = juan;

cout << "Copia de Juan - Nombre: " << copiaJuan.nombre << endl;
```

##### Pasar Estructuras a Funciones

```cpp
void imprimirPersona(Persona p) {
    cout << "Nombre: " << p.nombre << endl;
    cout << "Edad: " << p.edad << endl;
    cout << "Altura: " << p.altura << " metros" << endl;
}

int main() {
    Persona juan = {"Juan", 30, 1.75f};
    imprimirPersona(juan);
    return 0;
}
```

##### Retornar Estructuras desde Funciones

```cpp
Persona crearPersona(string nombre, int edad, float altura) {
    Persona p = {nombre, edad, altura};
    return p;
}

int main() {
    Persona ana = crearPersona("Ana", 22, 1.60f);
    cout << "Nombre: " << ana.nombre << endl;
    cout << "Edad: " << ana.edad << endl;
    cout << "Altura: " << ana.altura << " metros" << endl;
    return 0;
}
```

#### Diferencias entre `struct` y `class`

Aunque `struct` y `class` son similares, tienen algunas diferencias:

- **Acceso Predeterminado:**
  - En `struct`, los miembros son públicos por defecto.
  - En `class`, los miembros son privados por defecto.

- **Herencia:**
  - La herencia pública es la predeterminada para `struct`.
  - La herencia privada es la predeterminada para `class`.

##### Ejemplo Comparativo

```cpp
struct Punto {
    int x; // Público por defecto
    int y;
};

class PuntoClase {
private:
    int x; // Privado por defecto
    int y;
public:
    void setX(int val) { x = val; }
    int getX() { return x; }
};

int main() {
    Punto p1;
    p1.x = 10; // Acceso directo permitido

    PuntoClase p2;
    // p2.x = 10; // Error: x es privado
    p2.setX(10); // Acceso mediante función miembro

    return 0;
}
```

#### Ejemplo Completo

A continuación, un ejemplo completo que muestra la creación y manipulación de estructuras, así como su uso en funciones.

```cpp
#include <iostream>
using namespace std;

struct Fecha {
    int dia;
    int mes;
    int anio;
};

struct Persona {
    string nombre;
    int edad;
    float altura;
    Fecha nacimiento;
};

void imprimirPersona(const Persona& p) {
    cout << "Nombre: " << p.nombre << endl;
    cout << "Edad: " << p.edad << endl;
    cout << "Altura: " << p.altura << " metros" << endl;
    cout << "Fecha de Nacimiento: " << p.nacimiento.dia << "/"
         << p.nacimiento.mes << "/" << p.nacimiento.anio << endl;
}

int main() {
    Fecha fechaNacimiento = {15, 6, 1990};
    Persona juan = {"Juan", 30, 1.75f, fechaNacimiento};

    imprimirPersona(juan);

    Persona maria;
    maria.nombre = "Maria";
    maria.edad = 25;
    maria.altura = 1.65f;
    maria.nacimiento = {12, 10, 1995};

    imprimirPersona(maria);

    return 0;
}
```

En este ejemplo, la estructura `Fecha` se utiliza como un miembro dentro de la estructura `Persona`. La función `imprimirPersona` muestra cómo se pueden acceder y manipular estos datos estructurados.

### Conclusión

Las estructuras (`struct`) en C++ son herramientas poderosas para agrupar datos relacionados y manejarlos de forma cohesiva. Proporcionan una manera clara y eficiente de trabajar con datos complejos y son esenciales para la programación orientada a objetos y el diseño de software modular. Con un entendimiento sólido de `struct`, los desarrolladores pueden escribir código más organizado, mantenible y escalable.
### Enumeraciones (`enum`) y Clases de Enumeración (`enum class`) en C++

Las enumeraciones son tipos de datos definidos por el usuario que consisten en un conjunto de valores constantes integrales, llamados enumeradores. Las enumeraciones son útiles para representar un conjunto fijo de valores relacionados, como días de la semana, estados de un proceso, etc. C++ proporciona dos formas de definir enumeraciones: `enum` (enumeraciones tradicionales) y `enum class` (clases de enumeración).

#### Enumeraciones Tradicionales (`enum`)

Las enumeraciones tradicionales en C++ se declaran con la palabra clave `enum` y son esencialmente un conjunto de constantes integrales.

##### Sintaxis

```cpp
enum NombreEnum {
    valor1,
    valor2,
    // Otros valores
};
```

##### Ejemplo Básico

```cpp
#include <iostream>
using namespace std;

enum DiaSemana {
    Lunes,
    Martes,
    Miercoles,
    Jueves,
    Viernes,
    Sabado,
    Domingo
};

int main() {
    DiaSemana hoy = Miercoles;

    if (hoy == Miercoles) {
        cout << "Hoy es miércoles." << endl;
    }

    return 0;
}
```

En este ejemplo, `DiaSemana` es una enumeración que define los días de la semana.

##### Asignación de Valores Específicos

Por defecto, los enumeradores se asignan a valores enteros comenzando desde 0, pero se pueden asignar valores específicos.

```cpp
enum Mes {
    Enero = 1,
    Febrero,
    Marzo,
    Abril,
    Mayo,
    Junio,
    Julio,
    Agosto,
    Septiembre,
    Octubre,
    Noviembre,
    Diciembre
};
```

En este ejemplo, `Enero` está asignado a 1, y los siguientes enumeradores se incrementan automáticamente.

#### Clases de Enumeración (`enum class`)

Las clases de enumeración, introducidas en C++11, resuelven algunas de las limitaciones de las enumeraciones tradicionales, proporcionando un mayor control sobre el ámbito y el tipo de los enumeradores.

##### Sintaxis

```cpp
enum class NombreEnumClass {
    valor1,
    valor2,
    // Otros valores
};
```

##### Ejemplo Básico

```cpp
#include <iostream>
using namespace std;

enum class Color {
    Rojo,
    Verde,
    Azul
};

int main() {
    Color miColor = Color::Verde;

    if (miColor == Color::Verde) {
        cout << "El color es verde." << endl;
    }

    return 0;
}
```

En este ejemplo, `Color` es una clase de enumeración que define diferentes colores. A diferencia de las enumeraciones tradicionales, los enumeradores en `enum class` están en el ámbito de la clase de enumeración, lo que evita conflictos de nombres.

##### Ventajas de `enum class`

1. **Ámbito Estricto:** Los enumeradores están en el ámbito de la clase de enumeración, evitando conflictos de nombres.
2. **Tipo de Datos Fuertemente Tipado:** Los valores de `enum class` no se convierten implícitamente a tipos enteros, proporcionando una mayor seguridad de tipos.
3. **Asignación de Valores:** Se pueden asignar valores específicos, al igual que en las enumeraciones tradicionales.

##### Ejemplo con Asignación de Valores Específicos

```cpp
#include <iostream>
using namespace std;

enum class Estado {
    Inactivo = 0,
    Activo = 1,
    Suspendido = 2,
    Eliminado = 3
};

int main() {
    Estado usuario = Estado::Activo;

    if (usuario == Estado::Activo) {
        cout << "El usuario está activo." << endl;
    }

    return 0;
}
```

#### Conversión entre Enumeraciones y Enteros

A veces, puede ser necesario convertir entre enumeraciones y enteros. Para las enumeraciones tradicionales, esto se hace implícitamente, mientras que para `enum class`, se requiere una conversión explícita.

##### Ejemplo de Conversión

```cpp
#include <iostream>
using namespace std;

enum class Dia : int {
    Lunes = 1,
    Martes,
    Miercoles,
    Jueves,
    Viernes,
    Sabado,
    Domingo
};

int main() {
    Dia hoy = Dia::Jueves;

    // Conversión explícita de enum class a int
    int diaNumero = static_cast<int>(hoy);
    cout << "Hoy es el día número: " << diaNumero << endl;

    return 0;
}
```

#### Ejemplo Completo

A continuación, un ejemplo completo que ilustra el uso de `enum` y `enum class`, incluyendo conversiones y comparación de ventajas.

```cpp
#include <iostream>
using namespace std;

// Enumeración tradicional
enum DiaSemana {
    Lunes,
    Martes,
    Miercoles,
    Jueves,
    Viernes,
    Sabado,
    Domingo
};

// Clase de enumeración
enum class Estado {
    Inactivo = 0,
    Activo = 1,
    Suspendido = 2,
    Eliminado = 3
};

int main() {
    // Uso de enumeración tradicional
    DiaSemana hoy = Miercoles;
    if (hoy == Miercoles) {
        cout << "Hoy es miércoles." << endl;
    }

    // Uso de clase de enumeración
    Estado usuario = Estado::Activo;
    if (usuario == Estado::Activo) {
        cout << "El usuario está activo." << endl;
    }

    // Conversión explícita de enum class a int
    int estadoNumero = static_cast<int>(usuario);
    cout << "El estado del usuario es: " << estadoNumero << endl;

    return 0;
}
```

### Conclusión

Las enumeraciones (`enum`) y las clases de enumeración (`enum class`) en C++ son herramientas útiles para representar conjuntos de valores constantes. Las enumeraciones tradicionales son simples y fáciles de usar, mientras que las clases de enumeración proporcionan un control más estricto sobre el ámbito y la seguridad de tipos. Comprender las diferencias y las mejores prácticas para usar cada una es crucial para escribir código C++ claro, seguro y eficiente.
### Alias de Tipos en C++: `typedef` y `using`

En C++, `typedef` y `using` se utilizan para crear alias de tipos de datos, lo que puede hacer que el código sea más legible y manejable. Ambos permiten definir un nombre alternativo para un tipo existente, pero `using` ofrece más flexibilidad y características adicionales en C++11 y posteriores.

#### `typedef`

`typedef` es una palabra clave tradicional en C++ que se utiliza para crear alias de tipos de datos. Es especialmente útil para simplificar tipos complejos y mejorar la legibilidad del código.

##### Sintaxis

```cpp
typedef tipo_original nuevo_nombre;
```

##### Ejemplo Básico

```cpp
#include <iostream>
using namespace std;

typedef unsigned long ulong;

int main() {
    ulong numero = 1000000;
    cout << "Número: " << numero << endl;
    return 0;
}
```

En este ejemplo, `unsigned long` se ha renombrado como `ulong`, lo que simplifica el uso del tipo de datos.

##### Alias para Tipos Complejos

```cpp
#include <iostream>
using namespace std;

typedef int (*FuncionPtr)(int, int);

int sumar(int a, int b) {
    return a + b;
}

int main() {
    FuncionPtr fp = sumar;
    cout << "Suma: " << fp(5, 3) << endl;
    return 0;
}
```

En este ejemplo, `typedef` se usa para crear un alias `FuncionPtr` para un puntero a función que toma dos `int` y devuelve un `int`.

#### `using`

`using` es una forma más moderna y flexible de crear alias de tipos en C++. Introducido en C++11, `using` puede hacer todo lo que `typedef` hace y más, como alias de plantillas.

##### Sintaxis

```cpp
using nuevo_nombre = tipo_original;
```

##### Ejemplo Básico

```cpp
#include <iostream>
using namespace std;

using ulong = unsigned long;

int main() {
    ulong numero = 1000000;
    cout << "Número: " << numero << endl;
    return 0;
}
```

##### Alias para Tipos Complejos

```cpp
#include <iostream>
using namespace std;

using FuncionPtr = int(*)(int, int);

int sumar(int a, int b) {
    return a + b;
}

int main() {
    FuncionPtr fp = sumar;
    cout << "Suma: " << fp(5, 3) << endl;
    return 0;
}
```

##### Alias de Plantillas

Una de las características más poderosas de `using` es su capacidad para crear alias de plantillas, lo que `typedef` no puede hacer.

```cpp
#include <iostream>
#include <vector>
using namespace std;

template <typename T>
using Vec = vector<T>;

int main() {
    Vec<int> numeros = {1, 2, 3, 4, 5};
    for (int num : numeros) {
        cout << num << " ";
    }
    cout << endl;
    return 0;
}
```

En este ejemplo, `Vec<T>` es un alias de plantilla para `std::vector<T>`, simplificando la declaración de vectores.

#### Comparación entre `typedef` y `using`

| Característica            | `typedef`                      | `using`                                |
|---------------------------|--------------------------------|----------------------------------------|
| Sintaxis                  | Tradicional                    | Moderna (C++11 y posteriores)          |
| Alias para Tipos Simples  | Sí                             | Sí                                     |
| Alias para Tipos Complejos| Sí                             | Sí                                     |
| Alias de Plantillas       | No                             | Sí                                     |
| Legibilidad               | Menos intuitivo                | Más claro y legible                    |

#### Ejemplo Completo

A continuación, un ejemplo que muestra el uso de `typedef` y `using` para crear alias de tipos simples, complejos y plantillas:

```cpp
#include <iostream>
#include <vector>
using namespace std;

// Alias con typedef
typedef unsigned long ulong;
typedef int (*FuncionPtr)(int, int);

// Alias con using
using ulong_alias = unsigned long;
using FuncionPtr_alias = int(*)(int, int);

template <typename T>
using Vec = vector<T>;

int sumar(int a, int b) {
    return a + b;
}

int main() {
    // Uso de typedef
    ulong numero1 = 1000000;
    FuncionPtr fp1 = sumar;
    cout << "Número1: " << numero1 << endl;
    cout << "Suma1: " << fp1(5, 3) << endl;

    // Uso de using
    ulong_alias numero2 = 2000000;
    FuncionPtr_alias fp2 = sumar;
    cout << "Número2: " << numero2 << endl;
    cout << "Suma2: " << fp2(7, 2) << endl;

    // Uso de alias de plantilla con using
    Vec<int> numeros = {1, 2, 3, 4, 5};
    for (int num : numeros) {
        cout << num << " ";
    }
    cout << endl;

    return 0;
}
```

### Conclusión

`typedef` y `using` son herramientas útiles en C++ para crear alias de tipos de datos, mejorando la legibilidad y manejabilidad del código. Mientras que `typedef` ha sido la forma tradicional de hacerlo, `using` introduce una sintaxis más moderna y flexible, especialmente útil para alias de plantillas. Comprender cómo y cuándo usar cada uno es esencial para escribir código C++ limpio y eficiente.
<---FILES--->
Características de `std::list`
Características de `std::list` Result
Ejemplo de Uso de `std::list`
Ejemplo de Uso de `std::list` Result
Características de `std::queue`
Características de `std::queue` Result
Ejemplo de Uso de `std::queue`
Ejemplo de Uso de `std::queue` Result
Características de `std::list`
Características de `std::list` Result
Ejemplo de Uso de `std::list`
Ejemplo de Uso de `std::list` Result
Características de `std::queue`
Características de `std::queue` Result
Ejemplo de Uso de `std::queue`
Ejemplo de Uso de `std::queue` Result
Características de `std::stack`
Características de `std::stack` Result
Ejemplo de Uso de `std::stack`
Ejemplo de Uso de `std::stack` Result
Características de `std::set`
Características de `std::set` Result
Ejemplo de Uso de `std::set`
Ejemplo de Uso de `std::set` Result
Características de `std::list`
Características de `std::list` Result
Ejemplo de Uso de `std::list`
Ejemplo de Uso de `std::list` Result
Características de `std::queue`
Características de `std::queue` Result
Ejemplo de Uso de `std::queue`
Ejemplo de Uso de `std::queue` Result
Características de `std::stack`
Características de `std::stack` Result
Ejemplo de Uso de `std::stack`
Ejemplo de Uso de `std::stack` Result
Características de `std::set`
Características de `std::set` Result
Ejemplo de Uso de `std::set`
Ejemplo de Uso de `std::set` Result
Características de `std::map`
Características de `std::map` Result
Ejemplo de Uso de `std::map`
Ejemplo de Uso de `std::map` Result
Características de `std::unordered_map`
Características de `std::unordered_map` Result
Ejemplo de Uso de `std::unordered_map`
Ejemplo de Uso de `std::unordered_map` Result
Características de `std::list`
Características de `std::list` Result
Ejemplo de Uso de `std::list`
Ejemplo de Uso de `std::list` Result
Características de `std::queue`
Características de `std::queue` Result
Ejemplo de Uso de `std::queue`
Ejemplo de Uso de `std::queue` Result
Características de `std::stack`
Características de `std::stack` Result
Ejemplo de Uso de `std::stack`
Ejemplo de Uso de `std::stack` Result
Características de `std::set`
Características de `std::set` Result
Ejemplo de Uso de `std::set`
Ejemplo de Uso de `std::set` Result
Características de `std::map`
Características de `std::map` Result
Ejemplo de Uso de `std::map`
Ejemplo de Uso de `std::map` Result
Características de `std::unordered_map`
Características de `std::unordered_map` Result
Ejemplo de Uso de `std::unordered_map`
Ejemplo de Uso de `std::unordered_map` Result
Inicialización Estática
Inicialización Estática Result
Inicialización Dinámica
Inicialización Dinámica Result
Ejemplo de Array Tridimensional
Ejemplo de Array Tridimensional Result
Características de `std::list`
Características de `std::list` Result
Ejemplo de Uso de `std::list`
Ejemplo de Uso de `std::list` Result
Características de `std::queue`
Características de `std::queue` Result
Ejemplo de Uso de `std::queue`
Ejemplo de Uso de `std::queue` Result
Características de `std::stack`
Características de `std::stack` Result
Ejemplo de Uso de `std::stack`
Ejemplo de Uso de `std::stack` Result
Características de `std::set`
Características de `std::set` Result
Ejemplo de Uso de `std::set`
Ejemplo de Uso de `std::set` Result
Características de `std::map`
Características de `std::map` Result
Ejemplo de Uso de `std::map`
Ejemplo de Uso de `std::map` Result
Características de `std::unordered_map`
Características de `std::unordered_map` Result
Ejemplo de Uso de `std::unordered_map`
Ejemplo de Uso de `std::unordered_map` Result
Inicialización Estática
Inicialización Estática Result
Inicialización Dinámica
Inicialización Dinámica Result
Ejemplo de Array Tridimensional
Ejemplo de Array Tridimensional Result
Declaración Básica
Declaración Básica Result
Declaración y Inicialización Simplificada
Declaración y Inicialización Simplificada Result
Ejemplo Completo de Declaración y Inicialización
Ejemplo Completo de Declaración y Inicialización Result
Copia de Cadenas: `strcpy`
Copia de Cadenas: `strcpy` Result
Concatenación de Cadenas: `strcat`
Concatenación de Cadenas: `strcat` Result
Longitud de la Cadena: `strlen`
Longitud de la Cadena: `strlen` Result
Comparación de Cadenas: `strcmp`
Comparación de Cadenas: `strcmp` Result
Lectura de C-Strings con `cin`
Lectura de C-Strings con `cin` Result
Lectura de Cadenas con Espacios usando `cin.getline`
Lectura de Cadenas con Espacios usando `cin.getline` Result
Características de `std::list`
Características de `std::list` Result
Ejemplo de Uso de `std::list`
Ejemplo de Uso de `std::list` Result
Características de `std::queue`
Características de `std::queue` Result
Ejemplo de Uso de `std::queue`
Ejemplo de Uso de `std::queue` Result
Características de `std::stack`
Características de `std::stack` Result
Ejemplo de Uso de `std::stack`
Ejemplo de Uso de `std::stack` Result
Características de `std::set`
Características de `std::set` Result
Ejemplo de Uso de `std::set`
Ejemplo de Uso de `std::set` Result
Características de `std::map`
Características de `std::map` Result
Ejemplo de Uso de `std::map`
Ejemplo de Uso de `std::map` Result
Características de `std::unordered_map`
Características de `std::unordered_map` Result
Ejemplo de Uso de `std::unordered_map`
Ejemplo de Uso de `std::unordered_map` Result
Inicialización Estática
Inicialización Estática Result
Inicialización Dinámica
Inicialización Dinámica Result
Ejemplo de Array Tridimensional
Ejemplo de Array Tridimensional Result
Declaración Básica
Declaración Básica Result
Declaración y Inicialización Simplificada
Declaración y Inicialización Simplificada Result
Ejemplo Completo de Declaración y Inicialización
Ejemplo Completo de Declaración y Inicialización Result
Copia de Cadenas: `strcpy`
Copia de Cadenas: `strcpy` Result
Concatenación de Cadenas: `strcat`
Concatenación de Cadenas: `strcat` Result
Longitud de la Cadena: `strlen`
Longitud de la Cadena: `strlen` Result
Comparación de Cadenas: `strcmp`
Comparación de Cadenas: `strcmp` Result
Lectura de C-Strings con `cin`
Lectura de C-Strings con `cin` Result
Lectura de Cadenas con Espacios usando `cin.getline`
Lectura de Cadenas con Espacios usando `cin.getline` Result
Sintaxis
Sintaxis Result
Ejemplo Básico
Ejemplo Básico Result
Inicialización de Lista
Inicialización de Lista Result
Inicialización Miembro por Miembro
Inicialización Miembro por Miembro Result
Copia de Estructuras
Copia de Estructuras Result
Pasar Estructuras a Funciones
Pasar Estructuras a Funciones Result
Retornar Estructuras desde Funciones
Retornar Estructuras desde Funciones Result
Ejemplo Comparativo
Ejemplo Comparativo Result
Características de `std::list`
Características de `std::list` Result
Ejemplo de Uso de `std::list`
Ejemplo de Uso de `std::list` Result
Características de `std::queue`
Características de `std::queue` Result
Ejemplo de Uso de `std::queue`
Ejemplo de Uso de `std::queue` Result
Características de `std::stack`
Características de `std::stack` Result
Ejemplo de Uso de `std::stack`
Ejemplo de Uso de `std::stack` Result
Características de `std::set`
Características de `std::set` Result
Ejemplo de Uso de `std::set`
Ejemplo de Uso de `std::set` Result
Características de `std::map`
Características de `std::map` Result
Ejemplo de Uso de `std::map`
Ejemplo de Uso de `std::map` Result
Características de `std::unordered_map`
Características de `std::unordered_map` Result
Ejemplo de Uso de `std::unordered_map`
Ejemplo de Uso de `std::unordered_map` Result
Inicialización Estática
Inicialización Estática Result
Inicialización Dinámica
Inicialización Dinámica Result
Ejemplo de Array Tridimensional
Ejemplo de Array Tridimensional Result
Declaración Básica
Declaración Básica Result
Declaración y Inicialización Simplificada
Declaración y Inicialización Simplificada Result
Ejemplo Completo de Declaración y Inicialización
Ejemplo Completo de Declaración y Inicialización Result
Copia de Cadenas: `strcpy`
Copia de Cadenas: `strcpy` Result
Concatenación de Cadenas: `strcat`
Concatenación de Cadenas: `strcat` Result
Longitud de la Cadena: `strlen`
Longitud de la Cadena: `strlen` Result
Comparación de Cadenas: `strcmp`
Comparación de Cadenas: `strcmp` Result
Lectura de C-Strings con `cin`
Lectura de C-Strings con `cin` Result
Lectura de Cadenas con Espacios usando `cin.getline`
Lectura de Cadenas con Espacios usando `cin.getline` Result
Sintaxis
Sintaxis Result
Ejemplo Básico
Ejemplo Básico Result
Inicialización de Lista
Inicialización de Lista Result
Inicialización Miembro por Miembro
Inicialización Miembro por Miembro Result
Copia de Estructuras
Copia de Estructuras Result
Pasar Estructuras a Funciones
Pasar Estructuras a Funciones Result
Retornar Estructuras desde Funciones
Retornar Estructuras desde Funciones Result
Ejemplo Comparativo
Ejemplo Comparativo Result
Asignación de Valores Específicos
Asignación de Valores Específicos Result
Ventajas de `enum class`
Ventajas de `enum class` Result
Ejemplo con Asignación de Valores Específicos
Ejemplo con Asignación de Valores Específicos Result
Ejemplo de Conversión
Ejemplo de Conversión Result
Características de `std::list`
Características de `std::list` Result
Ejemplo de Uso de `std::list`
Ejemplo de Uso de `std::list` Result
Características de `std::queue`
Características de `std::queue` Result
Ejemplo de Uso de `std::queue`
Ejemplo de Uso de `std::queue` Result
Características de `std::stack`
Características de `std::stack` Result
Ejemplo de Uso de `std::stack`
Ejemplo de Uso de `std::stack` Result
Características de `std::set`
Características de `std::set` Result
Ejemplo de Uso de `std::set`
Ejemplo de Uso de `std::set` Result
Características de `std::map`
Características de `std::map` Result
Ejemplo de Uso de `std::map`
Ejemplo de Uso de `std::map` Result
Características de `std::unordered_map`
Características de `std::unordered_map` Result
Ejemplo de Uso de `std::unordered_map`
Ejemplo de Uso de `std::unordered_map` Result
Inicialización Estática
Inicialización Estática Result
Inicialización Dinámica
Inicialización Dinámica Result
Ejemplo de Array Tridimensional
Ejemplo de Array Tridimensional Result
Declaración Básica
Declaración Básica Result
Declaración y Inicialización Simplificada
Declaración y Inicialización Simplificada Result
Ejemplo Completo de Declaración y Inicialización
Ejemplo Completo de Declaración y Inicialización Result
Copia de Cadenas: `strcpy`
Copia de Cadenas: `strcpy` Result
Concatenación de Cadenas: `strcat`
Concatenación de Cadenas: `strcat` Result
Longitud de la Cadena: `strlen`
Longitud de la Cadena: `strlen` Result
Comparación de Cadenas: `strcmp`
Comparación de Cadenas: `strcmp` Result
Lectura de C-Strings con `cin`
Lectura de C-Strings con `cin` Result
Lectura de Cadenas con Espacios usando `cin.getline`
Lectura de Cadenas con Espacios usando `cin.getline` Result
Sintaxis
Sintaxis Result
Ejemplo Básico
Ejemplo Básico Result
Inicialización de Lista
Inicialización de Lista Result
Inicialización Miembro por Miembro
Inicialización Miembro por Miembro Result
Copia de Estructuras
Copia de Estructuras Result
Pasar Estructuras a Funciones
Pasar Estructuras a Funciones Result
Retornar Estructuras desde Funciones
Retornar Estructuras desde Funciones Result
Ejemplo Comparativo
Ejemplo Comparativo Result
Asignación de Valores Específicos
Asignación de Valores Específicos Result
Ventajas de `enum class`
Ventajas de `enum class` Result
Ejemplo con Asignación de Valores Específicos
Ejemplo con Asignación de Valores Específicos Result
Ejemplo de Conversión
Ejemplo de Conversión Result
Alias para Tipos Complejos
Alias para Tipos Complejos Result
Alias de Plantillas
Alias de Plantillas Result
<---Características de `std::list`--->
<---Características de `std::list` Result--->
<---Ejemplo de Uso de `std::list`--->
```cpp
#include <iostream>
#include <list>
using namespace std;

int main() {
    // Declaración e inicialización de una lista
    list<int> miLista = {10, 20, 30, 40};

    // Inserción de elementos
    miLista.push_back(50);  // Añade al final
    miLista.push_front(5);  // Añade al inicio

    // Iteración y acceso a los elementos
    for (int elemento : miLista) {
        cout << elemento << " ";
    }
    cout << endl;

    // Eliminación de elementos
    miLista.pop_back();  // Elimina el último elemento
    miLista.pop_front(); // Elimina el primer elemento

    // Iteración y acceso a los elementos después de la eliminación
    for (int elemento : miLista) {
        cout << elemento << " ";
    }
    cout << endl;

    return 0;
}
<---Ejemplo de Uso de `std::list` Result--->
<---Características de `std::queue`--->
<---Características de `std::queue` Result--->
<---Ejemplo de Uso de `std::queue`--->
```cpp
#include <iostream>
#include <queue>
using namespace std;

int main() {
    // Declaración e inicialización de una cola
    queue<int> miCola;

    // Inserción de elementos
    miCola.push(10);
    miCola.push(20);
    miCola.push(30);

    // Acceso al primer y último elemento
    cout << "Frente: " << miCola.front() << endl;
    cout << "Final: " << miCola.back() << endl;

    // Eliminación de elementos
    miCola.pop(); // Elimina el primer elemento (10)

    // Acceso después de la eliminación
    cout << "Frente después de pop: " << miCola.front() << endl;

    return 0;
}
```cpp
#include <iostream>
#include <list>
#include <queue>
using namespace std;

int main() {
    // Uso de std::list
    list<int> miLista = {1, 2, 3, 4, 5};
    miLista.push_back(6);
    miLista.push_front(0);

    cout << "Lista: ";
    for (int elemento : miLista) {
        cout << elemento << " ";
    }
    cout << endl;

    miLista.pop_back();
    miLista.pop_front();

    cout << "Lista después de pop: ";
    for (int elemento : miLista) {
        cout << elemento << " ";
    }
    cout << endl;

    // Uso de std::queue
    queue<int> miCola;
    miCola.push(10);
    miCola.push(20);
    miCola.push(30);

    cout << "Cola frente: " << miCola.front() << ", final: " << miCola.back() << endl;
    miCola.pop();
    cout << "Cola frente después de pop: " << miCola.front() << endl;

    return 0;
}
<---Ejemplo de Uso de `std::queue` Result--->
<---Características de `std::list`--->
<---Características de `std::list` Result--->
<---Ejemplo de Uso de `std::list`--->
```cpp
#include <iostream>
#include <list>
using namespace std;

int main() {
    // Declaración e inicialización de una lista
    list<int> miLista = {10, 20, 30, 40};

    // Inserción de elementos
    miLista.push_back(50);  // Añade al final
    miLista.push_front(5);  // Añade al inicio

    // Iteración y acceso a los elementos
    for (int elemento : miLista) {
        cout << elemento << " ";
    }
    cout << endl;

    // Eliminación de elementos
    miLista.pop_back();  // Elimina el último elemento
    miLista.pop_front(); // Elimina el primer elemento

    // Iteración y acceso a los elementos después de la eliminación
    for (int elemento : miLista) {
        cout << elemento << " ";
    }
    cout << endl;

    return 0;
}
<---Ejemplo de Uso de `std::list` Result--->
<---Características de `std::queue`--->
<---Características de `std::queue` Result--->
<---Ejemplo de Uso de `std::queue`--->
```cpp
#include <iostream>
#include <queue>
using namespace std;

int main() {
    // Declaración e inicialización de una cola
    queue<int> miCola;

    // Inserción de elementos
    miCola.push(10);
    miCola.push(20);
    miCola.push(30);

    // Acceso al primer y último elemento
    cout << "Frente: " << miCola.front() << endl;
    cout << "Final: " << miCola.back() << endl;

    // Eliminación de elementos
    miCola.pop(); // Elimina el primer elemento (10)

    // Acceso después de la eliminación
    cout << "Frente después de pop: " << miCola.front() << endl;

    return 0;
}
```cpp
#include <iostream>
#include <list>
#include <queue>
using namespace std;

int main() {
    // Uso de std::list
    list<int> miLista = {1, 2, 3, 4, 5};
    miLista.push_back(6);
    miLista.push_front(0);

    cout << "Lista: ";
    for (int elemento : miLista) {
        cout << elemento << " ";
    }
    cout << endl;

    miLista.pop_back();
    miLista.pop_front();

    cout << "Lista después de pop: ";
    for (int elemento : miLista) {
        cout << elemento << " ";
    }
    cout << endl;

    // Uso de std::queue
    queue<int> miCola;
    miCola.push(10);
    miCola.push(20);
    miCola.push(30);

    cout << "Cola frente: " << miCola.front() << ", final: " << miCola.back() << endl;
    miCola.pop();
    cout << "Cola frente después de pop: " << miCola.front() << endl;

    return 0;
}
<---Ejemplo de Uso de `std::queue` Result--->
<---Características de `std::stack`--->
<---Características de `std::stack` Result--->
<---Ejemplo de Uso de `std::stack`--->
```cpp
#include <iostream>
#include <stack>
using namespace std;

int main() {
    // Declaración e inicialización de una pila
    stack<int> miPila;

    // Inserción de elementos
    miPila.push(10);
    miPila.push(20);
    miPila.push(30);

    // Acceso al elemento superior
    cout << "Elemento superior: " << miPila.top() << endl;

    // Eliminación de elementos
    miPila.pop(); // Elimina el elemento superior (30)

    // Acceso después de la eliminación
    cout << "Elemento superior después de pop: " << miPila.top() << endl;

    return 0;
}
<---Ejemplo de Uso de `std::stack` Result--->
<---Características de `std::set`--->
<---Características de `std::set` Result--->
<---Ejemplo de Uso de `std::set`--->
```cpp
#include <iostream>
#include <set>
using namespace std;

int main() {
    // Declaración e inicialización de un conjunto
    set<int> miConjunto = {30, 10, 20, 40};

    // Inserción de elementos
    miConjunto.insert(50);
    miConjunto.insert(20); // No se añade ya que 20 ya existe

    // Iteración y acceso a los elementos
    cout << "Conjunto: ";
    for (int elemento : miConjunto) {
        cout << elemento << " ";
    }
    cout << endl;

    // Eliminación de un elemento
    miConjunto.erase(30);

    // Iteración y acceso a los elementos después de la eliminación
    cout << "Conjunto después de erase: ";
    for (int elemento : miConjunto) {
        cout << elemento << " ";
    }
    cout << endl;

    return 0;
}
```cpp
#include <iostream>
#include <stack>
#include <set>
using namespace std;

int main() {
    // Uso de std::stack
    stack<int> miPila;
    miPila.push(10);
    miPila.push(20);
    miPila.push(30);
    cout << "Pila elemento superior: " << miPila.top() << endl;
    miPila.pop();
    cout << "Pila elemento superior después de pop: " << miPila.top() << endl;

    // Uso de std::set
    set<int> miConjunto = {30, 10, 20, 40};
    miConjunto.insert(50);
    cout << "Conjunto: ";
    for (int elemento : miConjunto) {
        cout << elemento << " ";
    }
    cout << endl;
    miConjunto.erase(30);
    cout << "Conjunto después de erase: ";
    for (int elemento : miConjunto) {
        cout << elemento << " ";
    }
    cout << endl;

    return 0;
}
<---Ejemplo de Uso de `std::set` Result--->
<---Características de `std::list`--->
<---Características de `std::list` Result--->
<---Ejemplo de Uso de `std::list`--->
```cpp
#include <iostream>
#include <list>
using namespace std;

int main() {
    // Declaración e inicialización de una lista
    list<int> miLista = {10, 20, 30, 40};

    // Inserción de elementos
    miLista.push_back(50);  // Añade al final
    miLista.push_front(5);  // Añade al inicio

    // Iteración y acceso a los elementos
    for (int elemento : miLista) {
        cout << elemento << " ";
    }
    cout << endl;

    // Eliminación de elementos
    miLista.pop_back();  // Elimina el último elemento
    miLista.pop_front(); // Elimina el primer elemento

    // Iteración y acceso a los elementos después de la eliminación
    for (int elemento : miLista) {
        cout << elemento << " ";
    }
    cout << endl;

    return 0;
}
<---Ejemplo de Uso de `std::list` Result--->
<---Características de `std::queue`--->
<---Características de `std::queue` Result--->
<---Ejemplo de Uso de `std::queue`--->
```cpp
#include <iostream>
#include <queue>
using namespace std;

int main() {
    // Declaración e inicialización de una cola
    queue<int> miCola;

    // Inserción de elementos
    miCola.push(10);
    miCola.push(20);
    miCola.push(30);

    // Acceso al primer y último elemento
    cout << "Frente: " << miCola.front() << endl;
    cout << "Final: " << miCola.back() << endl;

    // Eliminación de elementos
    miCola.pop(); // Elimina el primer elemento (10)

    // Acceso después de la eliminación
    cout << "Frente después de pop: " << miCola.front() << endl;

    return 0;
}
```cpp
#include <iostream>
#include <list>
#include <queue>
using namespace std;

int main() {
    // Uso de std::list
    list<int> miLista = {1, 2, 3, 4, 5};
    miLista.push_back(6);
    miLista.push_front(0);

    cout << "Lista: ";
    for (int elemento : miLista) {
        cout << elemento << " ";
    }
    cout << endl;

    miLista.pop_back();
    miLista.pop_front();

    cout << "Lista después de pop: ";
    for (int elemento : miLista) {
        cout << elemento << " ";
    }
    cout << endl;

    // Uso de std::queue
    queue<int> miCola;
    miCola.push(10);
    miCola.push(20);
    miCola.push(30);

    cout << "Cola frente: " << miCola.front() << ", final: " << miCola.back() << endl;
    miCola.pop();
    cout << "Cola frente después de pop: " << miCola.front() << endl;

    return 0;
}
<---Ejemplo de Uso de `std::queue` Result--->
<---Características de `std::stack`--->
<---Características de `std::stack` Result--->
<---Ejemplo de Uso de `std::stack`--->
```cpp
#include <iostream>
#include <stack>
using namespace std;

int main() {
    // Declaración e inicialización de una pila
    stack<int> miPila;

    // Inserción de elementos
    miPila.push(10);
    miPila.push(20);
    miPila.push(30);

    // Acceso al elemento superior
    cout << "Elemento superior: " << miPila.top() << endl;

    // Eliminación de elementos
    miPila.pop(); // Elimina el elemento superior (30)

    // Acceso después de la eliminación
    cout << "Elemento superior después de pop: " << miPila.top() << endl;

    return 0;
}
<---Ejemplo de Uso de `std::stack` Result--->
<---Características de `std::set`--->
<---Características de `std::set` Result--->
<---Ejemplo de Uso de `std::set`--->
```cpp
#include <iostream>
#include <set>
using namespace std;

int main() {
    // Declaración e inicialización de un conjunto
    set<int> miConjunto = {30, 10, 20, 40};

    // Inserción de elementos
    miConjunto.insert(50);
    miConjunto.insert(20); // No se añade ya que 20 ya existe

    // Iteración y acceso a los elementos
    cout << "Conjunto: ";
    for (int elemento : miConjunto) {
        cout << elemento << " ";
    }
    cout << endl;

    // Eliminación de un elemento
    miConjunto.erase(30);

    // Iteración y acceso a los elementos después de la eliminación
    cout << "Conjunto después de erase: ";
    for (int elemento : miConjunto) {
        cout << elemento << " ";
    }
    cout << endl;

    return 0;
}
```cpp
#include <iostream>
#include <stack>
#include <set>
using namespace std;

int main() {
    // Uso de std::stack
    stack<int> miPila;
    miPila.push(10);
    miPila.push(20);
    miPila.push(30);
    cout << "Pila elemento superior: " << miPila.top() << endl;
    miPila.pop();
    cout << "Pila elemento superior después de pop: " << miPila.top() << endl;

    // Uso de std::set
    set<int> miConjunto = {30, 10, 20, 40};
    miConjunto.insert(50);
    cout << "Conjunto: ";
    for (int elemento : miConjunto) {
        cout << elemento << " ";
    }
    cout << endl;
    miConjunto.erase(30);
    cout << "Conjunto después de erase: ";
    for (int elemento : miConjunto) {
        cout << elemento << " ";
    }
    cout << endl;

    return 0;
}
<---Ejemplo de Uso de `std::set` Result--->
<---Características de `std::map`--->
<---Características de `std::map` Result--->
<---Ejemplo de Uso de `std::map`--->
```cpp
#include <iostream>
#include <map>
using namespace std;

int main() {
    // Declaración e inicialización de un mapa
    map<string, int> edades;
    edades["Juan"] = 30;
    edades["Maria"] = 25;
    edades["Pedro"] = 35;

    // Iteración y acceso a los elementos
    for (const auto& par : edades) {
        cout << par.first << " tiene " << par.second << " años." << endl;
    }

    // Acceso a un valor específico
    cout << "La edad de Maria es: " << edades["Maria"] << endl;

    // Modificación de un valor
    edades["Maria"] = 26;
    cout << "La nueva edad de Maria es: " << edades["Maria"] << endl;

    // Eliminación de un elemento
    edades.erase("Pedro");

    // Iteración después de la eliminación
    for (const auto& par : edades) {
        cout << par.first << " tiene " << par.second << " años." << endl;
    }

    return 0;
}
<---Ejemplo de Uso de `std::map` Result--->
<---Características de `std::unordered_map`--->
<---Características de `std::unordered_map` Result--->
<---Ejemplo de Uso de `std::unordered_map`--->
```cpp
#include <iostream>
#include <unordered_map>
using namespace std;

int main() {
    // Declaración e inicialización de un unordered_map
    unordered_map<string, int> edades;
    edades["Juan"] = 30;
    edades["Maria"] = 25;
    edades["Pedro"] = 35;

    // Iteración y acceso a los elementos
    for (const auto& par : edades) {
        cout << par.first << " tiene " << par.second << " años." << endl;
    }

    // Acceso a un valor específico
    cout << "La edad de Maria es: " << edades["Maria"] << endl;

    // Modificación de un valor
    edades["Maria"] = 26;
    cout << "La nueva edad de Maria es: " << edades["Maria"] << endl;

    // Eliminación de un elemento
    edades.erase("Pedro");

    // Iteración después de la eliminación
    for (const auto& par : edades) {
        cout << par.first << " tiene " << par.second << " años." << endl;
    }

    return 0;
}
```cpp
#include <iostream>
#include <map>
#include <unordered_map>
using namespace std;

int main() {
    // Uso de std::map
    map<string, int> mapaOrdenado;
    mapaOrdenado["Juan"] = 30;
    mapaOrdenado["Maria"] = 25;
    mapaOrdenado["Pedro"] = 35;

    cout << "Mapa ordenado:" << endl;
    for (const auto& par : mapaOrdenado) {
        cout << par.first << " tiene " << par.second << " años." << endl;
    }

    // Uso de std::unordered_map
    unordered_map<string, int> mapaNoOrdenado;
    mapaNoOrdenado["Juan"] = 30;
    mapaNoOrdenado["Maria"] = 25;
    mapaNoOrdenado["Pedro"] = 35;

    cout << "\nMapa no ordenado:" << endl;
    for (const auto& par : mapaNoOrdenado) {
        cout << par.first << " tiene " << par.second << " años." << endl;
    }

    return 0;
}
<---Ejemplo de Uso de `std::unordered_map` Result--->
<---Características de `std::list`--->
<---Características de `std::list` Result--->
<---Ejemplo de Uso de `std::list`--->
```cpp
#include <iostream>
#include <list>
using namespace std;

int main() {
    // Declaración e inicialización de una lista
    list<int> miLista = {10, 20, 30, 40};

    // Inserción de elementos
    miLista.push_back(50);  // Añade al final
    miLista.push_front(5);  // Añade al inicio

    // Iteración y acceso a los elementos
    for (int elemento : miLista) {
        cout << elemento << " ";
    }
    cout << endl;

    // Eliminación de elementos
    miLista.pop_back();  // Elimina el último elemento
    miLista.pop_front(); // Elimina el primer elemento

    // Iteración y acceso a los elementos después de la eliminación
    for (int elemento : miLista) {
        cout << elemento << " ";
    }
    cout << endl;

    return 0;
}
<---Ejemplo de Uso de `std::list` Result--->
<---Características de `std::queue`--->
<---Características de `std::queue` Result--->
<---Ejemplo de Uso de `std::queue`--->
```cpp
#include <iostream>
#include <queue>
using namespace std;

int main() {
    // Declaración e inicialización de una cola
    queue<int> miCola;

    // Inserción de elementos
    miCola.push(10);
    miCola.push(20);
    miCola.push(30);

    // Acceso al primer y último elemento
    cout << "Frente: " << miCola.front() << endl;
    cout << "Final: " << miCola.back() << endl;

    // Eliminación de elementos
    miCola.pop(); // Elimina el primer elemento (10)

    // Acceso después de la eliminación
    cout << "Frente después de pop: " << miCola.front() << endl;

    return 0;
}
```cpp
#include <iostream>
#include <list>
#include <queue>
using namespace std;

int main() {
    // Uso de std::list
    list<int> miLista = {1, 2, 3, 4, 5};
    miLista.push_back(6);
    miLista.push_front(0);

    cout << "Lista: ";
    for (int elemento : miLista) {
        cout << elemento << " ";
    }
    cout << endl;

    miLista.pop_back();
    miLista.pop_front();

    cout << "Lista después de pop: ";
    for (int elemento : miLista) {
        cout << elemento << " ";
    }
    cout << endl;

    // Uso de std::queue
    queue<int> miCola;
    miCola.push(10);
    miCola.push(20);
    miCola.push(30);

    cout << "Cola frente: " << miCola.front() << ", final: " << miCola.back() << endl;
    miCola.pop();
    cout << "Cola frente después de pop: " << miCola.front() << endl;

    return 0;
}
<---Ejemplo de Uso de `std::queue` Result--->
<---Características de `std::stack`--->
<---Características de `std::stack` Result--->
<---Ejemplo de Uso de `std::stack`--->
```cpp
#include <iostream>
#include <stack>
using namespace std;

int main() {
    // Declaración e inicialización de una pila
    stack<int> miPila;

    // Inserción de elementos
    miPila.push(10);
    miPila.push(20);
    miPila.push(30);

    // Acceso al elemento superior
    cout << "Elemento superior: " << miPila.top() << endl;

    // Eliminación de elementos
    miPila.pop(); // Elimina el elemento superior (30)

    // Acceso después de la eliminación
    cout << "Elemento superior después de pop: " << miPila.top() << endl;

    return 0;
}
<---Ejemplo de Uso de `std::stack` Result--->
<---Características de `std::set`--->
<---Características de `std::set` Result--->
<---Ejemplo de Uso de `std::set`--->
```cpp
#include <iostream>
#include <set>
using namespace std;

int main() {
    // Declaración e inicialización de un conjunto
    set<int> miConjunto = {30, 10, 20, 40};

    // Inserción de elementos
    miConjunto.insert(50);
    miConjunto.insert(20); // No se añade ya que 20 ya existe

    // Iteración y acceso a los elementos
    cout << "Conjunto: ";
    for (int elemento : miConjunto) {
        cout << elemento << " ";
    }
    cout << endl;

    // Eliminación de un elemento
    miConjunto.erase(30);

    // Iteración y acceso a los elementos después de la eliminación
    cout << "Conjunto después de erase: ";
    for (int elemento : miConjunto) {
        cout << elemento << " ";
    }
    cout << endl;

    return 0;
}
```cpp
#include <iostream>
#include <stack>
#include <set>
using namespace std;

int main() {
    // Uso de std::stack
    stack<int> miPila;
    miPila.push(10);
    miPila.push(20);
    miPila.push(30);
    cout << "Pila elemento superior: " << miPila.top() << endl;
    miPila.pop();
    cout << "Pila elemento superior después de pop: " << miPila.top() << endl;

    // Uso de std::set
    set<int> miConjunto = {30, 10, 20, 40};
    miConjunto.insert(50);
    cout << "Conjunto: ";
    for (int elemento : miConjunto) {
        cout << elemento << " ";
    }
    cout << endl;
    miConjunto.erase(30);
    cout << "Conjunto después de erase: ";
    for (int elemento : miConjunto) {
        cout << elemento << " ";
    }
    cout << endl;

    return 0;
}
<---Ejemplo de Uso de `std::set` Result--->
<---Características de `std::map`--->
<---Características de `std::map` Result--->
<---Ejemplo de Uso de `std::map`--->
```cpp
#include <iostream>
#include <map>
using namespace std;

int main() {
    // Declaración e inicialización de un mapa
    map<string, int> edades;
    edades["Juan"] = 30;
    edades["Maria"] = 25;
    edades["Pedro"] = 35;

    // Iteración y acceso a los elementos
    for (const auto& par : edades) {
        cout << par.first << " tiene " << par.second << " años." << endl;
    }

    // Acceso a un valor específico
    cout << "La edad de Maria es: " << edades["Maria"] << endl;

    // Modificación de un valor
    edades["Maria"] = 26;
    cout << "La nueva edad de Maria es: " << edades["Maria"] << endl;

    // Eliminación de un elemento
    edades.erase("Pedro");

    // Iteración después de la eliminación
    for (const auto& par : edades) {
        cout << par.first << " tiene " << par.second << " años." << endl;
    }

    return 0;
}
<---Ejemplo de Uso de `std::map` Result--->
<---Características de `std::unordered_map`--->
<---Características de `std::unordered_map` Result--->
<---Ejemplo de Uso de `std::unordered_map`--->
```cpp
#include <iostream>
#include <unordered_map>
using namespace std;

int main() {
    // Declaración e inicialización de un unordered_map
    unordered_map<string, int> edades;
    edades["Juan"] = 30;
    edades["Maria"] = 25;
    edades["Pedro"] = 35;

    // Iteración y acceso a los elementos
    for (const auto& par : edades) {
        cout << par.first << " tiene " << par.second << " años." << endl;
    }

    // Acceso a un valor específico
    cout << "La edad de Maria es: " << edades["Maria"] << endl;

    // Modificación de un valor
    edades["Maria"] = 26;
    cout << "La nueva edad de Maria es: " << edades["Maria"] << endl;

    // Eliminación de un elemento
    edades.erase("Pedro");

    // Iteración después de la eliminación
    for (const auto& par : edades) {
        cout << par.first << " tiene " << par.second << " años." << endl;
    }

    return 0;
}
```cpp
#include <iostream>
#include <map>
#include <unordered_map>
using namespace std;

int main() {
    // Uso de std::map
    map<string, int> mapaOrdenado;
    mapaOrdenado["Juan"] = 30;
    mapaOrdenado["Maria"] = 25;
    mapaOrdenado["Pedro"] = 35;

    cout << "Mapa ordenado:" << endl;
    for (const auto& par : mapaOrdenado) {
        cout << par.first << " tiene " << par.second << " años." << endl;
    }

    // Uso de std::unordered_map
    unordered_map<string, int> mapaNoOrdenado;
    mapaNoOrdenado["Juan"] = 30;
    mapaNoOrdenado["Maria"] = 25;
    mapaNoOrdenado["Pedro"] = 35;

    cout << "\nMapa no ordenado:" << endl;
    for (const auto& par : mapaNoOrdenado) {
        cout << par.first << " tiene " << par.second << " años." << endl;
    }

    return 0;
}
<---Ejemplo de Uso de `std::unordered_map` Result--->
<---Inicialización Estática--->
```cpp
int matriz[2][3] = {
    {1, 2, 3},
    {4, 5, 6}
};
<---Inicialización Estática Result--->
<---Inicialización Dinámica--->
```cpp
#include <iostream>
using namespace std;

int main() {
    int filas = 3;
    int columnas = 3;

    // Declaración de un puntero a puntero
    int** matriz = new int*[filas];

    // Asignación de memoria para cada fila
    for (int i = 0; i < filas; ++i) {
        matriz[i] = new int[columnas];
    }

    // Inicialización de la matriz
    int contador = 1;
    for (int i = 0; i < filas; ++i) {
        for (int j = 0; j < columnas; ++j) {
            matriz[i][j] = contador++;
        }
    }

    // Acceso a los elementos de la matriz
    for (int i = 0; i < filas; ++i) {
        for (int j = 0; j < columnas; ++j) {
            cout << "Elemento [" << i << "][" << j << "]: " << matriz[i][j] << endl;
        }
    }

    // Liberación de la memoria
    for (int i = 0; i < filas; ++i) {
        delete[] matriz[i];
    }
    delete[] matriz;

    return 0;
}
<---Inicialización Dinámica Result--->
<---Ejemplo de Array Tridimensional--->
```cpp
#include <iostream>
using namespace std;

int main() {
    // Declaración de un array 2x2x2
    int cubo[2][2][2] = {
        {
            {1, 2},
            {3, 4}
        },
        {
            {5, 6},
            {7, 8}
        }
    };

    // Acceso a los elementos del array tridimensional
    for (int i = 0; i < 2; ++i) {
        for (int j = 0; j < 2; ++j) {
            for (int k = 0; k < 2; ++k) {
                cout << "Elemento [" << i << "][" << j << "][" << k << "]: " << cubo[i][j][k] << endl;
            }
        }
    }

    return 0;
}
```cpp
#include <iostream>
using namespace std;

int main() {
    int filas = 3;
    int columnas = 3;

    // Declaración de un puntero a puntero
    int** matriz = new int*[filas];

    // Asignación de memoria para cada fila
    for (int i = 0; i < filas; ++i) {
        matriz[i] = new int[columnas];
    }

    // Inicialización de la matriz
    int contador = 1;
    for (int i = 0; i < filas; ++i) {
        for (int j = 0; j < columnas; ++j) {
            matriz[i][j] = contador++;
        }
    }

    // Acceso a los elementos de la matriz
    cout << "Matriz inicializada:" << endl;
    for (int i = 0; i < filas; ++i) {
        for (int j = 0; j < columnas; ++j) {
            cout << matriz[i][j] << " ";
        }
        cout << endl;
    }

    // Liberación de la memoria
    for (int i = 0; i < filas; ++i) {
        delete[] matriz[i];
    }
    delete[] matriz;

    return 0;
}
<---Ejemplo de Array Tridimensional Result--->
<---Características de `std::list`--->
<---Características de `std::list` Result--->
<---Ejemplo de Uso de `std::list`--->
```cpp
#include <iostream>
#include <list>
using namespace std;

int main() {
    // Declaración e inicialización de una lista
    list<int> miLista = {10, 20, 30, 40};

    // Inserción de elementos
    miLista.push_back(50);  // Añade al final
    miLista.push_front(5);  // Añade al inicio

    // Iteración y acceso a los elementos
    for (int elemento : miLista) {
        cout << elemento << " ";
    }
    cout << endl;

    // Eliminación de elementos
    miLista.pop_back();  // Elimina el último elemento
    miLista.pop_front(); // Elimina el primer elemento

    // Iteración y acceso a los elementos después de la eliminación
    for (int elemento : miLista) {
        cout << elemento << " ";
    }
    cout << endl;

    return 0;
}
<---Ejemplo de Uso de `std::list` Result--->
<---Características de `std::queue`--->
<---Características de `std::queue` Result--->
<---Ejemplo de Uso de `std::queue`--->
```cpp
#include <iostream>
#include <queue>
using namespace std;

int main() {
    // Declaración e inicialización de una cola
    queue<int> miCola;

    // Inserción de elementos
    miCola.push(10);
    miCola.push(20);
    miCola.push(30);

    // Acceso al primer y último elemento
    cout << "Frente: " << miCola.front() << endl;
    cout << "Final: " << miCola.back() << endl;

    // Eliminación de elementos
    miCola.pop(); // Elimina el primer elemento (10)

    // Acceso después de la eliminación
    cout << "Frente después de pop: " << miCola.front() << endl;

    return 0;
}
```cpp
#include <iostream>
#include <list>
#include <queue>
using namespace std;

int main() {
    // Uso de std::list
    list<int> miLista = {1, 2, 3, 4, 5};
    miLista.push_back(6);
    miLista.push_front(0);

    cout << "Lista: ";
    for (int elemento : miLista) {
        cout << elemento << " ";
    }
    cout << endl;

    miLista.pop_back();
    miLista.pop_front();

    cout << "Lista después de pop: ";
    for (int elemento : miLista) {
        cout << elemento << " ";
    }
    cout << endl;

    // Uso de std::queue
    queue<int> miCola;
    miCola.push(10);
    miCola.push(20);
    miCola.push(30);

    cout << "Cola frente: " << miCola.front() << ", final: " << miCola.back() << endl;
    miCola.pop();
    cout << "Cola frente después de pop: " << miCola.front() << endl;

    return 0;
}
<---Ejemplo de Uso de `std::queue` Result--->
<---Características de `std::stack`--->
<---Características de `std::stack` Result--->
<---Ejemplo de Uso de `std::stack`--->
```cpp
#include <iostream>
#include <stack>
using namespace std;

int main() {
    // Declaración e inicialización de una pila
    stack<int> miPila;

    // Inserción de elementos
    miPila.push(10);
    miPila.push(20);
    miPila.push(30);

    // Acceso al elemento superior
    cout << "Elemento superior: " << miPila.top() << endl;

    // Eliminación de elementos
    miPila.pop(); // Elimina el elemento superior (30)

    // Acceso después de la eliminación
    cout << "Elemento superior después de pop: " << miPila.top() << endl;

    return 0;
}
<---Ejemplo de Uso de `std::stack` Result--->
<---Características de `std::set`--->
<---Características de `std::set` Result--->
<---Ejemplo de Uso de `std::set`--->
```cpp
#include <iostream>
#include <set>
using namespace std;

int main() {
    // Declaración e inicialización de un conjunto
    set<int> miConjunto = {30, 10, 20, 40};

    // Inserción de elementos
    miConjunto.insert(50);
    miConjunto.insert(20); // No se añade ya que 20 ya existe

    // Iteración y acceso a los elementos
    cout << "Conjunto: ";
    for (int elemento : miConjunto) {
        cout << elemento << " ";
    }
    cout << endl;

    // Eliminación de un elemento
    miConjunto.erase(30);

    // Iteración y acceso a los elementos después de la eliminación
    cout << "Conjunto después de erase: ";
    for (int elemento : miConjunto) {
        cout << elemento << " ";
    }
    cout << endl;

    return 0;
}
```cpp
#include <iostream>
#include <stack>
#include <set>
using namespace std;

int main() {
    // Uso de std::stack
    stack<int> miPila;
    miPila.push(10);
    miPila.push(20);
    miPila.push(30);
    cout << "Pila elemento superior: " << miPila.top() << endl;
    miPila.pop();
    cout << "Pila elemento superior después de pop: " << miPila.top() << endl;

    // Uso de std::set
    set<int> miConjunto = {30, 10, 20, 40};
    miConjunto.insert(50);
    cout << "Conjunto: ";
    for (int elemento : miConjunto) {
        cout << elemento << " ";
    }
    cout << endl;
    miConjunto.erase(30);
    cout << "Conjunto después de erase: ";
    for (int elemento : miConjunto) {
        cout << elemento << " ";
    }
    cout << endl;

    return 0;
}
<---Ejemplo de Uso de `std::set` Result--->
<---Características de `std::map`--->
<---Características de `std::map` Result--->
<---Ejemplo de Uso de `std::map`--->
```cpp
#include <iostream>
#include <map>
using namespace std;

int main() {
    // Declaración e inicialización de un mapa
    map<string, int> edades;
    edades["Juan"] = 30;
    edades["Maria"] = 25;
    edades["Pedro"] = 35;

    // Iteración y acceso a los elementos
    for (const auto& par : edades) {
        cout << par.first << " tiene " << par.second << " años." << endl;
    }

    // Acceso a un valor específico
    cout << "La edad de Maria es: " << edades["Maria"] << endl;

    // Modificación de un valor
    edades["Maria"] = 26;
    cout << "La nueva edad de Maria es: " << edades["Maria"] << endl;

    // Eliminación de un elemento
    edades.erase("Pedro");

    // Iteración después de la eliminación
    for (const auto& par : edades) {
        cout << par.first << " tiene " << par.second << " años." << endl;
    }

    return 0;
}
<---Ejemplo de Uso de `std::map` Result--->
<---Características de `std::unordered_map`--->
<---Características de `std::unordered_map` Result--->
<---Ejemplo de Uso de `std::unordered_map`--->
```cpp
#include <iostream>
#include <unordered_map>
using namespace std;

int main() {
    // Declaración e inicialización de un unordered_map
    unordered_map<string, int> edades;
    edades["Juan"] = 30;
    edades["Maria"] = 25;
    edades["Pedro"] = 35;

    // Iteración y acceso a los elementos
    for (const auto& par : edades) {
        cout << par.first << " tiene " << par.second << " años." << endl;
    }

    // Acceso a un valor específico
    cout << "La edad de Maria es: " << edades["Maria"] << endl;

    // Modificación de un valor
    edades["Maria"] = 26;
    cout << "La nueva edad de Maria es: " << edades["Maria"] << endl;

    // Eliminación de un elemento
    edades.erase("Pedro");

    // Iteración después de la eliminación
    for (const auto& par : edades) {
        cout << par.first << " tiene " << par.second << " años." << endl;
    }

    return 0;
}
```cpp
#include <iostream>
#include <map>
#include <unordered_map>
using namespace std;

int main() {
    // Uso de std::map
    map<string, int> mapaOrdenado;
    mapaOrdenado["Juan"] = 30;
    mapaOrdenado["Maria"] = 25;
    mapaOrdenado["Pedro"] = 35;

    cout << "Mapa ordenado:" << endl;
    for (const auto& par : mapaOrdenado) {
        cout << par.first << " tiene " << par.second << " años." << endl;
    }

    // Uso de std::unordered_map
    unordered_map<string, int> mapaNoOrdenado;
    mapaNoOrdenado["Juan"] = 30;
    mapaNoOrdenado["Maria"] = 25;
    mapaNoOrdenado["Pedro"] = 35;

    cout << "\nMapa no ordenado:" << endl;
    for (const auto& par : mapaNoOrdenado) {
        cout << par.first << " tiene " << par.second << " años." << endl;
    }

    return 0;
}
<---Ejemplo de Uso de `std::unordered_map` Result--->
<---Inicialización Estática--->
```cpp
int matriz[2][3] = {
    {1, 2, 3},
    {4, 5, 6}
};
<---Inicialización Estática Result--->
<---Inicialización Dinámica--->
```cpp
#include <iostream>
using namespace std;

int main() {
    int filas = 3;
    int columnas = 3;

    // Declaración de un puntero a puntero
    int** matriz = new int*[filas];

    // Asignación de memoria para cada fila
    for (int i = 0; i < filas; ++i) {
        matriz[i] = new int[columnas];
    }

    // Inicialización de la matriz
    int contador = 1;
    for (int i = 0; i < filas; ++i) {
        for (int j = 0; j < columnas; ++j) {
            matriz[i][j] = contador++;
        }
    }

    // Acceso a los elementos de la matriz
    for (int i = 0; i < filas; ++i) {
        for (int j = 0; j < columnas; ++j) {
            cout << "Elemento [" << i << "][" << j << "]: " << matriz[i][j] << endl;
        }
    }

    // Liberación de la memoria
    for (int i = 0; i < filas; ++i) {
        delete[] matriz[i];
    }
    delete[] matriz;

    return 0;
}
<---Inicialización Dinámica Result--->
<---Ejemplo de Array Tridimensional--->
```cpp
#include <iostream>
using namespace std;

int main() {
    // Declaración de un array 2x2x2
    int cubo[2][2][2] = {
        {
            {1, 2},
            {3, 4}
        },
        {
            {5, 6},
            {7, 8}
        }
    };

    // Acceso a los elementos del array tridimensional
    for (int i = 0; i < 2; ++i) {
        for (int j = 0; j < 2; ++j) {
            for (int k = 0; k < 2; ++k) {
                cout << "Elemento [" << i << "][" << j << "][" << k << "]: " << cubo[i][j][k] << endl;
            }
        }
    }

    return 0;
}
```cpp
#include <iostream>
using namespace std;

int main() {
    int filas = 3;
    int columnas = 3;

    // Declaración de un puntero a puntero
    int** matriz = new int*[filas];

    // Asignación de memoria para cada fila
    for (int i = 0; i < filas; ++i) {
        matriz[i] = new int[columnas];
    }

    // Inicialización de la matriz
    int contador = 1;
    for (int i = 0; i < filas; ++i) {
        for (int j = 0; j < columnas; ++j) {
            matriz[i][j] = contador++;
        }
    }

    // Acceso a los elementos de la matriz
    cout << "Matriz inicializada:" << endl;
    for (int i = 0; i < filas; ++i) {
        for (int j = 0; j < columnas; ++j) {
            cout << matriz[i][j] << " ";
        }
        cout << endl;
    }

    // Liberación de la memoria
    for (int i = 0; i < filas; ++i) {
        delete[] matriz[i];
    }
    delete[] matriz;

    return 0;
}
<---Ejemplo de Array Tridimensional Result--->
<---Declaración Básica--->
```cpp
char cadena[6] = {'H', 'o', 'l', 'a', '\0'};
<---Declaración Básica Result--->
<---Declaración y Inicialización Simplificada--->
```cpp
char cadena[] = "Hola";
<---Declaración y Inicialización Simplificada Result--->
<---Ejemplo Completo de Declaración y Inicialización--->
```cpp
#include <iostream>
using namespace std;

int main() {
    char saludo1[] = "Hola";
    char saludo2[6] = {'H', 'o', 'l', 'a', '\0'};

    cout << saludo1 << endl;
    cout << saludo2 << endl;

    return 0;
}
<---Ejemplo Completo de Declaración y Inicialización Result--->
<---Copia de Cadenas: `strcpy`--->
```cpp
#include <iostream>
#include <cstring>
using namespace std;

int main() {
    char destino[20];
    const char* origen = "Hola Mundo";

    strcpy(destino, origen);

    cout << "Destino: " << destino << endl;

    return 0;
}
<---Copia de Cadenas: `strcpy` Result--->
<---Concatenación de Cadenas: `strcat`--->
```cpp
#include <iostream>
#include <cstring>
using namespace std;

int main() {
    char saludo[20] = "Hola, ";
    const char* nombre = "Mundo";

    strcat(saludo, nombre);

    cout << "Saludo completo: " << saludo << endl;

    return 0;
}
<---Concatenación de Cadenas: `strcat` Result--->
<---Longitud de la Cadena: `strlen`--->
```cpp
#include <iostream>
#include <cstring>
using namespace std;

int main() {
    const char* cadena = "Hola Mundo";
    size_t longitud = strlen(cadena);

    cout << "Longitud de la cadena: " << longitud << endl;

    return 0;
}
<---Longitud de la Cadena: `strlen` Result--->
<---Comparación de Cadenas: `strcmp`--->
```cpp
#include <iostream>
#include <cstring>
using namespace std;

int main() {
    const char* cadena1 = "Hola";
    const char* cadena2 = "Mundo";

    int resultado = strcmp(cadena1, cadena2);

    if (resultado == 0) {
        cout << "Las cadenas son iguales." << endl;
    } else if (resultado < 0) {
        cout << "cadena1 es menor que cadena2." << endl;
    } else {
        cout << "cadena1 es mayor que cadena2." << endl;
    }

    return 0;
}
<---Comparación de Cadenas: `strcmp` Result--->
<---Lectura de C-Strings con `cin`--->
```cpp
#include <iostream>
using namespace std;

int main() {
    char nombre[50];

    cout << "Introduce tu nombre: ";
    cin >> nombre;

    cout << "Hola, " << nombre << "!" << endl;

    return 0;
}
<---Lectura de C-Strings con `cin` Result--->
<---Lectura de Cadenas con Espacios usando `cin.getline`--->
```cpp
#include <iostream>
using namespace std;

int main() {
    char frase[100];

    cout << "Introduce una frase: ";
    cin.getline(frase, 100);

    cout << "Tu frase: " << frase << endl;

    return 0;
}
```cpp
#include <iostream>
#include <cstring>
using namespace std;

int main() {
    // Declaración e inicialización
    char saludo[50] = "Hola";
    const char* mundo = " Mundo";

    // Concatenación
    strcat(saludo, mundo);
    cout << "Concatenación: " << saludo << endl;

    // Copia
    char copia[50];
    strcpy(copia, saludo);
    cout << "Copia: " << copia << endl;

    // Longitud
    size_t longitud = strlen(copia);
    cout << "Longitud de la copia: " << longitud << endl;

    // Comparación
    const char* otraCadena = "Hola Mundo";
    if (strcmp(copia, otraCadena) == 0) {
        cout << "Las cadenas son iguales." << endl;
    } else {
        cout << "Las cadenas son diferentes." << endl;
    }

    // Entrada de C-Strings
    char entrada[50];
    cout << "Introduce una palabra: ";
    cin >> entrada;
    cout << "Palabra introducida: " << entrada << endl;

    return 0;
}
<---Lectura de Cadenas con Espacios usando `cin.getline` Result--->
<---Características de `std::list`--->
<---Características de `std::list` Result--->
<---Ejemplo de Uso de `std::list`--->
```cpp
#include <iostream>
#include <list>
using namespace std;

int main() {
    // Declaración e inicialización de una lista
    list<int> miLista = {10, 20, 30, 40};

    // Inserción de elementos
    miLista.push_back(50);  // Añade al final
    miLista.push_front(5);  // Añade al inicio

    // Iteración y acceso a los elementos
    for (int elemento : miLista) {
        cout << elemento << " ";
    }
    cout << endl;

    // Eliminación de elementos
    miLista.pop_back();  // Elimina el último elemento
    miLista.pop_front(); // Elimina el primer elemento

    // Iteración y acceso a los elementos después de la eliminación
    for (int elemento : miLista) {
        cout << elemento << " ";
    }
    cout << endl;

    return 0;
}
<---Ejemplo de Uso de `std::list` Result--->
<---Características de `std::queue`--->
<---Características de `std::queue` Result--->
<---Ejemplo de Uso de `std::queue`--->
```cpp
#include <iostream>
#include <queue>
using namespace std;

int main() {
    // Declaración e inicialización de una cola
    queue<int> miCola;

    // Inserción de elementos
    miCola.push(10);
    miCola.push(20);
    miCola.push(30);

    // Acceso al primer y último elemento
    cout << "Frente: " << miCola.front() << endl;
    cout << "Final: " << miCola.back() << endl;

    // Eliminación de elementos
    miCola.pop(); // Elimina el primer elemento (10)

    // Acceso después de la eliminación
    cout << "Frente después de pop: " << miCola.front() << endl;

    return 0;
}
```cpp
#include <iostream>
#include <list>
#include <queue>
using namespace std;

int main() {
    // Uso de std::list
    list<int> miLista = {1, 2, 3, 4, 5};
    miLista.push_back(6);
    miLista.push_front(0);

    cout << "Lista: ";
    for (int elemento : miLista) {
        cout << elemento << " ";
    }
    cout << endl;

    miLista.pop_back();
    miLista.pop_front();

    cout << "Lista después de pop: ";
    for (int elemento : miLista) {
        cout << elemento << " ";
    }
    cout << endl;

    // Uso de std::queue
    queue<int> miCola;
    miCola.push(10);
    miCola.push(20);
    miCola.push(30);

    cout << "Cola frente: " << miCola.front() << ", final: " << miCola.back() << endl;
    miCola.pop();
    cout << "Cola frente después de pop: " << miCola.front() << endl;

    return 0;
}
<---Ejemplo de Uso de `std::queue` Result--->
<---Características de `std::stack`--->
<---Características de `std::stack` Result--->
<---Ejemplo de Uso de `std::stack`--->
```cpp
#include <iostream>
#include <stack>
using namespace std;

int main() {
    // Declaración e inicialización de una pila
    stack<int> miPila;

    // Inserción de elementos
    miPila.push(10);
    miPila.push(20);
    miPila.push(30);

    // Acceso al elemento superior
    cout << "Elemento superior: " << miPila.top() << endl;

    // Eliminación de elementos
    miPila.pop(); // Elimina el elemento superior (30)

    // Acceso después de la eliminación
    cout << "Elemento superior después de pop: " << miPila.top() << endl;

    return 0;
}
<---Ejemplo de Uso de `std::stack` Result--->
<---Características de `std::set`--->
<---Características de `std::set` Result--->
<---Ejemplo de Uso de `std::set`--->
```cpp
#include <iostream>
#include <set>
using namespace std;

int main() {
    // Declaración e inicialización de un conjunto
    set<int> miConjunto = {30, 10, 20, 40};

    // Inserción de elementos
    miConjunto.insert(50);
    miConjunto.insert(20); // No se añade ya que 20 ya existe

    // Iteración y acceso a los elementos
    cout << "Conjunto: ";
    for (int elemento : miConjunto) {
        cout << elemento << " ";
    }
    cout << endl;

    // Eliminación de un elemento
    miConjunto.erase(30);

    // Iteración y acceso a los elementos después de la eliminación
    cout << "Conjunto después de erase: ";
    for (int elemento : miConjunto) {
        cout << elemento << " ";
    }
    cout << endl;

    return 0;
}
```cpp
#include <iostream>
#include <stack>
#include <set>
using namespace std;

int main() {
    // Uso de std::stack
    stack<int> miPila;
    miPila.push(10);
    miPila.push(20);
    miPila.push(30);
    cout << "Pila elemento superior: " << miPila.top() << endl;
    miPila.pop();
    cout << "Pila elemento superior después de pop: " << miPila.top() << endl;

    // Uso de std::set
    set<int> miConjunto = {30, 10, 20, 40};
    miConjunto.insert(50);
    cout << "Conjunto: ";
    for (int elemento : miConjunto) {
        cout << elemento << " ";
    }
    cout << endl;
    miConjunto.erase(30);
    cout << "Conjunto después de erase: ";
    for (int elemento : miConjunto) {
        cout << elemento << " ";
    }
    cout << endl;

    return 0;
}
<---Ejemplo de Uso de `std::set` Result--->
<---Características de `std::map`--->
<---Características de `std::map` Result--->
<---Ejemplo de Uso de `std::map`--->
```cpp
#include <iostream>
#include <map>
using namespace std;

int main() {
    // Declaración e inicialización de un mapa
    map<string, int> edades;
    edades["Juan"] = 30;
    edades["Maria"] = 25;
    edades["Pedro"] = 35;

    // Iteración y acceso a los elementos
    for (const auto& par : edades) {
        cout << par.first << " tiene " << par.second << " años." << endl;
    }

    // Acceso a un valor específico
    cout << "La edad de Maria es: " << edades["Maria"] << endl;

    // Modificación de un valor
    edades["Maria"] = 26;
    cout << "La nueva edad de Maria es: " << edades["Maria"] << endl;

    // Eliminación de un elemento
    edades.erase("Pedro");

    // Iteración después de la eliminación
    for (const auto& par : edades) {
        cout << par.first << " tiene " << par.second << " años." << endl;
    }

    return 0;
}
<---Ejemplo de Uso de `std::map` Result--->
<---Características de `std::unordered_map`--->
<---Características de `std::unordered_map` Result--->
<---Ejemplo de Uso de `std::unordered_map`--->
```cpp
#include <iostream>
#include <unordered_map>
using namespace std;

int main() {
    // Declaración e inicialización de un unordered_map
    unordered_map<string, int> edades;
    edades["Juan"] = 30;
    edades["Maria"] = 25;
    edades["Pedro"] = 35;

    // Iteración y acceso a los elementos
    for (const auto& par : edades) {
        cout << par.first << " tiene " << par.second << " años." << endl;
    }

    // Acceso a un valor específico
    cout << "La edad de Maria es: " << edades["Maria"] << endl;

    // Modificación de un valor
    edades["Maria"] = 26;
    cout << "La nueva edad de Maria es: " << edades["Maria"] << endl;

    // Eliminación de un elemento
    edades.erase("Pedro");

    // Iteración después de la eliminación
    for (const auto& par : edades) {
        cout << par.first << " tiene " << par.second << " años." << endl;
    }

    return 0;
}
```cpp
#include <iostream>
#include <map>
#include <unordered_map>
using namespace std;

int main() {
    // Uso de std::map
    map<string, int> mapaOrdenado;
    mapaOrdenado["Juan"] = 30;
    mapaOrdenado["Maria"] = 25;
    mapaOrdenado["Pedro"] = 35;

    cout << "Mapa ordenado:" << endl;
    for (const auto& par : mapaOrdenado) {
        cout << par.first << " tiene " << par.second << " años." << endl;
    }

    // Uso de std::unordered_map
    unordered_map<string, int> mapaNoOrdenado;
    mapaNoOrdenado["Juan"] = 30;
    mapaNoOrdenado["Maria"] = 25;
    mapaNoOrdenado["Pedro"] = 35;

    cout << "\nMapa no ordenado:" << endl;
    for (const auto& par : mapaNoOrdenado) {
        cout << par.first << " tiene " << par.second << " años." << endl;
    }

    return 0;
}
<---Ejemplo de Uso de `std::unordered_map` Result--->
<---Inicialización Estática--->
```cpp
int matriz[2][3] = {
    {1, 2, 3},
    {4, 5, 6}
};
<---Inicialización Estática Result--->
<---Inicialización Dinámica--->
```cpp
#include <iostream>
using namespace std;

int main() {
    int filas = 3;
    int columnas = 3;

    // Declaración de un puntero a puntero
    int** matriz = new int*[filas];

    // Asignación de memoria para cada fila
    for (int i = 0; i < filas; ++i) {
        matriz[i] = new int[columnas];
    }

    // Inicialización de la matriz
    int contador = 1;
    for (int i = 0; i < filas; ++i) {
        for (int j = 0; j < columnas; ++j) {
            matriz[i][j] = contador++;
        }
    }

    // Acceso a los elementos de la matriz
    for (int i = 0; i < filas; ++i) {
        for (int j = 0; j < columnas; ++j) {
            cout << "Elemento [" << i << "][" << j << "]: " << matriz[i][j] << endl;
        }
    }

    // Liberación de la memoria
    for (int i = 0; i < filas; ++i) {
        delete[] matriz[i];
    }
    delete[] matriz;

    return 0;
}
<---Inicialización Dinámica Result--->
<---Ejemplo de Array Tridimensional--->
```cpp
#include <iostream>
using namespace std;

int main() {
    // Declaración de un array 2x2x2
    int cubo[2][2][2] = {
        {
            {1, 2},
            {3, 4}
        },
        {
            {5, 6},
            {7, 8}
        }
    };

    // Acceso a los elementos del array tridimensional
    for (int i = 0; i < 2; ++i) {
        for (int j = 0; j < 2; ++j) {
            for (int k = 0; k < 2; ++k) {
                cout << "Elemento [" << i << "][" << j << "][" << k << "]: " << cubo[i][j][k] << endl;
            }
        }
    }

    return 0;
}
```cpp
#include <iostream>
using namespace std;

int main() {
    int filas = 3;
    int columnas = 3;

    // Declaración de un puntero a puntero
    int** matriz = new int*[filas];

    // Asignación de memoria para cada fila
    for (int i = 0; i < filas; ++i) {
        matriz[i] = new int[columnas];
    }

    // Inicialización de la matriz
    int contador = 1;
    for (int i = 0; i < filas; ++i) {
        for (int j = 0; j < columnas; ++j) {
            matriz[i][j] = contador++;
        }
    }

    // Acceso a los elementos de la matriz
    cout << "Matriz inicializada:" << endl;
    for (int i = 0; i < filas; ++i) {
        for (int j = 0; j < columnas; ++j) {
            cout << matriz[i][j] << " ";
        }
        cout << endl;
    }

    // Liberación de la memoria
    for (int i = 0; i < filas; ++i) {
        delete[] matriz[i];
    }
    delete[] matriz;

    return 0;
}
<---Ejemplo de Array Tridimensional Result--->
<---Declaración Básica--->
```cpp
char cadena[6] = {'H', 'o', 'l', 'a', '\0'};
<---Declaración Básica Result--->
<---Declaración y Inicialización Simplificada--->
```cpp
char cadena[] = "Hola";
<---Declaración y Inicialización Simplificada Result--->
<---Ejemplo Completo de Declaración y Inicialización--->
```cpp
#include <iostream>
using namespace std;

int main() {
    char saludo1[] = "Hola";
    char saludo2[6] = {'H', 'o', 'l', 'a', '\0'};

    cout << saludo1 << endl;
    cout << saludo2 << endl;

    return 0;
}
<---Ejemplo Completo de Declaración y Inicialización Result--->
<---Copia de Cadenas: `strcpy`--->
```cpp
#include <iostream>
#include <cstring>
using namespace std;

int main() {
    char destino[20];
    const char* origen = "Hola Mundo";

    strcpy(destino, origen);

    cout << "Destino: " << destino << endl;

    return 0;
}
<---Copia de Cadenas: `strcpy` Result--->
<---Concatenación de Cadenas: `strcat`--->
```cpp
#include <iostream>
#include <cstring>
using namespace std;

int main() {
    char saludo[20] = "Hola, ";
    const char* nombre = "Mundo";

    strcat(saludo, nombre);

    cout << "Saludo completo: " << saludo << endl;

    return 0;
}
<---Concatenación de Cadenas: `strcat` Result--->
<---Longitud de la Cadena: `strlen`--->
```cpp
#include <iostream>
#include <cstring>
using namespace std;

int main() {
    const char* cadena = "Hola Mundo";
    size_t longitud = strlen(cadena);

    cout << "Longitud de la cadena: " << longitud << endl;

    return 0;
}
<---Longitud de la Cadena: `strlen` Result--->
<---Comparación de Cadenas: `strcmp`--->
```cpp
#include <iostream>
#include <cstring>
using namespace std;

int main() {
    const char* cadena1 = "Hola";
    const char* cadena2 = "Mundo";

    int resultado = strcmp(cadena1, cadena2);

    if (resultado == 0) {
        cout << "Las cadenas son iguales." << endl;
    } else if (resultado < 0) {
        cout << "cadena1 es menor que cadena2." << endl;
    } else {
        cout << "cadena1 es mayor que cadena2." << endl;
    }

    return 0;
}
<---Comparación de Cadenas: `strcmp` Result--->
<---Lectura de C-Strings con `cin`--->
```cpp
#include <iostream>
using namespace std;

int main() {
    char nombre[50];

    cout << "Introduce tu nombre: ";
    cin >> nombre;

    cout << "Hola, " << nombre << "!" << endl;

    return 0;
}
<---Lectura de C-Strings con `cin` Result--->
<---Lectura de Cadenas con Espacios usando `cin.getline`--->
```cpp
#include <iostream>
using namespace std;

int main() {
    char frase[100];

    cout << "Introduce una frase: ";
    cin.getline(frase, 100);

    cout << "Tu frase: " << frase << endl;

    return 0;
}
```cpp
#include <iostream>
#include <cstring>
using namespace std;

int main() {
    // Declaración e inicialización
    char saludo[50] = "Hola";
    const char* mundo = " Mundo";

    // Concatenación
    strcat(saludo, mundo);
    cout << "Concatenación: " << saludo << endl;

    // Copia
    char copia[50];
    strcpy(copia, saludo);
    cout << "Copia: " << copia << endl;

    // Longitud
    size_t longitud = strlen(copia);
    cout << "Longitud de la copia: " << longitud << endl;

    // Comparación
    const char* otraCadena = "Hola Mundo";
    if (strcmp(copia, otraCadena) == 0) {
        cout << "Las cadenas son iguales." << endl;
    } else {
        cout << "Las cadenas son diferentes." << endl;
    }

    // Entrada de C-Strings
    char entrada[50];
    cout << "Introduce una palabra: ";
    cin >> entrada;
    cout << "Palabra introducida: " << entrada << endl;

    return 0;
}
<---Lectura de Cadenas con Espacios usando `cin.getline` Result--->
<---Sintaxis--->
```cpp
struct NombreEstructura {
    tipo_dato1 miembro1;
    tipo_dato2 miembro2;
    // Otros miembros
};
<---Sintaxis Result--->
<---Ejemplo Básico--->
```cpp
#include <iostream>
using namespace std;

struct Persona {
    string nombre;
    int edad;
    float altura;
};

int main() {
    // Declaración e inicialización de una estructura
    Persona juan = {"Juan", 30, 1.75f};

    // Acceso a los miembros de la estructura
    cout << "Nombre: " << juan.nombre << endl;
    cout << "Edad: " << juan.edad << endl;
    cout << "Altura: " << juan.altura << " metros" << endl;

    return 0;
}
<---Ejemplo Básico Result--->
<---Inicialización de Lista--->
```cpp
Persona maria = {"Maria", 25, 1.65f};
<---Inicialización de Lista Result--->
<---Inicialización Miembro por Miembro--->
```cpp
Persona pedro;
pedro.nombre = "Pedro";
pedro.edad = 28;
pedro.altura = 1.80f;
<---Inicialización Miembro por Miembro Result--->
<---Copia de Estructuras--->
```cpp
Persona juan = {"Juan", 30, 1.75f};
Persona copiaJuan = juan;

cout << "Copia de Juan - Nombre: " << copiaJuan.nombre << endl;
<---Copia de Estructuras Result--->
<---Pasar Estructuras a Funciones--->
```cpp
void imprimirPersona(Persona p) {
    cout << "Nombre: " << p.nombre << endl;
    cout << "Edad: " << p.edad << endl;
    cout << "Altura: " << p.altura << " metros" << endl;
}

int main() {
    Persona juan = {"Juan", 30, 1.75f};
    imprimirPersona(juan);
    return 0;
}
<---Pasar Estructuras a Funciones Result--->
<---Retornar Estructuras desde Funciones--->
```cpp
Persona crearPersona(string nombre, int edad, float altura) {
    Persona p = {nombre, edad, altura};
    return p;
}

int main() {
    Persona ana = crearPersona("Ana", 22, 1.60f);
    cout << "Nombre: " << ana.nombre << endl;
    cout << "Edad: " << ana.edad << endl;
    cout << "Altura: " << ana.altura << " metros" << endl;
    return 0;
}
<---Retornar Estructuras desde Funciones Result--->
<---Ejemplo Comparativo--->
```cpp
struct Punto {
    int x; // Público por defecto
    int y;
};

class PuntoClase {
private:
    int x; // Privado por defecto
    int y;
public:
    void setX(int val) { x = val; }
    int getX() { return x; }
};

int main() {
    Punto p1;
    p1.x = 10; // Acceso directo permitido

    PuntoClase p2;
    // p2.x = 10; // Error: x es privado
    p2.setX(10); // Acceso mediante función miembro

    return 0;
}
```cpp
#include <iostream>
using namespace std;

struct Fecha {
    int dia;
    int mes;
    int anio;
};

struct Persona {
    string nombre;
    int edad;
    float altura;
    Fecha nacimiento;
};

void imprimirPersona(const Persona& p) {
    cout << "Nombre: " << p.nombre << endl;
    cout << "Edad: " << p.edad << endl;
    cout << "Altura: " << p.altura << " metros" << endl;
    cout << "Fecha de Nacimiento: " << p.nacimiento.dia << "/"
         << p.nacimiento.mes << "/" << p.nacimiento.anio << endl;
}

int main() {
    Fecha fechaNacimiento = {15, 6, 1990};
    Persona juan = {"Juan", 30, 1.75f, fechaNacimiento};

    imprimirPersona(juan);

    Persona maria;
    maria.nombre = "Maria";
    maria.edad = 25;
    maria.altura = 1.65f;
    maria.nacimiento = {12, 10, 1995};

    imprimirPersona(maria);

    return 0;
}
<---Ejemplo Comparativo Result--->
<---Características de `std::list`--->
<---Características de `std::list` Result--->
<---Ejemplo de Uso de `std::list`--->
```cpp
#include <iostream>
#include <list>
using namespace std;

int main() {
    // Declaración e inicialización de una lista
    list<int> miLista = {10, 20, 30, 40};

    // Inserción de elementos
    miLista.push_back(50);  // Añade al final
    miLista.push_front(5);  // Añade al inicio

    // Iteración y acceso a los elementos
    for (int elemento : miLista) {
        cout << elemento << " ";
    }
    cout << endl;

    // Eliminación de elementos
    miLista.pop_back();  // Elimina el último elemento
    miLista.pop_front(); // Elimina el primer elemento

    // Iteración y acceso a los elementos después de la eliminación
    for (int elemento : miLista) {
        cout << elemento << " ";
    }
    cout << endl;

    return 0;
}
<---Ejemplo de Uso de `std::list` Result--->
<---Características de `std::queue`--->
<---Características de `std::queue` Result--->
<---Ejemplo de Uso de `std::queue`--->
```cpp
#include <iostream>
#include <queue>
using namespace std;

int main() {
    // Declaración e inicialización de una cola
    queue<int> miCola;

    // Inserción de elementos
    miCola.push(10);
    miCola.push(20);
    miCola.push(30);

    // Acceso al primer y último elemento
    cout << "Frente: " << miCola.front() << endl;
    cout << "Final: " << miCola.back() << endl;

    // Eliminación de elementos
    miCola.pop(); // Elimina el primer elemento (10)

    // Acceso después de la eliminación
    cout << "Frente después de pop: " << miCola.front() << endl;

    return 0;
}
```cpp
#include <iostream>
#include <list>
#include <queue>
using namespace std;

int main() {
    // Uso de std::list
    list<int> miLista = {1, 2, 3, 4, 5};
    miLista.push_back(6);
    miLista.push_front(0);

    cout << "Lista: ";
    for (int elemento : miLista) {
        cout << elemento << " ";
    }
    cout << endl;

    miLista.pop_back();
    miLista.pop_front();

    cout << "Lista después de pop: ";
    for (int elemento : miLista) {
        cout << elemento << " ";
    }
    cout << endl;

    // Uso de std::queue
    queue<int> miCola;
    miCola.push(10);
    miCola.push(20);
    miCola.push(30);

    cout << "Cola frente: " << miCola.front() << ", final: " << miCola.back() << endl;
    miCola.pop();
    cout << "Cola frente después de pop: " << miCola.front() << endl;

    return 0;
}
<---Ejemplo de Uso de `std::queue` Result--->
<---Características de `std::stack`--->
<---Características de `std::stack` Result--->
<---Ejemplo de Uso de `std::stack`--->
```cpp
#include <iostream>
#include <stack>
using namespace std;

int main() {
    // Declaración e inicialización de una pila
    stack<int> miPila;

    // Inserción de elementos
    miPila.push(10);
    miPila.push(20);
    miPila.push(30);

    // Acceso al elemento superior
    cout << "Elemento superior: " << miPila.top() << endl;

    // Eliminación de elementos
    miPila.pop(); // Elimina el elemento superior (30)

    // Acceso después de la eliminación
    cout << "Elemento superior después de pop: " << miPila.top() << endl;

    return 0;
}
<---Ejemplo de Uso de `std::stack` Result--->
<---Características de `std::set`--->
<---Características de `std::set` Result--->
<---Ejemplo de Uso de `std::set`--->
```cpp
#include <iostream>
#include <set>
using namespace std;

int main() {
    // Declaración e inicialización de un conjunto
    set<int> miConjunto = {30, 10, 20, 40};

    // Inserción de elementos
    miConjunto.insert(50);
    miConjunto.insert(20); // No se añade ya que 20 ya existe

    // Iteración y acceso a los elementos
    cout << "Conjunto: ";
    for (int elemento : miConjunto) {
        cout << elemento << " ";
    }
    cout << endl;

    // Eliminación de un elemento
    miConjunto.erase(30);

    // Iteración y acceso a los elementos después de la eliminación
    cout << "Conjunto después de erase: ";
    for (int elemento : miConjunto) {
        cout << elemento << " ";
    }
    cout << endl;

    return 0;
}
```cpp
#include <iostream>
#include <stack>
#include <set>
using namespace std;

int main() {
    // Uso de std::stack
    stack<int> miPila;
    miPila.push(10);
    miPila.push(20);
    miPila.push(30);
    cout << "Pila elemento superior: " << miPila.top() << endl;
    miPila.pop();
    cout << "Pila elemento superior después de pop: " << miPila.top() << endl;

    // Uso de std::set
    set<int> miConjunto = {30, 10, 20, 40};
    miConjunto.insert(50);
    cout << "Conjunto: ";
    for (int elemento : miConjunto) {
        cout << elemento << " ";
    }
    cout << endl;
    miConjunto.erase(30);
    cout << "Conjunto después de erase: ";
    for (int elemento : miConjunto) {
        cout << elemento << " ";
    }
    cout << endl;

    return 0;
}
<---Ejemplo de Uso de `std::set` Result--->
<---Características de `std::map`--->
<---Características de `std::map` Result--->
<---Ejemplo de Uso de `std::map`--->
```cpp
#include <iostream>
#include <map>
using namespace std;

int main() {
    // Declaración e inicialización de un mapa
    map<string, int> edades;
    edades["Juan"] = 30;
    edades["Maria"] = 25;
    edades["Pedro"] = 35;

    // Iteración y acceso a los elementos
    for (const auto& par : edades) {
        cout << par.first << " tiene " << par.second << " años." << endl;
    }

    // Acceso a un valor específico
    cout << "La edad de Maria es: " << edades["Maria"] << endl;

    // Modificación de un valor
    edades["Maria"] = 26;
    cout << "La nueva edad de Maria es: " << edades["Maria"] << endl;

    // Eliminación de un elemento
    edades.erase("Pedro");

    // Iteración después de la eliminación
    for (const auto& par : edades) {
        cout << par.first << " tiene " << par.second << " años." << endl;
    }

    return 0;
}
<---Ejemplo de Uso de `std::map` Result--->
<---Características de `std::unordered_map`--->
<---Características de `std::unordered_map` Result--->
<---Ejemplo de Uso de `std::unordered_map`--->
```cpp
#include <iostream>
#include <unordered_map>
using namespace std;

int main() {
    // Declaración e inicialización de un unordered_map
    unordered_map<string, int> edades;
    edades["Juan"] = 30;
    edades["Maria"] = 25;
    edades["Pedro"] = 35;

    // Iteración y acceso a los elementos
    for (const auto& par : edades) {
        cout << par.first << " tiene " << par.second << " años." << endl;
    }

    // Acceso a un valor específico
    cout << "La edad de Maria es: " << edades["Maria"] << endl;

    // Modificación de un valor
    edades["Maria"] = 26;
    cout << "La nueva edad de Maria es: " << edades["Maria"] << endl;

    // Eliminación de un elemento
    edades.erase("Pedro");

    // Iteración después de la eliminación
    for (const auto& par : edades) {
        cout << par.first << " tiene " << par.second << " años." << endl;
    }

    return 0;
}
```cpp
#include <iostream>
#include <map>
#include <unordered_map>
using namespace std;

int main() {
    // Uso de std::map
    map<string, int> mapaOrdenado;
    mapaOrdenado["Juan"] = 30;
    mapaOrdenado["Maria"] = 25;
    mapaOrdenado["Pedro"] = 35;

    cout << "Mapa ordenado:" << endl;
    for (const auto& par : mapaOrdenado) {
        cout << par.first << " tiene " << par.second << " años." << endl;
    }

    // Uso de std::unordered_map
    unordered_map<string, int> mapaNoOrdenado;
    mapaNoOrdenado["Juan"] = 30;
    mapaNoOrdenado["Maria"] = 25;
    mapaNoOrdenado["Pedro"] = 35;

    cout << "\nMapa no ordenado:" << endl;
    for (const auto& par : mapaNoOrdenado) {
        cout << par.first << " tiene " << par.second << " años." << endl;
    }

    return 0;
}
<---Ejemplo de Uso de `std::unordered_map` Result--->
<---Inicialización Estática--->
```cpp
int matriz[2][3] = {
    {1, 2, 3},
    {4, 5, 6}
};
<---Inicialización Estática Result--->
<---Inicialización Dinámica--->
```cpp
#include <iostream>
using namespace std;

int main() {
    int filas = 3;
    int columnas = 3;

    // Declaración de un puntero a puntero
    int** matriz = new int*[filas];

    // Asignación de memoria para cada fila
    for (int i = 0; i < filas; ++i) {
        matriz[i] = new int[columnas];
    }

    // Inicialización de la matriz
    int contador = 1;
    for (int i = 0; i < filas; ++i) {
        for (int j = 0; j < columnas; ++j) {
            matriz[i][j] = contador++;
        }
    }

    // Acceso a los elementos de la matriz
    for (int i = 0; i < filas; ++i) {
        for (int j = 0; j < columnas; ++j) {
            cout << "Elemento [" << i << "][" << j << "]: " << matriz[i][j] << endl;
        }
    }

    // Liberación de la memoria
    for (int i = 0; i < filas; ++i) {
        delete[] matriz[i];
    }
    delete[] matriz;

    return 0;
}
<---Inicialización Dinámica Result--->
<---Ejemplo de Array Tridimensional--->
```cpp
#include <iostream>
using namespace std;

int main() {
    // Declaración de un array 2x2x2
    int cubo[2][2][2] = {
        {
            {1, 2},
            {3, 4}
        },
        {
            {5, 6},
            {7, 8}
        }
    };

    // Acceso a los elementos del array tridimensional
    for (int i = 0; i < 2; ++i) {
        for (int j = 0; j < 2; ++j) {
            for (int k = 0; k < 2; ++k) {
                cout << "Elemento [" << i << "][" << j << "][" << k << "]: " << cubo[i][j][k] << endl;
            }
        }
    }

    return 0;
}
```cpp
#include <iostream>
using namespace std;

int main() {
    int filas = 3;
    int columnas = 3;

    // Declaración de un puntero a puntero
    int** matriz = new int*[filas];

    // Asignación de memoria para cada fila
    for (int i = 0; i < filas; ++i) {
        matriz[i] = new int[columnas];
    }

    // Inicialización de la matriz
    int contador = 1;
    for (int i = 0; i < filas; ++i) {
        for (int j = 0; j < columnas; ++j) {
            matriz[i][j] = contador++;
        }
    }

    // Acceso a los elementos de la matriz
    cout << "Matriz inicializada:" << endl;
    for (int i = 0; i < filas; ++i) {
        for (int j = 0; j < columnas; ++j) {
            cout << matriz[i][j] << " ";
        }
        cout << endl;
    }

    // Liberación de la memoria
    for (int i = 0; i < filas; ++i) {
        delete[] matriz[i];
    }
    delete[] matriz;

    return 0;
}
<---Ejemplo de Array Tridimensional Result--->
<---Declaración Básica--->
```cpp
char cadena[6] = {'H', 'o', 'l', 'a', '\0'};
<---Declaración Básica Result--->
<---Declaración y Inicialización Simplificada--->
```cpp
char cadena[] = "Hola";
<---Declaración y Inicialización Simplificada Result--->
<---Ejemplo Completo de Declaración y Inicialización--->
```cpp
#include <iostream>
using namespace std;

int main() {
    char saludo1[] = "Hola";
    char saludo2[6] = {'H', 'o', 'l', 'a', '\0'};

    cout << saludo1 << endl;
    cout << saludo2 << endl;

    return 0;
}
<---Ejemplo Completo de Declaración y Inicialización Result--->
<---Copia de Cadenas: `strcpy`--->
```cpp
#include <iostream>
#include <cstring>
using namespace std;

int main() {
    char destino[20];
    const char* origen = "Hola Mundo";

    strcpy(destino, origen);

    cout << "Destino: " << destino << endl;

    return 0;
}
<---Copia de Cadenas: `strcpy` Result--->
<---Concatenación de Cadenas: `strcat`--->
```cpp
#include <iostream>
#include <cstring>
using namespace std;

int main() {
    char saludo[20] = "Hola, ";
    const char* nombre = "Mundo";

    strcat(saludo, nombre);

    cout << "Saludo completo: " << saludo << endl;

    return 0;
}
<---Concatenación de Cadenas: `strcat` Result--->
<---Longitud de la Cadena: `strlen`--->
```cpp
#include <iostream>
#include <cstring>
using namespace std;

int main() {
    const char* cadena = "Hola Mundo";
    size_t longitud = strlen(cadena);

    cout << "Longitud de la cadena: " << longitud << endl;

    return 0;
}
<---Longitud de la Cadena: `strlen` Result--->
<---Comparación de Cadenas: `strcmp`--->
```cpp
#include <iostream>
#include <cstring>
using namespace std;

int main() {
    const char* cadena1 = "Hola";
    const char* cadena2 = "Mundo";

    int resultado = strcmp(cadena1, cadena2);

    if (resultado == 0) {
        cout << "Las cadenas son iguales." << endl;
    } else if (resultado < 0) {
        cout << "cadena1 es menor que cadena2." << endl;
    } else {
        cout << "cadena1 es mayor que cadena2." << endl;
    }

    return 0;
}
<---Comparación de Cadenas: `strcmp` Result--->
<---Lectura de C-Strings con `cin`--->
```cpp
#include <iostream>
using namespace std;

int main() {
    char nombre[50];

    cout << "Introduce tu nombre: ";
    cin >> nombre;

    cout << "Hola, " << nombre << "!" << endl;

    return 0;
}
<---Lectura de C-Strings con `cin` Result--->
<---Lectura de Cadenas con Espacios usando `cin.getline`--->
```cpp
#include <iostream>
using namespace std;

int main() {
    char frase[100];

    cout << "Introduce una frase: ";
    cin.getline(frase, 100);

    cout << "Tu frase: " << frase << endl;

    return 0;
}
```cpp
#include <iostream>
#include <cstring>
using namespace std;

int main() {
    // Declaración e inicialización
    char saludo[50] = "Hola";
    const char* mundo = " Mundo";

    // Concatenación
    strcat(saludo, mundo);
    cout << "Concatenación: " << saludo << endl;

    // Copia
    char copia[50];
    strcpy(copia, saludo);
    cout << "Copia: " << copia << endl;

    // Longitud
    size_t longitud = strlen(copia);
    cout << "Longitud de la copia: " << longitud << endl;

    // Comparación
    const char* otraCadena = "Hola Mundo";
    if (strcmp(copia, otraCadena) == 0) {
        cout << "Las cadenas son iguales." << endl;
    } else {
        cout << "Las cadenas son diferentes." << endl;
    }

    // Entrada de C-Strings
    char entrada[50];
    cout << "Introduce una palabra: ";
    cin >> entrada;
    cout << "Palabra introducida: " << entrada << endl;

    return 0;
}
<---Lectura de Cadenas con Espacios usando `cin.getline` Result--->
<---Sintaxis--->
```cpp
enum class NombreEnumClass {
    valor1,
    valor2,
    // Otros valores
};
<---Sintaxis Result--->
<---Ejemplo Básico--->
```cpp
#include <iostream>
using namespace std;

enum class Color {
    Rojo,
    Verde,
    Azul
};

int main() {
    Color miColor = Color::Verde;

    if (miColor == Color::Verde) {
        cout << "El color es verde." << endl;
    }

    return 0;
}
<---Ejemplo Básico Result--->
<---Inicialización de Lista--->
```cpp
Persona maria = {"Maria", 25, 1.65f};
<---Inicialización de Lista Result--->
<---Inicialización Miembro por Miembro--->
```cpp
Persona pedro;
pedro.nombre = "Pedro";
pedro.edad = 28;
pedro.altura = 1.80f;
<---Inicialización Miembro por Miembro Result--->
<---Copia de Estructuras--->
```cpp
Persona juan = {"Juan", 30, 1.75f};
Persona copiaJuan = juan;

cout << "Copia de Juan - Nombre: " << copiaJuan.nombre << endl;
<---Copia de Estructuras Result--->
<---Pasar Estructuras a Funciones--->
```cpp
void imprimirPersona(Persona p) {
    cout << "Nombre: " << p.nombre << endl;
    cout << "Edad: " << p.edad << endl;
    cout << "Altura: " << p.altura << " metros" << endl;
}

int main() {
    Persona juan = {"Juan", 30, 1.75f};
    imprimirPersona(juan);
    return 0;
}
<---Pasar Estructuras a Funciones Result--->
<---Retornar Estructuras desde Funciones--->
```cpp
Persona crearPersona(string nombre, int edad, float altura) {
    Persona p = {nombre, edad, altura};
    return p;
}

int main() {
    Persona ana = crearPersona("Ana", 22, 1.60f);
    cout << "Nombre: " << ana.nombre << endl;
    cout << "Edad: " << ana.edad << endl;
    cout << "Altura: " << ana.altura << " metros" << endl;
    return 0;
}
<---Retornar Estructuras desde Funciones Result--->
<---Ejemplo Comparativo--->
```cpp
struct Punto {
    int x; // Público por defecto
    int y;
};

class PuntoClase {
private:
    int x; // Privado por defecto
    int y;
public:
    void setX(int val) { x = val; }
    int getX() { return x; }
};

int main() {
    Punto p1;
    p1.x = 10; // Acceso directo permitido

    PuntoClase p2;
    // p2.x = 10; // Error: x es privado
    p2.setX(10); // Acceso mediante función miembro

    return 0;
}
```cpp
#include <iostream>
using namespace std;

struct Fecha {
    int dia;
    int mes;
    int anio;
};

struct Persona {
    string nombre;
    int edad;
    float altura;
    Fecha nacimiento;
};

void imprimirPersona(const Persona& p) {
    cout << "Nombre: " << p.nombre << endl;
    cout << "Edad: " << p.edad << endl;
    cout << "Altura: " << p.altura << " metros" << endl;
    cout << "Fecha de Nacimiento: " << p.nacimiento.dia << "/"
         << p.nacimiento.mes << "/" << p.nacimiento.anio << endl;
}

int main() {
    Fecha fechaNacimiento = {15, 6, 1990};
    Persona juan = {"Juan", 30, 1.75f, fechaNacimiento};

    imprimirPersona(juan);

    Persona maria;
    maria.nombre = "Maria";
    maria.edad = 25;
    maria.altura = 1.65f;
    maria.nacimiento = {12, 10, 1995};

    imprimirPersona(maria);

    return 0;
}
<---Ejemplo Comparativo Result--->
<---Asignación de Valores Específicos--->
```cpp
enum Mes {
    Enero = 1,
    Febrero,
    Marzo,
    Abril,
    Mayo,
    Junio,
    Julio,
    Agosto,
    Septiembre,
    Octubre,
    Noviembre,
    Diciembre
};
<---Asignación de Valores Específicos Result--->
<---Ventajas de `enum class`--->
<---Ventajas de `enum class` Result--->
<---Ejemplo con Asignación de Valores Específicos--->
```cpp
#include <iostream>
using namespace std;

enum class Estado {
    Inactivo = 0,
    Activo = 1,
    Suspendido = 2,
    Eliminado = 3
};

int main() {
    Estado usuario = Estado::Activo;

    if (usuario == Estado::Activo) {
        cout << "El usuario está activo." << endl;
    }

    return 0;
}
<---Ejemplo con Asignación de Valores Específicos Result--->
<---Ejemplo de Conversión--->
```cpp
#include <iostream>
using namespace std;

enum class Dia : int {
    Lunes = 1,
    Martes,
    Miercoles,
    Jueves,
    Viernes,
    Sabado,
    Domingo
};

int main() {
    Dia hoy = Dia::Jueves;

    // Conversión explícita de enum class a int
    int diaNumero = static_cast<int>(hoy);
    cout << "Hoy es el día número: " << diaNumero << endl;

    return 0;
}
```cpp
#include <iostream>
using namespace std;

// Enumeración tradicional
enum DiaSemana {
    Lunes,
    Martes,
    Miercoles,
    Jueves,
    Viernes,
    Sabado,
    Domingo
};

// Clase de enumeración
enum class Estado {
    Inactivo = 0,
    Activo = 1,
    Suspendido = 2,
    Eliminado = 3
};

int main() {
    // Uso de enumeración tradicional
    DiaSemana hoy = Miercoles;
    if (hoy == Miercoles) {
        cout << "Hoy es miércoles." << endl;
    }

    // Uso de clase de enumeración
    Estado usuario = Estado::Activo;
    if (usuario == Estado::Activo) {
        cout << "El usuario está activo." << endl;
    }

    // Conversión explícita de enum class a int
    int estadoNumero = static_cast<int>(usuario);
    cout << "El estado del usuario es: " << estadoNumero << endl;

    return 0;
}
<---Ejemplo de Conversión Result--->
<---Características de `std::list`--->
<---Características de `std::list` Result--->
<---Ejemplo de Uso de `std::list`--->
```cpp
#include <iostream>
#include <list>
using namespace std;

int main() {
    // Declaración e inicialización de una lista
    list<int> miLista = {10, 20, 30, 40};

    // Inserción de elementos
    miLista.push_back(50);  // Añade al final
    miLista.push_front(5);  // Añade al inicio

    // Iteración y acceso a los elementos
    for (int elemento : miLista) {
        cout << elemento << " ";
    }
    cout << endl;

    // Eliminación de elementos
    miLista.pop_back();  // Elimina el último elemento
    miLista.pop_front(); // Elimina el primer elemento

    // Iteración y acceso a los elementos después de la eliminación
    for (int elemento : miLista) {
        cout << elemento << " ";
    }
    cout << endl;

    return 0;
}
<---Ejemplo de Uso de `std::list` Result--->
<---Características de `std::queue`--->
<---Características de `std::queue` Result--->
<---Ejemplo de Uso de `std::queue`--->
```cpp
#include <iostream>
#include <queue>
using namespace std;

int main() {
    // Declaración e inicialización de una cola
    queue<int> miCola;

    // Inserción de elementos
    miCola.push(10);
    miCola.push(20);
    miCola.push(30);

    // Acceso al primer y último elemento
    cout << "Frente: " << miCola.front() << endl;
    cout << "Final: " << miCola.back() << endl;

    // Eliminación de elementos
    miCola.pop(); // Elimina el primer elemento (10)

    // Acceso después de la eliminación
    cout << "Frente después de pop: " << miCola.front() << endl;

    return 0;
}
```cpp
#include <iostream>
#include <list>
#include <queue>
using namespace std;

int main() {
    // Uso de std::list
    list<int> miLista = {1, 2, 3, 4, 5};
    miLista.push_back(6);
    miLista.push_front(0);

    cout << "Lista: ";
    for (int elemento : miLista) {
        cout << elemento << " ";
    }
    cout << endl;

    miLista.pop_back();
    miLista.pop_front();

    cout << "Lista después de pop: ";
    for (int elemento : miLista) {
        cout << elemento << " ";
    }
    cout << endl;

    // Uso de std::queue
    queue<int> miCola;
    miCola.push(10);
    miCola.push(20);
    miCola.push(30);

    cout << "Cola frente: " << miCola.front() << ", final: " << miCola.back() << endl;
    miCola.pop();
    cout << "Cola frente después de pop: " << miCola.front() << endl;

    return 0;
}
<---Ejemplo de Uso de `std::queue` Result--->
<---Características de `std::stack`--->
<---Características de `std::stack` Result--->
<---Ejemplo de Uso de `std::stack`--->
```cpp
#include <iostream>
#include <stack>
using namespace std;

int main() {
    // Declaración e inicialización de una pila
    stack<int> miPila;

    // Inserción de elementos
    miPila.push(10);
    miPila.push(20);
    miPila.push(30);

    // Acceso al elemento superior
    cout << "Elemento superior: " << miPila.top() << endl;

    // Eliminación de elementos
    miPila.pop(); // Elimina el elemento superior (30)

    // Acceso después de la eliminación
    cout << "Elemento superior después de pop: " << miPila.top() << endl;

    return 0;
}
<---Ejemplo de Uso de `std::stack` Result--->
<---Características de `std::set`--->
<---Características de `std::set` Result--->
<---Ejemplo de Uso de `std::set`--->
```cpp
#include <iostream>
#include <set>
using namespace std;

int main() {
    // Declaración e inicialización de un conjunto
    set<int> miConjunto = {30, 10, 20, 40};

    // Inserción de elementos
    miConjunto.insert(50);
    miConjunto.insert(20); // No se añade ya que 20 ya existe

    // Iteración y acceso a los elementos
    cout << "Conjunto: ";
    for (int elemento : miConjunto) {
        cout << elemento << " ";
    }
    cout << endl;

    // Eliminación de un elemento
    miConjunto.erase(30);

    // Iteración y acceso a los elementos después de la eliminación
    cout << "Conjunto después de erase: ";
    for (int elemento : miConjunto) {
        cout << elemento << " ";
    }
    cout << endl;

    return 0;
}
```cpp
#include <iostream>
#include <stack>
#include <set>
using namespace std;

int main() {
    // Uso de std::stack
    stack<int> miPila;
    miPila.push(10);
    miPila.push(20);
    miPila.push(30);
    cout << "Pila elemento superior: " << miPila.top() << endl;
    miPila.pop();
    cout << "Pila elemento superior después de pop: " << miPila.top() << endl;

    // Uso de std::set
    set<int> miConjunto = {30, 10, 20, 40};
    miConjunto.insert(50);
    cout << "Conjunto: ";
    for (int elemento : miConjunto) {
        cout << elemento << " ";
    }
    cout << endl;
    miConjunto.erase(30);
    cout << "Conjunto después de erase: ";
    for (int elemento : miConjunto) {
        cout << elemento << " ";
    }
    cout << endl;

    return 0;
}
<---Ejemplo de Uso de `std::set` Result--->
<---Características de `std::map`--->
<---Características de `std::map` Result--->
<---Ejemplo de Uso de `std::map`--->
```cpp
#include <iostream>
#include <map>
using namespace std;

int main() {
    // Declaración e inicialización de un mapa
    map<string, int> edades;
    edades["Juan"] = 30;
    edades["Maria"] = 25;
    edades["Pedro"] = 35;

    // Iteración y acceso a los elementos
    for (const auto& par : edades) {
        cout << par.first << " tiene " << par.second << " años." << endl;
    }

    // Acceso a un valor específico
    cout << "La edad de Maria es: " << edades["Maria"] << endl;

    // Modificación de un valor
    edades["Maria"] = 26;
    cout << "La nueva edad de Maria es: " << edades["Maria"] << endl;

    // Eliminación de un elemento
    edades.erase("Pedro");

    // Iteración después de la eliminación
    for (const auto& par : edades) {
        cout << par.first << " tiene " << par.second << " años." << endl;
    }

    return 0;
}
<---Ejemplo de Uso de `std::map` Result--->
<---Características de `std::unordered_map`--->
<---Características de `std::unordered_map` Result--->
<---Ejemplo de Uso de `std::unordered_map`--->
```cpp
#include <iostream>
#include <unordered_map>
using namespace std;

int main() {
    // Declaración e inicialización de un unordered_map
    unordered_map<string, int> edades;
    edades["Juan"] = 30;
    edades["Maria"] = 25;
    edades["Pedro"] = 35;

    // Iteración y acceso a los elementos
    for (const auto& par : edades) {
        cout << par.first << " tiene " << par.second << " años." << endl;
    }

    // Acceso a un valor específico
    cout << "La edad de Maria es: " << edades["Maria"] << endl;

    // Modificación de un valor
    edades["Maria"] = 26;
    cout << "La nueva edad de Maria es: " << edades["Maria"] << endl;

    // Eliminación de un elemento
    edades.erase("Pedro");

    // Iteración después de la eliminación
    for (const auto& par : edades) {
        cout << par.first << " tiene " << par.second << " años." << endl;
    }

    return 0;
}
```cpp
#include <iostream>
#include <map>
#include <unordered_map>
using namespace std;

int main() {
    // Uso de std::map
    map<string, int> mapaOrdenado;
    mapaOrdenado["Juan"] = 30;
    mapaOrdenado["Maria"] = 25;
    mapaOrdenado["Pedro"] = 35;

    cout << "Mapa ordenado:" << endl;
    for (const auto& par : mapaOrdenado) {
        cout << par.first << " tiene " << par.second << " años." << endl;
    }

    // Uso de std::unordered_map
    unordered_map<string, int> mapaNoOrdenado;
    mapaNoOrdenado["Juan"] = 30;
    mapaNoOrdenado["Maria"] = 25;
    mapaNoOrdenado["Pedro"] = 35;

    cout << "\nMapa no ordenado:" << endl;
    for (const auto& par : mapaNoOrdenado) {
        cout << par.first << " tiene " << par.second << " años." << endl;
    }

    return 0;
}
<---Ejemplo de Uso de `std::unordered_map` Result--->
<---Inicialización Estática--->
```cpp
int matriz[2][3] = {
    {1, 2, 3},
    {4, 5, 6}
};
<---Inicialización Estática Result--->
<---Inicialización Dinámica--->
```cpp
#include <iostream>
using namespace std;

int main() {
    int filas = 3;
    int columnas = 3;

    // Declaración de un puntero a puntero
    int** matriz = new int*[filas];

    // Asignación de memoria para cada fila
    for (int i = 0; i < filas; ++i) {
        matriz[i] = new int[columnas];
    }

    // Inicialización de la matriz
    int contador = 1;
    for (int i = 0; i < filas; ++i) {
        for (int j = 0; j < columnas; ++j) {
            matriz[i][j] = contador++;
        }
    }

    // Acceso a los elementos de la matriz
    for (int i = 0; i < filas; ++i) {
        for (int j = 0; j < columnas; ++j) {
            cout << "Elemento [" << i << "][" << j << "]: " << matriz[i][j] << endl;
        }
    }

    // Liberación de la memoria
    for (int i = 0; i < filas; ++i) {
        delete[] matriz[i];
    }
    delete[] matriz;

    return 0;
}
<---Inicialización Dinámica Result--->
<---Ejemplo de Array Tridimensional--->
```cpp
#include <iostream>
using namespace std;

int main() {
    // Declaración de un array 2x2x2
    int cubo[2][2][2] = {
        {
            {1, 2},
            {3, 4}
        },
        {
            {5, 6},
            {7, 8}
        }
    };

    // Acceso a los elementos del array tridimensional
    for (int i = 0; i < 2; ++i) {
        for (int j = 0; j < 2; ++j) {
            for (int k = 0; k < 2; ++k) {
                cout << "Elemento [" << i << "][" << j << "][" << k << "]: " << cubo[i][j][k] << endl;
            }
        }
    }

    return 0;
}
```cpp
#include <iostream>
using namespace std;

int main() {
    int filas = 3;
    int columnas = 3;

    // Declaración de un puntero a puntero
    int** matriz = new int*[filas];

    // Asignación de memoria para cada fila
    for (int i = 0; i < filas; ++i) {
        matriz[i] = new int[columnas];
    }

    // Inicialización de la matriz
    int contador = 1;
    for (int i = 0; i < filas; ++i) {
        for (int j = 0; j < columnas; ++j) {
            matriz[i][j] = contador++;
        }
    }

    // Acceso a los elementos de la matriz
    cout << "Matriz inicializada:" << endl;
    for (int i = 0; i < filas; ++i) {
        for (int j = 0; j < columnas; ++j) {
            cout << matriz[i][j] << " ";
        }
        cout << endl;
    }

    // Liberación de la memoria
    for (int i = 0; i < filas; ++i) {
        delete[] matriz[i];
    }
    delete[] matriz;

    return 0;
}
<---Ejemplo de Array Tridimensional Result--->
<---Declaración Básica--->
```cpp
char cadena[6] = {'H', 'o', 'l', 'a', '\0'};
<---Declaración Básica Result--->
<---Declaración y Inicialización Simplificada--->
```cpp
char cadena[] = "Hola";
<---Declaración y Inicialización Simplificada Result--->
<---Ejemplo Completo de Declaración y Inicialización--->
```cpp
#include <iostream>
using namespace std;

int main() {
    char saludo1[] = "Hola";
    char saludo2[6] = {'H', 'o', 'l', 'a', '\0'};

    cout << saludo1 << endl;
    cout << saludo2 << endl;

    return 0;
}
<---Ejemplo Completo de Declaración y Inicialización Result--->
<---Copia de Cadenas: `strcpy`--->
```cpp
#include <iostream>
#include <cstring>
using namespace std;

int main() {
    char destino[20];
    const char* origen = "Hola Mundo";

    strcpy(destino, origen);

    cout << "Destino: " << destino << endl;

    return 0;
}
<---Copia de Cadenas: `strcpy` Result--->
<---Concatenación de Cadenas: `strcat`--->
```cpp
#include <iostream>
#include <cstring>
using namespace std;

int main() {
    char saludo[20] = "Hola, ";
    const char* nombre = "Mundo";

    strcat(saludo, nombre);

    cout << "Saludo completo: " << saludo << endl;

    return 0;
}
<---Concatenación de Cadenas: `strcat` Result--->
<---Longitud de la Cadena: `strlen`--->
```cpp
#include <iostream>
#include <cstring>
using namespace std;

int main() {
    const char* cadena = "Hola Mundo";
    size_t longitud = strlen(cadena);

    cout << "Longitud de la cadena: " << longitud << endl;

    return 0;
}
<---Longitud de la Cadena: `strlen` Result--->
<---Comparación de Cadenas: `strcmp`--->
```cpp
#include <iostream>
#include <cstring>
using namespace std;

int main() {
    const char* cadena1 = "Hola";
    const char* cadena2 = "Mundo";

    int resultado = strcmp(cadena1, cadena2);

    if (resultado == 0) {
        cout << "Las cadenas son iguales." << endl;
    } else if (resultado < 0) {
        cout << "cadena1 es menor que cadena2." << endl;
    } else {
        cout << "cadena1 es mayor que cadena2." << endl;
    }

    return 0;
}
<---Comparación de Cadenas: `strcmp` Result--->
<---Lectura de C-Strings con `cin`--->
```cpp
#include <iostream>
using namespace std;

int main() {
    char nombre[50];

    cout << "Introduce tu nombre: ";
    cin >> nombre;

    cout << "Hola, " << nombre << "!" << endl;

    return 0;
}
<---Lectura de C-Strings con `cin` Result--->
<---Lectura de Cadenas con Espacios usando `cin.getline`--->
```cpp
#include <iostream>
using namespace std;

int main() {
    char frase[100];

    cout << "Introduce una frase: ";
    cin.getline(frase, 100);

    cout << "Tu frase: " << frase << endl;

    return 0;
}
```cpp
#include <iostream>
#include <cstring>
using namespace std;

int main() {
    // Declaración e inicialización
    char saludo[50] = "Hola";
    const char* mundo = " Mundo";

    // Concatenación
    strcat(saludo, mundo);
    cout << "Concatenación: " << saludo << endl;

    // Copia
    char copia[50];
    strcpy(copia, saludo);
    cout << "Copia: " << copia << endl;

    // Longitud
    size_t longitud = strlen(copia);
    cout << "Longitud de la copia: " << longitud << endl;

    // Comparación
    const char* otraCadena = "Hola Mundo";
    if (strcmp(copia, otraCadena) == 0) {
        cout << "Las cadenas son iguales." << endl;
    } else {
        cout << "Las cadenas son diferentes." << endl;
    }

    // Entrada de C-Strings
    char entrada[50];
    cout << "Introduce una palabra: ";
    cin >> entrada;
    cout << "Palabra introducida: " << entrada << endl;

    return 0;
}
<---Lectura de Cadenas con Espacios usando `cin.getline` Result--->
<---Sintaxis--->
```cpp
using nuevo_nombre = tipo_original;
<---Sintaxis Result--->
<---Ejemplo Básico--->
```cpp
#include <iostream>
using namespace std;

using ulong = unsigned long;

int main() {
    ulong numero = 1000000;
    cout << "Número: " << numero << endl;
    return 0;
}
<---Ejemplo Básico Result--->
<---Inicialización de Lista--->
```cpp
Persona maria = {"Maria", 25, 1.65f};
<---Inicialización de Lista Result--->
<---Inicialización Miembro por Miembro--->
```cpp
Persona pedro;
pedro.nombre = "Pedro";
pedro.edad = 28;
pedro.altura = 1.80f;
<---Inicialización Miembro por Miembro Result--->
<---Copia de Estructuras--->
```cpp
Persona juan = {"Juan", 30, 1.75f};
Persona copiaJuan = juan;

cout << "Copia de Juan - Nombre: " << copiaJuan.nombre << endl;
<---Copia de Estructuras Result--->
<---Pasar Estructuras a Funciones--->
```cpp
void imprimirPersona(Persona p) {
    cout << "Nombre: " << p.nombre << endl;
    cout << "Edad: " << p.edad << endl;
    cout << "Altura: " << p.altura << " metros" << endl;
}

int main() {
    Persona juan = {"Juan", 30, 1.75f};
    imprimirPersona(juan);
    return 0;
}
<---Pasar Estructuras a Funciones Result--->
<---Retornar Estructuras desde Funciones--->
```cpp
Persona crearPersona(string nombre, int edad, float altura) {
    Persona p = {nombre, edad, altura};
    return p;
}

int main() {
    Persona ana = crearPersona("Ana", 22, 1.60f);
    cout << "Nombre: " << ana.nombre << endl;
    cout << "Edad: " << ana.edad << endl;
    cout << "Altura: " << ana.altura << " metros" << endl;
    return 0;
}
<---Retornar Estructuras desde Funciones Result--->
<---Ejemplo Comparativo--->
```cpp
struct Punto {
    int x; // Público por defecto
    int y;
};

class PuntoClase {
private:
    int x; // Privado por defecto
    int y;
public:
    void setX(int val) { x = val; }
    int getX() { return x; }
};

int main() {
    Punto p1;
    p1.x = 10; // Acceso directo permitido

    PuntoClase p2;
    // p2.x = 10; // Error: x es privado
    p2.setX(10); // Acceso mediante función miembro

    return 0;
}
```cpp
#include <iostream>
using namespace std;

struct Fecha {
    int dia;
    int mes;
    int anio;
};

struct Persona {
    string nombre;
    int edad;
    float altura;
    Fecha nacimiento;
};

void imprimirPersona(const Persona& p) {
    cout << "Nombre: " << p.nombre << endl;
    cout << "Edad: " << p.edad << endl;
    cout << "Altura: " << p.altura << " metros" << endl;
    cout << "Fecha de Nacimiento: " << p.nacimiento.dia << "/"
         << p.nacimiento.mes << "/" << p.nacimiento.anio << endl;
}

int main() {
    Fecha fechaNacimiento = {15, 6, 1990};
    Persona juan = {"Juan", 30, 1.75f, fechaNacimiento};

    imprimirPersona(juan);

    Persona maria;
    maria.nombre = "Maria";
    maria.edad = 25;
    maria.altura = 1.65f;
    maria.nacimiento = {12, 10, 1995};

    imprimirPersona(maria);

    return 0;
}
<---Ejemplo Comparativo Result--->
<---Asignación de Valores Específicos--->
```cpp
enum Mes {
    Enero = 1,
    Febrero,
    Marzo,
    Abril,
    Mayo,
    Junio,
    Julio,
    Agosto,
    Septiembre,
    Octubre,
    Noviembre,
    Diciembre
};
<---Asignación de Valores Específicos Result--->
<---Ventajas de `enum class`--->
<---Ventajas de `enum class` Result--->
<---Ejemplo con Asignación de Valores Específicos--->
```cpp
#include <iostream>
using namespace std;

enum class Estado {
    Inactivo = 0,
    Activo = 1,
    Suspendido = 2,
    Eliminado = 3
};

int main() {
    Estado usuario = Estado::Activo;

    if (usuario == Estado::Activo) {
        cout << "El usuario está activo." << endl;
    }

    return 0;
}
<---Ejemplo con Asignación de Valores Específicos Result--->
<---Ejemplo de Conversión--->
```cpp
#include <iostream>
using namespace std;

enum class Dia : int {
    Lunes = 1,
    Martes,
    Miercoles,
    Jueves,
    Viernes,
    Sabado,
    Domingo
};

int main() {
    Dia hoy = Dia::Jueves;

    // Conversión explícita de enum class a int
    int diaNumero = static_cast<int>(hoy);
    cout << "Hoy es el día número: " << diaNumero << endl;

    return 0;
}
```cpp
#include <iostream>
using namespace std;

// Enumeración tradicional
enum DiaSemana {
    Lunes,
    Martes,
    Miercoles,
    Jueves,
    Viernes,
    Sabado,
    Domingo
};

// Clase de enumeración
enum class Estado {
    Inactivo = 0,
    Activo = 1,
    Suspendido = 2,
    Eliminado = 3
};

int main() {
    // Uso de enumeración tradicional
    DiaSemana hoy = Miercoles;
    if (hoy == Miercoles) {
        cout << "Hoy es miércoles." << endl;
    }

    // Uso de clase de enumeración
    Estado usuario = Estado::Activo;
    if (usuario == Estado::Activo) {
        cout << "El usuario está activo." << endl;
    }

    // Conversión explícita de enum class a int
    int estadoNumero = static_cast<int>(usuario);
    cout << "El estado del usuario es: " << estadoNumero << endl;

    return 0;
}
<---Ejemplo de Conversión Result--->
<---Alias para Tipos Complejos--->
```cpp
#include <iostream>
using namespace std;

using FuncionPtr = int(*)(int, int);

int sumar(int a, int b) {
    return a + b;
}

int main() {
    FuncionPtr fp = sumar;
    cout << "Suma: " << fp(5, 3) << endl;
    return 0;
}
<---Alias para Tipos Complejos Result--->
<---Alias de Plantillas--->
```cpp
#include <iostream>
#include <vector>
using namespace std;

template <typename T>
using Vec = vector<T>;

int main() {
    Vec<int> numeros = {1, 2, 3, 4, 5};
    for (int num : numeros) {
        cout << num << " ";
    }
    cout << endl;
    return 0;
}
```cpp
#include <iostream>
#include <vector>
using namespace std;

// Alias con typedef
typedef unsigned long ulong;
typedef int (*FuncionPtr)(int, int);

// Alias con using
using ulong_alias = unsigned long;
using FuncionPtr_alias = int(*)(int, int);

template <typename T>
using Vec = vector<T>;

int sumar(int a, int b) {
    return a + b;
}

int main() {
    // Uso de typedef
    ulong numero1 = 1000000;
    FuncionPtr fp1 = sumar;
    cout << "Número1: " << numero1 << endl;
    cout << "Suma1: " << fp1(5, 3) << endl;

    // Uso de using
    ulong_alias numero2 = 2000000;
    FuncionPtr_alias fp2 = sumar;
    cout << "Número2: " << numero2 << endl;
    cout << "Suma2: " << fp2(7, 2) << endl;

    // Uso de alias de plantilla con using
    Vec<int> numeros = {1, 2, 3, 4, 5};
    for (int num : numeros) {
        cout << num << " ";
    }
    cout << endl;

    return 0;
}
<---Alias de Plantillas Result--->
