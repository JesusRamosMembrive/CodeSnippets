<---EXPLANATION--->
### Introducción al Polimorfismo en C++

El polimorfismo es uno de los pilares fundamentales de la programación orientada a objetos (POO). En C++, el polimorfismo permite que una interfaz común sea utilizada para diferentes tipos de objetos, permitiendo que una misma operación se ejecute de diferentes maneras según el tipo específico del objeto que la ejecuta. Este comportamiento es crucial para diseñar sistemas flexibles y reutilizables.

#### Definición de Polimorfismo

El término polimorfismo proviene del griego "poly" (muchos) y "morph" (forma), lo que significa "muchas formas". En el contexto de la POO, se refiere a la capacidad de una función o método para operar con objetos de diferentes tipos de forma uniforme.

##### Tipos de Polimorfismo en C++

1. **Polimorfismo de Sobrecarga (Polimorfismo Ad Hoc):** Permite definir múltiples funciones con el mismo nombre pero diferentes firmas (listas de parámetros). Se resuelve en tiempo de compilación.
2. **Polimorfismo Paramétrico:** Se implementa mediante plantillas (templates) en C++, permitiendo que las funciones y clases trabajen con cualquier tipo de datos.
3. **Polimorfismo de Inclusión (Polimorfismo Subtipo):** Permite que una clase derivada sea tratada como una clase base. Se resuelve en tiempo de ejecución y es el tipo de polimorfismo más común en la POO.

#### Polimorfismo de Inclusión

El polimorfismo de inclusión se logra mediante la herencia y el uso de funciones virtuales. Permite que un puntero o referencia a una clase base ejecute una función específica de la clase derivada a la que realmente pertenece el objeto.

##### Ejemplo de Polimorfismo de Inclusión

```cpp
#include <iostream>
using namespace std;

class Animal {
public:
    virtual void hacerSonido() const {
        cout << "El animal hace un sonido" << endl;
    }
};

class Perro : public Animal {
public:
    void hacerSonido() const override {
        cout << "El perro ladra" << endl;
    }
};

class Gato : public Animal {
public:
    void hacerSonido() const override {
        cout << "El gato maúlla" << endl;
    }
};

void hacerSonidoAnimal(const Animal& animal) {
    animal.hacerSonido();
}

int main() {
    Animal a;
    Perro p;
    Gato g;

    hacerSonidoAnimal(a); // Llama a Animal::hacerSonido()
    hacerSonidoAnimal(p); // Llama a Perro::hacerSonido()
    hacerSonidoAnimal(g); // Llama a Gato::hacerSonido()

    return 0;
}
```

En este ejemplo, la función `hacerSonidoAnimal` acepta una referencia a `Animal` pero llama a la implementación apropiada de `hacerSonido` según el tipo real del objeto (`Perro` o `Gato`).

#### Clases Abstractas y Funciones Virtuales Puras

Las clases abstractas son clases que no pueden ser instanciadas y se utilizan para definir interfaces comunes para sus clases derivadas. Contienen al menos una función virtual pura, que se declara utilizando `= 0`.

##### Ejemplo de Clase Abstracta

```cpp
#include <iostream>
using namespace std;

class Animal {
public:
    virtual void hacerSonido() const = 0; // Función virtual pura
};

class Perro : public Animal {
public:
    void hacerSonido() const override {
        cout << "El perro ladra" << endl;
    }
};

class Gato : public Animal {
public:
    void hacerSonido() const override {
        cout << "El gato maúlla" << endl;
    }
};

void hacerSonidoAnimal(const Animal& animal) {
    animal.hacerSonido();
}

int main() {
    // Animal a; // Error: no se puede instanciar una clase abstracta
    Perro p;
    Gato g;

    hacerSonidoAnimal(p); // Llama a Perro::hacerSonido()
    hacerSonidoAnimal(g); // Llama a Gato::hacerSonido()

    return 0;
}
```

En este ejemplo, `Animal` es una clase abstracta con una función virtual pura `hacerSonido`. Las clases derivadas `Perro` y `Gato` proporcionan implementaciones específicas de `hacerSonido`.

#### Uso del Polimorfismo en Colecciones

El polimorfismo es especialmente útil cuando se trabaja con colecciones de objetos de diferentes tipos derivados de una misma clase base. Esto permite tratar todos los objetos de manera uniforme mientras se mantiene la capacidad de ejecutar comportamientos específicos.

##### Ejemplo con Colección Polimórfica

```cpp
#include <iostream>
#include <vector>
using namespace std;

class Animal {
public:
    virtual void hacerSonido() const = 0; // Función virtual pura
    virtual ~Animal() {}
};

class Perro : public Animal {
public:
    void hacerSonido() const override {
        cout << "El perro ladra" << endl;
    }
};

class Gato : public Animal {
public:
    void hacerSonido() const override {
        cout << "El gato maúlla" << endl;
    }
};

int main() {
    vector<Animal*> animales;
    animales.push_back(new Perro());
    animales.push_back(new Gato());

    for (const auto& animal : animales) {
        animal->hacerSonido(); // Llama a la implementación apropiada
    }

    // Liberar memoria
    for (const auto& animal : animales) {
        delete animal;
    }

    return 0;
}
```

En este ejemplo, un vector de punteros a `Animal` contiene objetos de diferentes tipos derivados. El polimorfismo permite que `hacerSonido` llame a la implementación correcta para cada tipo de objeto.

### Conclusión

El polimorfismo es una característica poderosa de la programación orientada a objetos que permite a las funciones operar de manera uniforme en objetos de diferentes tipos. En C++, el polimorfismo se logra principalmente a través de funciones virtuales y herencia. Este mecanismo permite diseñar sistemas flexibles y reutilizables, facilitando la implementación de interfaces comunes y comportamientos específicos según el tipo de objeto. Comprender y utilizar correctamente el polimorfismo es esencial para aprovechar al máximo las capacidades de la programación orientada a objetos en C++.
<---FILES--->
Tipos de Polimorfismo en C++
Tipos de Polimorfismo en C++ Result
Ejemplo de Polimorfismo de Inclusión
Ejemplo de Polimorfismo de Inclusión Result
Ejemplo de Clase Abstracta
Ejemplo de Clase Abstracta Result
Ejemplo con Colección Polimórfica
Ejemplo con Colección Polimórfica Result
<---Tipos de Polimorfismo en C++--->
<---Tipos de Polimorfismo en C++ Result--->
<---Ejemplo de Polimorfismo de Inclusión--->
```cpp
#include <iostream>
using namespace std;

class Animal {
public:
    virtual void hacerSonido() const {
        cout << "El animal hace un sonido" << endl;
    }
};

class Perro : public Animal {
public:
    void hacerSonido() const override {
        cout << "El perro ladra" << endl;
    }
};

class Gato : public Animal {
public:
    void hacerSonido() const override {
        cout << "El gato maúlla" << endl;
    }
};

void hacerSonidoAnimal(const Animal& animal) {
    animal.hacerSonido();
}

int main() {
    Animal a;
    Perro p;
    Gato g;

    hacerSonidoAnimal(a); // Llama a Animal::hacerSonido()
    hacerSonidoAnimal(p); // Llama a Perro::hacerSonido()
    hacerSonidoAnimal(g); // Llama a Gato::hacerSonido()

    return 0;
}
<---Ejemplo de Polimorfismo de Inclusión Result--->
<---Ejemplo de Clase Abstracta--->
```cpp
#include <iostream>
using namespace std;

class Animal {
public:
    virtual void hacerSonido() const = 0; // Función virtual pura
};

class Perro : public Animal {
public:
    void hacerSonido() const override {
        cout << "El perro ladra" << endl;
    }
};

class Gato : public Animal {
public:
    void hacerSonido() const override {
        cout << "El gato maúlla" << endl;
    }
};

void hacerSonidoAnimal(const Animal& animal) {
    animal.hacerSonido();
}

int main() {
    // Animal a; // Error: no se puede instanciar una clase abstracta
    Perro p;
    Gato g;

    hacerSonidoAnimal(p); // Llama a Perro::hacerSonido()
    hacerSonidoAnimal(g); // Llama a Gato::hacerSonido()

    return 0;
}
<---Ejemplo de Clase Abstracta Result--->
<---Ejemplo con Colección Polimórfica--->
```cpp
#include <iostream>
#include <vector>
using namespace std;

class Animal {
public:
    virtual void hacerSonido() const = 0; // Función virtual pura
    virtual ~Animal() {}
};

class Perro : public Animal {
public:
    void hacerSonido() const override {
        cout << "El perro ladra" << endl;
    }
};

class Gato : public Animal {
public:
    void hacerSonido() const override {
        cout << "El gato maúlla" << endl;
    }
};

int main() {
    vector<Animal*> animales;
    animales.push_back(new Perro());
    animales.push_back(new Gato());

    for (const auto& animal : animales) {
        animal->hacerSonido(); // Llama a la implementación apropiada
    }

    // Liberar memoria
    for (const auto& animal : animales) {
        delete animal;
    }

    return 0;
}
<---Ejemplo con Colección Polimórfica Result--->
