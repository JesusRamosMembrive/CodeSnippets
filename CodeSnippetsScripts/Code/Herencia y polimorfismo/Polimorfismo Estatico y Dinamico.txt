<---EXPLANATION--->
### Herencia en C++

La herencia es uno de los pilares fundamentales de la programación orientada a objetos (POO). En C++, la herencia permite crear nuevas clases a partir de clases existentes, lo que facilita la reutilización del código y la creación de jerarquías de clases.

#### Definición de Herencia

La herencia es un mecanismo mediante el cual una clase (llamada clase derivada o subclase) puede heredar atributos y métodos de otra clase (llamada clase base o superclase). La clase derivada puede extender o modificar el comportamiento de la clase base.

- **Clase Base (Superclase):** La clase original que proporciona atributos y métodos a otras clases.
- **Clase Derivada (Subclase):** La nueva clase que hereda atributos y métodos de la clase base.

#### Ventajas de la Herencia

1. **Reutilización de Código:** La herencia permite reutilizar el código existente, lo que reduce la duplicación de código y facilita el mantenimiento.
2. **Extensibilidad:** Las clases derivadas pueden añadir nuevas funcionalidades o modificar las existentes sin cambiar el código de la clase base.
3. **Jerarquía y Organización:** La herencia permite organizar el código en jerarquías lógicas, facilitando la comprensión y gestión del mismo.
4. **Polimorfismo:** La herencia facilita el uso del polimorfismo, permitiendo que una misma interfaz se utilice para diferentes tipos de objetos.

#### Sintaxis Básica de la Herencia

La sintaxis básica para definir una clase derivada en C++ es la siguiente:

```cpp
class ClaseBase {
public:
    // Atributos y métodos de la clase base
};

class ClaseDerivada : public ClaseBase {
public:
    // Atributos y métodos adicionales de la clase derivada
};
```

- **`public`** indica que todos los miembros públicos de la clase base son accesibles como públicos en la clase derivada. Existen otros modos de herencia (`protected` y `private`), pero `public` es el más común.

##### Ejemplo Básico de Herencia

```cpp
#include <iostream>
using namespace std;

class Animal {
public:
    void comer() {
        cout << "El animal está comiendo." << endl;
    }
};

class Perro : public Animal {
public:
    void ladrar() {
        cout << "El perro está ladrando." << endl;
    }
};

int main() {
    Perro miPerro;
    miPerro.comer(); // Método heredado de la clase base
    miPerro.ladrar(); // Método de la clase derivada

    return 0;
}
```

En este ejemplo:
- `Animal` es la clase base que define un método `comer`.
- `Perro` es la clase derivada que hereda de `Animal` y añade un método `ladrar`.

#### Tipos de Herencia

1. **Herencia Pública (`public`):** Los miembros públicos y protegidos de la clase base se convierten en públicos y protegidos en la clase derivada, respectivamente.
2. **Herencia Protegida (`protected`):** Los miembros públicos y protegidos de la clase base se convierten en protegidos en la clase derivada.
3. **Herencia Privada (`private`):** Los miembros públicos y protegidos de la clase base se convierten en privados en la clase derivada.

##### Ejemplo de Diferentes Modos de Herencia

```cpp
#include <iostream>
using namespace std;

class Base {
public:
    int publicVar;
protected:
    int protectedVar;
private:
    int privateVar;
};

class DerivadaPublic : public Base {
    // publicVar es public
    // protectedVar es protected
    // privateVar no es accesible
};

class DerivadaProtected : protected Base {
    // publicVar es protected
    // protectedVar es protected
    // privateVar no es accesible
};

class DerivadaPrivate : private Base {
    // publicVar es private
    // protectedVar es private
    // privateVar no es accesible
};

int main() {
    DerivadaPublic objPublic;
    objPublic.publicVar = 10; // Accesible
    // objPublic.protectedVar = 20; // No accesible
    // objPublic.privateVar = 30; // No accesible

    DerivadaProtected objProtected;
    // objProtected.publicVar = 10; // No accesible
    // objProtected.protectedVar = 20; // No accesible

    DerivadaPrivate objPrivate;
    // objPrivate.publicVar = 10; // No accesible
    // objPrivate.protectedVar = 20; // No accesible

    return 0;
}
```

En este ejemplo, se muestra cómo los diferentes modos de herencia afectan la accesibilidad de los miembros de la clase base en la clase derivada.

### Conclusión

La herencia es una característica poderosa de la programación orientada a objetos que permite crear nuevas clases basadas en clases existentes. Ofrece numerosas ventajas, como la reutilización de código, la extensibilidad y el uso de polimorfismo. La sintaxis de herencia en C++ es sencilla y permite definir jerarquías claras y organizadas, facilitando el desarrollo y mantenimiento del software. Entender los diferentes modos de herencia y cómo afectan la accesibilidad de los miembros es crucial para aprovechar al máximo esta característica.
### Definición de Clase, Clase Base y Clase Derivada en C++

En la programación orientada a objetos (POO) en C++, las clases son los bloques de construcción fundamentales que encapsulan datos y comportamientos relacionados. La herencia permite crear jerarquías de clases donde una clase puede heredar atributos y métodos de otra. Entender la diferencia entre clases base y clases derivadas es crucial para aprovechar al máximo las ventajas de la POO.

#### Definición de Clase

Una clase en C++ es una plantilla para crear objetos. Una clase define un conjunto de atributos (datos) y métodos (funciones) que operan sobre esos datos. Los atributos representan el estado del objeto, mientras que los métodos representan el comportamiento del objeto.

##### Sintaxis Básica de una Clase

```cpp
class NombreClase {
public:
    // Atributos
    tipo_atributo nombre_atributo;

    // Métodos
    tipo_retorno nombre_metodo(parametros);

    // Otros componentes, como constructores, destructores, etc.
};
```

##### Ejemplo de una Clase Básica

```cpp
#include <iostream>
using namespace std;

class Persona {
public:
    string nombre;
    int edad;

    // Constructor
    Persona(string n, int e) : nombre(n), edad(e) {}

    // Método para mostrar información
    void mostrarInformacion() const {
        cout << "Nombre: " << nombre << ", Edad: " << edad << endl;
    }
};

int main() {
    Persona juan("Juan", 30);
    juan.mostrarInformacion();

    return 0;
}
```

En este ejemplo, `Persona` es una clase con dos atributos (`nombre` y `edad`) y un método (`mostrarInformacion`).

#### Definición de Clase Base

Una clase base (también conocida como superclase o clase padre) es una clase que se utiliza como punto de partida para crear otras clases mediante herencia. La clase base proporciona atributos y métodos que son comunes a todas las clases derivadas.

##### Ejemplo de una Clase Base

```cpp
#include <iostream>
using namespace std;

class Animal {
public:
    void comer() const {
        cout << "El animal está comiendo." << endl;
    }

    void dormir() const {
        cout << "El animal está durmiendo." << endl;
    }
};
```

En este ejemplo, `Animal` es una clase base que define dos métodos (`comer` y `dormir`) que son comunes a todos los animales.

#### Definición de Clase Derivada

Una clase derivada (también conocida como subclase o clase hija) es una clase que hereda atributos y métodos de otra clase (la clase base). La clase derivada puede extender o modificar el comportamiento de la clase base.

##### Sintaxis Básica de una Clase Derivada

```cpp
class ClaseDerivada : public ClaseBase {
public:
    // Atributos y métodos adicionales
};
```

- **`public`** indica que la herencia es pública, es decir, los miembros públicos y protegidos de la clase base permanecen públicos y protegidos en la clase derivada.

##### Ejemplo de una Clase Derivada

```cpp
#include <iostream>
using namespace std;

class Animal {
public:
    void comer() const {
        cout << "El animal está comiendo." << endl;
    }

    void dormir() const {
        cout << "El animal está durmiendo." << endl;
    }
};

class Perro : public Animal {
public:
    void ladrar() const {
        cout << "El perro está ladrando." << endl;
    }
};

int main() {
    Perro miPerro;
    miPerro.comer(); // Método heredado de la clase base
    miPerro.dormir(); // Método heredado de la clase base
    miPerro.ladrar(); // Método de la clase derivada

    return 0;
}
```

En este ejemplo:
- `Animal` es la clase base que define métodos comunes (`comer` y `dormir`).
- `Perro` es la clase derivada que hereda de `Animal` y añade un método adicional (`ladrar`).

### Conclusión

Las clases son los bloques de construcción fundamentales en la programación orientada a objetos en C++. Una clase encapsula datos y comportamientos, proporcionando una plantilla para crear objetos. Las clases base y derivadas permiten la reutilización y extensión del código a través de la herencia, donde las clases derivadas heredan y pueden extender los atributos y métodos de las clases base. Esta estructura facilita la organización, mantenimiento y expansión del código en proyectos de software complejos.
### Acceso a Miembros de la Clase Base y Creación de Objetos de la Clase Derivada en C++

En la programación orientada a objetos en C++, la herencia permite que las clases derivadas accedan a los miembros de la clase base y extiendan su funcionalidad. Entender cómo se accede a estos miembros y cómo se crean objetos de clases derivadas es crucial para aprovechar al máximo la herencia.

#### Acceso a Miembros de la Clase Base

En C++, los miembros de una clase base pueden tener diferentes niveles de acceso: `public`, `protected`, y `private`. La accesibilidad de estos miembros en una clase derivada depende del especificador de acceso utilizado en la herencia y del nivel de acceso original de los miembros en la clase base.

##### Especificadores de Acceso

- **`public`:** Los miembros públicos de la clase base se mantienen públicos en la clase derivada. Los miembros protegidos de la clase base se mantienen protegidos en la clase derivada.
- **`protected`:** Los miembros públicos y protegidos de la clase base se convierten en protegidos en la clase derivada.
- **`private`:** Los miembros públicos y protegidos de la clase base se convierten en privados en la clase derivada.

##### Ejemplo de Acceso a Miembros de la Clase Base

```cpp
#include <iostream>
using namespace std;

class Base {
public:
    int publicVar;

protected:
    int protectedVar;

private:
    int privateVar;
};

class DerivadaPublic : public Base {
public:
    void mostrar() {
        cout << "Acceso en DerivadaPublic:" << endl;
        cout << "publicVar: " << publicVar << endl; // Accesible
        cout << "protectedVar: " << protectedVar << endl; // Accesible
        // cout << "privateVar: " << privateVar << endl; // No accesible
    }
};

class DerivadaProtected : protected Base {
public:
    void mostrar() {
        cout << "Acceso en DerivadaProtected:" << endl;
        cout << "publicVar: " << publicVar << endl; // Accesible
        cout << "protectedVar: " << protectedVar << endl; // Accesible
        // cout << "privateVar: " << privateVar << endl; // No accesible
    }
};

class DerivadaPrivate : private Base {
public:
    void mostrar() {
        cout << "Acceso en DerivadaPrivate:" << endl;
        cout << "publicVar: " << publicVar << endl; // Accesible
        cout << "protectedVar: " << protectedVar << endl; // Accesible
        // cout << "privateVar: " << privateVar << endl; // No accesible
    }
};

int main() {
    DerivadaPublic objPublic;
    objPublic.publicVar = 10;
    objPublic.mostrar();

    DerivadaProtected objProtected;
    // objProtected.publicVar = 20; // No accesible desde fuera de la clase derivada
    objProtected.mostrar();

    DerivadaPrivate objPrivate;
    // objPrivate.publicVar = 30; // No accesible desde fuera de la clase derivada
    objPrivate.mostrar();

    return 0;
}
```

En este ejemplo, mostramos cómo los miembros de la clase base son accesibles en clases derivadas dependiendo del especificador de acceso utilizado en la herencia.

#### Creación de Objetos de la Clase Derivada

La creación de objetos de la clase derivada sigue las mismas reglas básicas que la creación de objetos de cualquier clase en C++. Sin embargo, es importante entender cómo se inicializan los miembros de la clase base durante la construcción de un objeto derivado.

##### Constructores de Clases Derivadas

Cuando se crea un objeto de una clase derivada, el constructor de la clase base se llama automáticamente antes de que se ejecute el constructor de la clase derivada. La lista de inicialización del constructor de la clase derivada se puede utilizar para inicializar los miembros de la clase base.

##### Ejemplo de Creación de Objetos de la Clase Derivada

```cpp
#include <iostream>
using namespace std;

class Base {
protected:
    int baseVar;

public:
    // Constructor de la clase base
    Base(int v) : baseVar(v) {
        cout << "Constructor de la clase Base llamado con valor " << baseVar << endl;
    }

    void mostrarBase() const {
        cout << "Valor de baseVar: " << baseVar << endl;
    }
};

class Derivada : public Base {
private:
    int derivadaVar;

public:
    // Constructor de la clase derivada
    Derivada(int baseVal, int derivadaVal) : Base(baseVal), derivadaVar(derivadaVal) {
        cout << "Constructor de la clase Derivada llamado con valor " << derivadaVar << endl;
    }

    void mostrarDerivada() const {
        mostrarBase();
        cout << "Valor de derivadaVar: " << derivadaVar << endl;
    }
};

int main() {
    Derivada obj(10, 20);
    obj.mostrarDerivada();

    return 0;
}
```

En este ejemplo:
- La clase `Base` tiene un constructor que inicializa `baseVar`.
- La clase `Derivada` hereda de `Base` y su constructor inicializa tanto `baseVar` (a través de la lista de inicialización) como `derivadaVar`.

#### Invocación de Constructores de la Clase Base

El constructor de la clase base se llama automáticamente antes de que se ejecute el constructor de la clase derivada. Esto asegura que todos los miembros de la clase base se inicialicen correctamente antes de inicializar los miembros de la clase derivada.

##### Ejemplo de Invocación de Constructores

```cpp
#include <iostream>
using namespace std;

class Base {
public:
    Base() {
        cout << "Constructor de Base llamado" << endl;
    }

    Base(int x) {
        cout << "Constructor de Base llamado con valor " << x << endl;
    }
};

class Derivada : public Base {
public:
    Derivada() {
        cout << "Constructor de Derivada llamado" << endl;
    }

    Derivada(int y) : Base(y) {
        cout << "Constructor de Derivada llamado con valor " << y << endl;
    }
};

int main() {
    cout << "Creando obj1:" << endl;
    Derivada obj1;

    cout << "\nCreando obj2:" << endl;
    Derivada obj2(100);

    return 0;
}
```

En este ejemplo, vemos cómo el constructor de la clase base se llama automáticamente antes del constructor de la clase derivada. Cuando se crea `obj2` con un valor, el constructor parametrizado de `Base` se invoca con el valor proporcionado.

### Conclusión

La herencia en C++ permite que las clases derivadas accedan a los miembros de la clase base y extiendan su funcionalidad. Los especificadores de acceso (`public`, `protected`, `private`) juegan un papel crucial en determinar cómo los miembros de la clase base son accesibles en la clase derivada. La creación de objetos de la clase derivada implica la llamada automática al constructor de la clase base, asegurando que todos los miembros se inicialicen correctamente. Entender estos conceptos es esencial para diseñar jerarquías de clases efectivas y aprovechar al máximo la programación orientada a objetos en C++.
### Tipos de Herencia en C++

La herencia en C++ permite a las clases derivadas heredar atributos y métodos de una o más clases base. Existen varios tipos de herencia que pueden utilizarse dependiendo de la relación entre las clases. Estos tipos incluyen herencia simple, múltiple, multinivel, jerárquica y híbrida.

#### Herencia Simple

La herencia simple es el tipo más básico de herencia en el que una clase derivada hereda de una única clase base.

##### Ejemplo de Herencia Simple

```cpp
#include <iostream>
using namespace std;

class Animal {
public:
    void comer() {
        cout << "El animal está comiendo." << endl;
    }
};

class Perro : public Animal {
public:
    void ladrar() {
        cout << "El perro está ladrando." << endl;
    }
};

int main() {
    Perro miPerro;
    miPerro.comer(); // Método heredado de la clase base
    miPerro.ladrar(); // Método de la clase derivada

    return 0;
}
```

En este ejemplo, `Perro` hereda de `Animal` utilizando herencia simple.

#### Herencia Múltiple

La herencia múltiple permite que una clase derivada herede de más de una clase base. C++ admite herencia múltiple, aunque se debe usar con cuidado para evitar ambigüedades y problemas de mantenimiento.

##### Ejemplo de Herencia Múltiple

```cpp
#include <iostream>
using namespace std;

class Animal {
public:
    void comer() {
        cout << "El animal está comiendo." << endl;
    }
};

class Mascota {
public:
    void jugar() {
        cout << "La mascota está jugando." << endl;
    }
};

class Perro : public Animal, public Mascota {
public:
    void ladrar() {
        cout << "El perro está ladrando." << endl;
    }
};

int main() {
    Perro miPerro;
    miPerro.comer(); // Método heredado de Animal
    miPerro.jugar(); // Método heredado de Mascota
    miPerro.ladrar(); // Método de la clase derivada

    return 0;
}
```

En este ejemplo, `Perro` hereda de ambas clases `Animal` y `Mascota` utilizando herencia múltiple.

#### Herencia Multinivel

La herencia multinivel es una cadena de herencias en la que una clase derivada se convierte en la clase base de otra clase derivada. Esto crea una cadena de clases.

##### Ejemplo de Herencia Multinivel

```cpp
#include <iostream>
using namespace std;

class Animal {
public:
    void comer() {
        cout << "El animal está comiendo." << endl;
    }
};

class Mamifero : public Animal {
public:
    void amamantar() {
        cout << "El mamífero está amamantando." << endl;
    }
};

class Perro : public Mamifero {
public:
    void ladrar() {
        cout << "El perro está ladrando." << endl;
    }
};

int main() {
    Perro miPerro;
    miPerro.comer(); // Método heredado de Animal
    miPerro.amamantar(); // Método heredado de Mamifero
    miPerro.ladrar(); // Método de la clase derivada

    return 0;
}
```

En este ejemplo, `Perro` hereda de `Mamifero`, que a su vez hereda de `Animal`, formando una herencia multinivel.

#### Herencia Jerárquica

La herencia jerárquica ocurre cuando una sola clase base tiene más de una clase derivada. Es decir, múltiples clases derivadas heredan de una misma clase base.

##### Ejemplo de Herencia Jerárquica

```cpp
#include <iostream>
using namespace std;

class Animal {
public:
    void comer() {
        cout << "El animal está comiendo." << endl;
    }
};

class Perro : public Animal {
public:
    void ladrar() {
        cout << "El perro está ladrando." << endl;
    }
};

class Gato : public Animal {
public:
    void maullar() {
        cout << "El gato está maullando." << endl;
    }
};

int main() {
    Perro miPerro;
    miPerro.comer(); // Método heredado de Animal
    miPerro.ladrar(); // Método de la clase derivada

    Gato miGato;
    miGato.comer(); // Método heredado de Animal
    miGato.maullar(); // Método de la clase derivada

    return 0;
}
```

En este ejemplo, tanto `Perro` como `Gato` heredan de `Animal`, utilizando herencia jerárquica.

#### Herencia Híbrida

La herencia híbrida es una combinación de dos o más tipos de herencia. Puede incluir una combinación de herencia simple, múltiple, multinivel y jerárquica.

##### Ejemplo de Herencia Híbrida

```cpp
#include <iostream>
using namespace std;

class Animal {
public:
    void comer() {
        cout << "El animal está comiendo." << endl;
    }
};

class Mascota {
public:
    void jugar() {
        cout << "La mascota está jugando." << endl;
    }
};

class Mamifero : public Animal {
public:
    void amamantar() {
        cout << "El mamífero está amamantando." << endl;
    }
};

class Perro : public Mamifero, public Mascota {
public:
    void ladrar() {
        cout << "El perro está ladrando." << endl;
    }
};

int main() {
    Perro miPerro;
    miPerro.comer(); // Método heredado de Animal a través de Mamifero
    miPerro.amamantar(); // Método heredado de Mamifero
    miPerro.jugar(); // Método heredado de Mascota
    miPerro.ladrar(); // Método de la clase derivada

    return 0;
}
```

En este ejemplo, `Perro` hereda de `Mamifero` (que a su vez hereda de `Animal`) y también de `Mascota`, combinando herencia múltiple y multinivel, formando una herencia híbrida.

### Conclusión

C++ ofrece varios tipos de herencia que permiten a los desarrolladores diseñar jerarquías de clases de acuerdo con las necesidades del problema. Herencia simple, múltiple, multinivel, jerárquica e híbrida son herramientas poderosas para crear relaciones entre clases y reutilizar código de manera eficiente. Sin embargo, es importante utilizar la herencia de manera adecuada para evitar problemas de complejidad y mantenimiento del código. Entender estos tipos de herencia y cómo aplicarlos correctamente es esencial para el desarrollo de software orientado a objetos en C++.
### Modificadores de Acceso dentro de la Herencia en C++

En C++, los modificadores de acceso (`public`, `protected`, y `private`) juegan un papel crucial en la herencia, ya que determinan cómo los miembros de la clase base son accesibles en la clase derivada y en otras partes del programa. Entender estos modificadores es esencial para controlar la visibilidad y accesibilidad de los atributos y métodos heredados.

#### Modificadores de Acceso

1. **`public`:** Los miembros públicos son accesibles desde cualquier parte del programa.
2. **`protected`:** Los miembros protegidos son accesibles dentro de la propia clase, en las clases derivadas y en las clases amigas, pero no desde fuera de estas clases.
3. **`private`:** Los miembros privados son accesibles solo dentro de la propia clase y en las clases amigas, pero no en las clases derivadas ni desde fuera de estas clases.

#### Herencia Pública (`public`)

Cuando una clase derivada hereda de una clase base utilizando el modificador de acceso `public`, los miembros públicos y protegidos de la clase base mantienen su nivel de acceso en la clase derivada.

##### Ejemplo de Herencia Pública

```cpp
#include <iostream>
using namespace std;

class Base {
public:
    int publicVar;
protected:
    int protectedVar;
private:
    int privateVar;
};

class Derivada : public Base {
public:
    void mostrar() {
        cout << "Acceso en Derivada:" << endl;
        cout << "publicVar: " << publicVar << endl; // Accesible
        cout << "protectedVar: " << protectedVar << endl; // Accesible
        // cout << "privateVar: " << privateVar << endl; // No accesible
    }
};

int main() {
    Derivada obj;
    obj.publicVar = 10;
    // obj.protectedVar = 20; // No accesible desde fuera de la clase derivada
    obj.mostrar();

    return 0;
}
```

En este ejemplo, `publicVar` y `protectedVar` son accesibles dentro de la clase derivada `Derivada`, pero `protectedVar` no es accesible fuera de la clase derivada.

#### Herencia Protegida (`protected`)

Cuando una clase derivada hereda de una clase base utilizando el modificador de acceso `protected`, los miembros públicos y protegidos de la clase base se convierten en protegidos en la clase derivada.

##### Ejemplo de Herencia Protegida

```cpp
#include <iostream>
using namespace std;

class Base {
public:
    int publicVar;
protected:
    int protectedVar;
private:
    int privateVar;
};

class Derivada : protected Base {
public:
    void mostrar() {
        cout << "Acceso en Derivada:" << endl;
        cout << "publicVar: " << publicVar << endl; // Accesible
        cout << "protectedVar: " << protectedVar << endl; // Accesible
        // cout << "privateVar: " << privateVar << endl; // No accesible
    }
};

int main() {
    Derivada obj;
    // obj.publicVar = 10; // No accesible desde fuera de la clase derivada
    // obj.protectedVar = 20; // No accesible desde fuera de la clase derivada
    obj.mostrar();

    return 0;
}
```

En este ejemplo, `publicVar` y `protectedVar` son accesibles dentro de la clase derivada `Derivada`, pero no son accesibles desde fuera de la clase derivada.

#### Herencia Privada (`private`)

Cuando una clase derivada hereda de una clase base utilizando el modificador de acceso `private`, los miembros públicos y protegidos de la clase base se convierten en privados en la clase derivada.

##### Ejemplo de Herencia Privada

```cpp
#include <iostream>
using namespace std;

class Base {
public:
    int publicVar;
protected:
    int protectedVar;
private:
    int privateVar;
};

class Derivada : private Base {
public:
    void mostrar() {
        cout << "Acceso en Derivada:" << endl;
        cout << "publicVar: " << publicVar << endl; // Accesible
        cout << "protectedVar: " << protectedVar << endl; // Accesible
        // cout << "privateVar: " << privateVar << endl; // No accesible
    }
};

int main() {
    Derivada obj;
    // obj.publicVar = 10; // No accesible desde fuera de la clase derivada
    // obj.protectedVar = 20; // No accesible desde fuera de la clase derivada
    obj.mostrar();

    return 0;
}
```

En este ejemplo, `publicVar` y `protectedVar` son accesibles dentro de la clase derivada `Derivada`, pero no son accesibles desde fuera de la clase derivada, ya que se convierten en privados en `Derivada`.

### Comparación de Modificadores de Acceso en Herencia

La siguiente tabla resume cómo se heredan los miembros de la clase base según el modificador de acceso utilizado:

| Tipo de Miembro    | Herencia Pública | Herencia Protegida | Herencia Privada |
|--------------------|------------------|--------------------|------------------|
| `public`           | `public`         | `protected`        | `private`        |
| `protected`        | `protected`      | `protected`        | `private`        |
| `private`          | No accesible     | No accesible       | No accesible     |

### Conclusión

Los modificadores de acceso en la herencia (`public`, `protected`, y `private`) son esenciales para controlar la visibilidad y accesibilidad de los miembros de la clase base en las clases derivadas. La herencia pública mantiene los miembros públicos y protegidos, la herencia protegida convierte los miembros públicos y protegidos en protegidos, y la herencia privada convierte los miembros públicos y protegidos en privados. Comprender cómo funcionan estos modificadores de acceso es crucial para diseñar jerarquías de clases que sean seguras y fáciles de mantener en C++.
### Sobrecarga de Funciones en Herencia

La sobrecarga de funciones es un concepto importante en la programación orientada a objetos en C++. Permite definir múltiples funciones con el mismo nombre pero con diferentes parámetros en la misma clase o en clases derivadas. En el contexto de herencia, la sobrecarga de funciones se vuelve aún más poderosa, permitiendo a las clases derivadas extender y modificar el comportamiento de las funciones miembro de las clases base.

#### Sobrecarga de Funciones

La sobrecarga de funciones se refiere a la capacidad de definir múltiples funciones con el mismo nombre pero con diferentes listas de parámetros. Esto permite que una función se comporte de manera diferente según los argumentos que se le pasen.

##### Ejemplo Básico de Sobrecarga de Funciones

```cpp
#include <iostream>
using namespace std;

class Base {
public:
    void mostrar() {
        cout << "Mostrar sin parámetros en la clase Base" << endl;
    }

    void mostrar(int x) {
        cout << "Mostrar con un parámetro en la clase Base: " << x << endl;
    }
};

int main() {
    Base b;
    b.mostrar();
    b.mostrar(10);

    return 0;
}
```

En este ejemplo, la clase `Base` tiene dos funciones `mostrar` sobrecargadas: una sin parámetros y otra con un parámetro entero.

#### Sobrecarga de Funciones en Herencia

En herencia, una clase derivada puede sobrecargar funciones miembro de la clase base, proporcionando diferentes versiones de la función en la clase derivada. Esto permite que la clase derivada extienda el comportamiento de la clase base.

##### Ejemplo de Sobrecarga de Funciones en Herencia

```cpp
#include <iostream>
using namespace std;

class Base {
public:
    void mostrar() {
        cout << "Mostrar sin parámetros en la clase Base" << endl;
    }

    void mostrar(int x) {
        cout << "Mostrar con un parámetro en la clase Base: " << x << endl;
    }
};

class Derivada : public Base {
public:
    void mostrar(double y) {
        cout << "Mostrar con un parámetro double en la clase Derivada: " << y << endl;
    }
};

int main() {
    Derivada d;
    d.mostrar();       // Llama a Base::mostrar()
    d.mostrar(10);     // Llama a Base::mostrar(int)
    d.mostrar(3.14);   // Llama a Derivada::mostrar(double)

    return 0;
}
```

En este ejemplo, la clase `Derivada` hereda de `Base` y sobrecarga la función `mostrar` añadiendo una versión que toma un parámetro de tipo `double`. Las funciones `mostrar` de la clase base también están disponibles en la clase derivada.

#### Uso de `using` para Sobrecargar Funciones

En algunos casos, es posible que desee sobrecargar una función de la clase base en la clase derivada y también exponer las versiones de la función de la clase base. Puede utilizar la declaración `using` para hacer esto explícitamente.

##### Ejemplo de Uso de `using`

```cpp
#include <iostream>
using namespace std;

class Base {
public:
    void mostrar() {
        cout << "Mostrar sin parámetros en la clase Base" << endl;
    }

    void mostrar(int x) {
        cout << "Mostrar con un parámetro en la clase Base: " << x << endl;
    }
};

class Derivada : public Base {
public:
    using Base::mostrar; // Hacer visibles las funciones sobrecargadas de la clase base

    void mostrar(double y) {
        cout << "Mostrar con un parámetro double en la clase Derivada: " << y << endl;
    }
};

int main() {
    Derivada d;
    d.mostrar();       // Llama a Base::mostrar()
    d.mostrar(10);     // Llama a Base::mostrar(int)
    d.mostrar(3.14);   // Llama a Derivada::mostrar(double)

    return 0;
}
```

En este ejemplo, `using Base::mostrar;` en la clase `Derivada` hace visibles las funciones `mostrar` sobrecargadas de la clase base, permitiendo que las versiones de la clase base y la nueva versión en la clase derivada se utilicen en la instancia de la clase derivada.

#### Sobrecarga de Operadores en Herencia

Al igual que las funciones miembro, los operadores pueden ser sobrecargados en las clases derivadas. Esto permite que las clases derivadas extiendan el comportamiento de los operadores definidos en las clases base.

##### Ejemplo de Sobrecarga de Operadores en Herencia

```cpp
#include <iostream>
using namespace std;

class Base {
public:
    virtual void mostrar() const {
        cout << "Mostrar en la clase Base" << endl;
    }

    virtual void operador() const {
        cout << "Operador en la clase Base" << endl;
    }
};

class Derivada : public Base {
public:
    void mostrar() const override {
        cout << "Mostrar en la clase Derivada" << endl;
    }

    void operador() const override {
        cout << "Operador en la clase Derivada" << endl;
    }
};

int main() {
    Base* ptrBase = new Derivada();
    ptrBase->mostrar();    // Llama a Derivada::mostrar()
    ptrBase->operador();   // Llama a Derivada::operador()

    delete ptrBase;
    return 0;
}
```

En este ejemplo, `Derivada` sobrecarga los operadores definidos en la clase `Base`, extendiendo su comportamiento.

### Conclusión

La sobrecarga de funciones en herencia es una herramienta poderosa en C++ que permite a las clases derivadas extender y modificar el comportamiento de las funciones miembro de las clases base. Utilizando la declaración `using`, puede exponer las versiones de la función de la clase base en la clase derivada. Además, la sobrecarga de operadores puede ser utilizada de manera similar para extender el comportamiento de los operadores en las clases derivadas. Comprender y utilizar adecuadamente la sobrecarga de funciones en herencia es crucial para aprovechar al máximo las capacidades de la programación orientada a objetos en C++.
### Anulación de Funciones en Herencia en C++

La anulación de funciones (también conocida como "sobrescritura" de funciones) es un concepto clave en la programación orientada a objetos en C++. Permite a las clases derivadas proporcionar una implementación específica de una función que ya está definida en su clase base. Este mecanismo es fundamental para el polimorfismo, ya que permite que las funciones se comporten de manera diferente según el tipo de objeto que las invoca.

#### Definición de Anulación de Funciones

La anulación de funciones ocurre cuando una clase derivada redefine una función miembro de su clase base. Para que una función pueda ser anulada, debe ser declarada como `virtual` en la clase base. La función en la clase derivada debe tener la misma firma (nombre, parámetros y tipo de retorno) que en la clase base.

##### Sintaxis Básica

```cpp
class Base {
public:
    virtual void funcion() {
        // Implementación de la clase base
    }
};

class Derivada : public Base {
public:
    void funcion() override {
        // Implementación de la clase derivada
    }
};
```

- **`virtual`**: Indica que la función puede ser anulada en una clase derivada.
- **`override`**: Es opcional pero recomendable, ya que proporciona una verificación en tiempo de compilación de que la función está realmente anulando una función virtual de la clase base.

#### Ejemplo Básico de Anulación de Funciones

```cpp
#include <iostream>
using namespace std;

class Animal {
public:
    virtual void hacerSonido() const {
        cout << "El animal hace un sonido" << endl;
    }
};

class Perro : public Animal {
public:
    void hacerSonido() const override {
        cout << "El perro ladra" << endl;
    }
};

class Gato : public Animal {
public:
    void hacerSonido() const override {
        cout << "El gato maúlla" << endl;
    }
};

void hacerSonidoAnimal(const Animal& animal) {
    animal.hacerSonido();
}

int main() {
    Animal a;
    Perro p;
    Gato g;

    hacerSonidoAnimal(a); // Llama a Animal::hacerSonido()
    hacerSonidoAnimal(p); // Llama a Perro::hacerSonido()
    hacerSonidoAnimal(g); // Llama a Gato::hacerSonido()

    return 0;
}
```

En este ejemplo:
- La clase `Animal` define una función virtual `hacerSonido`.
- Las clases `Perro` y `Gato` anulan la función `hacerSonido` para proporcionar implementaciones específicas.

#### Importancia del Polimorfismo

La anulación de funciones permite el polimorfismo, donde la función que se invoca depende del tipo real del objeto, no del tipo de referencia o puntero. Esto es especialmente útil cuando se trabaja con colecciones de objetos de diferentes tipos derivados de una misma clase base.

##### Ejemplo de Polimorfismo

```cpp
#include <iostream>
#include <vector>
using namespace std;

class Animal {
public:
    virtual void hacerSonido() const {
        cout << "El animal hace un sonido" << endl;
    }
};

class Perro : public Animal {
public:
    void hacerSonido() const override {
        cout << "El perro ladra" << endl;
    }
};

class Gato : public Animal {
public:
    void hacerSonido() const override {
        cout << "El gato maúlla" << endl;
    }
};

int main() {
    vector<Animal*> animales;
    animales.push_back(new Animal());
    animales.push_back(new Perro());
    animales.push_back(new Gato());

    for (const auto& animal : animales) {
        animal->hacerSonido(); // Llama a la versión apropiada de hacerSonido()
    }

    // Liberar memoria
    for (const auto& animal : animales) {
        delete animal;
    }

    return 0;
}
```

En este ejemplo, un vector de punteros a `Animal` contiene objetos de diferentes tipos derivados. Cuando se llama a `hacerSonido`, se invoca la versión correcta de la función según el tipo real del objeto.

#### Uso de `final` para Prevenir Anulación

C++11 introdujo la palabra clave `final`, que se puede usar para prevenir la anulación de una función virtual en clases derivadas.

##### Ejemplo de `final`

```cpp
#include <iostream>
using namespace std;

class Base {
public:
    virtual void mostrar() const final {
        cout << "Mostrar en la clase Base" << endl;
    }
};

class Derivada : public Base {
public:
    // void mostrar() const override { // Error: no se puede anular una función final
    //     cout << "Mostrar en la clase Derivada" << endl;
    // }
};

int main() {
    Derivada d;
    d.mostrar(); // Llama a Base::mostrar()

    return 0;
}
```

En este ejemplo, `Base::mostrar` se declara como `final`, lo que impide que cualquier clase derivada anule esta función.

#### Sobrecarga vs. Anulación

Es importante no confundir la sobrecarga de funciones con la anulación de funciones. La sobrecarga de funciones se refiere a definir múltiples funciones con el mismo nombre pero con diferentes listas de parámetros en la misma clase, mientras que la anulación de funciones se refiere a redefinir una función virtual de la clase base en una clase derivada.

##### Ejemplo de Sobrecarga y Anulación

```cpp
#include <iostream>
using namespace std;

class Base {
public:
    virtual void funcion(int x) {
        cout << "Base::funcion(int): " << x << endl;
    }

    void funcion(double y) {
        cout << "Base::funcion(double): " << y << endl;
    }
};

class Derivada : public Base {
public:
    void funcion(int x) override {
        cout << "Derivada::funcion(int): " << x << endl;
    }

    // Sobrecarga, no anulación
    void funcion(string s) {
        cout << "Derivada::funcion(string): " << s << endl;
    }
};

int main() {
    Derivada d;
    d.funcion(10);        // Llama a Derivada::funcion(int)
    d.funcion(3.14);      // Llama a Base::funcion(double)
    d.funcion("Hola");    // Llama a Derivada::funcion(string)

    return 0;
}
```

En este ejemplo, `Derivada` anula `funcion(int)` de `Base` y también sobrecarga `funcion` con un nuevo parámetro de tipo `string`.

### Conclusión

La anulación de funciones es una característica esencial en C++ que permite a las clases derivadas proporcionar implementaciones específicas de funciones definidas en la clase base. Esto es crucial para el polimorfismo, permitiendo que el comportamiento de las funciones dependa del tipo real del objeto. La palabra clave `virtual` se utiliza para indicar que una función puede ser anulada, y `override` proporciona una verificación en tiempo de compilación para asegurar que la anulación es correcta. Entender la diferencia entre sobrecarga y anulación es fundamental para diseñar jerarquías de clases efectivas y utilizar el polimorfismo de manera eficiente.
### Funciones Virtuales en Herencia en C++

Las funciones virtuales son una característica clave de la programación orientada a objetos en C++. Permiten que las funciones miembro se comporten de manera polimórfica, es decir, el comportamiento de la función se puede determinar en tiempo de ejecución en lugar de en tiempo de compilación. Esto es fundamental para la creación de interfaces flexibles y reutilizables y para la implementación del polimorfismo.

#### Definición de Funciones Virtuales

Una función virtual es una función miembro de una clase que se puede redefinir en una clase derivada. Se declara con la palabra clave `virtual` en la clase base. Las funciones virtuales permiten que las llamadas a funciones a través de punteros o referencias a la clase base se dirijan a la versión más derivada de la función, según el tipo del objeto que realmente está siendo apuntado o referenciado.

##### Sintaxis Básica

```cpp
class Base {
public:
    virtual void funcion() {
        // Implementación de la clase base
    }
};

class Derivada : public Base {
public:
    void funcion() override {
        // Implementación de la clase derivada
    }
};
```

- **`virtual`**: Indica que la función puede ser anulada en una clase derivada.
- **`override`**: Es opcional pero recomendable, ya que proporciona una verificación en tiempo de compilación de que la función está realmente anulando una función virtual de la clase base.

#### Ejemplo Básico de Funciones Virtuales

```cpp
#include <iostream>
using namespace std;

class Animal {
public:
    virtual void hacerSonido() const {
        cout << "El animal hace un sonido" << endl;
    }
};

class Perro : public Animal {
public:
    void hacerSonido() const override {
        cout << "El perro ladra" << endl;
    }
};

class Gato : public Animal {
public:
    void hacerSonido() const override {
        cout << "El gato maúlla" << endl;
    }
};

void hacerSonidoAnimal(const Animal& animal) {
    animal.hacerSonido();
}

int main() {
    Animal a;
    Perro p;
    Gato g;

    hacerSonidoAnimal(a); // Llama a Animal::hacerSonido()
    hacerSonidoAnimal(p); // Llama a Perro::hacerSonido()
    hacerSonidoAnimal(g); // Llama a Gato::hacerSonido()

    return 0;
}
```

En este ejemplo:
- `Animal` define una función virtual `hacerSonido`.
- `Perro` y `Gato` anulan `hacerSonido` para proporcionar implementaciones específicas.
- La función `hacerSonidoAnimal` demuestra el polimorfismo al llamar a `hacerSonido` en un `Animal`, `Perro` y `Gato`.

#### Polimorfismo y Tablas Virtuales

El polimorfismo se logra en C++ mediante el uso de una estructura llamada "tabla virtual" (vtable). Una vtable es una tabla de punteros a funciones virtuales. Cada clase que tiene funciones virtuales tiene su propia vtable, y cada objeto de esa clase tiene un puntero a la vtable correspondiente.

Cuando se llama a una función virtual, el compilador utiliza el puntero a la vtable para encontrar la implementación correcta de la función a ejecutar en tiempo de ejecución.

#### Funciones Virtuales Puras y Clases Abstractas

Una función virtual pura se declara con `= 0` y no tiene implementación en la clase base. Una clase que contiene al menos una función virtual pura es una clase abstracta y no puede instanciarse. Las clases derivadas deben proporcionar una implementación para las funciones virtuales puras para poder ser instanciadas.

##### Ejemplo de Funciones Virtuales Puras

```cpp
#include <iostream>
using namespace std;

class Animal {
public:
    virtual void hacerSonido() const = 0; // Función virtual pura
};

class Perro : public Animal {
public:
    void hacerSonido() const override {
        cout << "El perro ladra" << endl;
    }
};

class Gato : public Animal {
public:
    void hacerSonido() const override {
        cout << "El gato maúlla" << endl;
    }
};

void hacerSonidoAnimal(const Animal& animal) {
    animal.hacerSonido();
}

int main() {
    // Animal a; // Error: no se puede instanciar una clase abstracta
    Perro p;
    Gato g;

    hacerSonidoAnimal(p); // Llama a Perro::hacerSonido()
    hacerSonidoAnimal(g); // Llama a Gato::hacerSonido()

    return 0;
}
```

En este ejemplo, `Animal` es una clase abstracta con una función virtual pura `hacerSonido`. `Perro` y `Gato` proporcionan implementaciones específicas de `hacerSonido`.

#### Virtualidad y Constructores

Las funciones virtuales no se comportan de manera polimórfica cuando son llamadas desde constructores y destructores. Durante la construcción y destrucción de un objeto, el tipo de objeto se considera el tipo de la clase en la que se está ejecutando el constructor o destructor, no el tipo de la clase derivada.

##### Ejemplo de Virtualidad y Constructores

```cpp
#include <iostream>
using namespace std;

class Base {
public:
    Base() {
        imprimir();
    }

    virtual void imprimir() const {
        cout << "Base::imprimir()" << endl;
    }
};

class Derivada : public Base {
public:
    Derivada() {
        imprimir();
    }

    void imprimir() const override {
        cout << "Derivada::imprimir()" << endl;
    }
};

int main() {
    Derivada d;
    return 0;
}
```

En este ejemplo, durante la construcción de un objeto `Derivada`, la llamada a `imprimir` desde el constructor de `Base` invoca `Base::imprimir`, no `Derivada::imprimir`.

### Conclusión

Las funciones virtuales son fundamentales para la implementación del polimorfismo en C++. Permiten que las funciones miembro se comporten de manera polimórfica, lo que es crucial para la creación de interfaces flexibles y reutilizables. Las funciones virtuales puras definen interfaces que deben ser implementadas por clases derivadas, creando clases abstractas que no pueden ser instanciadas. Es importante comprender las limitaciones de la virtualidad, especialmente en el contexto de constructores y destructores, para utilizar de manera efectiva las funciones virtuales en el diseño de software orientado a objetos en C++.
### Orden de Invocación de Constructores y Destructores en Herencia en C++

En C++, el orden de invocación de constructores y destructores en una jerarquía de herencia sigue reglas específicas. Estas reglas aseguran que los objetos se construyan y destruyan de manera consistente y que todos los recursos se manejen correctamente.

#### Orden de Invocación de Constructores

Cuando se crea un objeto de una clase derivada, los constructores se invocan en un orden específico:

1. **Constructor de la Clase Base:** Primero se llama al constructor de la clase base. Si hay una cadena de herencia, se llama primero al constructor del ancestro más alto y luego se procede hacia abajo hasta llegar a la clase derivada.
2. **Constructores de las Clases Derivadas:** Después de que todos los constructores de las clases base hayan sido invocados, se llama al constructor de la clase derivada más específica.

##### Ejemplo de Invocación de Constructores

```cpp
#include <iostream>
using namespace std;

class Base {
public:
    Base() {
        cout << "Constructor de Base" << endl;
    }
};

class Intermedia : public Base {
public:
    Intermedia() {
        cout << "Constructor de Intermedia" << endl;
    }
};

class Derivada : public Intermedia {
public:
    Derivada() {
        cout << "Constructor de Derivada" << endl;
    }
};

int main() {
    Derivada obj;
    return 0;
}
```

En este ejemplo, el orden de invocación de los constructores es:

1. **Base**
2. **Intermedia**
3. **Derivada**

La salida será:
```
Constructor de Base
Constructor de Intermedia
Constructor de Derivada
```

#### Orden de Invocación de Destructores

El orden de invocación de los destructores es el inverso al de los constructores:

1. **Destructor de la Clase Derivada:** Primero se llama al destructor de la clase derivada más específica.
2. **Destructores de las Clases Base:** Después de que el destructor de la clase derivada ha sido invocado, se llama a los destructores de las clases base en el orden inverso al de la construcción.

##### Ejemplo de Invocación de Destructores

Continuando con el ejemplo anterior, si añadimos destructores a cada clase:

```cpp
#include <iostream>
using namespace std;

class Base {
public:
    Base() {
        cout << "Constructor de Base" << endl;
    }
    ~Base() {
        cout << "Destructor de Base" << endl;
    }
};

class Intermedia : public Base {
public:
    Intermedia() {
        cout << "Constructor de Intermedia" << endl;
    }
    ~Intermedia() {
        cout << "Destructor de Intermedia" << endl;
    }
};

class Derivada : public Intermedia {
public:
    Derivada() {
        cout << "Constructor de Derivada" << endl;
    }
    ~Derivada() {
        cout << "Destructor de Derivada" << endl;
    }
};

int main() {
    Derivada obj;
    return 0;
}
```

La salida será:
```
Constructor de Base
Constructor de Intermedia
Constructor de Derivada
Destructor de Derivada
Destructor de Intermedia
Destructor de Base
```

Esto demuestra que los destructores se invocan en el orden inverso al de los constructores, garantizando que los recursos asignados por las clases derivadas se liberen antes de que se liberen los recursos asignados por las clases base.

### Consideraciones Adicionales

1. **Constructores y Destructores Virtuales:**
   - Si se espera que una clase base se utilice de manera polimórfica, sus destructores deben ser declarados como `virtual`. Esto asegura que el destructor adecuado se llame cuando se elimine un objeto a través de un puntero a la clase base.

##### Ejemplo de Destructor Virtual

```cpp
#include <iostream>
using namespace std;

class Base {
public:
    Base() {
        cout << "Constructor de Base" << endl;
    }
    virtual ~Base() {
        cout << "Destructor de Base" << endl;
    }
};

class Derivada : public Base {
public:
    Derivada() {
        cout << "Constructor de Derivada" << endl;
    }
    ~Derivada() {
        cout << "Destructor de Derivada" << endl;
    }
};

int main() {
    Base* obj = new Derivada();
    delete obj;
    return 0;
}
```

La salida será:
```
Constructor de Base
Constructor de Derivada
Destructor de Derivada
Destructor de Base
```

Sin el destructor virtual en la clase base, el destructor de la clase derivada no se llamaría, lo que podría llevar a fugas de memoria y otros problemas.

2. **Lista de Inicialización del Constructor:**
   - La lista de inicialización del constructor se utiliza para inicializar los miembros de la clase base y los miembros de la clase derivada antes de que el cuerpo del constructor se ejecute.

##### Ejemplo de Lista de Inicialización del Constructor

```cpp
#include <iostream>
using namespace std;

class Base {
private:
    int valorBase;
public:
    Base(int v) : valorBase(v) {
        cout << "Constructor de Base con valor " << valorBase << endl;
    }
};

class Derivada : public Base {
private:
    int valorDerivada;
public:
    Derivada(int vb, int vd) : Base(vb), valorDerivada(vd) {
        cout << "Constructor de Derivada con valor " << valorDerivada << endl;
    }
};

int main() {
    Derivada obj(10, 20);
    return 0;
}
```

La salida será:
```
Constructor de Base con valor 10
Constructor de Derivada con valor 20
```

En este ejemplo, `Base` se inicializa con el valor `10` antes de que `Derivada` se inicialice con el valor `20`.

### Conclusión

El orden de invocación de constructores y destructores en C++ es crucial para garantizar que los recursos se gestionen adecuadamente. Los constructores se invocan desde la clase base hasta la clase derivada, mientras que los destructores se invocan en el orden inverso. Entender este orden ayuda a diseñar jerarquías de herencia robustas y evitar problemas relacionados con la gestión de recursos y la integridad de los objetos.
### Uso de la Palabra Clave `virtual` en Destructores

En C++, el uso de la palabra clave `virtual` en destructores es fundamental para asegurar que los destructores de las clases derivadas se llamen correctamente cuando se destruye un objeto a través de un puntero a la clase base. Esto es crucial para evitar fugas de memoria y asegurar una correcta liberación de recursos en jerarquías de herencia.

#### ¿Por Qué Usar `virtual` en Destructores?

Cuando se utilizan punteros a la clase base para manipular objetos de clases derivadas, no tener un destructor virtual en la clase base puede resultar en que el destructor de la clase derivada nunca sea llamado. Esto puede llevar a recursos no liberados y otros comportamientos inesperados.

##### Ejemplo Sin Destructor Virtual

```cpp
#include <iostream>
using namespace std;

class Base {
public:
    Base() {
        cout << "Constructor de Base" << endl;
    }
    ~Base() {
        cout << "Destructor de Base" << endl;
    }
};

class Derivada : public Base {
public:
    Derivada() {
        cout << "Constructor de Derivada" << endl;
    }
    ~Derivada() {
        cout << "Destructor de Derivada" << endl;
    }
};

int main() {
    Base* obj = new Derivada();
    delete obj; // Solo llama a ~Base(), no a ~Derivada()
    return 0;
}
```

Salida:
```
Constructor de Base
Constructor de Derivada
Destructor de Base
```

En este ejemplo, el destructor de `Derivada` no se llama porque el destructor de `Base` no es virtual. Esto puede llevar a que los recursos de `Derivada` no se liberen adecuadamente.

#### Ejemplo Con Destructor Virtual

Para asegurar que el destructor de la clase derivada sea llamado, se debe declarar el destructor de la clase base como `virtual`.

```cpp
#include <iostream>
using namespace std;

class Base {
public:
    Base() {
        cout << "Constructor de Base" << endl;
    }
    virtual ~Base() {
        cout << "Destructor de Base" << endl;
    }
};

class Derivada : public Base {
public:
    Derivada() {
        cout << "Constructor de Derivada" << endl;
    }
    ~Derivada() {
        cout << "Destructor de Derivada" << endl;
    }
};

int main() {
    Base* obj = new Derivada();
    delete obj; // Llama a ~Derivada() y luego a ~Base()
    return 0;
}
```

Salida:
```
Constructor de Base
Constructor de Derivada
Destructor de Derivada
Destructor de Base
```

En este ejemplo, el destructor de `Derivada` se llama correctamente antes de que el destructor de `Base` sea llamado, asegurando una limpieza adecuada de los recursos.

#### Cuando Usar `virtual` en Destructores

- **Siempre que haya Polimorfismo:** Si una clase está destinada a ser una clase base de una jerarquía polimórfica (es decir, se espera que las funciones miembro se llamen de manera polimórfica), su destructor debe ser virtual.
- **Clases Abstractas:** Las clases abstractas que contienen funciones virtuales puras generalmente deben tener destructores virtuales para asegurar que cualquier clase derivada se destruya correctamente.

#### Ejemplo con Clase Abstracta

```cpp
#include <iostream>
using namespace std;

class Animal {
public:
    virtual void hacerSonido() const = 0; // Función virtual pura
    virtual ~Animal() {
        cout << "Destructor de Animal" << endl;
    }
};

class Perro : public Animal {
public:
    void hacerSonido() const override {
        cout << "El perro ladra" << endl;
    }
    ~Perro() {
        cout << "Destructor de Perro" << endl;
    }
};

class Gato : public Animal {
public:
    void hacerSonido() const override {
        cout << "El gato maúlla" << endl;
    }
    ~Gato() {
        cout << "Destructor de Gato" << endl;
    }
};

int main() {
    Animal* p = new Perro();
    Animal* g = new Gato();
    delete p; // Llama a ~Perro() y luego a ~Animal()
    delete g; // Llama a ~Gato() y luego a ~Animal()
    return 0;
}
```

Salida:
```
Destructor de Perro
Destructor de Animal
Destructor de Gato
Destructor de Animal
```

En este ejemplo, ambos destructores de las clases derivadas (`Perro` y `Gato`) se llaman correctamente antes del destructor de la clase base `Animal`.

### Conclusión

El uso de destructores virtuales en C++ es crucial para la correcta gestión de la memoria y otros recursos en jerarquías de herencia. Declarar el destructor de la clase base como `virtual` asegura que los destructores de las clases derivadas se llamen correctamente, previniendo fugas de memoria y garantizando una limpieza adecuada de los recursos. Esta práctica es especialmente importante en aplicaciones que utilizan polimorfismo, donde los objetos son manipulados a través de punteros o referencias a la clase base.
### Introducción al Polimorfismo en C++

El polimorfismo es uno de los pilares fundamentales de la programación orientada a objetos (POO). En C++, el polimorfismo permite que una interfaz común sea utilizada para diferentes tipos de objetos, permitiendo que una misma operación se ejecute de diferentes maneras según el tipo específico del objeto que la ejecuta. Este comportamiento es crucial para diseñar sistemas flexibles y reutilizables.

#### Definición de Polimorfismo

El término polimorfismo proviene del griego "poly" (muchos) y "morph" (forma), lo que significa "muchas formas". En el contexto de la POO, se refiere a la capacidad de una función o método para operar con objetos de diferentes tipos de forma uniforme.

##### Tipos de Polimorfismo en C++

1. **Polimorfismo de Sobrecarga (Polimorfismo Ad Hoc):** Permite definir múltiples funciones con el mismo nombre pero diferentes firmas (listas de parámetros). Se resuelve en tiempo de compilación.
2. **Polimorfismo Paramétrico:** Se implementa mediante plantillas (templates) en C++, permitiendo que las funciones y clases trabajen con cualquier tipo de datos.
3. **Polimorfismo de Inclusión (Polimorfismo Subtipo):** Permite que una clase derivada sea tratada como una clase base. Se resuelve en tiempo de ejecución y es el tipo de polimorfismo más común en la POO.

#### Polimorfismo de Inclusión

El polimorfismo de inclusión se logra mediante la herencia y el uso de funciones virtuales. Permite que un puntero o referencia a una clase base ejecute una función específica de la clase derivada a la que realmente pertenece el objeto.

##### Ejemplo de Polimorfismo de Inclusión

```cpp
#include <iostream>
using namespace std;

class Animal {
public:
    virtual void hacerSonido() const {
        cout << "El animal hace un sonido" << endl;
    }
};

class Perro : public Animal {
public:
    void hacerSonido() const override {
        cout << "El perro ladra" << endl;
    }
};

class Gato : public Animal {
public:
    void hacerSonido() const override {
        cout << "El gato maúlla" << endl;
    }
};

void hacerSonidoAnimal(const Animal& animal) {
    animal.hacerSonido();
}

int main() {
    Animal a;
    Perro p;
    Gato g;

    hacerSonidoAnimal(a); // Llama a Animal::hacerSonido()
    hacerSonidoAnimal(p); // Llama a Perro::hacerSonido()
    hacerSonidoAnimal(g); // Llama a Gato::hacerSonido()

    return 0;
}
```

En este ejemplo, la función `hacerSonidoAnimal` acepta una referencia a `Animal` pero llama a la implementación apropiada de `hacerSonido` según el tipo real del objeto (`Perro` o `Gato`).

#### Clases Abstractas y Funciones Virtuales Puras

Las clases abstractas son clases que no pueden ser instanciadas y se utilizan para definir interfaces comunes para sus clases derivadas. Contienen al menos una función virtual pura, que se declara utilizando `= 0`.

##### Ejemplo de Clase Abstracta

```cpp
#include <iostream>
using namespace std;

class Animal {
public:
    virtual void hacerSonido() const = 0; // Función virtual pura
};

class Perro : public Animal {
public:
    void hacerSonido() const override {
        cout << "El perro ladra" << endl;
    }
};

class Gato : public Animal {
public:
    void hacerSonido() const override {
        cout << "El gato maúlla" << endl;
    }
};

void hacerSonidoAnimal(const Animal& animal) {
    animal.hacerSonido();
}

int main() {
    // Animal a; // Error: no se puede instanciar una clase abstracta
    Perro p;
    Gato g;

    hacerSonidoAnimal(p); // Llama a Perro::hacerSonido()
    hacerSonidoAnimal(g); // Llama a Gato::hacerSonido()

    return 0;
}
```

En este ejemplo, `Animal` es una clase abstracta con una función virtual pura `hacerSonido`. Las clases derivadas `Perro` y `Gato` proporcionan implementaciones específicas de `hacerSonido`.

#### Uso del Polimorfismo en Colecciones

El polimorfismo es especialmente útil cuando se trabaja con colecciones de objetos de diferentes tipos derivados de una misma clase base. Esto permite tratar todos los objetos de manera uniforme mientras se mantiene la capacidad de ejecutar comportamientos específicos.

##### Ejemplo con Colección Polimórfica

```cpp
#include <iostream>
#include <vector>
using namespace std;

class Animal {
public:
    virtual void hacerSonido() const = 0; // Función virtual pura
    virtual ~Animal() {}
};

class Perro : public Animal {
public:
    void hacerSonido() const override {
        cout << "El perro ladra" << endl;
    }
};

class Gato : public Animal {
public:
    void hacerSonido() const override {
        cout << "El gato maúlla" << endl;
    }
};

int main() {
    vector<Animal*> animales;
    animales.push_back(new Perro());
    animales.push_back(new Gato());

    for (const auto& animal : animales) {
        animal->hacerSonido(); // Llama a la implementación apropiada
    }

    // Liberar memoria
    for (const auto& animal : animales) {
        delete animal;
    }

    return 0;
}
```

En este ejemplo, un vector de punteros a `Animal` contiene objetos de diferentes tipos derivados. El polimorfismo permite que `hacerSonido` llame a la implementación correcta para cada tipo de objeto.

### Conclusión

El polimorfismo es una característica poderosa de la programación orientada a objetos que permite a las funciones operar de manera uniforme en objetos de diferentes tipos. En C++, el polimorfismo se logra principalmente a través de funciones virtuales y herencia. Este mecanismo permite diseñar sistemas flexibles y reutilizables, facilitando la implementación de interfaces comunes y comportamientos específicos según el tipo de objeto. Comprender y utilizar correctamente el polimorfismo es esencial para aprovechar al máximo las capacidades de la programación orientada a objetos en C++.
### Polimorfismo Estático y Dinámico en C++

El polimorfismo en C++ se puede clasificar en dos tipos principales: polimorfismo estático y polimorfismo dinámico. Ambos tipos permiten que las funciones se comporten de diferentes maneras dependiendo de cómo se invocan, pero difieren en cuándo se resuelve la llamada a la función (en tiempo de compilación o en tiempo de ejecución) y en cómo se implementan.

#### Polimorfismo Estático

El polimorfismo estático, también conocido como polimorfismo en tiempo de compilación, se resuelve durante la compilación del programa. Se logra principalmente mediante sobrecarga de funciones y plantillas (templates).

##### Sobrecarga de Funciones

La sobrecarga de funciones permite definir múltiples funciones con el mismo nombre pero con diferentes listas de parámetros.

```cpp
#include <iostream>
using namespace std;

class Sobrecarga {
public:
    void imprimir(int i) {
        cout << "Entero: " << i << endl;
    }

    void imprimir(double d) {
        cout << "Doble: " << d << endl;
    }

    void imprimir(const string& s) {
        cout << "Cadena: " << s << endl;
    }
};

int main() {
    Sobrecarga obj;
    obj.imprimir(10);
    obj.imprimir(3.14);
    obj.imprimir("Hola");
    return 0;
}
```

En este ejemplo, la clase `Sobrecarga` tiene tres versiones de la función `imprimir`, cada una con diferentes parámetros. La selección de la función correcta se realiza en tiempo de compilación.

##### Plantillas (Templates)

Las plantillas permiten crear funciones y clases genéricas que pueden trabajar con cualquier tipo de datos.

```cpp
#include <iostream>
using namespace std;

template <typename T>
void imprimir(T valor) {
    cout << "Valor: " << valor << endl;
}

int main() {
    imprimir(10);
    imprimir(3.14);
    imprimir("Hola");
    return 0;
}
```

En este ejemplo, la función plantilla `imprimir` puede tomar cualquier tipo de argumento. El compilador genera la versión adecuada de la función para cada llamada en tiempo de compilación.

#### Polimorfismo Dinámico

El polimorfismo dinámico, también conocido como polimorfismo en tiempo de ejecución, se resuelve durante la ejecución del programa. Se logra mediante herencia y funciones virtuales. Permite que una llamada a una función miembro se dirija a diferentes implementaciones según el tipo real del objeto que invoca la función.

##### Ejemplo de Polimorfismo Dinámico

```cpp
#include <iostream>
using namespace std;

class Animal {
public:
    virtual void hacerSonido() const {
        cout << "El animal hace un sonido" << endl;
    }
    virtual ~Animal() {}
};

class Perro : public Animal {
public:
    void hacerSonido() const override {
        cout << "El perro ladra" << endl;
    }
};

class Gato : public Animal {
public:
    void hacerSonido() const override {
        cout << "El gato maúlla" << endl;
    }
};

void hacerSonidoAnimal(const Animal& animal) {
    animal.hacerSonido();
}

int main() {
    Animal* a = new Animal();
    Animal* p = new Perro();
    Animal* g = new Gato();

    hacerSonidoAnimal(*a); // Llama a Animal::hacerSonido()
    hacerSonidoAnimal(*p); // Llama a Perro::hacerSonido()
    hacerSonidoAnimal(*g); // Llama a Gato::hacerSonido()

    delete a;
    delete p;
    delete g;
    return 0;
}
```

En este ejemplo, la función `hacerSonidoAnimal` acepta una referencia a `Animal` pero llama a la implementación correcta de `hacerSonido` en tiempo de ejecución según el tipo real del objeto (`Animal`, `Perro`, `Gato`).

#### Diferencias entre Polimorfismo Estático y Dinámico

1. **Resolución:**
   - **Polimorfismo Estático:** Se resuelve en tiempo de compilación.
   - **Polimorfismo Dinámico:** Se resuelve en tiempo de ejecución.

2. **Mecanismo:**
   - **Polimorfismo Estático:** Se implementa mediante sobrecarga de funciones y plantillas.
   - **Polimorfismo Dinámico:** Se implementa mediante herencia y funciones virtuales.

3. **Flexibilidad:**
   - **Polimorfismo Estático:** Menos flexible ya que las decisiones se toman en tiempo de compilación.
   - **Polimorfismo Dinámico:** Más flexible ya que las decisiones se toman en tiempo de ejecución.

4. **Uso de Recursos:**
   - **Polimorfismo Estático:** Generalmente más eficiente en términos de uso de recursos ya que no hay sobrecarga en tiempo de ejecución.
   - **Polimorfismo Dinámico:** Puede tener una sobrecarga en tiempo de ejecución debido a la resolución dinámica de las funciones.

### Conclusión

El polimorfismo es una característica fundamental de la programación orientada a objetos que permite a las funciones comportarse de manera diferente según el contexto. En C++, el polimorfismo puede ser estático o dinámico. El polimorfismo estático se resuelve en tiempo de compilación mediante sobrecarga de funciones y plantillas, mientras que el polimorfismo dinámico se resuelve en tiempo de ejecución mediante herencia y funciones virtuales. Entender y utilizar ambos tipos de polimorfismo permite a los desarrolladores diseñar sistemas más flexibles, reutilizables y eficientes.
<---FILES--->
Ejemplo Básico de Herencia
Ejemplo Básico de Herencia Result
Ejemplo de Diferentes Modos de Herencia
Ejemplo de Diferentes Modos de Herencia Result
Ejemplo Básico de Herencia
Ejemplo Básico de Herencia Result
Ejemplo de Diferentes Modos de Herencia
Ejemplo de Diferentes Modos de Herencia Result
Sintaxis Básica de una Clase
Sintaxis Básica de una Clase Result
Ejemplo de una Clase Básica
Ejemplo de una Clase Básica Result
Ejemplo de una Clase Base
Ejemplo de una Clase Base Result
Sintaxis Básica de una Clase Derivada
Sintaxis Básica de una Clase Derivada Result
Ejemplo de una Clase Derivada
Ejemplo de una Clase Derivada Result
Ejemplo Básico de Herencia
Ejemplo Básico de Herencia Result
Ejemplo de Diferentes Modos de Herencia
Ejemplo de Diferentes Modos de Herencia Result
Sintaxis Básica de una Clase
Sintaxis Básica de una Clase Result
Ejemplo de una Clase Básica
Ejemplo de una Clase Básica Result
Ejemplo de una Clase Base
Ejemplo de una Clase Base Result
Sintaxis Básica de una Clase Derivada
Sintaxis Básica de una Clase Derivada Result
Ejemplo de una Clase Derivada
Ejemplo de una Clase Derivada Result
Especificadores de Acceso
Especificadores de Acceso Result
Ejemplo de Acceso a Miembros de la Clase Base
Ejemplo de Acceso a Miembros de la Clase Base Result
Constructores de Clases Derivadas
Constructores de Clases Derivadas Result
Ejemplo de Creación de Objetos de la Clase Derivada
Ejemplo de Creación de Objetos de la Clase Derivada Result
Ejemplo de Invocación de Constructores
Ejemplo de Invocación de Constructores Result
Ejemplo Básico de Herencia
Ejemplo Básico de Herencia Result
Ejemplo de Diferentes Modos de Herencia
Ejemplo de Diferentes Modos de Herencia Result
Sintaxis Básica de una Clase
Sintaxis Básica de una Clase Result
Ejemplo de una Clase Básica
Ejemplo de una Clase Básica Result
Ejemplo de una Clase Base
Ejemplo de una Clase Base Result
Sintaxis Básica de una Clase Derivada
Sintaxis Básica de una Clase Derivada Result
Ejemplo de una Clase Derivada
Ejemplo de una Clase Derivada Result
Especificadores de Acceso
Especificadores de Acceso Result
Ejemplo de Acceso a Miembros de la Clase Base
Ejemplo de Acceso a Miembros de la Clase Base Result
Constructores de Clases Derivadas
Constructores de Clases Derivadas Result
Ejemplo de Creación de Objetos de la Clase Derivada
Ejemplo de Creación de Objetos de la Clase Derivada Result
Ejemplo de Invocación de Constructores
Ejemplo de Invocación de Constructores Result
Ejemplo de Herencia Simple
Ejemplo de Herencia Simple Result
Ejemplo de Herencia Múltiple
Ejemplo de Herencia Múltiple Result
Ejemplo de Herencia Multinivel
Ejemplo de Herencia Multinivel Result
Ejemplo de Herencia Jerárquica
Ejemplo de Herencia Jerárquica Result
Ejemplo de Herencia Híbrida
Ejemplo de Herencia Híbrida Result
Ejemplo Básico de Herencia
Ejemplo Básico de Herencia Result
Ejemplo de Diferentes Modos de Herencia
Ejemplo de Diferentes Modos de Herencia Result
Sintaxis Básica de una Clase
Sintaxis Básica de una Clase Result
Ejemplo de una Clase Básica
Ejemplo de una Clase Básica Result
Ejemplo de una Clase Base
Ejemplo de una Clase Base Result
Sintaxis Básica de una Clase Derivada
Sintaxis Básica de una Clase Derivada Result
Ejemplo de una Clase Derivada
Ejemplo de una Clase Derivada Result
Especificadores de Acceso
Especificadores de Acceso Result
Ejemplo de Acceso a Miembros de la Clase Base
Ejemplo de Acceso a Miembros de la Clase Base Result
Constructores de Clases Derivadas
Constructores de Clases Derivadas Result
Ejemplo de Creación de Objetos de la Clase Derivada
Ejemplo de Creación de Objetos de la Clase Derivada Result
Ejemplo de Invocación de Constructores
Ejemplo de Invocación de Constructores Result
Ejemplo de Herencia Simple
Ejemplo de Herencia Simple Result
Ejemplo de Herencia Múltiple
Ejemplo de Herencia Múltiple Result
Ejemplo de Herencia Multinivel
Ejemplo de Herencia Multinivel Result
Ejemplo de Herencia Jerárquica
Ejemplo de Herencia Jerárquica Result
Ejemplo de Herencia Híbrida
Ejemplo de Herencia Híbrida Result
Ejemplo de Herencia Pública
Ejemplo de Herencia Pública Result
Ejemplo de Herencia Protegida
Ejemplo de Herencia Protegida Result
Ejemplo de Herencia Privada
Ejemplo de Herencia Privada Result
Ejemplo Básico de Herencia
Ejemplo Básico de Herencia Result
Ejemplo de Diferentes Modos de Herencia
Ejemplo de Diferentes Modos de Herencia Result
Sintaxis Básica de una Clase
Sintaxis Básica de una Clase Result
Ejemplo de una Clase Básica
Ejemplo de una Clase Básica Result
Ejemplo de una Clase Base
Ejemplo de una Clase Base Result
Sintaxis Básica de una Clase Derivada
Sintaxis Básica de una Clase Derivada Result
Ejemplo de una Clase Derivada
Ejemplo de una Clase Derivada Result
Especificadores de Acceso
Especificadores de Acceso Result
Ejemplo de Acceso a Miembros de la Clase Base
Ejemplo de Acceso a Miembros de la Clase Base Result
Constructores de Clases Derivadas
Constructores de Clases Derivadas Result
Ejemplo de Creación de Objetos de la Clase Derivada
Ejemplo de Creación de Objetos de la Clase Derivada Result
Ejemplo de Invocación de Constructores
Ejemplo de Invocación de Constructores Result
Ejemplo de Herencia Simple
Ejemplo de Herencia Simple Result
Ejemplo de Herencia Múltiple
Ejemplo de Herencia Múltiple Result
Ejemplo de Herencia Multinivel
Ejemplo de Herencia Multinivel Result
Ejemplo de Herencia Jerárquica
Ejemplo de Herencia Jerárquica Result
Ejemplo de Herencia Híbrida
Ejemplo de Herencia Híbrida Result
Ejemplo de Herencia Pública
Ejemplo de Herencia Pública Result
Ejemplo de Herencia Protegida
Ejemplo de Herencia Protegida Result
Ejemplo de Herencia Privada
Ejemplo de Herencia Privada Result
Ejemplo Básico de Sobrecarga de Funciones
Ejemplo Básico de Sobrecarga de Funciones Result
Ejemplo de Sobrecarga de Funciones en Herencia
Ejemplo de Sobrecarga de Funciones en Herencia Result
Ejemplo de Uso de `using`
Ejemplo de Uso de `using` Result
Ejemplo de Sobrecarga de Operadores en Herencia
Ejemplo de Sobrecarga de Operadores en Herencia Result
Ejemplo Básico de Herencia
Ejemplo Básico de Herencia Result
Ejemplo de Diferentes Modos de Herencia
Ejemplo de Diferentes Modos de Herencia Result
Sintaxis Básica de una Clase
Sintaxis Básica de una Clase Result
Ejemplo de una Clase Básica
Ejemplo de una Clase Básica Result
Ejemplo de una Clase Base
Ejemplo de una Clase Base Result
Sintaxis Básica de una Clase Derivada
Sintaxis Básica de una Clase Derivada Result
Ejemplo de una Clase Derivada
Ejemplo de una Clase Derivada Result
Especificadores de Acceso
Especificadores de Acceso Result
Ejemplo de Acceso a Miembros de la Clase Base
Ejemplo de Acceso a Miembros de la Clase Base Result
Constructores de Clases Derivadas
Constructores de Clases Derivadas Result
Ejemplo de Creación de Objetos de la Clase Derivada
Ejemplo de Creación de Objetos de la Clase Derivada Result
Ejemplo de Invocación de Constructores
Ejemplo de Invocación de Constructores Result
Ejemplo de Herencia Simple
Ejemplo de Herencia Simple Result
Ejemplo de Herencia Múltiple
Ejemplo de Herencia Múltiple Result
Ejemplo de Herencia Multinivel
Ejemplo de Herencia Multinivel Result
Ejemplo de Herencia Jerárquica
Ejemplo de Herencia Jerárquica Result
Ejemplo de Herencia Híbrida
Ejemplo de Herencia Híbrida Result
Ejemplo de Herencia Pública
Ejemplo de Herencia Pública Result
Ejemplo de Herencia Protegida
Ejemplo de Herencia Protegida Result
Ejemplo de Herencia Privada
Ejemplo de Herencia Privada Result
Ejemplo Básico de Sobrecarga de Funciones
Ejemplo Básico de Sobrecarga de Funciones Result
Ejemplo de Sobrecarga de Funciones en Herencia
Ejemplo de Sobrecarga de Funciones en Herencia Result
Ejemplo de Uso de `using`
Ejemplo de Uso de `using` Result
Ejemplo de Sobrecarga de Operadores en Herencia
Ejemplo de Sobrecarga de Operadores en Herencia Result
Sintaxis Básica
Sintaxis Básica Result
Ejemplo de Polimorfismo
Ejemplo de Polimorfismo Result
Ejemplo de `final`
Ejemplo de `final` Result
Ejemplo de Sobrecarga y Anulación
Ejemplo de Sobrecarga y Anulación Result
Ejemplo Básico de Herencia
Ejemplo Básico de Herencia Result
Ejemplo de Diferentes Modos de Herencia
Ejemplo de Diferentes Modos de Herencia Result
Sintaxis Básica de una Clase
Sintaxis Básica de una Clase Result
Ejemplo de una Clase Básica
Ejemplo de una Clase Básica Result
Ejemplo de una Clase Base
Ejemplo de una Clase Base Result
Sintaxis Básica de una Clase Derivada
Sintaxis Básica de una Clase Derivada Result
Ejemplo de una Clase Derivada
Ejemplo de una Clase Derivada Result
Especificadores de Acceso
Especificadores de Acceso Result
Ejemplo de Acceso a Miembros de la Clase Base
Ejemplo de Acceso a Miembros de la Clase Base Result
Constructores de Clases Derivadas
Constructores de Clases Derivadas Result
Ejemplo de Creación de Objetos de la Clase Derivada
Ejemplo de Creación de Objetos de la Clase Derivada Result
Ejemplo de Invocación de Constructores
Ejemplo de Invocación de Constructores Result
Ejemplo de Herencia Simple
Ejemplo de Herencia Simple Result
Ejemplo de Herencia Múltiple
Ejemplo de Herencia Múltiple Result
Ejemplo de Herencia Multinivel
Ejemplo de Herencia Multinivel Result
Ejemplo de Herencia Jerárquica
Ejemplo de Herencia Jerárquica Result
Ejemplo de Herencia Híbrida
Ejemplo de Herencia Híbrida Result
Ejemplo de Herencia Pública
Ejemplo de Herencia Pública Result
Ejemplo de Herencia Protegida
Ejemplo de Herencia Protegida Result
Ejemplo de Herencia Privada
Ejemplo de Herencia Privada Result
Ejemplo Básico de Sobrecarga de Funciones
Ejemplo Básico de Sobrecarga de Funciones Result
Ejemplo de Sobrecarga de Funciones en Herencia
Ejemplo de Sobrecarga de Funciones en Herencia Result
Ejemplo de Uso de `using`
Ejemplo de Uso de `using` Result
Ejemplo de Sobrecarga de Operadores en Herencia
Ejemplo de Sobrecarga de Operadores en Herencia Result
Sintaxis Básica
Sintaxis Básica Result
Ejemplo de Polimorfismo
Ejemplo de Polimorfismo Result
Ejemplo de `final`
Ejemplo de `final` Result
Ejemplo de Sobrecarga y Anulación
Ejemplo de Sobrecarga y Anulación Result
Ejemplo de Funciones Virtuales Puras
Ejemplo de Funciones Virtuales Puras Result
Ejemplo de Virtualidad y Constructores
Ejemplo de Virtualidad y Constructores Result
Ejemplo Básico de Herencia
Ejemplo Básico de Herencia Result
Ejemplo de Diferentes Modos de Herencia
Ejemplo de Diferentes Modos de Herencia Result
Sintaxis Básica de una Clase
Sintaxis Básica de una Clase Result
Ejemplo de una Clase Básica
Ejemplo de una Clase Básica Result
Ejemplo de una Clase Base
Ejemplo de una Clase Base Result
Sintaxis Básica de una Clase Derivada
Sintaxis Básica de una Clase Derivada Result
Ejemplo de una Clase Derivada
Ejemplo de una Clase Derivada Result
Especificadores de Acceso
Especificadores de Acceso Result
Ejemplo de Acceso a Miembros de la Clase Base
Ejemplo de Acceso a Miembros de la Clase Base Result
Constructores de Clases Derivadas
Constructores de Clases Derivadas Result
Ejemplo de Creación de Objetos de la Clase Derivada
Ejemplo de Creación de Objetos de la Clase Derivada Result
Ejemplo de Invocación de Constructores
Ejemplo de Invocación de Constructores Result
Ejemplo de Herencia Simple
Ejemplo de Herencia Simple Result
Ejemplo de Herencia Múltiple
Ejemplo de Herencia Múltiple Result
Ejemplo de Herencia Multinivel
Ejemplo de Herencia Multinivel Result
Ejemplo de Herencia Jerárquica
Ejemplo de Herencia Jerárquica Result
Ejemplo de Herencia Híbrida
Ejemplo de Herencia Híbrida Result
Ejemplo de Herencia Pública
Ejemplo de Herencia Pública Result
Ejemplo de Herencia Protegida
Ejemplo de Herencia Protegida Result
Ejemplo de Herencia Privada
Ejemplo de Herencia Privada Result
Ejemplo Básico de Sobrecarga de Funciones
Ejemplo Básico de Sobrecarga de Funciones Result
Ejemplo de Sobrecarga de Funciones en Herencia
Ejemplo de Sobrecarga de Funciones en Herencia Result
Ejemplo de Uso de `using`
Ejemplo de Uso de `using` Result
Ejemplo de Sobrecarga de Operadores en Herencia
Ejemplo de Sobrecarga de Operadores en Herencia Result
Sintaxis Básica
Sintaxis Básica Result
Ejemplo de Polimorfismo
Ejemplo de Polimorfismo Result
Ejemplo de `final`
Ejemplo de `final` Result
Ejemplo de Sobrecarga y Anulación
Ejemplo de Sobrecarga y Anulación Result
Ejemplo de Funciones Virtuales Puras
Ejemplo de Funciones Virtuales Puras Result
Ejemplo de Virtualidad y Constructores
Ejemplo de Virtualidad y Constructores Result
Ejemplo de Invocación de Destructores
Ejemplo de Invocación de Destructores Result
Ejemplo de Destructor Virtual
Ejemplo de Destructor Virtual Result
Ejemplo de Lista de Inicialización del Constructor
Ejemplo de Lista de Inicialización del Constructor Result
Ejemplo Básico de Herencia
Ejemplo Básico de Herencia Result
Ejemplo de Diferentes Modos de Herencia
Ejemplo de Diferentes Modos de Herencia Result
Sintaxis Básica de una Clase
Sintaxis Básica de una Clase Result
Ejemplo de una Clase Básica
Ejemplo de una Clase Básica Result
Ejemplo de una Clase Base
Ejemplo de una Clase Base Result
Sintaxis Básica de una Clase Derivada
Sintaxis Básica de una Clase Derivada Result
Ejemplo de una Clase Derivada
Ejemplo de una Clase Derivada Result
Especificadores de Acceso
Especificadores de Acceso Result
Ejemplo de Acceso a Miembros de la Clase Base
Ejemplo de Acceso a Miembros de la Clase Base Result
Constructores de Clases Derivadas
Constructores de Clases Derivadas Result
Ejemplo de Creación de Objetos de la Clase Derivada
Ejemplo de Creación de Objetos de la Clase Derivada Result
Ejemplo de Invocación de Constructores
Ejemplo de Invocación de Constructores Result
Ejemplo de Herencia Simple
Ejemplo de Herencia Simple Result
Ejemplo de Herencia Múltiple
Ejemplo de Herencia Múltiple Result
Ejemplo de Herencia Multinivel
Ejemplo de Herencia Multinivel Result
Ejemplo de Herencia Jerárquica
Ejemplo de Herencia Jerárquica Result
Ejemplo de Herencia Híbrida
Ejemplo de Herencia Híbrida Result
Ejemplo de Herencia Pública
Ejemplo de Herencia Pública Result
Ejemplo de Herencia Protegida
Ejemplo de Herencia Protegida Result
Ejemplo de Herencia Privada
Ejemplo de Herencia Privada Result
Ejemplo Básico de Sobrecarga de Funciones
Ejemplo Básico de Sobrecarga de Funciones Result
Ejemplo de Sobrecarga de Funciones en Herencia
Ejemplo de Sobrecarga de Funciones en Herencia Result
Ejemplo de Uso de `using`
Ejemplo de Uso de `using` Result
Ejemplo de Sobrecarga de Operadores en Herencia
Ejemplo de Sobrecarga de Operadores en Herencia Result
Sintaxis Básica
Sintaxis Básica Result
Ejemplo de Polimorfismo
Ejemplo de Polimorfismo Result
Ejemplo de `final`
Ejemplo de `final` Result
Ejemplo de Sobrecarga y Anulación
Ejemplo de Sobrecarga y Anulación Result
Ejemplo de Funciones Virtuales Puras
Ejemplo de Funciones Virtuales Puras Result
Ejemplo de Virtualidad y Constructores
Ejemplo de Virtualidad y Constructores Result
Ejemplo de Invocación de Destructores
Ejemplo de Invocación de Destructores Result
Ejemplo de Destructor Virtual
Ejemplo de Destructor Virtual Result
Ejemplo de Lista de Inicialización del Constructor
Ejemplo de Lista de Inicialización del Constructor Result
Ejemplo Sin Destructor Virtual
Ejemplo Sin Destructor Virtual Result
Ejemplo Básico de Herencia
Ejemplo Básico de Herencia Result
Ejemplo de Diferentes Modos de Herencia
Ejemplo de Diferentes Modos de Herencia Result
Sintaxis Básica de una Clase
Sintaxis Básica de una Clase Result
Ejemplo de una Clase Básica
Ejemplo de una Clase Básica Result
Ejemplo de una Clase Base
Ejemplo de una Clase Base Result
Sintaxis Básica de una Clase Derivada
Sintaxis Básica de una Clase Derivada Result
Ejemplo de una Clase Derivada
Ejemplo de una Clase Derivada Result
Especificadores de Acceso
Especificadores de Acceso Result
Ejemplo de Acceso a Miembros de la Clase Base
Ejemplo de Acceso a Miembros de la Clase Base Result
Constructores de Clases Derivadas
Constructores de Clases Derivadas Result
Ejemplo de Creación de Objetos de la Clase Derivada
Ejemplo de Creación de Objetos de la Clase Derivada Result
Ejemplo de Invocación de Constructores
Ejemplo de Invocación de Constructores Result
Ejemplo de Herencia Simple
Ejemplo de Herencia Simple Result
Ejemplo de Herencia Múltiple
Ejemplo de Herencia Múltiple Result
Ejemplo de Herencia Multinivel
Ejemplo de Herencia Multinivel Result
Ejemplo de Herencia Jerárquica
Ejemplo de Herencia Jerárquica Result
Ejemplo de Herencia Híbrida
Ejemplo de Herencia Híbrida Result
Ejemplo de Herencia Pública
Ejemplo de Herencia Pública Result
Ejemplo de Herencia Protegida
Ejemplo de Herencia Protegida Result
Ejemplo de Herencia Privada
Ejemplo de Herencia Privada Result
Ejemplo Básico de Sobrecarga de Funciones
Ejemplo Básico de Sobrecarga de Funciones Result
Ejemplo de Sobrecarga de Funciones en Herencia
Ejemplo de Sobrecarga de Funciones en Herencia Result
Ejemplo de Uso de `using`
Ejemplo de Uso de `using` Result
Ejemplo de Sobrecarga de Operadores en Herencia
Ejemplo de Sobrecarga de Operadores en Herencia Result
Sintaxis Básica
Sintaxis Básica Result
Ejemplo de Polimorfismo
Ejemplo de Polimorfismo Result
Ejemplo de `final`
Ejemplo de `final` Result
Ejemplo de Sobrecarga y Anulación
Ejemplo de Sobrecarga y Anulación Result
Ejemplo de Funciones Virtuales Puras
Ejemplo de Funciones Virtuales Puras Result
Ejemplo de Virtualidad y Constructores
Ejemplo de Virtualidad y Constructores Result
Ejemplo de Invocación de Destructores
Ejemplo de Invocación de Destructores Result
Ejemplo de Destructor Virtual
Ejemplo de Destructor Virtual Result
Ejemplo de Lista de Inicialización del Constructor
Ejemplo de Lista de Inicialización del Constructor Result
Ejemplo Sin Destructor Virtual
Ejemplo Sin Destructor Virtual Result
Tipos de Polimorfismo en C++
Tipos de Polimorfismo en C++ Result
Ejemplo de Polimorfismo de Inclusión
Ejemplo de Polimorfismo de Inclusión Result
Ejemplo de Clase Abstracta
Ejemplo de Clase Abstracta Result
Ejemplo con Colección Polimórfica
Ejemplo con Colección Polimórfica Result
Ejemplo Básico de Herencia
Ejemplo Básico de Herencia Result
Ejemplo de Diferentes Modos de Herencia
Ejemplo de Diferentes Modos de Herencia Result
Sintaxis Básica de una Clase
Sintaxis Básica de una Clase Result
Ejemplo de una Clase Básica
Ejemplo de una Clase Básica Result
Ejemplo de una Clase Base
Ejemplo de una Clase Base Result
Sintaxis Básica de una Clase Derivada
Sintaxis Básica de una Clase Derivada Result
Ejemplo de una Clase Derivada
Ejemplo de una Clase Derivada Result
Especificadores de Acceso
Especificadores de Acceso Result
Ejemplo de Acceso a Miembros de la Clase Base
Ejemplo de Acceso a Miembros de la Clase Base Result
Constructores de Clases Derivadas
Constructores de Clases Derivadas Result
Ejemplo de Creación de Objetos de la Clase Derivada
Ejemplo de Creación de Objetos de la Clase Derivada Result
Ejemplo de Invocación de Constructores
Ejemplo de Invocación de Constructores Result
Ejemplo de Herencia Simple
Ejemplo de Herencia Simple Result
Ejemplo de Herencia Múltiple
Ejemplo de Herencia Múltiple Result
Ejemplo de Herencia Multinivel
Ejemplo de Herencia Multinivel Result
Ejemplo de Herencia Jerárquica
Ejemplo de Herencia Jerárquica Result
Ejemplo de Herencia Híbrida
Ejemplo de Herencia Híbrida Result
Ejemplo de Herencia Pública
Ejemplo de Herencia Pública Result
Ejemplo de Herencia Protegida
Ejemplo de Herencia Protegida Result
Ejemplo de Herencia Privada
Ejemplo de Herencia Privada Result
Ejemplo Básico de Sobrecarga de Funciones
Ejemplo Básico de Sobrecarga de Funciones Result
Ejemplo de Sobrecarga de Funciones en Herencia
Ejemplo de Sobrecarga de Funciones en Herencia Result
Ejemplo de Uso de `using`
Ejemplo de Uso de `using` Result
Ejemplo de Sobrecarga de Operadores en Herencia
Ejemplo de Sobrecarga de Operadores en Herencia Result
Sintaxis Básica
Sintaxis Básica Result
Ejemplo de Polimorfismo
Ejemplo de Polimorfismo Result
Ejemplo de `final`
Ejemplo de `final` Result
Ejemplo de Sobrecarga y Anulación
Ejemplo de Sobrecarga y Anulación Result
Ejemplo de Funciones Virtuales Puras
Ejemplo de Funciones Virtuales Puras Result
Ejemplo de Virtualidad y Constructores
Ejemplo de Virtualidad y Constructores Result
Ejemplo de Invocación de Destructores
Ejemplo de Invocación de Destructores Result
Ejemplo de Destructor Virtual
Ejemplo de Destructor Virtual Result
Ejemplo de Lista de Inicialización del Constructor
Ejemplo de Lista de Inicialización del Constructor Result
Ejemplo Sin Destructor Virtual
Ejemplo Sin Destructor Virtual Result
Tipos de Polimorfismo en C++
Tipos de Polimorfismo en C++ Result
Ejemplo de Polimorfismo de Inclusión
Ejemplo de Polimorfismo de Inclusión Result
Ejemplo de Clase Abstracta
Ejemplo de Clase Abstracta Result
Ejemplo con Colección Polimórfica
Ejemplo con Colección Polimórfica Result
Sobrecarga de Funciones
Sobrecarga de Funciones Result
Plantillas (Templates)
Plantillas (Templates) Result
Ejemplo de Polimorfismo Dinámico
Ejemplo de Polimorfismo Dinámico Result
<---Ejemplo Básico de Herencia--->
```cpp
#include <iostream>
using namespace std;

class Animal {
public:
    void comer() {
        cout << "El animal está comiendo." << endl;
    }
};

class Perro : public Animal {
public:
    void ladrar() {
        cout << "El perro está ladrando." << endl;
    }
};

int main() {
    Perro miPerro;
    miPerro.comer(); // Método heredado de la clase base
    miPerro.ladrar(); // Método de la clase derivada

    return 0;
}
<---Ejemplo Básico de Herencia Result--->
<---Ejemplo de Diferentes Modos de Herencia--->
```cpp
#include <iostream>
using namespace std;

class Base {
public:
    int publicVar;
protected:
    int protectedVar;
private:
    int privateVar;
};

class DerivadaPublic : public Base {
    // publicVar es public
    // protectedVar es protected
    // privateVar no es accesible
};

class DerivadaProtected : protected Base {
    // publicVar es protected
    // protectedVar es protected
    // privateVar no es accesible
};

class DerivadaPrivate : private Base {
    // publicVar es private
    // protectedVar es private
    // privateVar no es accesible
};

int main() {
    DerivadaPublic objPublic;
    objPublic.publicVar = 10; // Accesible
    // objPublic.protectedVar = 20; // No accesible
    // objPublic.privateVar = 30; // No accesible

    DerivadaProtected objProtected;
    // objProtected.publicVar = 10; // No accesible
    // objProtected.protectedVar = 20; // No accesible

    DerivadaPrivate objPrivate;
    // objPrivate.publicVar = 10; // No accesible
    // objPrivate.protectedVar = 20; // No accesible

    return 0;
}
<---Ejemplo de Diferentes Modos de Herencia Result--->
<---Ejemplo Básico de Herencia--->
```cpp
#include <iostream>
using namespace std;

class Animal {
public:
    void comer() {
        cout << "El animal está comiendo." << endl;
    }
};

class Perro : public Animal {
public:
    void ladrar() {
        cout << "El perro está ladrando." << endl;
    }
};

int main() {
    Perro miPerro;
    miPerro.comer(); // Método heredado de la clase base
    miPerro.ladrar(); // Método de la clase derivada

    return 0;
}
<---Ejemplo Básico de Herencia Result--->
<---Ejemplo de Diferentes Modos de Herencia--->
```cpp
#include <iostream>
using namespace std;

class Base {
public:
    int publicVar;
protected:
    int protectedVar;
private:
    int privateVar;
};

class DerivadaPublic : public Base {
    // publicVar es public
    // protectedVar es protected
    // privateVar no es accesible
};

class DerivadaProtected : protected Base {
    // publicVar es protected
    // protectedVar es protected
    // privateVar no es accesible
};

class DerivadaPrivate : private Base {
    // publicVar es private
    // protectedVar es private
    // privateVar no es accesible
};

int main() {
    DerivadaPublic objPublic;
    objPublic.publicVar = 10; // Accesible
    // objPublic.protectedVar = 20; // No accesible
    // objPublic.privateVar = 30; // No accesible

    DerivadaProtected objProtected;
    // objProtected.publicVar = 10; // No accesible
    // objProtected.protectedVar = 20; // No accesible

    DerivadaPrivate objPrivate;
    // objPrivate.publicVar = 10; // No accesible
    // objPrivate.protectedVar = 20; // No accesible

    return 0;
}
<---Ejemplo de Diferentes Modos de Herencia Result--->
<---Sintaxis Básica de una Clase--->
```cpp
class NombreClase {
public:
    // Atributos
    tipo_atributo nombre_atributo;

    // Métodos
    tipo_retorno nombre_metodo(parametros);

    // Otros componentes, como constructores, destructores, etc.
};
<---Sintaxis Básica de una Clase Result--->
<---Ejemplo de una Clase Básica--->
```cpp
#include <iostream>
using namespace std;

class Persona {
public:
    string nombre;
    int edad;

    // Constructor
    Persona(string n, int e) : nombre(n), edad(e) {}

    // Método para mostrar información
    void mostrarInformacion() const {
        cout << "Nombre: " << nombre << ", Edad: " << edad << endl;
    }
};

int main() {
    Persona juan("Juan", 30);
    juan.mostrarInformacion();

    return 0;
}
<---Ejemplo de una Clase Básica Result--->
<---Ejemplo de una Clase Base--->
```cpp
#include <iostream>
using namespace std;

class Animal {
public:
    void comer() const {
        cout << "El animal está comiendo." << endl;
    }

    void dormir() const {
        cout << "El animal está durmiendo." << endl;
    }
};
<---Ejemplo de una Clase Base Result--->
<---Sintaxis Básica de una Clase Derivada--->
```cpp
class ClaseDerivada : public ClaseBase {
public:
    // Atributos y métodos adicionales
};
<---Sintaxis Básica de una Clase Derivada Result--->
<---Ejemplo de una Clase Derivada--->
```cpp
#include <iostream>
using namespace std;

class Animal {
public:
    void comer() const {
        cout << "El animal está comiendo." << endl;
    }

    void dormir() const {
        cout << "El animal está durmiendo." << endl;
    }
};

class Perro : public Animal {
public:
    void ladrar() const {
        cout << "El perro está ladrando." << endl;
    }
};

int main() {
    Perro miPerro;
    miPerro.comer(); // Método heredado de la clase base
    miPerro.dormir(); // Método heredado de la clase base
    miPerro.ladrar(); // Método de la clase derivada

    return 0;
}
<---Ejemplo de una Clase Derivada Result--->
<---Ejemplo Básico de Herencia--->
```cpp
#include <iostream>
using namespace std;

class Animal {
public:
    void comer() {
        cout << "El animal está comiendo." << endl;
    }
};

class Perro : public Animal {
public:
    void ladrar() {
        cout << "El perro está ladrando." << endl;
    }
};

int main() {
    Perro miPerro;
    miPerro.comer(); // Método heredado de la clase base
    miPerro.ladrar(); // Método de la clase derivada

    return 0;
}
<---Ejemplo Básico de Herencia Result--->
<---Ejemplo de Diferentes Modos de Herencia--->
```cpp
#include <iostream>
using namespace std;

class Base {
public:
    int publicVar;
protected:
    int protectedVar;
private:
    int privateVar;
};

class DerivadaPublic : public Base {
    // publicVar es public
    // protectedVar es protected
    // privateVar no es accesible
};

class DerivadaProtected : protected Base {
    // publicVar es protected
    // protectedVar es protected
    // privateVar no es accesible
};

class DerivadaPrivate : private Base {
    // publicVar es private
    // protectedVar es private
    // privateVar no es accesible
};

int main() {
    DerivadaPublic objPublic;
    objPublic.publicVar = 10; // Accesible
    // objPublic.protectedVar = 20; // No accesible
    // objPublic.privateVar = 30; // No accesible

    DerivadaProtected objProtected;
    // objProtected.publicVar = 10; // No accesible
    // objProtected.protectedVar = 20; // No accesible

    DerivadaPrivate objPrivate;
    // objPrivate.publicVar = 10; // No accesible
    // objPrivate.protectedVar = 20; // No accesible

    return 0;
}
<---Ejemplo de Diferentes Modos de Herencia Result--->
<---Sintaxis Básica de una Clase--->
```cpp
class NombreClase {
public:
    // Atributos
    tipo_atributo nombre_atributo;

    // Métodos
    tipo_retorno nombre_metodo(parametros);

    // Otros componentes, como constructores, destructores, etc.
};
<---Sintaxis Básica de una Clase Result--->
<---Ejemplo de una Clase Básica--->
```cpp
#include <iostream>
using namespace std;

class Persona {
public:
    string nombre;
    int edad;

    // Constructor
    Persona(string n, int e) : nombre(n), edad(e) {}

    // Método para mostrar información
    void mostrarInformacion() const {
        cout << "Nombre: " << nombre << ", Edad: " << edad << endl;
    }
};

int main() {
    Persona juan("Juan", 30);
    juan.mostrarInformacion();

    return 0;
}
<---Ejemplo de una Clase Básica Result--->
<---Ejemplo de una Clase Base--->
```cpp
#include <iostream>
using namespace std;

class Animal {
public:
    void comer() const {
        cout << "El animal está comiendo." << endl;
    }

    void dormir() const {
        cout << "El animal está durmiendo." << endl;
    }
};
<---Ejemplo de una Clase Base Result--->
<---Sintaxis Básica de una Clase Derivada--->
```cpp
class ClaseDerivada : public ClaseBase {
public:
    // Atributos y métodos adicionales
};
<---Sintaxis Básica de una Clase Derivada Result--->
<---Ejemplo de una Clase Derivada--->
```cpp
#include <iostream>
using namespace std;

class Animal {
public:
    void comer() const {
        cout << "El animal está comiendo." << endl;
    }

    void dormir() const {
        cout << "El animal está durmiendo." << endl;
    }
};

class Perro : public Animal {
public:
    void ladrar() const {
        cout << "El perro está ladrando." << endl;
    }
};

int main() {
    Perro miPerro;
    miPerro.comer(); // Método heredado de la clase base
    miPerro.dormir(); // Método heredado de la clase base
    miPerro.ladrar(); // Método de la clase derivada

    return 0;
}
<---Ejemplo de una Clase Derivada Result--->
<---Especificadores de Acceso--->
<---Especificadores de Acceso Result--->
<---Ejemplo de Acceso a Miembros de la Clase Base--->
```cpp
#include <iostream>
using namespace std;

class Base {
public:
    int publicVar;

protected:
    int protectedVar;

private:
    int privateVar;
};

class DerivadaPublic : public Base {
public:
    void mostrar() {
        cout << "Acceso en DerivadaPublic:" << endl;
        cout << "publicVar: " << publicVar << endl; // Accesible
        cout << "protectedVar: " << protectedVar << endl; // Accesible
        // cout << "privateVar: " << privateVar << endl; // No accesible
    }
};

class DerivadaProtected : protected Base {
public:
    void mostrar() {
        cout << "Acceso en DerivadaProtected:" << endl;
        cout << "publicVar: " << publicVar << endl; // Accesible
        cout << "protectedVar: " << protectedVar << endl; // Accesible
        // cout << "privateVar: " << privateVar << endl; // No accesible
    }
};

class DerivadaPrivate : private Base {
public:
    void mostrar() {
        cout << "Acceso en DerivadaPrivate:" << endl;
        cout << "publicVar: " << publicVar << endl; // Accesible
        cout << "protectedVar: " << protectedVar << endl; // Accesible
        // cout << "privateVar: " << privateVar << endl; // No accesible
    }
};

int main() {
    DerivadaPublic objPublic;
    objPublic.publicVar = 10;
    objPublic.mostrar();

    DerivadaProtected objProtected;
    // objProtected.publicVar = 20; // No accesible desde fuera de la clase derivada
    objProtected.mostrar();

    DerivadaPrivate objPrivate;
    // objPrivate.publicVar = 30; // No accesible desde fuera de la clase derivada
    objPrivate.mostrar();

    return 0;
}
<---Ejemplo de Acceso a Miembros de la Clase Base Result--->
<---Constructores de Clases Derivadas--->
<---Constructores de Clases Derivadas Result--->
<---Ejemplo de Creación de Objetos de la Clase Derivada--->
```cpp
#include <iostream>
using namespace std;

class Base {
protected:
    int baseVar;

public:
    // Constructor de la clase base
    Base(int v) : baseVar(v) {
        cout << "Constructor de la clase Base llamado con valor " << baseVar << endl;
    }

    void mostrarBase() const {
        cout << "Valor de baseVar: " << baseVar << endl;
    }
};

class Derivada : public Base {
private:
    int derivadaVar;

public:
    // Constructor de la clase derivada
    Derivada(int baseVal, int derivadaVal) : Base(baseVal), derivadaVar(derivadaVal) {
        cout << "Constructor de la clase Derivada llamado con valor " << derivadaVar << endl;
    }

    void mostrarDerivada() const {
        mostrarBase();
        cout << "Valor de derivadaVar: " << derivadaVar << endl;
    }
};

int main() {
    Derivada obj(10, 20);
    obj.mostrarDerivada();

    return 0;
}
<---Ejemplo de Creación de Objetos de la Clase Derivada Result--->
<---Ejemplo de Invocación de Constructores--->
```cpp
#include <iostream>
using namespace std;

class Base {
public:
    Base() {
        cout << "Constructor de Base llamado" << endl;
    }

    Base(int x) {
        cout << "Constructor de Base llamado con valor " << x << endl;
    }
};

class Derivada : public Base {
public:
    Derivada() {
        cout << "Constructor de Derivada llamado" << endl;
    }

    Derivada(int y) : Base(y) {
        cout << "Constructor de Derivada llamado con valor " << y << endl;
    }
};

int main() {
    cout << "Creando obj1:" << endl;
    Derivada obj1;

    cout << "\nCreando obj2:" << endl;
    Derivada obj2(100);

    return 0;
}
<---Ejemplo de Invocación de Constructores Result--->
<---Ejemplo Básico de Herencia--->
```cpp
#include <iostream>
using namespace std;

class Animal {
public:
    void comer() {
        cout << "El animal está comiendo." << endl;
    }
};

class Perro : public Animal {
public:
    void ladrar() {
        cout << "El perro está ladrando." << endl;
    }
};

int main() {
    Perro miPerro;
    miPerro.comer(); // Método heredado de la clase base
    miPerro.ladrar(); // Método de la clase derivada

    return 0;
}
<---Ejemplo Básico de Herencia Result--->
<---Ejemplo de Diferentes Modos de Herencia--->
```cpp
#include <iostream>
using namespace std;

class Base {
public:
    int publicVar;
protected:
    int protectedVar;
private:
    int privateVar;
};

class DerivadaPublic : public Base {
    // publicVar es public
    // protectedVar es protected
    // privateVar no es accesible
};

class DerivadaProtected : protected Base {
    // publicVar es protected
    // protectedVar es protected
    // privateVar no es accesible
};

class DerivadaPrivate : private Base {
    // publicVar es private
    // protectedVar es private
    // privateVar no es accesible
};

int main() {
    DerivadaPublic objPublic;
    objPublic.publicVar = 10; // Accesible
    // objPublic.protectedVar = 20; // No accesible
    // objPublic.privateVar = 30; // No accesible

    DerivadaProtected objProtected;
    // objProtected.publicVar = 10; // No accesible
    // objProtected.protectedVar = 20; // No accesible

    DerivadaPrivate objPrivate;
    // objPrivate.publicVar = 10; // No accesible
    // objPrivate.protectedVar = 20; // No accesible

    return 0;
}
<---Ejemplo de Diferentes Modos de Herencia Result--->
<---Sintaxis Básica de una Clase--->
```cpp
class NombreClase {
public:
    // Atributos
    tipo_atributo nombre_atributo;

    // Métodos
    tipo_retorno nombre_metodo(parametros);

    // Otros componentes, como constructores, destructores, etc.
};
<---Sintaxis Básica de una Clase Result--->
<---Ejemplo de una Clase Básica--->
```cpp
#include <iostream>
using namespace std;

class Persona {
public:
    string nombre;
    int edad;

    // Constructor
    Persona(string n, int e) : nombre(n), edad(e) {}

    // Método para mostrar información
    void mostrarInformacion() const {
        cout << "Nombre: " << nombre << ", Edad: " << edad << endl;
    }
};

int main() {
    Persona juan("Juan", 30);
    juan.mostrarInformacion();

    return 0;
}
<---Ejemplo de una Clase Básica Result--->
<---Ejemplo de una Clase Base--->
```cpp
#include <iostream>
using namespace std;

class Animal {
public:
    void comer() const {
        cout << "El animal está comiendo." << endl;
    }

    void dormir() const {
        cout << "El animal está durmiendo." << endl;
    }
};
<---Ejemplo de una Clase Base Result--->
<---Sintaxis Básica de una Clase Derivada--->
```cpp
class ClaseDerivada : public ClaseBase {
public:
    // Atributos y métodos adicionales
};
<---Sintaxis Básica de una Clase Derivada Result--->
<---Ejemplo de una Clase Derivada--->
```cpp
#include <iostream>
using namespace std;

class Animal {
public:
    void comer() const {
        cout << "El animal está comiendo." << endl;
    }

    void dormir() const {
        cout << "El animal está durmiendo." << endl;
    }
};

class Perro : public Animal {
public:
    void ladrar() const {
        cout << "El perro está ladrando." << endl;
    }
};

int main() {
    Perro miPerro;
    miPerro.comer(); // Método heredado de la clase base
    miPerro.dormir(); // Método heredado de la clase base
    miPerro.ladrar(); // Método de la clase derivada

    return 0;
}
<---Ejemplo de una Clase Derivada Result--->
<---Especificadores de Acceso--->
<---Especificadores de Acceso Result--->
<---Ejemplo de Acceso a Miembros de la Clase Base--->
```cpp
#include <iostream>
using namespace std;

class Base {
public:
    int publicVar;

protected:
    int protectedVar;

private:
    int privateVar;
};

class DerivadaPublic : public Base {
public:
    void mostrar() {
        cout << "Acceso en DerivadaPublic:" << endl;
        cout << "publicVar: " << publicVar << endl; // Accesible
        cout << "protectedVar: " << protectedVar << endl; // Accesible
        // cout << "privateVar: " << privateVar << endl; // No accesible
    }
};

class DerivadaProtected : protected Base {
public:
    void mostrar() {
        cout << "Acceso en DerivadaProtected:" << endl;
        cout << "publicVar: " << publicVar << endl; // Accesible
        cout << "protectedVar: " << protectedVar << endl; // Accesible
        // cout << "privateVar: " << privateVar << endl; // No accesible
    }
};

class DerivadaPrivate : private Base {
public:
    void mostrar() {
        cout << "Acceso en DerivadaPrivate:" << endl;
        cout << "publicVar: " << publicVar << endl; // Accesible
        cout << "protectedVar: " << protectedVar << endl; // Accesible
        // cout << "privateVar: " << privateVar << endl; // No accesible
    }
};

int main() {
    DerivadaPublic objPublic;
    objPublic.publicVar = 10;
    objPublic.mostrar();

    DerivadaProtected objProtected;
    // objProtected.publicVar = 20; // No accesible desde fuera de la clase derivada
    objProtected.mostrar();

    DerivadaPrivate objPrivate;
    // objPrivate.publicVar = 30; // No accesible desde fuera de la clase derivada
    objPrivate.mostrar();

    return 0;
}
<---Ejemplo de Acceso a Miembros de la Clase Base Result--->
<---Constructores de Clases Derivadas--->
<---Constructores de Clases Derivadas Result--->
<---Ejemplo de Creación de Objetos de la Clase Derivada--->
```cpp
#include <iostream>
using namespace std;

class Base {
protected:
    int baseVar;

public:
    // Constructor de la clase base
    Base(int v) : baseVar(v) {
        cout << "Constructor de la clase Base llamado con valor " << baseVar << endl;
    }

    void mostrarBase() const {
        cout << "Valor de baseVar: " << baseVar << endl;
    }
};

class Derivada : public Base {
private:
    int derivadaVar;

public:
    // Constructor de la clase derivada
    Derivada(int baseVal, int derivadaVal) : Base(baseVal), derivadaVar(derivadaVal) {
        cout << "Constructor de la clase Derivada llamado con valor " << derivadaVar << endl;
    }

    void mostrarDerivada() const {
        mostrarBase();
        cout << "Valor de derivadaVar: " << derivadaVar << endl;
    }
};

int main() {
    Derivada obj(10, 20);
    obj.mostrarDerivada();

    return 0;
}
<---Ejemplo de Creación de Objetos de la Clase Derivada Result--->
<---Ejemplo de Invocación de Constructores--->
```cpp
#include <iostream>
using namespace std;

class Base {
public:
    Base() {
        cout << "Constructor de Base llamado" << endl;
    }

    Base(int x) {
        cout << "Constructor de Base llamado con valor " << x << endl;
    }
};

class Derivada : public Base {
public:
    Derivada() {
        cout << "Constructor de Derivada llamado" << endl;
    }

    Derivada(int y) : Base(y) {
        cout << "Constructor de Derivada llamado con valor " << y << endl;
    }
};

int main() {
    cout << "Creando obj1:" << endl;
    Derivada obj1;

    cout << "\nCreando obj2:" << endl;
    Derivada obj2(100);

    return 0;
}
<---Ejemplo de Invocación de Constructores Result--->
<---Ejemplo de Herencia Simple--->
```cpp
#include <iostream>
using namespace std;

class Animal {
public:
    void comer() {
        cout << "El animal está comiendo." << endl;
    }
};

class Perro : public Animal {
public:
    void ladrar() {
        cout << "El perro está ladrando." << endl;
    }
};

int main() {
    Perro miPerro;
    miPerro.comer(); // Método heredado de la clase base
    miPerro.ladrar(); // Método de la clase derivada

    return 0;
}
<---Ejemplo de Herencia Simple Result--->
<---Ejemplo de Herencia Múltiple--->
```cpp
#include <iostream>
using namespace std;

class Animal {
public:
    void comer() {
        cout << "El animal está comiendo." << endl;
    }
};

class Mascota {
public:
    void jugar() {
        cout << "La mascota está jugando." << endl;
    }
};

class Perro : public Animal, public Mascota {
public:
    void ladrar() {
        cout << "El perro está ladrando." << endl;
    }
};

int main() {
    Perro miPerro;
    miPerro.comer(); // Método heredado de Animal
    miPerro.jugar(); // Método heredado de Mascota
    miPerro.ladrar(); // Método de la clase derivada

    return 0;
}
<---Ejemplo de Herencia Múltiple Result--->
<---Ejemplo de Herencia Multinivel--->
```cpp
#include <iostream>
using namespace std;

class Animal {
public:
    void comer() {
        cout << "El animal está comiendo." << endl;
    }
};

class Mamifero : public Animal {
public:
    void amamantar() {
        cout << "El mamífero está amamantando." << endl;
    }
};

class Perro : public Mamifero {
public:
    void ladrar() {
        cout << "El perro está ladrando." << endl;
    }
};

int main() {
    Perro miPerro;
    miPerro.comer(); // Método heredado de Animal
    miPerro.amamantar(); // Método heredado de Mamifero
    miPerro.ladrar(); // Método de la clase derivada

    return 0;
}
<---Ejemplo de Herencia Multinivel Result--->
<---Ejemplo de Herencia Jerárquica--->
```cpp
#include <iostream>
using namespace std;

class Animal {
public:
    void comer() {
        cout << "El animal está comiendo." << endl;
    }
};

class Perro : public Animal {
public:
    void ladrar() {
        cout << "El perro está ladrando." << endl;
    }
};

class Gato : public Animal {
public:
    void maullar() {
        cout << "El gato está maullando." << endl;
    }
};

int main() {
    Perro miPerro;
    miPerro.comer(); // Método heredado de Animal
    miPerro.ladrar(); // Método de la clase derivada

    Gato miGato;
    miGato.comer(); // Método heredado de Animal
    miGato.maullar(); // Método de la clase derivada

    return 0;
}
<---Ejemplo de Herencia Jerárquica Result--->
<---Ejemplo de Herencia Híbrida--->
```cpp
#include <iostream>
using namespace std;

class Animal {
public:
    void comer() {
        cout << "El animal está comiendo." << endl;
    }
};

class Mascota {
public:
    void jugar() {
        cout << "La mascota está jugando." << endl;
    }
};

class Mamifero : public Animal {
public:
    void amamantar() {
        cout << "El mamífero está amamantando." << endl;
    }
};

class Perro : public Mamifero, public Mascota {
public:
    void ladrar() {
        cout << "El perro está ladrando." << endl;
    }
};

int main() {
    Perro miPerro;
    miPerro.comer(); // Método heredado de Animal a través de Mamifero
    miPerro.amamantar(); // Método heredado de Mamifero
    miPerro.jugar(); // Método heredado de Mascota
    miPerro.ladrar(); // Método de la clase derivada

    return 0;
}
<---Ejemplo de Herencia Híbrida Result--->
<---Ejemplo Básico de Herencia--->
```cpp
#include <iostream>
using namespace std;

class Animal {
public:
    void comer() {
        cout << "El animal está comiendo." << endl;
    }
};

class Perro : public Animal {
public:
    void ladrar() {
        cout << "El perro está ladrando." << endl;
    }
};

int main() {
    Perro miPerro;
    miPerro.comer(); // Método heredado de la clase base
    miPerro.ladrar(); // Método de la clase derivada

    return 0;
}
<---Ejemplo Básico de Herencia Result--->
<---Ejemplo de Diferentes Modos de Herencia--->
```cpp
#include <iostream>
using namespace std;

class Base {
public:
    int publicVar;
protected:
    int protectedVar;
private:
    int privateVar;
};

class DerivadaPublic : public Base {
    // publicVar es public
    // protectedVar es protected
    // privateVar no es accesible
};

class DerivadaProtected : protected Base {
    // publicVar es protected
    // protectedVar es protected
    // privateVar no es accesible
};

class DerivadaPrivate : private Base {
    // publicVar es private
    // protectedVar es private
    // privateVar no es accesible
};

int main() {
    DerivadaPublic objPublic;
    objPublic.publicVar = 10; // Accesible
    // objPublic.protectedVar = 20; // No accesible
    // objPublic.privateVar = 30; // No accesible

    DerivadaProtected objProtected;
    // objProtected.publicVar = 10; // No accesible
    // objProtected.protectedVar = 20; // No accesible

    DerivadaPrivate objPrivate;
    // objPrivate.publicVar = 10; // No accesible
    // objPrivate.protectedVar = 20; // No accesible

    return 0;
}
<---Ejemplo de Diferentes Modos de Herencia Result--->
<---Sintaxis Básica de una Clase--->
```cpp
class NombreClase {
public:
    // Atributos
    tipo_atributo nombre_atributo;

    // Métodos
    tipo_retorno nombre_metodo(parametros);

    // Otros componentes, como constructores, destructores, etc.
};
<---Sintaxis Básica de una Clase Result--->
<---Ejemplo de una Clase Básica--->
```cpp
#include <iostream>
using namespace std;

class Persona {
public:
    string nombre;
    int edad;

    // Constructor
    Persona(string n, int e) : nombre(n), edad(e) {}

    // Método para mostrar información
    void mostrarInformacion() const {
        cout << "Nombre: " << nombre << ", Edad: " << edad << endl;
    }
};

int main() {
    Persona juan("Juan", 30);
    juan.mostrarInformacion();

    return 0;
}
<---Ejemplo de una Clase Básica Result--->
<---Ejemplo de una Clase Base--->
```cpp
#include <iostream>
using namespace std;

class Animal {
public:
    void comer() const {
        cout << "El animal está comiendo." << endl;
    }

    void dormir() const {
        cout << "El animal está durmiendo." << endl;
    }
};
<---Ejemplo de una Clase Base Result--->
<---Sintaxis Básica de una Clase Derivada--->
```cpp
class ClaseDerivada : public ClaseBase {
public:
    // Atributos y métodos adicionales
};
<---Sintaxis Básica de una Clase Derivada Result--->
<---Ejemplo de una Clase Derivada--->
```cpp
#include <iostream>
using namespace std;

class Animal {
public:
    void comer() const {
        cout << "El animal está comiendo." << endl;
    }

    void dormir() const {
        cout << "El animal está durmiendo." << endl;
    }
};

class Perro : public Animal {
public:
    void ladrar() const {
        cout << "El perro está ladrando." << endl;
    }
};

int main() {
    Perro miPerro;
    miPerro.comer(); // Método heredado de la clase base
    miPerro.dormir(); // Método heredado de la clase base
    miPerro.ladrar(); // Método de la clase derivada

    return 0;
}
<---Ejemplo de una Clase Derivada Result--->
<---Especificadores de Acceso--->
<---Especificadores de Acceso Result--->
<---Ejemplo de Acceso a Miembros de la Clase Base--->
```cpp
#include <iostream>
using namespace std;

class Base {
public:
    int publicVar;

protected:
    int protectedVar;

private:
    int privateVar;
};

class DerivadaPublic : public Base {
public:
    void mostrar() {
        cout << "Acceso en DerivadaPublic:" << endl;
        cout << "publicVar: " << publicVar << endl; // Accesible
        cout << "protectedVar: " << protectedVar << endl; // Accesible
        // cout << "privateVar: " << privateVar << endl; // No accesible
    }
};

class DerivadaProtected : protected Base {
public:
    void mostrar() {
        cout << "Acceso en DerivadaProtected:" << endl;
        cout << "publicVar: " << publicVar << endl; // Accesible
        cout << "protectedVar: " << protectedVar << endl; // Accesible
        // cout << "privateVar: " << privateVar << endl; // No accesible
    }
};

class DerivadaPrivate : private Base {
public:
    void mostrar() {
        cout << "Acceso en DerivadaPrivate:" << endl;
        cout << "publicVar: " << publicVar << endl; // Accesible
        cout << "protectedVar: " << protectedVar << endl; // Accesible
        // cout << "privateVar: " << privateVar << endl; // No accesible
    }
};

int main() {
    DerivadaPublic objPublic;
    objPublic.publicVar = 10;
    objPublic.mostrar();

    DerivadaProtected objProtected;
    // objProtected.publicVar = 20; // No accesible desde fuera de la clase derivada
    objProtected.mostrar();

    DerivadaPrivate objPrivate;
    // objPrivate.publicVar = 30; // No accesible desde fuera de la clase derivada
    objPrivate.mostrar();

    return 0;
}
<---Ejemplo de Acceso a Miembros de la Clase Base Result--->
<---Constructores de Clases Derivadas--->
<---Constructores de Clases Derivadas Result--->
<---Ejemplo de Creación de Objetos de la Clase Derivada--->
```cpp
#include <iostream>
using namespace std;

class Base {
protected:
    int baseVar;

public:
    // Constructor de la clase base
    Base(int v) : baseVar(v) {
        cout << "Constructor de la clase Base llamado con valor " << baseVar << endl;
    }

    void mostrarBase() const {
        cout << "Valor de baseVar: " << baseVar << endl;
    }
};

class Derivada : public Base {
private:
    int derivadaVar;

public:
    // Constructor de la clase derivada
    Derivada(int baseVal, int derivadaVal) : Base(baseVal), derivadaVar(derivadaVal) {
        cout << "Constructor de la clase Derivada llamado con valor " << derivadaVar << endl;
    }

    void mostrarDerivada() const {
        mostrarBase();
        cout << "Valor de derivadaVar: " << derivadaVar << endl;
    }
};

int main() {
    Derivada obj(10, 20);
    obj.mostrarDerivada();

    return 0;
}
<---Ejemplo de Creación de Objetos de la Clase Derivada Result--->
<---Ejemplo de Invocación de Constructores--->
```cpp
#include <iostream>
using namespace std;

class Base {
public:
    Base() {
        cout << "Constructor de Base llamado" << endl;
    }

    Base(int x) {
        cout << "Constructor de Base llamado con valor " << x << endl;
    }
};

class Derivada : public Base {
public:
    Derivada() {
        cout << "Constructor de Derivada llamado" << endl;
    }

    Derivada(int y) : Base(y) {
        cout << "Constructor de Derivada llamado con valor " << y << endl;
    }
};

int main() {
    cout << "Creando obj1:" << endl;
    Derivada obj1;

    cout << "\nCreando obj2:" << endl;
    Derivada obj2(100);

    return 0;
}
<---Ejemplo de Invocación de Constructores Result--->
<---Ejemplo de Herencia Simple--->
```cpp
#include <iostream>
using namespace std;

class Animal {
public:
    void comer() {
        cout << "El animal está comiendo." << endl;
    }
};

class Perro : public Animal {
public:
    void ladrar() {
        cout << "El perro está ladrando." << endl;
    }
};

int main() {
    Perro miPerro;
    miPerro.comer(); // Método heredado de la clase base
    miPerro.ladrar(); // Método de la clase derivada

    return 0;
}
<---Ejemplo de Herencia Simple Result--->
<---Ejemplo de Herencia Múltiple--->
```cpp
#include <iostream>
using namespace std;

class Animal {
public:
    void comer() {
        cout << "El animal está comiendo." << endl;
    }
};

class Mascota {
public:
    void jugar() {
        cout << "La mascota está jugando." << endl;
    }
};

class Perro : public Animal, public Mascota {
public:
    void ladrar() {
        cout << "El perro está ladrando." << endl;
    }
};

int main() {
    Perro miPerro;
    miPerro.comer(); // Método heredado de Animal
    miPerro.jugar(); // Método heredado de Mascota
    miPerro.ladrar(); // Método de la clase derivada

    return 0;
}
<---Ejemplo de Herencia Múltiple Result--->
<---Ejemplo de Herencia Multinivel--->
```cpp
#include <iostream>
using namespace std;

class Animal {
public:
    void comer() {
        cout << "El animal está comiendo." << endl;
    }
};

class Mamifero : public Animal {
public:
    void amamantar() {
        cout << "El mamífero está amamantando." << endl;
    }
};

class Perro : public Mamifero {
public:
    void ladrar() {
        cout << "El perro está ladrando." << endl;
    }
};

int main() {
    Perro miPerro;
    miPerro.comer(); // Método heredado de Animal
    miPerro.amamantar(); // Método heredado de Mamifero
    miPerro.ladrar(); // Método de la clase derivada

    return 0;
}
<---Ejemplo de Herencia Multinivel Result--->
<---Ejemplo de Herencia Jerárquica--->
```cpp
#include <iostream>
using namespace std;

class Animal {
public:
    void comer() {
        cout << "El animal está comiendo." << endl;
    }
};

class Perro : public Animal {
public:
    void ladrar() {
        cout << "El perro está ladrando." << endl;
    }
};

class Gato : public Animal {
public:
    void maullar() {
        cout << "El gato está maullando." << endl;
    }
};

int main() {
    Perro miPerro;
    miPerro.comer(); // Método heredado de Animal
    miPerro.ladrar(); // Método de la clase derivada

    Gato miGato;
    miGato.comer(); // Método heredado de Animal
    miGato.maullar(); // Método de la clase derivada

    return 0;
}
<---Ejemplo de Herencia Jerárquica Result--->
<---Ejemplo de Herencia Híbrida--->
```cpp
#include <iostream>
using namespace std;

class Animal {
public:
    void comer() {
        cout << "El animal está comiendo." << endl;
    }
};

class Mascota {
public:
    void jugar() {
        cout << "La mascota está jugando." << endl;
    }
};

class Mamifero : public Animal {
public:
    void amamantar() {
        cout << "El mamífero está amamantando." << endl;
    }
};

class Perro : public Mamifero, public Mascota {
public:
    void ladrar() {
        cout << "El perro está ladrando." << endl;
    }
};

int main() {
    Perro miPerro;
    miPerro.comer(); // Método heredado de Animal a través de Mamifero
    miPerro.amamantar(); // Método heredado de Mamifero
    miPerro.jugar(); // Método heredado de Mascota
    miPerro.ladrar(); // Método de la clase derivada

    return 0;
}
<---Ejemplo de Herencia Híbrida Result--->
<---Ejemplo de Herencia Pública--->
```cpp
#include <iostream>
using namespace std;

class Base {
public:
    int publicVar;
protected:
    int protectedVar;
private:
    int privateVar;
};

class Derivada : public Base {
public:
    void mostrar() {
        cout << "Acceso en Derivada:" << endl;
        cout << "publicVar: " << publicVar << endl; // Accesible
        cout << "protectedVar: " << protectedVar << endl; // Accesible
        // cout << "privateVar: " << privateVar << endl; // No accesible
    }
};

int main() {
    Derivada obj;
    obj.publicVar = 10;
    // obj.protectedVar = 20; // No accesible desde fuera de la clase derivada
    obj.mostrar();

    return 0;
}
<---Ejemplo de Herencia Pública Result--->
<---Ejemplo de Herencia Protegida--->
```cpp
#include <iostream>
using namespace std;

class Base {
public:
    int publicVar;
protected:
    int protectedVar;
private:
    int privateVar;
};

class Derivada : protected Base {
public:
    void mostrar() {
        cout << "Acceso en Derivada:" << endl;
        cout << "publicVar: " << publicVar << endl; // Accesible
        cout << "protectedVar: " << protectedVar << endl; // Accesible
        // cout << "privateVar: " << privateVar << endl; // No accesible
    }
};

int main() {
    Derivada obj;
    // obj.publicVar = 10; // No accesible desde fuera de la clase derivada
    // obj.protectedVar = 20; // No accesible desde fuera de la clase derivada
    obj.mostrar();

    return 0;
}
<---Ejemplo de Herencia Protegida Result--->
<---Ejemplo de Herencia Privada--->
```cpp
#include <iostream>
using namespace std;

class Base {
public:
    int publicVar;
protected:
    int protectedVar;
private:
    int privateVar;
};

class Derivada : private Base {
public:
    void mostrar() {
        cout << "Acceso en Derivada:" << endl;
        cout << "publicVar: " << publicVar << endl; // Accesible
        cout << "protectedVar: " << protectedVar << endl; // Accesible
        // cout << "privateVar: " << privateVar << endl; // No accesible
    }
};

int main() {
    Derivada obj;
    // obj.publicVar = 10; // No accesible desde fuera de la clase derivada
    // obj.protectedVar = 20; // No accesible desde fuera de la clase derivada
    obj.mostrar();

    return 0;
}
<---Ejemplo de Herencia Privada Result--->
<---Ejemplo Básico de Herencia--->
```cpp
#include <iostream>
using namespace std;

class Animal {
public:
    void comer() {
        cout << "El animal está comiendo." << endl;
    }
};

class Perro : public Animal {
public:
    void ladrar() {
        cout << "El perro está ladrando." << endl;
    }
};

int main() {
    Perro miPerro;
    miPerro.comer(); // Método heredado de la clase base
    miPerro.ladrar(); // Método de la clase derivada

    return 0;
}
<---Ejemplo Básico de Herencia Result--->
<---Ejemplo de Diferentes Modos de Herencia--->
```cpp
#include <iostream>
using namespace std;

class Base {
public:
    int publicVar;
protected:
    int protectedVar;
private:
    int privateVar;
};

class DerivadaPublic : public Base {
    // publicVar es public
    // protectedVar es protected
    // privateVar no es accesible
};

class DerivadaProtected : protected Base {
    // publicVar es protected
    // protectedVar es protected
    // privateVar no es accesible
};

class DerivadaPrivate : private Base {
    // publicVar es private
    // protectedVar es private
    // privateVar no es accesible
};

int main() {
    DerivadaPublic objPublic;
    objPublic.publicVar = 10; // Accesible
    // objPublic.protectedVar = 20; // No accesible
    // objPublic.privateVar = 30; // No accesible

    DerivadaProtected objProtected;
    // objProtected.publicVar = 10; // No accesible
    // objProtected.protectedVar = 20; // No accesible

    DerivadaPrivate objPrivate;
    // objPrivate.publicVar = 10; // No accesible
    // objPrivate.protectedVar = 20; // No accesible

    return 0;
}
<---Ejemplo de Diferentes Modos de Herencia Result--->
<---Sintaxis Básica de una Clase--->
```cpp
class NombreClase {
public:
    // Atributos
    tipo_atributo nombre_atributo;

    // Métodos
    tipo_retorno nombre_metodo(parametros);

    // Otros componentes, como constructores, destructores, etc.
};
<---Sintaxis Básica de una Clase Result--->
<---Ejemplo de una Clase Básica--->
```cpp
#include <iostream>
using namespace std;

class Persona {
public:
    string nombre;
    int edad;

    // Constructor
    Persona(string n, int e) : nombre(n), edad(e) {}

    // Método para mostrar información
    void mostrarInformacion() const {
        cout << "Nombre: " << nombre << ", Edad: " << edad << endl;
    }
};

int main() {
    Persona juan("Juan", 30);
    juan.mostrarInformacion();

    return 0;
}
<---Ejemplo de una Clase Básica Result--->
<---Ejemplo de una Clase Base--->
```cpp
#include <iostream>
using namespace std;

class Animal {
public:
    void comer() const {
        cout << "El animal está comiendo." << endl;
    }

    void dormir() const {
        cout << "El animal está durmiendo." << endl;
    }
};
<---Ejemplo de una Clase Base Result--->
<---Sintaxis Básica de una Clase Derivada--->
```cpp
class ClaseDerivada : public ClaseBase {
public:
    // Atributos y métodos adicionales
};
<---Sintaxis Básica de una Clase Derivada Result--->
<---Ejemplo de una Clase Derivada--->
```cpp
#include <iostream>
using namespace std;

class Animal {
public:
    void comer() const {
        cout << "El animal está comiendo." << endl;
    }

    void dormir() const {
        cout << "El animal está durmiendo." << endl;
    }
};

class Perro : public Animal {
public:
    void ladrar() const {
        cout << "El perro está ladrando." << endl;
    }
};

int main() {
    Perro miPerro;
    miPerro.comer(); // Método heredado de la clase base
    miPerro.dormir(); // Método heredado de la clase base
    miPerro.ladrar(); // Método de la clase derivada

    return 0;
}
<---Ejemplo de una Clase Derivada Result--->
<---Especificadores de Acceso--->
<---Especificadores de Acceso Result--->
<---Ejemplo de Acceso a Miembros de la Clase Base--->
```cpp
#include <iostream>
using namespace std;

class Base {
public:
    int publicVar;

protected:
    int protectedVar;

private:
    int privateVar;
};

class DerivadaPublic : public Base {
public:
    void mostrar() {
        cout << "Acceso en DerivadaPublic:" << endl;
        cout << "publicVar: " << publicVar << endl; // Accesible
        cout << "protectedVar: " << protectedVar << endl; // Accesible
        // cout << "privateVar: " << privateVar << endl; // No accesible
    }
};

class DerivadaProtected : protected Base {
public:
    void mostrar() {
        cout << "Acceso en DerivadaProtected:" << endl;
        cout << "publicVar: " << publicVar << endl; // Accesible
        cout << "protectedVar: " << protectedVar << endl; // Accesible
        // cout << "privateVar: " << privateVar << endl; // No accesible
    }
};

class DerivadaPrivate : private Base {
public:
    void mostrar() {
        cout << "Acceso en DerivadaPrivate:" << endl;
        cout << "publicVar: " << publicVar << endl; // Accesible
        cout << "protectedVar: " << protectedVar << endl; // Accesible
        // cout << "privateVar: " << privateVar << endl; // No accesible
    }
};

int main() {
    DerivadaPublic objPublic;
    objPublic.publicVar = 10;
    objPublic.mostrar();

    DerivadaProtected objProtected;
    // objProtected.publicVar = 20; // No accesible desde fuera de la clase derivada
    objProtected.mostrar();

    DerivadaPrivate objPrivate;
    // objPrivate.publicVar = 30; // No accesible desde fuera de la clase derivada
    objPrivate.mostrar();

    return 0;
}
<---Ejemplo de Acceso a Miembros de la Clase Base Result--->
<---Constructores de Clases Derivadas--->
<---Constructores de Clases Derivadas Result--->
<---Ejemplo de Creación de Objetos de la Clase Derivada--->
```cpp
#include <iostream>
using namespace std;

class Base {
protected:
    int baseVar;

public:
    // Constructor de la clase base
    Base(int v) : baseVar(v) {
        cout << "Constructor de la clase Base llamado con valor " << baseVar << endl;
    }

    void mostrarBase() const {
        cout << "Valor de baseVar: " << baseVar << endl;
    }
};

class Derivada : public Base {
private:
    int derivadaVar;

public:
    // Constructor de la clase derivada
    Derivada(int baseVal, int derivadaVal) : Base(baseVal), derivadaVar(derivadaVal) {
        cout << "Constructor de la clase Derivada llamado con valor " << derivadaVar << endl;
    }

    void mostrarDerivada() const {
        mostrarBase();
        cout << "Valor de derivadaVar: " << derivadaVar << endl;
    }
};

int main() {
    Derivada obj(10, 20);
    obj.mostrarDerivada();

    return 0;
}
<---Ejemplo de Creación de Objetos de la Clase Derivada Result--->
<---Ejemplo de Invocación de Constructores--->
```cpp
#include <iostream>
using namespace std;

class Base {
public:
    Base() {
        cout << "Constructor de Base llamado" << endl;
    }

    Base(int x) {
        cout << "Constructor de Base llamado con valor " << x << endl;
    }
};

class Derivada : public Base {
public:
    Derivada() {
        cout << "Constructor de Derivada llamado" << endl;
    }

    Derivada(int y) : Base(y) {
        cout << "Constructor de Derivada llamado con valor " << y << endl;
    }
};

int main() {
    cout << "Creando obj1:" << endl;
    Derivada obj1;

    cout << "\nCreando obj2:" << endl;
    Derivada obj2(100);

    return 0;
}
<---Ejemplo de Invocación de Constructores Result--->
<---Ejemplo de Herencia Simple--->
```cpp
#include <iostream>
using namespace std;

class Animal {
public:
    void comer() {
        cout << "El animal está comiendo." << endl;
    }
};

class Perro : public Animal {
public:
    void ladrar() {
        cout << "El perro está ladrando." << endl;
    }
};

int main() {
    Perro miPerro;
    miPerro.comer(); // Método heredado de la clase base
    miPerro.ladrar(); // Método de la clase derivada

    return 0;
}
<---Ejemplo de Herencia Simple Result--->
<---Ejemplo de Herencia Múltiple--->
```cpp
#include <iostream>
using namespace std;

class Animal {
public:
    void comer() {
        cout << "El animal está comiendo." << endl;
    }
};

class Mascota {
public:
    void jugar() {
        cout << "La mascota está jugando." << endl;
    }
};

class Perro : public Animal, public Mascota {
public:
    void ladrar() {
        cout << "El perro está ladrando." << endl;
    }
};

int main() {
    Perro miPerro;
    miPerro.comer(); // Método heredado de Animal
    miPerro.jugar(); // Método heredado de Mascota
    miPerro.ladrar(); // Método de la clase derivada

    return 0;
}
<---Ejemplo de Herencia Múltiple Result--->
<---Ejemplo de Herencia Multinivel--->
```cpp
#include <iostream>
using namespace std;

class Animal {
public:
    void comer() {
        cout << "El animal está comiendo." << endl;
    }
};

class Mamifero : public Animal {
public:
    void amamantar() {
        cout << "El mamífero está amamantando." << endl;
    }
};

class Perro : public Mamifero {
public:
    void ladrar() {
        cout << "El perro está ladrando." << endl;
    }
};

int main() {
    Perro miPerro;
    miPerro.comer(); // Método heredado de Animal
    miPerro.amamantar(); // Método heredado de Mamifero
    miPerro.ladrar(); // Método de la clase derivada

    return 0;
}
<---Ejemplo de Herencia Multinivel Result--->
<---Ejemplo de Herencia Jerárquica--->
```cpp
#include <iostream>
using namespace std;

class Animal {
public:
    void comer() {
        cout << "El animal está comiendo." << endl;
    }
};

class Perro : public Animal {
public:
    void ladrar() {
        cout << "El perro está ladrando." << endl;
    }
};

class Gato : public Animal {
public:
    void maullar() {
        cout << "El gato está maullando." << endl;
    }
};

int main() {
    Perro miPerro;
    miPerro.comer(); // Método heredado de Animal
    miPerro.ladrar(); // Método de la clase derivada

    Gato miGato;
    miGato.comer(); // Método heredado de Animal
    miGato.maullar(); // Método de la clase derivada

    return 0;
}
<---Ejemplo de Herencia Jerárquica Result--->
<---Ejemplo de Herencia Híbrida--->
```cpp
#include <iostream>
using namespace std;

class Animal {
public:
    void comer() {
        cout << "El animal está comiendo." << endl;
    }
};

class Mascota {
public:
    void jugar() {
        cout << "La mascota está jugando." << endl;
    }
};

class Mamifero : public Animal {
public:
    void amamantar() {
        cout << "El mamífero está amamantando." << endl;
    }
};

class Perro : public Mamifero, public Mascota {
public:
    void ladrar() {
        cout << "El perro está ladrando." << endl;
    }
};

int main() {
    Perro miPerro;
    miPerro.comer(); // Método heredado de Animal a través de Mamifero
    miPerro.amamantar(); // Método heredado de Mamifero
    miPerro.jugar(); // Método heredado de Mascota
    miPerro.ladrar(); // Método de la clase derivada

    return 0;
}
<---Ejemplo de Herencia Híbrida Result--->
<---Ejemplo de Herencia Pública--->
```cpp
#include <iostream>
using namespace std;

class Base {
public:
    int publicVar;
protected:
    int protectedVar;
private:
    int privateVar;
};

class Derivada : public Base {
public:
    void mostrar() {
        cout << "Acceso en Derivada:" << endl;
        cout << "publicVar: " << publicVar << endl; // Accesible
        cout << "protectedVar: " << protectedVar << endl; // Accesible
        // cout << "privateVar: " << privateVar << endl; // No accesible
    }
};

int main() {
    Derivada obj;
    obj.publicVar = 10;
    // obj.protectedVar = 20; // No accesible desde fuera de la clase derivada
    obj.mostrar();

    return 0;
}
<---Ejemplo de Herencia Pública Result--->
<---Ejemplo de Herencia Protegida--->
```cpp
#include <iostream>
using namespace std;

class Base {
public:
    int publicVar;
protected:
    int protectedVar;
private:
    int privateVar;
};

class Derivada : protected Base {
public:
    void mostrar() {
        cout << "Acceso en Derivada:" << endl;
        cout << "publicVar: " << publicVar << endl; // Accesible
        cout << "protectedVar: " << protectedVar << endl; // Accesible
        // cout << "privateVar: " << privateVar << endl; // No accesible
    }
};

int main() {
    Derivada obj;
    // obj.publicVar = 10; // No accesible desde fuera de la clase derivada
    // obj.protectedVar = 20; // No accesible desde fuera de la clase derivada
    obj.mostrar();

    return 0;
}
<---Ejemplo de Herencia Protegida Result--->
<---Ejemplo de Herencia Privada--->
```cpp
#include <iostream>
using namespace std;

class Base {
public:
    int publicVar;
protected:
    int protectedVar;
private:
    int privateVar;
};

class Derivada : private Base {
public:
    void mostrar() {
        cout << "Acceso en Derivada:" << endl;
        cout << "publicVar: " << publicVar << endl; // Accesible
        cout << "protectedVar: " << protectedVar << endl; // Accesible
        // cout << "privateVar: " << privateVar << endl; // No accesible
    }
};

int main() {
    Derivada obj;
    // obj.publicVar = 10; // No accesible desde fuera de la clase derivada
    // obj.protectedVar = 20; // No accesible desde fuera de la clase derivada
    obj.mostrar();

    return 0;
}
<---Ejemplo de Herencia Privada Result--->
<---Ejemplo Básico de Sobrecarga de Funciones--->
```cpp
#include <iostream>
using namespace std;

class Base {
public:
    void mostrar() {
        cout << "Mostrar sin parámetros en la clase Base" << endl;
    }

    void mostrar(int x) {
        cout << "Mostrar con un parámetro en la clase Base: " << x << endl;
    }
};

int main() {
    Base b;
    b.mostrar();
    b.mostrar(10);

    return 0;
}
<---Ejemplo Básico de Sobrecarga de Funciones Result--->
<---Ejemplo de Sobrecarga de Funciones en Herencia--->
```cpp
#include <iostream>
using namespace std;

class Base {
public:
    void mostrar() {
        cout << "Mostrar sin parámetros en la clase Base" << endl;
    }

    void mostrar(int x) {
        cout << "Mostrar con un parámetro en la clase Base: " << x << endl;
    }
};

class Derivada : public Base {
public:
    void mostrar(double y) {
        cout << "Mostrar con un parámetro double en la clase Derivada: " << y << endl;
    }
};

int main() {
    Derivada d;
    d.mostrar();       // Llama a Base::mostrar()
    d.mostrar(10);     // Llama a Base::mostrar(int)
    d.mostrar(3.14);   // Llama a Derivada::mostrar(double)

    return 0;
}
<---Ejemplo de Sobrecarga de Funciones en Herencia Result--->
<---Ejemplo de Uso de `using`--->
```cpp
#include <iostream>
using namespace std;

class Base {
public:
    void mostrar() {
        cout << "Mostrar sin parámetros en la clase Base" << endl;
    }

    void mostrar(int x) {
        cout << "Mostrar con un parámetro en la clase Base: " << x << endl;
    }
};

class Derivada : public Base {
public:
    using Base::mostrar; // Hacer visibles las funciones sobrecargadas de la clase base

    void mostrar(double y) {
        cout << "Mostrar con un parámetro double en la clase Derivada: " << y << endl;
    }
};

int main() {
    Derivada d;
    d.mostrar();       // Llama a Base::mostrar()
    d.mostrar(10);     // Llama a Base::mostrar(int)
    d.mostrar(3.14);   // Llama a Derivada::mostrar(double)

    return 0;
}
<---Ejemplo de Uso de `using` Result--->
<---Ejemplo de Sobrecarga de Operadores en Herencia--->
```cpp
#include <iostream>
using namespace std;

class Base {
public:
    virtual void mostrar() const {
        cout << "Mostrar en la clase Base" << endl;
    }

    virtual void operador() const {
        cout << "Operador en la clase Base" << endl;
    }
};

class Derivada : public Base {
public:
    void mostrar() const override {
        cout << "Mostrar en la clase Derivada" << endl;
    }

    void operador() const override {
        cout << "Operador en la clase Derivada" << endl;
    }
};

int main() {
    Base* ptrBase = new Derivada();
    ptrBase->mostrar();    // Llama a Derivada::mostrar()
    ptrBase->operador();   // Llama a Derivada::operador()

    delete ptrBase;
    return 0;
}
<---Ejemplo de Sobrecarga de Operadores en Herencia Result--->
<---Ejemplo Básico de Herencia--->
```cpp
#include <iostream>
using namespace std;

class Animal {
public:
    void comer() {
        cout << "El animal está comiendo." << endl;
    }
};

class Perro : public Animal {
public:
    void ladrar() {
        cout << "El perro está ladrando." << endl;
    }
};

int main() {
    Perro miPerro;
    miPerro.comer(); // Método heredado de la clase base
    miPerro.ladrar(); // Método de la clase derivada

    return 0;
}
<---Ejemplo Básico de Herencia Result--->
<---Ejemplo de Diferentes Modos de Herencia--->
```cpp
#include <iostream>
using namespace std;

class Base {
public:
    int publicVar;
protected:
    int protectedVar;
private:
    int privateVar;
};

class DerivadaPublic : public Base {
    // publicVar es public
    // protectedVar es protected
    // privateVar no es accesible
};

class DerivadaProtected : protected Base {
    // publicVar es protected
    // protectedVar es protected
    // privateVar no es accesible
};

class DerivadaPrivate : private Base {
    // publicVar es private
    // protectedVar es private
    // privateVar no es accesible
};

int main() {
    DerivadaPublic objPublic;
    objPublic.publicVar = 10; // Accesible
    // objPublic.protectedVar = 20; // No accesible
    // objPublic.privateVar = 30; // No accesible

    DerivadaProtected objProtected;
    // objProtected.publicVar = 10; // No accesible
    // objProtected.protectedVar = 20; // No accesible

    DerivadaPrivate objPrivate;
    // objPrivate.publicVar = 10; // No accesible
    // objPrivate.protectedVar = 20; // No accesible

    return 0;
}
<---Ejemplo de Diferentes Modos de Herencia Result--->
<---Sintaxis Básica de una Clase--->
```cpp
class NombreClase {
public:
    // Atributos
    tipo_atributo nombre_atributo;

    // Métodos
    tipo_retorno nombre_metodo(parametros);

    // Otros componentes, como constructores, destructores, etc.
};
<---Sintaxis Básica de una Clase Result--->
<---Ejemplo de una Clase Básica--->
```cpp
#include <iostream>
using namespace std;

class Persona {
public:
    string nombre;
    int edad;

    // Constructor
    Persona(string n, int e) : nombre(n), edad(e) {}

    // Método para mostrar información
    void mostrarInformacion() const {
        cout << "Nombre: " << nombre << ", Edad: " << edad << endl;
    }
};

int main() {
    Persona juan("Juan", 30);
    juan.mostrarInformacion();

    return 0;
}
<---Ejemplo de una Clase Básica Result--->
<---Ejemplo de una Clase Base--->
```cpp
#include <iostream>
using namespace std;

class Animal {
public:
    void comer() const {
        cout << "El animal está comiendo." << endl;
    }

    void dormir() const {
        cout << "El animal está durmiendo." << endl;
    }
};
<---Ejemplo de una Clase Base Result--->
<---Sintaxis Básica de una Clase Derivada--->
```cpp
class ClaseDerivada : public ClaseBase {
public:
    // Atributos y métodos adicionales
};
<---Sintaxis Básica de una Clase Derivada Result--->
<---Ejemplo de una Clase Derivada--->
```cpp
#include <iostream>
using namespace std;

class Animal {
public:
    void comer() const {
        cout << "El animal está comiendo." << endl;
    }

    void dormir() const {
        cout << "El animal está durmiendo." << endl;
    }
};

class Perro : public Animal {
public:
    void ladrar() const {
        cout << "El perro está ladrando." << endl;
    }
};

int main() {
    Perro miPerro;
    miPerro.comer(); // Método heredado de la clase base
    miPerro.dormir(); // Método heredado de la clase base
    miPerro.ladrar(); // Método de la clase derivada

    return 0;
}
<---Ejemplo de una Clase Derivada Result--->
<---Especificadores de Acceso--->
<---Especificadores de Acceso Result--->
<---Ejemplo de Acceso a Miembros de la Clase Base--->
```cpp
#include <iostream>
using namespace std;

class Base {
public:
    int publicVar;

protected:
    int protectedVar;

private:
    int privateVar;
};

class DerivadaPublic : public Base {
public:
    void mostrar() {
        cout << "Acceso en DerivadaPublic:" << endl;
        cout << "publicVar: " << publicVar << endl; // Accesible
        cout << "protectedVar: " << protectedVar << endl; // Accesible
        // cout << "privateVar: " << privateVar << endl; // No accesible
    }
};

class DerivadaProtected : protected Base {
public:
    void mostrar() {
        cout << "Acceso en DerivadaProtected:" << endl;
        cout << "publicVar: " << publicVar << endl; // Accesible
        cout << "protectedVar: " << protectedVar << endl; // Accesible
        // cout << "privateVar: " << privateVar << endl; // No accesible
    }
};

class DerivadaPrivate : private Base {
public:
    void mostrar() {
        cout << "Acceso en DerivadaPrivate:" << endl;
        cout << "publicVar: " << publicVar << endl; // Accesible
        cout << "protectedVar: " << protectedVar << endl; // Accesible
        // cout << "privateVar: " << privateVar << endl; // No accesible
    }
};

int main() {
    DerivadaPublic objPublic;
    objPublic.publicVar = 10;
    objPublic.mostrar();

    DerivadaProtected objProtected;
    // objProtected.publicVar = 20; // No accesible desde fuera de la clase derivada
    objProtected.mostrar();

    DerivadaPrivate objPrivate;
    // objPrivate.publicVar = 30; // No accesible desde fuera de la clase derivada
    objPrivate.mostrar();

    return 0;
}
<---Ejemplo de Acceso a Miembros de la Clase Base Result--->
<---Constructores de Clases Derivadas--->
<---Constructores de Clases Derivadas Result--->
<---Ejemplo de Creación de Objetos de la Clase Derivada--->
```cpp
#include <iostream>
using namespace std;

class Base {
protected:
    int baseVar;

public:
    // Constructor de la clase base
    Base(int v) : baseVar(v) {
        cout << "Constructor de la clase Base llamado con valor " << baseVar << endl;
    }

    void mostrarBase() const {
        cout << "Valor de baseVar: " << baseVar << endl;
    }
};

class Derivada : public Base {
private:
    int derivadaVar;

public:
    // Constructor de la clase derivada
    Derivada(int baseVal, int derivadaVal) : Base(baseVal), derivadaVar(derivadaVal) {
        cout << "Constructor de la clase Derivada llamado con valor " << derivadaVar << endl;
    }

    void mostrarDerivada() const {
        mostrarBase();
        cout << "Valor de derivadaVar: " << derivadaVar << endl;
    }
};

int main() {
    Derivada obj(10, 20);
    obj.mostrarDerivada();

    return 0;
}
<---Ejemplo de Creación de Objetos de la Clase Derivada Result--->
<---Ejemplo de Invocación de Constructores--->
```cpp
#include <iostream>
using namespace std;

class Base {
public:
    Base() {
        cout << "Constructor de Base llamado" << endl;
    }

    Base(int x) {
        cout << "Constructor de Base llamado con valor " << x << endl;
    }
};

class Derivada : public Base {
public:
    Derivada() {
        cout << "Constructor de Derivada llamado" << endl;
    }

    Derivada(int y) : Base(y) {
        cout << "Constructor de Derivada llamado con valor " << y << endl;
    }
};

int main() {
    cout << "Creando obj1:" << endl;
    Derivada obj1;

    cout << "\nCreando obj2:" << endl;
    Derivada obj2(100);

    return 0;
}
<---Ejemplo de Invocación de Constructores Result--->
<---Ejemplo de Herencia Simple--->
```cpp
#include <iostream>
using namespace std;

class Animal {
public:
    void comer() {
        cout << "El animal está comiendo." << endl;
    }
};

class Perro : public Animal {
public:
    void ladrar() {
        cout << "El perro está ladrando." << endl;
    }
};

int main() {
    Perro miPerro;
    miPerro.comer(); // Método heredado de la clase base
    miPerro.ladrar(); // Método de la clase derivada

    return 0;
}
<---Ejemplo de Herencia Simple Result--->
<---Ejemplo de Herencia Múltiple--->
```cpp
#include <iostream>
using namespace std;

class Animal {
public:
    void comer() {
        cout << "El animal está comiendo." << endl;
    }
};

class Mascota {
public:
    void jugar() {
        cout << "La mascota está jugando." << endl;
    }
};

class Perro : public Animal, public Mascota {
public:
    void ladrar() {
        cout << "El perro está ladrando." << endl;
    }
};

int main() {
    Perro miPerro;
    miPerro.comer(); // Método heredado de Animal
    miPerro.jugar(); // Método heredado de Mascota
    miPerro.ladrar(); // Método de la clase derivada

    return 0;
}
<---Ejemplo de Herencia Múltiple Result--->
<---Ejemplo de Herencia Multinivel--->
```cpp
#include <iostream>
using namespace std;

class Animal {
public:
    void comer() {
        cout << "El animal está comiendo." << endl;
    }
};

class Mamifero : public Animal {
public:
    void amamantar() {
        cout << "El mamífero está amamantando." << endl;
    }
};

class Perro : public Mamifero {
public:
    void ladrar() {
        cout << "El perro está ladrando." << endl;
    }
};

int main() {
    Perro miPerro;
    miPerro.comer(); // Método heredado de Animal
    miPerro.amamantar(); // Método heredado de Mamifero
    miPerro.ladrar(); // Método de la clase derivada

    return 0;
}
<---Ejemplo de Herencia Multinivel Result--->
<---Ejemplo de Herencia Jerárquica--->
```cpp
#include <iostream>
using namespace std;

class Animal {
public:
    void comer() {
        cout << "El animal está comiendo." << endl;
    }
};

class Perro : public Animal {
public:
    void ladrar() {
        cout << "El perro está ladrando." << endl;
    }
};

class Gato : public Animal {
public:
    void maullar() {
        cout << "El gato está maullando." << endl;
    }
};

int main() {
    Perro miPerro;
    miPerro.comer(); // Método heredado de Animal
    miPerro.ladrar(); // Método de la clase derivada

    Gato miGato;
    miGato.comer(); // Método heredado de Animal
    miGato.maullar(); // Método de la clase derivada

    return 0;
}
<---Ejemplo de Herencia Jerárquica Result--->
<---Ejemplo de Herencia Híbrida--->
```cpp
#include <iostream>
using namespace std;

class Animal {
public:
    void comer() {
        cout << "El animal está comiendo." << endl;
    }
};

class Mascota {
public:
    void jugar() {
        cout << "La mascota está jugando." << endl;
    }
};

class Mamifero : public Animal {
public:
    void amamantar() {
        cout << "El mamífero está amamantando." << endl;
    }
};

class Perro : public Mamifero, public Mascota {
public:
    void ladrar() {
        cout << "El perro está ladrando." << endl;
    }
};

int main() {
    Perro miPerro;
    miPerro.comer(); // Método heredado de Animal a través de Mamifero
    miPerro.amamantar(); // Método heredado de Mamifero
    miPerro.jugar(); // Método heredado de Mascota
    miPerro.ladrar(); // Método de la clase derivada

    return 0;
}
<---Ejemplo de Herencia Híbrida Result--->
<---Ejemplo de Herencia Pública--->
```cpp
#include <iostream>
using namespace std;

class Base {
public:
    int publicVar;
protected:
    int protectedVar;
private:
    int privateVar;
};

class Derivada : public Base {
public:
    void mostrar() {
        cout << "Acceso en Derivada:" << endl;
        cout << "publicVar: " << publicVar << endl; // Accesible
        cout << "protectedVar: " << protectedVar << endl; // Accesible
        // cout << "privateVar: " << privateVar << endl; // No accesible
    }
};

int main() {
    Derivada obj;
    obj.publicVar = 10;
    // obj.protectedVar = 20; // No accesible desde fuera de la clase derivada
    obj.mostrar();

    return 0;
}
<---Ejemplo de Herencia Pública Result--->
<---Ejemplo de Herencia Protegida--->
```cpp
#include <iostream>
using namespace std;

class Base {
public:
    int publicVar;
protected:
    int protectedVar;
private:
    int privateVar;
};

class Derivada : protected Base {
public:
    void mostrar() {
        cout << "Acceso en Derivada:" << endl;
        cout << "publicVar: " << publicVar << endl; // Accesible
        cout << "protectedVar: " << protectedVar << endl; // Accesible
        // cout << "privateVar: " << privateVar << endl; // No accesible
    }
};

int main() {
    Derivada obj;
    // obj.publicVar = 10; // No accesible desde fuera de la clase derivada
    // obj.protectedVar = 20; // No accesible desde fuera de la clase derivada
    obj.mostrar();

    return 0;
}
<---Ejemplo de Herencia Protegida Result--->
<---Ejemplo de Herencia Privada--->
```cpp
#include <iostream>
using namespace std;

class Base {
public:
    int publicVar;
protected:
    int protectedVar;
private:
    int privateVar;
};

class Derivada : private Base {
public:
    void mostrar() {
        cout << "Acceso en Derivada:" << endl;
        cout << "publicVar: " << publicVar << endl; // Accesible
        cout << "protectedVar: " << protectedVar << endl; // Accesible
        // cout << "privateVar: " << privateVar << endl; // No accesible
    }
};

int main() {
    Derivada obj;
    // obj.publicVar = 10; // No accesible desde fuera de la clase derivada
    // obj.protectedVar = 20; // No accesible desde fuera de la clase derivada
    obj.mostrar();

    return 0;
}
<---Ejemplo de Herencia Privada Result--->
<---Ejemplo Básico de Sobrecarga de Funciones--->
```cpp
#include <iostream>
using namespace std;

class Base {
public:
    void mostrar() {
        cout << "Mostrar sin parámetros en la clase Base" << endl;
    }

    void mostrar(int x) {
        cout << "Mostrar con un parámetro en la clase Base: " << x << endl;
    }
};

int main() {
    Base b;
    b.mostrar();
    b.mostrar(10);

    return 0;
}
<---Ejemplo Básico de Sobrecarga de Funciones Result--->
<---Ejemplo de Sobrecarga de Funciones en Herencia--->
```cpp
#include <iostream>
using namespace std;

class Base {
public:
    void mostrar() {
        cout << "Mostrar sin parámetros en la clase Base" << endl;
    }

    void mostrar(int x) {
        cout << "Mostrar con un parámetro en la clase Base: " << x << endl;
    }
};

class Derivada : public Base {
public:
    void mostrar(double y) {
        cout << "Mostrar con un parámetro double en la clase Derivada: " << y << endl;
    }
};

int main() {
    Derivada d;
    d.mostrar();       // Llama a Base::mostrar()
    d.mostrar(10);     // Llama a Base::mostrar(int)
    d.mostrar(3.14);   // Llama a Derivada::mostrar(double)

    return 0;
}
<---Ejemplo de Sobrecarga de Funciones en Herencia Result--->
<---Ejemplo de Uso de `using`--->
```cpp
#include <iostream>
using namespace std;

class Base {
public:
    void mostrar() {
        cout << "Mostrar sin parámetros en la clase Base" << endl;
    }

    void mostrar(int x) {
        cout << "Mostrar con un parámetro en la clase Base: " << x << endl;
    }
};

class Derivada : public Base {
public:
    using Base::mostrar; // Hacer visibles las funciones sobrecargadas de la clase base

    void mostrar(double y) {
        cout << "Mostrar con un parámetro double en la clase Derivada: " << y << endl;
    }
};

int main() {
    Derivada d;
    d.mostrar();       // Llama a Base::mostrar()
    d.mostrar(10);     // Llama a Base::mostrar(int)
    d.mostrar(3.14);   // Llama a Derivada::mostrar(double)

    return 0;
}
<---Ejemplo de Uso de `using` Result--->
<---Ejemplo de Sobrecarga de Operadores en Herencia--->
```cpp
#include <iostream>
using namespace std;

class Base {
public:
    virtual void mostrar() const {
        cout << "Mostrar en la clase Base" << endl;
    }

    virtual void operador() const {
        cout << "Operador en la clase Base" << endl;
    }
};

class Derivada : public Base {
public:
    void mostrar() const override {
        cout << "Mostrar en la clase Derivada" << endl;
    }

    void operador() const override {
        cout << "Operador en la clase Derivada" << endl;
    }
};

int main() {
    Base* ptrBase = new Derivada();
    ptrBase->mostrar();    // Llama a Derivada::mostrar()
    ptrBase->operador();   // Llama a Derivada::operador()

    delete ptrBase;
    return 0;
}
<---Ejemplo de Sobrecarga de Operadores en Herencia Result--->
<---Sintaxis Básica--->
```cpp
class Base {
public:
    virtual void funcion() {
        // Implementación de la clase base
    }
};

class Derivada : public Base {
public:
    void funcion() override {
        // Implementación de la clase derivada
    }
};
```cpp
#include <iostream>
using namespace std;

class Animal {
public:
    virtual void hacerSonido() const {
        cout << "El animal hace un sonido" << endl;
    }
};

class Perro : public Animal {
public:
    void hacerSonido() const override {
        cout << "El perro ladra" << endl;
    }
};

class Gato : public Animal {
public:
    void hacerSonido() const override {
        cout << "El gato maúlla" << endl;
    }
};

void hacerSonidoAnimal(const Animal& animal) {
    animal.hacerSonido();
}

int main() {
    Animal a;
    Perro p;
    Gato g;

    hacerSonidoAnimal(a); // Llama a Animal::hacerSonido()
    hacerSonidoAnimal(p); // Llama a Perro::hacerSonido()
    hacerSonidoAnimal(g); // Llama a Gato::hacerSonido()

    return 0;
}
<---Sintaxis Básica Result--->
<---Ejemplo de Polimorfismo--->
```cpp
#include <iostream>
#include <vector>
using namespace std;

class Animal {
public:
    virtual void hacerSonido() const {
        cout << "El animal hace un sonido" << endl;
    }
};

class Perro : public Animal {
public:
    void hacerSonido() const override {
        cout << "El perro ladra" << endl;
    }
};

class Gato : public Animal {
public:
    void hacerSonido() const override {
        cout << "El gato maúlla" << endl;
    }
};

int main() {
    vector<Animal*> animales;
    animales.push_back(new Animal());
    animales.push_back(new Perro());
    animales.push_back(new Gato());

    for (const auto& animal : animales) {
        animal->hacerSonido(); // Llama a la versión apropiada de hacerSonido()
    }

    // Liberar memoria
    for (const auto& animal : animales) {
        delete animal;
    }

    return 0;
}
<---Ejemplo de Polimorfismo Result--->
<---Ejemplo de `final`--->
```cpp
#include <iostream>
using namespace std;

class Base {
public:
    virtual void mostrar() const final {
        cout << "Mostrar en la clase Base" << endl;
    }
};

class Derivada : public Base {
public:
    // void mostrar() const override { // Error: no se puede anular una función final
    //     cout << "Mostrar en la clase Derivada" << endl;
    // }
};

int main() {
    Derivada d;
    d.mostrar(); // Llama a Base::mostrar()

    return 0;
}
<---Ejemplo de `final` Result--->
<---Ejemplo de Sobrecarga y Anulación--->
```cpp
#include <iostream>
using namespace std;

class Base {
public:
    virtual void funcion(int x) {
        cout << "Base::funcion(int): " << x << endl;
    }

    void funcion(double y) {
        cout << "Base::funcion(double): " << y << endl;
    }
};

class Derivada : public Base {
public:
    void funcion(int x) override {
        cout << "Derivada::funcion(int): " << x << endl;
    }

    // Sobrecarga, no anulación
    void funcion(string s) {
        cout << "Derivada::funcion(string): " << s << endl;
    }
};

int main() {
    Derivada d;
    d.funcion(10);        // Llama a Derivada::funcion(int)
    d.funcion(3.14);      // Llama a Base::funcion(double)
    d.funcion("Hola");    // Llama a Derivada::funcion(string)

    return 0;
}
<---Ejemplo de Sobrecarga y Anulación Result--->
<---Ejemplo Básico de Herencia--->
```cpp
#include <iostream>
using namespace std;

class Animal {
public:
    void comer() {
        cout << "El animal está comiendo." << endl;
    }
};

class Perro : public Animal {
public:
    void ladrar() {
        cout << "El perro está ladrando." << endl;
    }
};

int main() {
    Perro miPerro;
    miPerro.comer(); // Método heredado de la clase base
    miPerro.ladrar(); // Método de la clase derivada

    return 0;
}
<---Ejemplo Básico de Herencia Result--->
<---Ejemplo de Diferentes Modos de Herencia--->
```cpp
#include <iostream>
using namespace std;

class Base {
public:
    int publicVar;
protected:
    int protectedVar;
private:
    int privateVar;
};

class DerivadaPublic : public Base {
    // publicVar es public
    // protectedVar es protected
    // privateVar no es accesible
};

class DerivadaProtected : protected Base {
    // publicVar es protected
    // protectedVar es protected
    // privateVar no es accesible
};

class DerivadaPrivate : private Base {
    // publicVar es private
    // protectedVar es private
    // privateVar no es accesible
};

int main() {
    DerivadaPublic objPublic;
    objPublic.publicVar = 10; // Accesible
    // objPublic.protectedVar = 20; // No accesible
    // objPublic.privateVar = 30; // No accesible

    DerivadaProtected objProtected;
    // objProtected.publicVar = 10; // No accesible
    // objProtected.protectedVar = 20; // No accesible

    DerivadaPrivate objPrivate;
    // objPrivate.publicVar = 10; // No accesible
    // objPrivate.protectedVar = 20; // No accesible

    return 0;
}
<---Ejemplo de Diferentes Modos de Herencia Result--->
<---Sintaxis Básica de una Clase--->
```cpp
class NombreClase {
public:
    // Atributos
    tipo_atributo nombre_atributo;

    // Métodos
    tipo_retorno nombre_metodo(parametros);

    // Otros componentes, como constructores, destructores, etc.
};
<---Sintaxis Básica de una Clase Result--->
<---Ejemplo de una Clase Básica--->
```cpp
#include <iostream>
using namespace std;

class Persona {
public:
    string nombre;
    int edad;

    // Constructor
    Persona(string n, int e) : nombre(n), edad(e) {}

    // Método para mostrar información
    void mostrarInformacion() const {
        cout << "Nombre: " << nombre << ", Edad: " << edad << endl;
    }
};

int main() {
    Persona juan("Juan", 30);
    juan.mostrarInformacion();

    return 0;
}
<---Ejemplo de una Clase Básica Result--->
<---Ejemplo de una Clase Base--->
```cpp
#include <iostream>
using namespace std;

class Animal {
public:
    void comer() const {
        cout << "El animal está comiendo." << endl;
    }

    void dormir() const {
        cout << "El animal está durmiendo." << endl;
    }
};
<---Ejemplo de una Clase Base Result--->
<---Sintaxis Básica de una Clase Derivada--->
```cpp
class ClaseDerivada : public ClaseBase {
public:
    // Atributos y métodos adicionales
};
<---Sintaxis Básica de una Clase Derivada Result--->
<---Ejemplo de una Clase Derivada--->
```cpp
#include <iostream>
using namespace std;

class Animal {
public:
    void comer() const {
        cout << "El animal está comiendo." << endl;
    }

    void dormir() const {
        cout << "El animal está durmiendo." << endl;
    }
};

class Perro : public Animal {
public:
    void ladrar() const {
        cout << "El perro está ladrando." << endl;
    }
};

int main() {
    Perro miPerro;
    miPerro.comer(); // Método heredado de la clase base
    miPerro.dormir(); // Método heredado de la clase base
    miPerro.ladrar(); // Método de la clase derivada

    return 0;
}
<---Ejemplo de una Clase Derivada Result--->
<---Especificadores de Acceso--->
<---Especificadores de Acceso Result--->
<---Ejemplo de Acceso a Miembros de la Clase Base--->
```cpp
#include <iostream>
using namespace std;

class Base {
public:
    int publicVar;

protected:
    int protectedVar;

private:
    int privateVar;
};

class DerivadaPublic : public Base {
public:
    void mostrar() {
        cout << "Acceso en DerivadaPublic:" << endl;
        cout << "publicVar: " << publicVar << endl; // Accesible
        cout << "protectedVar: " << protectedVar << endl; // Accesible
        // cout << "privateVar: " << privateVar << endl; // No accesible
    }
};

class DerivadaProtected : protected Base {
public:
    void mostrar() {
        cout << "Acceso en DerivadaProtected:" << endl;
        cout << "publicVar: " << publicVar << endl; // Accesible
        cout << "protectedVar: " << protectedVar << endl; // Accesible
        // cout << "privateVar: " << privateVar << endl; // No accesible
    }
};

class DerivadaPrivate : private Base {
public:
    void mostrar() {
        cout << "Acceso en DerivadaPrivate:" << endl;
        cout << "publicVar: " << publicVar << endl; // Accesible
        cout << "protectedVar: " << protectedVar << endl; // Accesible
        // cout << "privateVar: " << privateVar << endl; // No accesible
    }
};

int main() {
    DerivadaPublic objPublic;
    objPublic.publicVar = 10;
    objPublic.mostrar();

    DerivadaProtected objProtected;
    // objProtected.publicVar = 20; // No accesible desde fuera de la clase derivada
    objProtected.mostrar();

    DerivadaPrivate objPrivate;
    // objPrivate.publicVar = 30; // No accesible desde fuera de la clase derivada
    objPrivate.mostrar();

    return 0;
}
<---Ejemplo de Acceso a Miembros de la Clase Base Result--->
<---Constructores de Clases Derivadas--->
<---Constructores de Clases Derivadas Result--->
<---Ejemplo de Creación de Objetos de la Clase Derivada--->
```cpp
#include <iostream>
using namespace std;

class Base {
protected:
    int baseVar;

public:
    // Constructor de la clase base
    Base(int v) : baseVar(v) {
        cout << "Constructor de la clase Base llamado con valor " << baseVar << endl;
    }

    void mostrarBase() const {
        cout << "Valor de baseVar: " << baseVar << endl;
    }
};

class Derivada : public Base {
private:
    int derivadaVar;

public:
    // Constructor de la clase derivada
    Derivada(int baseVal, int derivadaVal) : Base(baseVal), derivadaVar(derivadaVal) {
        cout << "Constructor de la clase Derivada llamado con valor " << derivadaVar << endl;
    }

    void mostrarDerivada() const {
        mostrarBase();
        cout << "Valor de derivadaVar: " << derivadaVar << endl;
    }
};

int main() {
    Derivada obj(10, 20);
    obj.mostrarDerivada();

    return 0;
}
<---Ejemplo de Creación de Objetos de la Clase Derivada Result--->
<---Ejemplo de Invocación de Constructores--->
```cpp
#include <iostream>
using namespace std;

class Base {
public:
    Base() {
        cout << "Constructor de Base llamado" << endl;
    }

    Base(int x) {
        cout << "Constructor de Base llamado con valor " << x << endl;
    }
};

class Derivada : public Base {
public:
    Derivada() {
        cout << "Constructor de Derivada llamado" << endl;
    }

    Derivada(int y) : Base(y) {
        cout << "Constructor de Derivada llamado con valor " << y << endl;
    }
};

int main() {
    cout << "Creando obj1:" << endl;
    Derivada obj1;

    cout << "\nCreando obj2:" << endl;
    Derivada obj2(100);

    return 0;
}
<---Ejemplo de Invocación de Constructores Result--->
<---Ejemplo de Herencia Simple--->
```cpp
#include <iostream>
using namespace std;

class Animal {
public:
    void comer() {
        cout << "El animal está comiendo." << endl;
    }
};

class Perro : public Animal {
public:
    void ladrar() {
        cout << "El perro está ladrando." << endl;
    }
};

int main() {
    Perro miPerro;
    miPerro.comer(); // Método heredado de la clase base
    miPerro.ladrar(); // Método de la clase derivada

    return 0;
}
<---Ejemplo de Herencia Simple Result--->
<---Ejemplo de Herencia Múltiple--->
```cpp
#include <iostream>
using namespace std;

class Animal {
public:
    void comer() {
        cout << "El animal está comiendo." << endl;
    }
};

class Mascota {
public:
    void jugar() {
        cout << "La mascota está jugando." << endl;
    }
};

class Perro : public Animal, public Mascota {
public:
    void ladrar() {
        cout << "El perro está ladrando." << endl;
    }
};

int main() {
    Perro miPerro;
    miPerro.comer(); // Método heredado de Animal
    miPerro.jugar(); // Método heredado de Mascota
    miPerro.ladrar(); // Método de la clase derivada

    return 0;
}
<---Ejemplo de Herencia Múltiple Result--->
<---Ejemplo de Herencia Multinivel--->
```cpp
#include <iostream>
using namespace std;

class Animal {
public:
    void comer() {
        cout << "El animal está comiendo." << endl;
    }
};

class Mamifero : public Animal {
public:
    void amamantar() {
        cout << "El mamífero está amamantando." << endl;
    }
};

class Perro : public Mamifero {
public:
    void ladrar() {
        cout << "El perro está ladrando." << endl;
    }
};

int main() {
    Perro miPerro;
    miPerro.comer(); // Método heredado de Animal
    miPerro.amamantar(); // Método heredado de Mamifero
    miPerro.ladrar(); // Método de la clase derivada

    return 0;
}
<---Ejemplo de Herencia Multinivel Result--->
<---Ejemplo de Herencia Jerárquica--->
```cpp
#include <iostream>
using namespace std;

class Animal {
public:
    void comer() {
        cout << "El animal está comiendo." << endl;
    }
};

class Perro : public Animal {
public:
    void ladrar() {
        cout << "El perro está ladrando." << endl;
    }
};

class Gato : public Animal {
public:
    void maullar() {
        cout << "El gato está maullando." << endl;
    }
};

int main() {
    Perro miPerro;
    miPerro.comer(); // Método heredado de Animal
    miPerro.ladrar(); // Método de la clase derivada

    Gato miGato;
    miGato.comer(); // Método heredado de Animal
    miGato.maullar(); // Método de la clase derivada

    return 0;
}
<---Ejemplo de Herencia Jerárquica Result--->
<---Ejemplo de Herencia Híbrida--->
```cpp
#include <iostream>
using namespace std;

class Animal {
public:
    void comer() {
        cout << "El animal está comiendo." << endl;
    }
};

class Mascota {
public:
    void jugar() {
        cout << "La mascota está jugando." << endl;
    }
};

class Mamifero : public Animal {
public:
    void amamantar() {
        cout << "El mamífero está amamantando." << endl;
    }
};

class Perro : public Mamifero, public Mascota {
public:
    void ladrar() {
        cout << "El perro está ladrando." << endl;
    }
};

int main() {
    Perro miPerro;
    miPerro.comer(); // Método heredado de Animal a través de Mamifero
    miPerro.amamantar(); // Método heredado de Mamifero
    miPerro.jugar(); // Método heredado de Mascota
    miPerro.ladrar(); // Método de la clase derivada

    return 0;
}
<---Ejemplo de Herencia Híbrida Result--->
<---Ejemplo de Herencia Pública--->
```cpp
#include <iostream>
using namespace std;

class Base {
public:
    int publicVar;
protected:
    int protectedVar;
private:
    int privateVar;
};

class Derivada : public Base {
public:
    void mostrar() {
        cout << "Acceso en Derivada:" << endl;
        cout << "publicVar: " << publicVar << endl; // Accesible
        cout << "protectedVar: " << protectedVar << endl; // Accesible
        // cout << "privateVar: " << privateVar << endl; // No accesible
    }
};

int main() {
    Derivada obj;
    obj.publicVar = 10;
    // obj.protectedVar = 20; // No accesible desde fuera de la clase derivada
    obj.mostrar();

    return 0;
}
<---Ejemplo de Herencia Pública Result--->
<---Ejemplo de Herencia Protegida--->
```cpp
#include <iostream>
using namespace std;

class Base {
public:
    int publicVar;
protected:
    int protectedVar;
private:
    int privateVar;
};

class Derivada : protected Base {
public:
    void mostrar() {
        cout << "Acceso en Derivada:" << endl;
        cout << "publicVar: " << publicVar << endl; // Accesible
        cout << "protectedVar: " << protectedVar << endl; // Accesible
        // cout << "privateVar: " << privateVar << endl; // No accesible
    }
};

int main() {
    Derivada obj;
    // obj.publicVar = 10; // No accesible desde fuera de la clase derivada
    // obj.protectedVar = 20; // No accesible desde fuera de la clase derivada
    obj.mostrar();

    return 0;
}
<---Ejemplo de Herencia Protegida Result--->
<---Ejemplo de Herencia Privada--->
```cpp
#include <iostream>
using namespace std;

class Base {
public:
    int publicVar;
protected:
    int protectedVar;
private:
    int privateVar;
};

class Derivada : private Base {
public:
    void mostrar() {
        cout << "Acceso en Derivada:" << endl;
        cout << "publicVar: " << publicVar << endl; // Accesible
        cout << "protectedVar: " << protectedVar << endl; // Accesible
        // cout << "privateVar: " << privateVar << endl; // No accesible
    }
};

int main() {
    Derivada obj;
    // obj.publicVar = 10; // No accesible desde fuera de la clase derivada
    // obj.protectedVar = 20; // No accesible desde fuera de la clase derivada
    obj.mostrar();

    return 0;
}
<---Ejemplo de Herencia Privada Result--->
<---Ejemplo Básico de Sobrecarga de Funciones--->
```cpp
#include <iostream>
using namespace std;

class Base {
public:
    void mostrar() {
        cout << "Mostrar sin parámetros en la clase Base" << endl;
    }

    void mostrar(int x) {
        cout << "Mostrar con un parámetro en la clase Base: " << x << endl;
    }
};

int main() {
    Base b;
    b.mostrar();
    b.mostrar(10);

    return 0;
}
<---Ejemplo Básico de Sobrecarga de Funciones Result--->
<---Ejemplo de Sobrecarga de Funciones en Herencia--->
```cpp
#include <iostream>
using namespace std;

class Base {
public:
    void mostrar() {
        cout << "Mostrar sin parámetros en la clase Base" << endl;
    }

    void mostrar(int x) {
        cout << "Mostrar con un parámetro en la clase Base: " << x << endl;
    }
};

class Derivada : public Base {
public:
    void mostrar(double y) {
        cout << "Mostrar con un parámetro double en la clase Derivada: " << y << endl;
    }
};

int main() {
    Derivada d;
    d.mostrar();       // Llama a Base::mostrar()
    d.mostrar(10);     // Llama a Base::mostrar(int)
    d.mostrar(3.14);   // Llama a Derivada::mostrar(double)

    return 0;
}
<---Ejemplo de Sobrecarga de Funciones en Herencia Result--->
<---Ejemplo de Uso de `using`--->
```cpp
#include <iostream>
using namespace std;

class Base {
public:
    void mostrar() {
        cout << "Mostrar sin parámetros en la clase Base" << endl;
    }

    void mostrar(int x) {
        cout << "Mostrar con un parámetro en la clase Base: " << x << endl;
    }
};

class Derivada : public Base {
public:
    using Base::mostrar; // Hacer visibles las funciones sobrecargadas de la clase base

    void mostrar(double y) {
        cout << "Mostrar con un parámetro double en la clase Derivada: " << y << endl;
    }
};

int main() {
    Derivada d;
    d.mostrar();       // Llama a Base::mostrar()
    d.mostrar(10);     // Llama a Base::mostrar(int)
    d.mostrar(3.14);   // Llama a Derivada::mostrar(double)

    return 0;
}
<---Ejemplo de Uso de `using` Result--->
<---Ejemplo de Sobrecarga de Operadores en Herencia--->
```cpp
#include <iostream>
using namespace std;

class Base {
public:
    virtual void mostrar() const {
        cout << "Mostrar en la clase Base" << endl;
    }

    virtual void operador() const {
        cout << "Operador en la clase Base" << endl;
    }
};

class Derivada : public Base {
public:
    void mostrar() const override {
        cout << "Mostrar en la clase Derivada" << endl;
    }

    void operador() const override {
        cout << "Operador en la clase Derivada" << endl;
    }
};

int main() {
    Base* ptrBase = new Derivada();
    ptrBase->mostrar();    // Llama a Derivada::mostrar()
    ptrBase->operador();   // Llama a Derivada::operador()

    delete ptrBase;
    return 0;
}
<---Ejemplo de Sobrecarga de Operadores en Herencia Result--->
<---Sintaxis Básica--->
```cpp
class Base {
public:
    virtual void funcion() {
        // Implementación de la clase base
    }
};

class Derivada : public Base {
public:
    void funcion() override {
        // Implementación de la clase derivada
    }
};
```cpp
#include <iostream>
using namespace std;

class Animal {
public:
    virtual void hacerSonido() const {
        cout << "El animal hace un sonido" << endl;
    }
};

class Perro : public Animal {
public:
    void hacerSonido() const override {
        cout << "El perro ladra" << endl;
    }
};

class Gato : public Animal {
public:
    void hacerSonido() const override {
        cout << "El gato maúlla" << endl;
    }
};

void hacerSonidoAnimal(const Animal& animal) {
    animal.hacerSonido();
}

int main() {
    Animal a;
    Perro p;
    Gato g;

    hacerSonidoAnimal(a); // Llama a Animal::hacerSonido()
    hacerSonidoAnimal(p); // Llama a Perro::hacerSonido()
    hacerSonidoAnimal(g); // Llama a Gato::hacerSonido()

    return 0;
}
<---Sintaxis Básica Result--->
<---Ejemplo de Polimorfismo--->
```cpp
#include <iostream>
#include <vector>
using namespace std;

class Animal {
public:
    virtual void hacerSonido() const {
        cout << "El animal hace un sonido" << endl;
    }
};

class Perro : public Animal {
public:
    void hacerSonido() const override {
        cout << "El perro ladra" << endl;
    }
};

class Gato : public Animal {
public:
    void hacerSonido() const override {
        cout << "El gato maúlla" << endl;
    }
};

int main() {
    vector<Animal*> animales;
    animales.push_back(new Animal());
    animales.push_back(new Perro());
    animales.push_back(new Gato());

    for (const auto& animal : animales) {
        animal->hacerSonido(); // Llama a la versión apropiada de hacerSonido()
    }

    // Liberar memoria
    for (const auto& animal : animales) {
        delete animal;
    }

    return 0;
}
<---Ejemplo de Polimorfismo Result--->
<---Ejemplo de `final`--->
```cpp
#include <iostream>
using namespace std;

class Base {
public:
    virtual void mostrar() const final {
        cout << "Mostrar en la clase Base" << endl;
    }
};

class Derivada : public Base {
public:
    // void mostrar() const override { // Error: no se puede anular una función final
    //     cout << "Mostrar en la clase Derivada" << endl;
    // }
};

int main() {
    Derivada d;
    d.mostrar(); // Llama a Base::mostrar()

    return 0;
}
<---Ejemplo de `final` Result--->
<---Ejemplo de Sobrecarga y Anulación--->
```cpp
#include <iostream>
using namespace std;

class Base {
public:
    virtual void funcion(int x) {
        cout << "Base::funcion(int): " << x << endl;
    }

    void funcion(double y) {
        cout << "Base::funcion(double): " << y << endl;
    }
};

class Derivada : public Base {
public:
    void funcion(int x) override {
        cout << "Derivada::funcion(int): " << x << endl;
    }

    // Sobrecarga, no anulación
    void funcion(string s) {
        cout << "Derivada::funcion(string): " << s << endl;
    }
};

int main() {
    Derivada d;
    d.funcion(10);        // Llama a Derivada::funcion(int)
    d.funcion(3.14);      // Llama a Base::funcion(double)
    d.funcion("Hola");    // Llama a Derivada::funcion(string)

    return 0;
}
<---Ejemplo de Sobrecarga y Anulación Result--->
<---Ejemplo de Funciones Virtuales Puras--->
```cpp
#include <iostream>
using namespace std;

class Animal {
public:
    virtual void hacerSonido() const = 0; // Función virtual pura
};

class Perro : public Animal {
public:
    void hacerSonido() const override {
        cout << "El perro ladra" << endl;
    }
};

class Gato : public Animal {
public:
    void hacerSonido() const override {
        cout << "El gato maúlla" << endl;
    }
};

void hacerSonidoAnimal(const Animal& animal) {
    animal.hacerSonido();
}

int main() {
    // Animal a; // Error: no se puede instanciar una clase abstracta
    Perro p;
    Gato g;

    hacerSonidoAnimal(p); // Llama a Perro::hacerSonido()
    hacerSonidoAnimal(g); // Llama a Gato::hacerSonido()

    return 0;
}
<---Ejemplo de Funciones Virtuales Puras Result--->
<---Ejemplo de Virtualidad y Constructores--->
```cpp
#include <iostream>
using namespace std;

class Base {
public:
    Base() {
        imprimir();
    }

    virtual void imprimir() const {
        cout << "Base::imprimir()" << endl;
    }
};

class Derivada : public Base {
public:
    Derivada() {
        imprimir();
    }

    void imprimir() const override {
        cout << "Derivada::imprimir()" << endl;
    }
};

int main() {
    Derivada d;
    return 0;
}
<---Ejemplo de Virtualidad y Constructores Result--->
<---Ejemplo Básico de Herencia--->
```cpp
#include <iostream>
using namespace std;

class Animal {
public:
    void comer() {
        cout << "El animal está comiendo." << endl;
    }
};

class Perro : public Animal {
public:
    void ladrar() {
        cout << "El perro está ladrando." << endl;
    }
};

int main() {
    Perro miPerro;
    miPerro.comer(); // Método heredado de la clase base
    miPerro.ladrar(); // Método de la clase derivada

    return 0;
}
<---Ejemplo Básico de Herencia Result--->
<---Ejemplo de Diferentes Modos de Herencia--->
```cpp
#include <iostream>
using namespace std;

class Base {
public:
    int publicVar;
protected:
    int protectedVar;
private:
    int privateVar;
};

class DerivadaPublic : public Base {
    // publicVar es public
    // protectedVar es protected
    // privateVar no es accesible
};

class DerivadaProtected : protected Base {
    // publicVar es protected
    // protectedVar es protected
    // privateVar no es accesible
};

class DerivadaPrivate : private Base {
    // publicVar es private
    // protectedVar es private
    // privateVar no es accesible
};

int main() {
    DerivadaPublic objPublic;
    objPublic.publicVar = 10; // Accesible
    // objPublic.protectedVar = 20; // No accesible
    // objPublic.privateVar = 30; // No accesible

    DerivadaProtected objProtected;
    // objProtected.publicVar = 10; // No accesible
    // objProtected.protectedVar = 20; // No accesible

    DerivadaPrivate objPrivate;
    // objPrivate.publicVar = 10; // No accesible
    // objPrivate.protectedVar = 20; // No accesible

    return 0;
}
<---Ejemplo de Diferentes Modos de Herencia Result--->
<---Sintaxis Básica de una Clase--->
```cpp
class NombreClase {
public:
    // Atributos
    tipo_atributo nombre_atributo;

    // Métodos
    tipo_retorno nombre_metodo(parametros);

    // Otros componentes, como constructores, destructores, etc.
};
<---Sintaxis Básica de una Clase Result--->
<---Ejemplo de una Clase Básica--->
```cpp
#include <iostream>
using namespace std;

class Persona {
public:
    string nombre;
    int edad;

    // Constructor
    Persona(string n, int e) : nombre(n), edad(e) {}

    // Método para mostrar información
    void mostrarInformacion() const {
        cout << "Nombre: " << nombre << ", Edad: " << edad << endl;
    }
};

int main() {
    Persona juan("Juan", 30);
    juan.mostrarInformacion();

    return 0;
}
<---Ejemplo de una Clase Básica Result--->
<---Ejemplo de una Clase Base--->
```cpp
#include <iostream>
using namespace std;

class Animal {
public:
    void comer() const {
        cout << "El animal está comiendo." << endl;
    }

    void dormir() const {
        cout << "El animal está durmiendo." << endl;
    }
};
<---Ejemplo de una Clase Base Result--->
<---Sintaxis Básica de una Clase Derivada--->
```cpp
class ClaseDerivada : public ClaseBase {
public:
    // Atributos y métodos adicionales
};
<---Sintaxis Básica de una Clase Derivada Result--->
<---Ejemplo de una Clase Derivada--->
```cpp
#include <iostream>
using namespace std;

class Animal {
public:
    void comer() const {
        cout << "El animal está comiendo." << endl;
    }

    void dormir() const {
        cout << "El animal está durmiendo." << endl;
    }
};

class Perro : public Animal {
public:
    void ladrar() const {
        cout << "El perro está ladrando." << endl;
    }
};

int main() {
    Perro miPerro;
    miPerro.comer(); // Método heredado de la clase base
    miPerro.dormir(); // Método heredado de la clase base
    miPerro.ladrar(); // Método de la clase derivada

    return 0;
}
<---Ejemplo de una Clase Derivada Result--->
<---Especificadores de Acceso--->
<---Especificadores de Acceso Result--->
<---Ejemplo de Acceso a Miembros de la Clase Base--->
```cpp
#include <iostream>
using namespace std;

class Base {
public:
    int publicVar;

protected:
    int protectedVar;

private:
    int privateVar;
};

class DerivadaPublic : public Base {
public:
    void mostrar() {
        cout << "Acceso en DerivadaPublic:" << endl;
        cout << "publicVar: " << publicVar << endl; // Accesible
        cout << "protectedVar: " << protectedVar << endl; // Accesible
        // cout << "privateVar: " << privateVar << endl; // No accesible
    }
};

class DerivadaProtected : protected Base {
public:
    void mostrar() {
        cout << "Acceso en DerivadaProtected:" << endl;
        cout << "publicVar: " << publicVar << endl; // Accesible
        cout << "protectedVar: " << protectedVar << endl; // Accesible
        // cout << "privateVar: " << privateVar << endl; // No accesible
    }
};

class DerivadaPrivate : private Base {
public:
    void mostrar() {
        cout << "Acceso en DerivadaPrivate:" << endl;
        cout << "publicVar: " << publicVar << endl; // Accesible
        cout << "protectedVar: " << protectedVar << endl; // Accesible
        // cout << "privateVar: " << privateVar << endl; // No accesible
    }
};

int main() {
    DerivadaPublic objPublic;
    objPublic.publicVar = 10;
    objPublic.mostrar();

    DerivadaProtected objProtected;
    // objProtected.publicVar = 20; // No accesible desde fuera de la clase derivada
    objProtected.mostrar();

    DerivadaPrivate objPrivate;
    // objPrivate.publicVar = 30; // No accesible desde fuera de la clase derivada
    objPrivate.mostrar();

    return 0;
}
<---Ejemplo de Acceso a Miembros de la Clase Base Result--->
<---Constructores de Clases Derivadas--->
<---Constructores de Clases Derivadas Result--->
<---Ejemplo de Creación de Objetos de la Clase Derivada--->
```cpp
#include <iostream>
using namespace std;

class Base {
protected:
    int baseVar;

public:
    // Constructor de la clase base
    Base(int v) : baseVar(v) {
        cout << "Constructor de la clase Base llamado con valor " << baseVar << endl;
    }

    void mostrarBase() const {
        cout << "Valor de baseVar: " << baseVar << endl;
    }
};

class Derivada : public Base {
private:
    int derivadaVar;

public:
    // Constructor de la clase derivada
    Derivada(int baseVal, int derivadaVal) : Base(baseVal), derivadaVar(derivadaVal) {
        cout << "Constructor de la clase Derivada llamado con valor " << derivadaVar << endl;
    }

    void mostrarDerivada() const {
        mostrarBase();
        cout << "Valor de derivadaVar: " << derivadaVar << endl;
    }
};

int main() {
    Derivada obj(10, 20);
    obj.mostrarDerivada();

    return 0;
}
<---Ejemplo de Creación de Objetos de la Clase Derivada Result--->
<---Ejemplo de Invocación de Constructores--->
```cpp
#include <iostream>
using namespace std;

class Base {
public:
    Base() {
        cout << "Constructor de Base" << endl;
    }
};

class Intermedia : public Base {
public:
    Intermedia() {
        cout << "Constructor de Intermedia" << endl;
    }
};

class Derivada : public Intermedia {
public:
    Derivada() {
        cout << "Constructor de Derivada" << endl;
    }
};

int main() {
    Derivada obj;
    return 0;
}
<---Ejemplo de Invocación de Constructores Result--->
<---Ejemplo de Herencia Simple--->
```cpp
#include <iostream>
using namespace std;

class Animal {
public:
    void comer() {
        cout << "El animal está comiendo." << endl;
    }
};

class Perro : public Animal {
public:
    void ladrar() {
        cout << "El perro está ladrando." << endl;
    }
};

int main() {
    Perro miPerro;
    miPerro.comer(); // Método heredado de la clase base
    miPerro.ladrar(); // Método de la clase derivada

    return 0;
}
<---Ejemplo de Herencia Simple Result--->
<---Ejemplo de Herencia Múltiple--->
```cpp
#include <iostream>
using namespace std;

class Animal {
public:
    void comer() {
        cout << "El animal está comiendo." << endl;
    }
};

class Mascota {
public:
    void jugar() {
        cout << "La mascota está jugando." << endl;
    }
};

class Perro : public Animal, public Mascota {
public:
    void ladrar() {
        cout << "El perro está ladrando." << endl;
    }
};

int main() {
    Perro miPerro;
    miPerro.comer(); // Método heredado de Animal
    miPerro.jugar(); // Método heredado de Mascota
    miPerro.ladrar(); // Método de la clase derivada

    return 0;
}
<---Ejemplo de Herencia Múltiple Result--->
<---Ejemplo de Herencia Multinivel--->
```cpp
#include <iostream>
using namespace std;

class Animal {
public:
    void comer() {
        cout << "El animal está comiendo." << endl;
    }
};

class Mamifero : public Animal {
public:
    void amamantar() {
        cout << "El mamífero está amamantando." << endl;
    }
};

class Perro : public Mamifero {
public:
    void ladrar() {
        cout << "El perro está ladrando." << endl;
    }
};

int main() {
    Perro miPerro;
    miPerro.comer(); // Método heredado de Animal
    miPerro.amamantar(); // Método heredado de Mamifero
    miPerro.ladrar(); // Método de la clase derivada

    return 0;
}
<---Ejemplo de Herencia Multinivel Result--->
<---Ejemplo de Herencia Jerárquica--->
```cpp
#include <iostream>
using namespace std;

class Animal {
public:
    void comer() {
        cout << "El animal está comiendo." << endl;
    }
};

class Perro : public Animal {
public:
    void ladrar() {
        cout << "El perro está ladrando." << endl;
    }
};

class Gato : public Animal {
public:
    void maullar() {
        cout << "El gato está maullando." << endl;
    }
};

int main() {
    Perro miPerro;
    miPerro.comer(); // Método heredado de Animal
    miPerro.ladrar(); // Método de la clase derivada

    Gato miGato;
    miGato.comer(); // Método heredado de Animal
    miGato.maullar(); // Método de la clase derivada

    return 0;
}
<---Ejemplo de Herencia Jerárquica Result--->
<---Ejemplo de Herencia Híbrida--->
```cpp
#include <iostream>
using namespace std;

class Animal {
public:
    void comer() {
        cout << "El animal está comiendo." << endl;
    }
};

class Mascota {
public:
    void jugar() {
        cout << "La mascota está jugando." << endl;
    }
};

class Mamifero : public Animal {
public:
    void amamantar() {
        cout << "El mamífero está amamantando." << endl;
    }
};

class Perro : public Mamifero, public Mascota {
public:
    void ladrar() {
        cout << "El perro está ladrando." << endl;
    }
};

int main() {
    Perro miPerro;
    miPerro.comer(); // Método heredado de Animal a través de Mamifero
    miPerro.amamantar(); // Método heredado de Mamifero
    miPerro.jugar(); // Método heredado de Mascota
    miPerro.ladrar(); // Método de la clase derivada

    return 0;
}
<---Ejemplo de Herencia Híbrida Result--->
<---Ejemplo de Herencia Pública--->
```cpp
#include <iostream>
using namespace std;

class Base {
public:
    int publicVar;
protected:
    int protectedVar;
private:
    int privateVar;
};

class Derivada : public Base {
public:
    void mostrar() {
        cout << "Acceso en Derivada:" << endl;
        cout << "publicVar: " << publicVar << endl; // Accesible
        cout << "protectedVar: " << protectedVar << endl; // Accesible
        // cout << "privateVar: " << privateVar << endl; // No accesible
    }
};

int main() {
    Derivada obj;
    obj.publicVar = 10;
    // obj.protectedVar = 20; // No accesible desde fuera de la clase derivada
    obj.mostrar();

    return 0;
}
<---Ejemplo de Herencia Pública Result--->
<---Ejemplo de Herencia Protegida--->
```cpp
#include <iostream>
using namespace std;

class Base {
public:
    int publicVar;
protected:
    int protectedVar;
private:
    int privateVar;
};

class Derivada : protected Base {
public:
    void mostrar() {
        cout << "Acceso en Derivada:" << endl;
        cout << "publicVar: " << publicVar << endl; // Accesible
        cout << "protectedVar: " << protectedVar << endl; // Accesible
        // cout << "privateVar: " << privateVar << endl; // No accesible
    }
};

int main() {
    Derivada obj;
    // obj.publicVar = 10; // No accesible desde fuera de la clase derivada
    // obj.protectedVar = 20; // No accesible desde fuera de la clase derivada
    obj.mostrar();

    return 0;
}
<---Ejemplo de Herencia Protegida Result--->
<---Ejemplo de Herencia Privada--->
```cpp
#include <iostream>
using namespace std;

class Base {
public:
    int publicVar;
protected:
    int protectedVar;
private:
    int privateVar;
};

class Derivada : private Base {
public:
    void mostrar() {
        cout << "Acceso en Derivada:" << endl;
        cout << "publicVar: " << publicVar << endl; // Accesible
        cout << "protectedVar: " << protectedVar << endl; // Accesible
        // cout << "privateVar: " << privateVar << endl; // No accesible
    }
};

int main() {
    Derivada obj;
    // obj.publicVar = 10; // No accesible desde fuera de la clase derivada
    // obj.protectedVar = 20; // No accesible desde fuera de la clase derivada
    obj.mostrar();

    return 0;
}
<---Ejemplo de Herencia Privada Result--->
<---Ejemplo Básico de Sobrecarga de Funciones--->
```cpp
#include <iostream>
using namespace std;

class Base {
public:
    void mostrar() {
        cout << "Mostrar sin parámetros en la clase Base" << endl;
    }

    void mostrar(int x) {
        cout << "Mostrar con un parámetro en la clase Base: " << x << endl;
    }
};

int main() {
    Base b;
    b.mostrar();
    b.mostrar(10);

    return 0;
}
<---Ejemplo Básico de Sobrecarga de Funciones Result--->
<---Ejemplo de Sobrecarga de Funciones en Herencia--->
```cpp
#include <iostream>
using namespace std;

class Base {
public:
    void mostrar() {
        cout << "Mostrar sin parámetros en la clase Base" << endl;
    }

    void mostrar(int x) {
        cout << "Mostrar con un parámetro en la clase Base: " << x << endl;
    }
};

class Derivada : public Base {
public:
    void mostrar(double y) {
        cout << "Mostrar con un parámetro double en la clase Derivada: " << y << endl;
    }
};

int main() {
    Derivada d;
    d.mostrar();       // Llama a Base::mostrar()
    d.mostrar(10);     // Llama a Base::mostrar(int)
    d.mostrar(3.14);   // Llama a Derivada::mostrar(double)

    return 0;
}
<---Ejemplo de Sobrecarga de Funciones en Herencia Result--->
<---Ejemplo de Uso de `using`--->
```cpp
#include <iostream>
using namespace std;

class Base {
public:
    void mostrar() {
        cout << "Mostrar sin parámetros en la clase Base" << endl;
    }

    void mostrar(int x) {
        cout << "Mostrar con un parámetro en la clase Base: " << x << endl;
    }
};

class Derivada : public Base {
public:
    using Base::mostrar; // Hacer visibles las funciones sobrecargadas de la clase base

    void mostrar(double y) {
        cout << "Mostrar con un parámetro double en la clase Derivada: " << y << endl;
    }
};

int main() {
    Derivada d;
    d.mostrar();       // Llama a Base::mostrar()
    d.mostrar(10);     // Llama a Base::mostrar(int)
    d.mostrar(3.14);   // Llama a Derivada::mostrar(double)

    return 0;
}
<---Ejemplo de Uso de `using` Result--->
<---Ejemplo de Sobrecarga de Operadores en Herencia--->
```cpp
#include <iostream>
using namespace std;

class Base {
public:
    virtual void mostrar() const {
        cout << "Mostrar en la clase Base" << endl;
    }

    virtual void operador() const {
        cout << "Operador en la clase Base" << endl;
    }
};

class Derivada : public Base {
public:
    void mostrar() const override {
        cout << "Mostrar en la clase Derivada" << endl;
    }

    void operador() const override {
        cout << "Operador en la clase Derivada" << endl;
    }
};

int main() {
    Base* ptrBase = new Derivada();
    ptrBase->mostrar();    // Llama a Derivada::mostrar()
    ptrBase->operador();   // Llama a Derivada::operador()

    delete ptrBase;
    return 0;
}
<---Ejemplo de Sobrecarga de Operadores en Herencia Result--->
<---Sintaxis Básica--->
```cpp
class Base {
public:
    virtual void funcion() {
        // Implementación de la clase base
    }
};

class Derivada : public Base {
public:
    void funcion() override {
        // Implementación de la clase derivada
    }
};
```cpp
#include <iostream>
using namespace std;

class Animal {
public:
    virtual void hacerSonido() const {
        cout << "El animal hace un sonido" << endl;
    }
};

class Perro : public Animal {
public:
    void hacerSonido() const override {
        cout << "El perro ladra" << endl;
    }
};

class Gato : public Animal {
public:
    void hacerSonido() const override {
        cout << "El gato maúlla" << endl;
    }
};

void hacerSonidoAnimal(const Animal& animal) {
    animal.hacerSonido();
}

int main() {
    Animal a;
    Perro p;
    Gato g;

    hacerSonidoAnimal(a); // Llama a Animal::hacerSonido()
    hacerSonidoAnimal(p); // Llama a Perro::hacerSonido()
    hacerSonidoAnimal(g); // Llama a Gato::hacerSonido()

    return 0;
}
<---Sintaxis Básica Result--->
<---Ejemplo de Polimorfismo--->
```cpp
#include <iostream>
#include <vector>
using namespace std;

class Animal {
public:
    virtual void hacerSonido() const {
        cout << "El animal hace un sonido" << endl;
    }
};

class Perro : public Animal {
public:
    void hacerSonido() const override {
        cout << "El perro ladra" << endl;
    }
};

class Gato : public Animal {
public:
    void hacerSonido() const override {
        cout << "El gato maúlla" << endl;
    }
};

int main() {
    vector<Animal*> animales;
    animales.push_back(new Animal());
    animales.push_back(new Perro());
    animales.push_back(new Gato());

    for (const auto& animal : animales) {
        animal->hacerSonido(); // Llama a la versión apropiada de hacerSonido()
    }

    // Liberar memoria
    for (const auto& animal : animales) {
        delete animal;
    }

    return 0;
}
<---Ejemplo de Polimorfismo Result--->
<---Ejemplo de `final`--->
```cpp
#include <iostream>
using namespace std;

class Base {
public:
    virtual void mostrar() const final {
        cout << "Mostrar en la clase Base" << endl;
    }
};

class Derivada : public Base {
public:
    // void mostrar() const override { // Error: no se puede anular una función final
    //     cout << "Mostrar en la clase Derivada" << endl;
    // }
};

int main() {
    Derivada d;
    d.mostrar(); // Llama a Base::mostrar()

    return 0;
}
<---Ejemplo de `final` Result--->
<---Ejemplo de Sobrecarga y Anulación--->
```cpp
#include <iostream>
using namespace std;

class Base {
public:
    virtual void funcion(int x) {
        cout << "Base::funcion(int): " << x << endl;
    }

    void funcion(double y) {
        cout << "Base::funcion(double): " << y << endl;
    }
};

class Derivada : public Base {
public:
    void funcion(int x) override {
        cout << "Derivada::funcion(int): " << x << endl;
    }

    // Sobrecarga, no anulación
    void funcion(string s) {
        cout << "Derivada::funcion(string): " << s << endl;
    }
};

int main() {
    Derivada d;
    d.funcion(10);        // Llama a Derivada::funcion(int)
    d.funcion(3.14);      // Llama a Base::funcion(double)
    d.funcion("Hola");    // Llama a Derivada::funcion(string)

    return 0;
}
<---Ejemplo de Sobrecarga y Anulación Result--->
<---Ejemplo de Funciones Virtuales Puras--->
```cpp
#include <iostream>
using namespace std;

class Animal {
public:
    virtual void hacerSonido() const = 0; // Función virtual pura
};

class Perro : public Animal {
public:
    void hacerSonido() const override {
        cout << "El perro ladra" << endl;
    }
};

class Gato : public Animal {
public:
    void hacerSonido() const override {
        cout << "El gato maúlla" << endl;
    }
};

void hacerSonidoAnimal(const Animal& animal) {
    animal.hacerSonido();
}

int main() {
    // Animal a; // Error: no se puede instanciar una clase abstracta
    Perro p;
    Gato g;

    hacerSonidoAnimal(p); // Llama a Perro::hacerSonido()
    hacerSonidoAnimal(g); // Llama a Gato::hacerSonido()

    return 0;
}
<---Ejemplo de Funciones Virtuales Puras Result--->
<---Ejemplo de Virtualidad y Constructores--->
```cpp
#include <iostream>
using namespace std;

class Base {
public:
    Base() {
        imprimir();
    }

    virtual void imprimir() const {
        cout << "Base::imprimir()" << endl;
    }
};

class Derivada : public Base {
public:
    Derivada() {
        imprimir();
    }

    void imprimir() const override {
        cout << "Derivada::imprimir()" << endl;
    }
};

int main() {
    Derivada d;
    return 0;
}
<---Ejemplo de Virtualidad y Constructores Result--->
<---Ejemplo de Invocación de Destructores--->
```cpp
#include <iostream>
using namespace std;

class Base {
public:
    Base() {
        cout << "Constructor de Base" << endl;
    }
    ~Base() {
        cout << "Destructor de Base" << endl;
    }
};

class Intermedia : public Base {
public:
    Intermedia() {
        cout << "Constructor de Intermedia" << endl;
    }
    ~Intermedia() {
        cout << "Destructor de Intermedia" << endl;
    }
};

class Derivada : public Intermedia {
public:
    Derivada() {
        cout << "Constructor de Derivada" << endl;
    }
    ~Derivada() {
        cout << "Destructor de Derivada" << endl;
    }
};

int main() {
    Derivada obj;
    return 0;
}
<---Ejemplo de Invocación de Destructores Result--->
<---Ejemplo de Destructor Virtual--->
```cpp
#include <iostream>
using namespace std;

class Base {
public:
    Base() {
        cout << "Constructor de Base" << endl;
    }
    virtual ~Base() {
        cout << "Destructor de Base" << endl;
    }
};

class Derivada : public Base {
public:
    Derivada() {
        cout << "Constructor de Derivada" << endl;
    }
    ~Derivada() {
        cout << "Destructor de Derivada" << endl;
    }
};

int main() {
    Base* obj = new Derivada();
    delete obj;
    return 0;
}
<---Ejemplo de Destructor Virtual Result--->
<---Ejemplo de Lista de Inicialización del Constructor--->
```cpp
#include <iostream>
using namespace std;

class Base {
private:
    int valorBase;
public:
    Base(int v) : valorBase(v) {
        cout << "Constructor de Base con valor " << valorBase << endl;
    }
};

class Derivada : public Base {
private:
    int valorDerivada;
public:
    Derivada(int vb, int vd) : Base(vb), valorDerivada(vd) {
        cout << "Constructor de Derivada con valor " << valorDerivada << endl;
    }
};

int main() {
    Derivada obj(10, 20);
    return 0;
}
<---Ejemplo de Lista de Inicialización del Constructor Result--->
<---Ejemplo Básico de Herencia--->
```cpp
#include <iostream>
using namespace std;

class Animal {
public:
    void comer() {
        cout << "El animal está comiendo." << endl;
    }
};

class Perro : public Animal {
public:
    void ladrar() {
        cout << "El perro está ladrando." << endl;
    }
};

int main() {
    Perro miPerro;
    miPerro.comer(); // Método heredado de la clase base
    miPerro.ladrar(); // Método de la clase derivada

    return 0;
}
<---Ejemplo Básico de Herencia Result--->
<---Ejemplo de Diferentes Modos de Herencia--->
```cpp
#include <iostream>
using namespace std;

class Base {
public:
    int publicVar;
protected:
    int protectedVar;
private:
    int privateVar;
};

class DerivadaPublic : public Base {
    // publicVar es public
    // protectedVar es protected
    // privateVar no es accesible
};

class DerivadaProtected : protected Base {
    // publicVar es protected
    // protectedVar es protected
    // privateVar no es accesible
};

class DerivadaPrivate : private Base {
    // publicVar es private
    // protectedVar es private
    // privateVar no es accesible
};

int main() {
    DerivadaPublic objPublic;
    objPublic.publicVar = 10; // Accesible
    // objPublic.protectedVar = 20; // No accesible
    // objPublic.privateVar = 30; // No accesible

    DerivadaProtected objProtected;
    // objProtected.publicVar = 10; // No accesible
    // objProtected.protectedVar = 20; // No accesible

    DerivadaPrivate objPrivate;
    // objPrivate.publicVar = 10; // No accesible
    // objPrivate.protectedVar = 20; // No accesible

    return 0;
}
<---Ejemplo de Diferentes Modos de Herencia Result--->
<---Sintaxis Básica de una Clase--->
```cpp
class NombreClase {
public:
    // Atributos
    tipo_atributo nombre_atributo;

    // Métodos
    tipo_retorno nombre_metodo(parametros);

    // Otros componentes, como constructores, destructores, etc.
};
<---Sintaxis Básica de una Clase Result--->
<---Ejemplo de una Clase Básica--->
```cpp
#include <iostream>
using namespace std;

class Persona {
public:
    string nombre;
    int edad;

    // Constructor
    Persona(string n, int e) : nombre(n), edad(e) {}

    // Método para mostrar información
    void mostrarInformacion() const {
        cout << "Nombre: " << nombre << ", Edad: " << edad << endl;
    }
};

int main() {
    Persona juan("Juan", 30);
    juan.mostrarInformacion();

    return 0;
}
<---Ejemplo de una Clase Básica Result--->
<---Ejemplo de una Clase Base--->
```cpp
#include <iostream>
using namespace std;

class Animal {
public:
    void comer() const {
        cout << "El animal está comiendo." << endl;
    }

    void dormir() const {
        cout << "El animal está durmiendo." << endl;
    }
};
<---Ejemplo de una Clase Base Result--->
<---Sintaxis Básica de una Clase Derivada--->
```cpp
class ClaseDerivada : public ClaseBase {
public:
    // Atributos y métodos adicionales
};
<---Sintaxis Básica de una Clase Derivada Result--->
<---Ejemplo de una Clase Derivada--->
```cpp
#include <iostream>
using namespace std;

class Animal {
public:
    void comer() const {
        cout << "El animal está comiendo." << endl;
    }

    void dormir() const {
        cout << "El animal está durmiendo." << endl;
    }
};

class Perro : public Animal {
public:
    void ladrar() const {
        cout << "El perro está ladrando." << endl;
    }
};

int main() {
    Perro miPerro;
    miPerro.comer(); // Método heredado de la clase base
    miPerro.dormir(); // Método heredado de la clase base
    miPerro.ladrar(); // Método de la clase derivada

    return 0;
}
<---Ejemplo de una Clase Derivada Result--->
<---Especificadores de Acceso--->
<---Especificadores de Acceso Result--->
<---Ejemplo de Acceso a Miembros de la Clase Base--->
```cpp
#include <iostream>
using namespace std;

class Base {
public:
    int publicVar;

protected:
    int protectedVar;

private:
    int privateVar;
};

class DerivadaPublic : public Base {
public:
    void mostrar() {
        cout << "Acceso en DerivadaPublic:" << endl;
        cout << "publicVar: " << publicVar << endl; // Accesible
        cout << "protectedVar: " << protectedVar << endl; // Accesible
        // cout << "privateVar: " << privateVar << endl; // No accesible
    }
};

class DerivadaProtected : protected Base {
public:
    void mostrar() {
        cout << "Acceso en DerivadaProtected:" << endl;
        cout << "publicVar: " << publicVar << endl; // Accesible
        cout << "protectedVar: " << protectedVar << endl; // Accesible
        // cout << "privateVar: " << privateVar << endl; // No accesible
    }
};

class DerivadaPrivate : private Base {
public:
    void mostrar() {
        cout << "Acceso en DerivadaPrivate:" << endl;
        cout << "publicVar: " << publicVar << endl; // Accesible
        cout << "protectedVar: " << protectedVar << endl; // Accesible
        // cout << "privateVar: " << privateVar << endl; // No accesible
    }
};

int main() {
    DerivadaPublic objPublic;
    objPublic.publicVar = 10;
    objPublic.mostrar();

    DerivadaProtected objProtected;
    // objProtected.publicVar = 20; // No accesible desde fuera de la clase derivada
    objProtected.mostrar();

    DerivadaPrivate objPrivate;
    // objPrivate.publicVar = 30; // No accesible desde fuera de la clase derivada
    objPrivate.mostrar();

    return 0;
}
<---Ejemplo de Acceso a Miembros de la Clase Base Result--->
<---Constructores de Clases Derivadas--->
<---Constructores de Clases Derivadas Result--->
<---Ejemplo de Creación de Objetos de la Clase Derivada--->
```cpp
#include <iostream>
using namespace std;

class Base {
protected:
    int baseVar;

public:
    // Constructor de la clase base
    Base(int v) : baseVar(v) {
        cout << "Constructor de la clase Base llamado con valor " << baseVar << endl;
    }

    void mostrarBase() const {
        cout << "Valor de baseVar: " << baseVar << endl;
    }
};

class Derivada : public Base {
private:
    int derivadaVar;

public:
    // Constructor de la clase derivada
    Derivada(int baseVal, int derivadaVal) : Base(baseVal), derivadaVar(derivadaVal) {
        cout << "Constructor de la clase Derivada llamado con valor " << derivadaVar << endl;
    }

    void mostrarDerivada() const {
        mostrarBase();
        cout << "Valor de derivadaVar: " << derivadaVar << endl;
    }
};

int main() {
    Derivada obj(10, 20);
    obj.mostrarDerivada();

    return 0;
}
<---Ejemplo de Creación de Objetos de la Clase Derivada Result--->
<---Ejemplo de Invocación de Constructores--->
```cpp
#include <iostream>
using namespace std;

class Base {
public:
    Base() {
        cout << "Constructor de Base" << endl;
    }
};

class Intermedia : public Base {
public:
    Intermedia() {
        cout << "Constructor de Intermedia" << endl;
    }
};

class Derivada : public Intermedia {
public:
    Derivada() {
        cout << "Constructor de Derivada" << endl;
    }
};

int main() {
    Derivada obj;
    return 0;
}
<---Ejemplo de Invocación de Constructores Result--->
<---Ejemplo de Herencia Simple--->
```cpp
#include <iostream>
using namespace std;

class Animal {
public:
    void comer() {
        cout << "El animal está comiendo." << endl;
    }
};

class Perro : public Animal {
public:
    void ladrar() {
        cout << "El perro está ladrando." << endl;
    }
};

int main() {
    Perro miPerro;
    miPerro.comer(); // Método heredado de la clase base
    miPerro.ladrar(); // Método de la clase derivada

    return 0;
}
<---Ejemplo de Herencia Simple Result--->
<---Ejemplo de Herencia Múltiple--->
```cpp
#include <iostream>
using namespace std;

class Animal {
public:
    void comer() {
        cout << "El animal está comiendo." << endl;
    }
};

class Mascota {
public:
    void jugar() {
        cout << "La mascota está jugando." << endl;
    }
};

class Perro : public Animal, public Mascota {
public:
    void ladrar() {
        cout << "El perro está ladrando." << endl;
    }
};

int main() {
    Perro miPerro;
    miPerro.comer(); // Método heredado de Animal
    miPerro.jugar(); // Método heredado de Mascota
    miPerro.ladrar(); // Método de la clase derivada

    return 0;
}
<---Ejemplo de Herencia Múltiple Result--->
<---Ejemplo de Herencia Multinivel--->
```cpp
#include <iostream>
using namespace std;

class Animal {
public:
    void comer() {
        cout << "El animal está comiendo." << endl;
    }
};

class Mamifero : public Animal {
public:
    void amamantar() {
        cout << "El mamífero está amamantando." << endl;
    }
};

class Perro : public Mamifero {
public:
    void ladrar() {
        cout << "El perro está ladrando." << endl;
    }
};

int main() {
    Perro miPerro;
    miPerro.comer(); // Método heredado de Animal
    miPerro.amamantar(); // Método heredado de Mamifero
    miPerro.ladrar(); // Método de la clase derivada

    return 0;
}
<---Ejemplo de Herencia Multinivel Result--->
<---Ejemplo de Herencia Jerárquica--->
```cpp
#include <iostream>
using namespace std;

class Animal {
public:
    void comer() {
        cout << "El animal está comiendo." << endl;
    }
};

class Perro : public Animal {
public:
    void ladrar() {
        cout << "El perro está ladrando." << endl;
    }
};

class Gato : public Animal {
public:
    void maullar() {
        cout << "El gato está maullando." << endl;
    }
};

int main() {
    Perro miPerro;
    miPerro.comer(); // Método heredado de Animal
    miPerro.ladrar(); // Método de la clase derivada

    Gato miGato;
    miGato.comer(); // Método heredado de Animal
    miGato.maullar(); // Método de la clase derivada

    return 0;
}
<---Ejemplo de Herencia Jerárquica Result--->
<---Ejemplo de Herencia Híbrida--->
```cpp
#include <iostream>
using namespace std;

class Animal {
public:
    void comer() {
        cout << "El animal está comiendo." << endl;
    }
};

class Mascota {
public:
    void jugar() {
        cout << "La mascota está jugando." << endl;
    }
};

class Mamifero : public Animal {
public:
    void amamantar() {
        cout << "El mamífero está amamantando." << endl;
    }
};

class Perro : public Mamifero, public Mascota {
public:
    void ladrar() {
        cout << "El perro está ladrando." << endl;
    }
};

int main() {
    Perro miPerro;
    miPerro.comer(); // Método heredado de Animal a través de Mamifero
    miPerro.amamantar(); // Método heredado de Mamifero
    miPerro.jugar(); // Método heredado de Mascota
    miPerro.ladrar(); // Método de la clase derivada

    return 0;
}
<---Ejemplo de Herencia Híbrida Result--->
<---Ejemplo de Herencia Pública--->
```cpp
#include <iostream>
using namespace std;

class Base {
public:
    int publicVar;
protected:
    int protectedVar;
private:
    int privateVar;
};

class Derivada : public Base {
public:
    void mostrar() {
        cout << "Acceso en Derivada:" << endl;
        cout << "publicVar: " << publicVar << endl; // Accesible
        cout << "protectedVar: " << protectedVar << endl; // Accesible
        // cout << "privateVar: " << privateVar << endl; // No accesible
    }
};

int main() {
    Derivada obj;
    obj.publicVar = 10;
    // obj.protectedVar = 20; // No accesible desde fuera de la clase derivada
    obj.mostrar();

    return 0;
}
<---Ejemplo de Herencia Pública Result--->
<---Ejemplo de Herencia Protegida--->
```cpp
#include <iostream>
using namespace std;

class Base {
public:
    int publicVar;
protected:
    int protectedVar;
private:
    int privateVar;
};

class Derivada : protected Base {
public:
    void mostrar() {
        cout << "Acceso en Derivada:" << endl;
        cout << "publicVar: " << publicVar << endl; // Accesible
        cout << "protectedVar: " << protectedVar << endl; // Accesible
        // cout << "privateVar: " << privateVar << endl; // No accesible
    }
};

int main() {
    Derivada obj;
    // obj.publicVar = 10; // No accesible desde fuera de la clase derivada
    // obj.protectedVar = 20; // No accesible desde fuera de la clase derivada
    obj.mostrar();

    return 0;
}
<---Ejemplo de Herencia Protegida Result--->
<---Ejemplo de Herencia Privada--->
```cpp
#include <iostream>
using namespace std;

class Base {
public:
    int publicVar;
protected:
    int protectedVar;
private:
    int privateVar;
};

class Derivada : private Base {
public:
    void mostrar() {
        cout << "Acceso en Derivada:" << endl;
        cout << "publicVar: " << publicVar << endl; // Accesible
        cout << "protectedVar: " << protectedVar << endl; // Accesible
        // cout << "privateVar: " << privateVar << endl; // No accesible
    }
};

int main() {
    Derivada obj;
    // obj.publicVar = 10; // No accesible desde fuera de la clase derivada
    // obj.protectedVar = 20; // No accesible desde fuera de la clase derivada
    obj.mostrar();

    return 0;
}
<---Ejemplo de Herencia Privada Result--->
<---Ejemplo Básico de Sobrecarga de Funciones--->
```cpp
#include <iostream>
using namespace std;

class Base {
public:
    void mostrar() {
        cout << "Mostrar sin parámetros en la clase Base" << endl;
    }

    void mostrar(int x) {
        cout << "Mostrar con un parámetro en la clase Base: " << x << endl;
    }
};

int main() {
    Base b;
    b.mostrar();
    b.mostrar(10);

    return 0;
}
<---Ejemplo Básico de Sobrecarga de Funciones Result--->
<---Ejemplo de Sobrecarga de Funciones en Herencia--->
```cpp
#include <iostream>
using namespace std;

class Base {
public:
    void mostrar() {
        cout << "Mostrar sin parámetros en la clase Base" << endl;
    }

    void mostrar(int x) {
        cout << "Mostrar con un parámetro en la clase Base: " << x << endl;
    }
};

class Derivada : public Base {
public:
    void mostrar(double y) {
        cout << "Mostrar con un parámetro double en la clase Derivada: " << y << endl;
    }
};

int main() {
    Derivada d;
    d.mostrar();       // Llama a Base::mostrar()
    d.mostrar(10);     // Llama a Base::mostrar(int)
    d.mostrar(3.14);   // Llama a Derivada::mostrar(double)

    return 0;
}
<---Ejemplo de Sobrecarga de Funciones en Herencia Result--->
<---Ejemplo de Uso de `using`--->
```cpp
#include <iostream>
using namespace std;

class Base {
public:
    void mostrar() {
        cout << "Mostrar sin parámetros en la clase Base" << endl;
    }

    void mostrar(int x) {
        cout << "Mostrar con un parámetro en la clase Base: " << x << endl;
    }
};

class Derivada : public Base {
public:
    using Base::mostrar; // Hacer visibles las funciones sobrecargadas de la clase base

    void mostrar(double y) {
        cout << "Mostrar con un parámetro double en la clase Derivada: " << y << endl;
    }
};

int main() {
    Derivada d;
    d.mostrar();       // Llama a Base::mostrar()
    d.mostrar(10);     // Llama a Base::mostrar(int)
    d.mostrar(3.14);   // Llama a Derivada::mostrar(double)

    return 0;
}
<---Ejemplo de Uso de `using` Result--->
<---Ejemplo de Sobrecarga de Operadores en Herencia--->
```cpp
#include <iostream>
using namespace std;

class Base {
public:
    virtual void mostrar() const {
        cout << "Mostrar en la clase Base" << endl;
    }

    virtual void operador() const {
        cout << "Operador en la clase Base" << endl;
    }
};

class Derivada : public Base {
public:
    void mostrar() const override {
        cout << "Mostrar en la clase Derivada" << endl;
    }

    void operador() const override {
        cout << "Operador en la clase Derivada" << endl;
    }
};

int main() {
    Base* ptrBase = new Derivada();
    ptrBase->mostrar();    // Llama a Derivada::mostrar()
    ptrBase->operador();   // Llama a Derivada::operador()

    delete ptrBase;
    return 0;
}
<---Ejemplo de Sobrecarga de Operadores en Herencia Result--->
<---Sintaxis Básica--->
```cpp
class Base {
public:
    virtual void funcion() {
        // Implementación de la clase base
    }
};

class Derivada : public Base {
public:
    void funcion() override {
        // Implementación de la clase derivada
    }
};
```cpp
#include <iostream>
using namespace std;

class Animal {
public:
    virtual void hacerSonido() const {
        cout << "El animal hace un sonido" << endl;
    }
};

class Perro : public Animal {
public:
    void hacerSonido() const override {
        cout << "El perro ladra" << endl;
    }
};

class Gato : public Animal {
public:
    void hacerSonido() const override {
        cout << "El gato maúlla" << endl;
    }
};

void hacerSonidoAnimal(const Animal& animal) {
    animal.hacerSonido();
}

int main() {
    Animal a;
    Perro p;
    Gato g;

    hacerSonidoAnimal(a); // Llama a Animal::hacerSonido()
    hacerSonidoAnimal(p); // Llama a Perro::hacerSonido()
    hacerSonidoAnimal(g); // Llama a Gato::hacerSonido()

    return 0;
}
<---Sintaxis Básica Result--->
<---Ejemplo de Polimorfismo--->
```cpp
#include <iostream>
#include <vector>
using namespace std;

class Animal {
public:
    virtual void hacerSonido() const {
        cout << "El animal hace un sonido" << endl;
    }
};

class Perro : public Animal {
public:
    void hacerSonido() const override {
        cout << "El perro ladra" << endl;
    }
};

class Gato : public Animal {
public:
    void hacerSonido() const override {
        cout << "El gato maúlla" << endl;
    }
};

int main() {
    vector<Animal*> animales;
    animales.push_back(new Animal());
    animales.push_back(new Perro());
    animales.push_back(new Gato());

    for (const auto& animal : animales) {
        animal->hacerSonido(); // Llama a la versión apropiada de hacerSonido()
    }

    // Liberar memoria
    for (const auto& animal : animales) {
        delete animal;
    }

    return 0;
}
<---Ejemplo de Polimorfismo Result--->
<---Ejemplo de `final`--->
```cpp
#include <iostream>
using namespace std;

class Base {
public:
    virtual void mostrar() const final {
        cout << "Mostrar en la clase Base" << endl;
    }
};

class Derivada : public Base {
public:
    // void mostrar() const override { // Error: no se puede anular una función final
    //     cout << "Mostrar en la clase Derivada" << endl;
    // }
};

int main() {
    Derivada d;
    d.mostrar(); // Llama a Base::mostrar()

    return 0;
}
<---Ejemplo de `final` Result--->
<---Ejemplo de Sobrecarga y Anulación--->
```cpp
#include <iostream>
using namespace std;

class Base {
public:
    virtual void funcion(int x) {
        cout << "Base::funcion(int): " << x << endl;
    }

    void funcion(double y) {
        cout << "Base::funcion(double): " << y << endl;
    }
};

class Derivada : public Base {
public:
    void funcion(int x) override {
        cout << "Derivada::funcion(int): " << x << endl;
    }

    // Sobrecarga, no anulación
    void funcion(string s) {
        cout << "Derivada::funcion(string): " << s << endl;
    }
};

int main() {
    Derivada d;
    d.funcion(10);        // Llama a Derivada::funcion(int)
    d.funcion(3.14);      // Llama a Base::funcion(double)
    d.funcion("Hola");    // Llama a Derivada::funcion(string)

    return 0;
}
<---Ejemplo de Sobrecarga y Anulación Result--->
<---Ejemplo de Funciones Virtuales Puras--->
```cpp
#include <iostream>
using namespace std;

class Animal {
public:
    virtual void hacerSonido() const = 0; // Función virtual pura
};

class Perro : public Animal {
public:
    void hacerSonido() const override {
        cout << "El perro ladra" << endl;
    }
};

class Gato : public Animal {
public:
    void hacerSonido() const override {
        cout << "El gato maúlla" << endl;
    }
};

void hacerSonidoAnimal(const Animal& animal) {
    animal.hacerSonido();
}

int main() {
    // Animal a; // Error: no se puede instanciar una clase abstracta
    Perro p;
    Gato g;

    hacerSonidoAnimal(p); // Llama a Perro::hacerSonido()
    hacerSonidoAnimal(g); // Llama a Gato::hacerSonido()

    return 0;
}
<---Ejemplo de Funciones Virtuales Puras Result--->
<---Ejemplo de Virtualidad y Constructores--->
```cpp
#include <iostream>
using namespace std;

class Base {
public:
    Base() {
        imprimir();
    }

    virtual void imprimir() const {
        cout << "Base::imprimir()" << endl;
    }
};

class Derivada : public Base {
public:
    Derivada() {
        imprimir();
    }

    void imprimir() const override {
        cout << "Derivada::imprimir()" << endl;
    }
};

int main() {
    Derivada d;
    return 0;
}
<---Ejemplo de Virtualidad y Constructores Result--->
<---Ejemplo de Invocación de Destructores--->
```cpp
#include <iostream>
using namespace std;

class Base {
public:
    Base() {
        cout << "Constructor de Base" << endl;
    }
    ~Base() {
        cout << "Destructor de Base" << endl;
    }
};

class Intermedia : public Base {
public:
    Intermedia() {
        cout << "Constructor de Intermedia" << endl;
    }
    ~Intermedia() {
        cout << "Destructor de Intermedia" << endl;
    }
};

class Derivada : public Intermedia {
public:
    Derivada() {
        cout << "Constructor de Derivada" << endl;
    }
    ~Derivada() {
        cout << "Destructor de Derivada" << endl;
    }
};

int main() {
    Derivada obj;
    return 0;
}
<---Ejemplo de Invocación de Destructores Result--->
<---Ejemplo de Destructor Virtual--->
```cpp
#include <iostream>
using namespace std;

class Base {
public:
    Base() {
        cout << "Constructor de Base" << endl;
    }
    virtual ~Base() {
        cout << "Destructor de Base" << endl;
    }
};

class Derivada : public Base {
public:
    Derivada() {
        cout << "Constructor de Derivada" << endl;
    }
    ~Derivada() {
        cout << "Destructor de Derivada" << endl;
    }
};

int main() {
    Base* obj = new Derivada();
    delete obj;
    return 0;
}
<---Ejemplo de Destructor Virtual Result--->
<---Ejemplo de Lista de Inicialización del Constructor--->
```cpp
#include <iostream>
using namespace std;

class Base {
private:
    int valorBase;
public:
    Base(int v) : valorBase(v) {
        cout << "Constructor de Base con valor " << valorBase << endl;
    }
};

class Derivada : public Base {
private:
    int valorDerivada;
public:
    Derivada(int vb, int vd) : Base(vb), valorDerivada(vd) {
        cout << "Constructor de Derivada con valor " << valorDerivada << endl;
    }
};

int main() {
    Derivada obj(10, 20);
    return 0;
}
<---Ejemplo de Lista de Inicialización del Constructor Result--->
<---Ejemplo Sin Destructor Virtual--->
```cpp
#include <iostream>
using namespace std;

class Base {
public:
    Base() {
        cout << "Constructor de Base" << endl;
    }
    ~Base() {
        cout << "Destructor de Base" << endl;
    }
};

class Derivada : public Base {
public:
    Derivada() {
        cout << "Constructor de Derivada" << endl;
    }
    ~Derivada() {
        cout << "Destructor de Derivada" << endl;
    }
};

int main() {
    Base* obj = new Derivada();
    delete obj; // Solo llama a ~Base(), no a ~Derivada()
    return 0;
}
```cpp
#include <iostream>
using namespace std;

class Base {
public:
    Base() {
        cout << "Constructor de Base" << endl;
    }
    virtual ~Base() {
        cout << "Destructor de Base" << endl;
    }
};

class Derivada : public Base {
public:
    Derivada() {
        cout << "Constructor de Derivada" << endl;
    }
    ~Derivada() {
        cout << "Destructor de Derivada" << endl;
    }
};

int main() {
    Base* obj = new Derivada();
    delete obj; // Llama a ~Derivada() y luego a ~Base()
    return 0;
}
```cpp
#include <iostream>
using namespace std;

class Animal {
public:
    virtual void hacerSonido() const = 0; // Función virtual pura
    virtual ~Animal() {
        cout << "Destructor de Animal" << endl;
    }
};

class Perro : public Animal {
public:
    void hacerSonido() const override {
        cout << "El perro ladra" << endl;
    }
    ~Perro() {
        cout << "Destructor de Perro" << endl;
    }
};

class Gato : public Animal {
public:
    void hacerSonido() const override {
        cout << "El gato maúlla" << endl;
    }
    ~Gato() {
        cout << "Destructor de Gato" << endl;
    }
};

int main() {
    Animal* p = new Perro();
    Animal* g = new Gato();
    delete p; // Llama a ~Perro() y luego a ~Animal()
    delete g; // Llama a ~Gato() y luego a ~Animal()
    return 0;
}
<---Ejemplo Sin Destructor Virtual Result--->
<---Ejemplo Básico de Herencia--->
```cpp
#include <iostream>
using namespace std;

class Animal {
public:
    void comer() {
        cout << "El animal está comiendo." << endl;
    }
};

class Perro : public Animal {
public:
    void ladrar() {
        cout << "El perro está ladrando." << endl;
    }
};

int main() {
    Perro miPerro;
    miPerro.comer(); // Método heredado de la clase base
    miPerro.ladrar(); // Método de la clase derivada

    return 0;
}
<---Ejemplo Básico de Herencia Result--->
<---Ejemplo de Diferentes Modos de Herencia--->
```cpp
#include <iostream>
using namespace std;

class Base {
public:
    int publicVar;
protected:
    int protectedVar;
private:
    int privateVar;
};

class DerivadaPublic : public Base {
    // publicVar es public
    // protectedVar es protected
    // privateVar no es accesible
};

class DerivadaProtected : protected Base {
    // publicVar es protected
    // protectedVar es protected
    // privateVar no es accesible
};

class DerivadaPrivate : private Base {
    // publicVar es private
    // protectedVar es private
    // privateVar no es accesible
};

int main() {
    DerivadaPublic objPublic;
    objPublic.publicVar = 10; // Accesible
    // objPublic.protectedVar = 20; // No accesible
    // objPublic.privateVar = 30; // No accesible

    DerivadaProtected objProtected;
    // objProtected.publicVar = 10; // No accesible
    // objProtected.protectedVar = 20; // No accesible

    DerivadaPrivate objPrivate;
    // objPrivate.publicVar = 10; // No accesible
    // objPrivate.protectedVar = 20; // No accesible

    return 0;
}
<---Ejemplo de Diferentes Modos de Herencia Result--->
<---Sintaxis Básica de una Clase--->
```cpp
class NombreClase {
public:
    // Atributos
    tipo_atributo nombre_atributo;

    // Métodos
    tipo_retorno nombre_metodo(parametros);

    // Otros componentes, como constructores, destructores, etc.
};
<---Sintaxis Básica de una Clase Result--->
<---Ejemplo de una Clase Básica--->
```cpp
#include <iostream>
using namespace std;

class Persona {
public:
    string nombre;
    int edad;

    // Constructor
    Persona(string n, int e) : nombre(n), edad(e) {}

    // Método para mostrar información
    void mostrarInformacion() const {
        cout << "Nombre: " << nombre << ", Edad: " << edad << endl;
    }
};

int main() {
    Persona juan("Juan", 30);
    juan.mostrarInformacion();

    return 0;
}
<---Ejemplo de una Clase Básica Result--->
<---Ejemplo de una Clase Base--->
```cpp
#include <iostream>
using namespace std;

class Animal {
public:
    void comer() const {
        cout << "El animal está comiendo." << endl;
    }

    void dormir() const {
        cout << "El animal está durmiendo." << endl;
    }
};
<---Ejemplo de una Clase Base Result--->
<---Sintaxis Básica de una Clase Derivada--->
```cpp
class ClaseDerivada : public ClaseBase {
public:
    // Atributos y métodos adicionales
};
<---Sintaxis Básica de una Clase Derivada Result--->
<---Ejemplo de una Clase Derivada--->
```cpp
#include <iostream>
using namespace std;

class Animal {
public:
    void comer() const {
        cout << "El animal está comiendo." << endl;
    }

    void dormir() const {
        cout << "El animal está durmiendo." << endl;
    }
};

class Perro : public Animal {
public:
    void ladrar() const {
        cout << "El perro está ladrando." << endl;
    }
};

int main() {
    Perro miPerro;
    miPerro.comer(); // Método heredado de la clase base
    miPerro.dormir(); // Método heredado de la clase base
    miPerro.ladrar(); // Método de la clase derivada

    return 0;
}
<---Ejemplo de una Clase Derivada Result--->
<---Especificadores de Acceso--->
<---Especificadores de Acceso Result--->
<---Ejemplo de Acceso a Miembros de la Clase Base--->
```cpp
#include <iostream>
using namespace std;

class Base {
public:
    int publicVar;

protected:
    int protectedVar;

private:
    int privateVar;
};

class DerivadaPublic : public Base {
public:
    void mostrar() {
        cout << "Acceso en DerivadaPublic:" << endl;
        cout << "publicVar: " << publicVar << endl; // Accesible
        cout << "protectedVar: " << protectedVar << endl; // Accesible
        // cout << "privateVar: " << privateVar << endl; // No accesible
    }
};

class DerivadaProtected : protected Base {
public:
    void mostrar() {
        cout << "Acceso en DerivadaProtected:" << endl;
        cout << "publicVar: " << publicVar << endl; // Accesible
        cout << "protectedVar: " << protectedVar << endl; // Accesible
        // cout << "privateVar: " << privateVar << endl; // No accesible
    }
};

class DerivadaPrivate : private Base {
public:
    void mostrar() {
        cout << "Acceso en DerivadaPrivate:" << endl;
        cout << "publicVar: " << publicVar << endl; // Accesible
        cout << "protectedVar: " << protectedVar << endl; // Accesible
        // cout << "privateVar: " << privateVar << endl; // No accesible
    }
};

int main() {
    DerivadaPublic objPublic;
    objPublic.publicVar = 10;
    objPublic.mostrar();

    DerivadaProtected objProtected;
    // objProtected.publicVar = 20; // No accesible desde fuera de la clase derivada
    objProtected.mostrar();

    DerivadaPrivate objPrivate;
    // objPrivate.publicVar = 30; // No accesible desde fuera de la clase derivada
    objPrivate.mostrar();

    return 0;
}
<---Ejemplo de Acceso a Miembros de la Clase Base Result--->
<---Constructores de Clases Derivadas--->
<---Constructores de Clases Derivadas Result--->
<---Ejemplo de Creación de Objetos de la Clase Derivada--->
```cpp
#include <iostream>
using namespace std;

class Base {
protected:
    int baseVar;

public:
    // Constructor de la clase base
    Base(int v) : baseVar(v) {
        cout << "Constructor de la clase Base llamado con valor " << baseVar << endl;
    }

    void mostrarBase() const {
        cout << "Valor de baseVar: " << baseVar << endl;
    }
};

class Derivada : public Base {
private:
    int derivadaVar;

public:
    // Constructor de la clase derivada
    Derivada(int baseVal, int derivadaVal) : Base(baseVal), derivadaVar(derivadaVal) {
        cout << "Constructor de la clase Derivada llamado con valor " << derivadaVar << endl;
    }

    void mostrarDerivada() const {
        mostrarBase();
        cout << "Valor de derivadaVar: " << derivadaVar << endl;
    }
};

int main() {
    Derivada obj(10, 20);
    obj.mostrarDerivada();

    return 0;
}
<---Ejemplo de Creación de Objetos de la Clase Derivada Result--->
<---Ejemplo de Invocación de Constructores--->
```cpp
#include <iostream>
using namespace std;

class Base {
public:
    Base() {
        cout << "Constructor de Base" << endl;
    }
};

class Intermedia : public Base {
public:
    Intermedia() {
        cout << "Constructor de Intermedia" << endl;
    }
};

class Derivada : public Intermedia {
public:
    Derivada() {
        cout << "Constructor de Derivada" << endl;
    }
};

int main() {
    Derivada obj;
    return 0;
}
<---Ejemplo de Invocación de Constructores Result--->
<---Ejemplo de Herencia Simple--->
```cpp
#include <iostream>
using namespace std;

class Animal {
public:
    void comer() {
        cout << "El animal está comiendo." << endl;
    }
};

class Perro : public Animal {
public:
    void ladrar() {
        cout << "El perro está ladrando." << endl;
    }
};

int main() {
    Perro miPerro;
    miPerro.comer(); // Método heredado de la clase base
    miPerro.ladrar(); // Método de la clase derivada

    return 0;
}
<---Ejemplo de Herencia Simple Result--->
<---Ejemplo de Herencia Múltiple--->
```cpp
#include <iostream>
using namespace std;

class Animal {
public:
    void comer() {
        cout << "El animal está comiendo." << endl;
    }
};

class Mascota {
public:
    void jugar() {
        cout << "La mascota está jugando." << endl;
    }
};

class Perro : public Animal, public Mascota {
public:
    void ladrar() {
        cout << "El perro está ladrando." << endl;
    }
};

int main() {
    Perro miPerro;
    miPerro.comer(); // Método heredado de Animal
    miPerro.jugar(); // Método heredado de Mascota
    miPerro.ladrar(); // Método de la clase derivada

    return 0;
}
<---Ejemplo de Herencia Múltiple Result--->
<---Ejemplo de Herencia Multinivel--->
```cpp
#include <iostream>
using namespace std;

class Animal {
public:
    void comer() {
        cout << "El animal está comiendo." << endl;
    }
};

class Mamifero : public Animal {
public:
    void amamantar() {
        cout << "El mamífero está amamantando." << endl;
    }
};

class Perro : public Mamifero {
public:
    void ladrar() {
        cout << "El perro está ladrando." << endl;
    }
};

int main() {
    Perro miPerro;
    miPerro.comer(); // Método heredado de Animal
    miPerro.amamantar(); // Método heredado de Mamifero
    miPerro.ladrar(); // Método de la clase derivada

    return 0;
}
<---Ejemplo de Herencia Multinivel Result--->
<---Ejemplo de Herencia Jerárquica--->
```cpp
#include <iostream>
using namespace std;

class Animal {
public:
    void comer() {
        cout << "El animal está comiendo." << endl;
    }
};

class Perro : public Animal {
public:
    void ladrar() {
        cout << "El perro está ladrando." << endl;
    }
};

class Gato : public Animal {
public:
    void maullar() {
        cout << "El gato está maullando." << endl;
    }
};

int main() {
    Perro miPerro;
    miPerro.comer(); // Método heredado de Animal
    miPerro.ladrar(); // Método de la clase derivada

    Gato miGato;
    miGato.comer(); // Método heredado de Animal
    miGato.maullar(); // Método de la clase derivada

    return 0;
}
<---Ejemplo de Herencia Jerárquica Result--->
<---Ejemplo de Herencia Híbrida--->
```cpp
#include <iostream>
using namespace std;

class Animal {
public:
    void comer() {
        cout << "El animal está comiendo." << endl;
    }
};

class Mascota {
public:
    void jugar() {
        cout << "La mascota está jugando." << endl;
    }
};

class Mamifero : public Animal {
public:
    void amamantar() {
        cout << "El mamífero está amamantando." << endl;
    }
};

class Perro : public Mamifero, public Mascota {
public:
    void ladrar() {
        cout << "El perro está ladrando." << endl;
    }
};

int main() {
    Perro miPerro;
    miPerro.comer(); // Método heredado de Animal a través de Mamifero
    miPerro.amamantar(); // Método heredado de Mamifero
    miPerro.jugar(); // Método heredado de Mascota
    miPerro.ladrar(); // Método de la clase derivada

    return 0;
}
<---Ejemplo de Herencia Híbrida Result--->
<---Ejemplo de Herencia Pública--->
```cpp
#include <iostream>
using namespace std;

class Base {
public:
    int publicVar;
protected:
    int protectedVar;
private:
    int privateVar;
};

class Derivada : public Base {
public:
    void mostrar() {
        cout << "Acceso en Derivada:" << endl;
        cout << "publicVar: " << publicVar << endl; // Accesible
        cout << "protectedVar: " << protectedVar << endl; // Accesible
        // cout << "privateVar: " << privateVar << endl; // No accesible
    }
};

int main() {
    Derivada obj;
    obj.publicVar = 10;
    // obj.protectedVar = 20; // No accesible desde fuera de la clase derivada
    obj.mostrar();

    return 0;
}
<---Ejemplo de Herencia Pública Result--->
<---Ejemplo de Herencia Protegida--->
```cpp
#include <iostream>
using namespace std;

class Base {
public:
    int publicVar;
protected:
    int protectedVar;
private:
    int privateVar;
};

class Derivada : protected Base {
public:
    void mostrar() {
        cout << "Acceso en Derivada:" << endl;
        cout << "publicVar: " << publicVar << endl; // Accesible
        cout << "protectedVar: " << protectedVar << endl; // Accesible
        // cout << "privateVar: " << privateVar << endl; // No accesible
    }
};

int main() {
    Derivada obj;
    // obj.publicVar = 10; // No accesible desde fuera de la clase derivada
    // obj.protectedVar = 20; // No accesible desde fuera de la clase derivada
    obj.mostrar();

    return 0;
}
<---Ejemplo de Herencia Protegida Result--->
<---Ejemplo de Herencia Privada--->
```cpp
#include <iostream>
using namespace std;

class Base {
public:
    int publicVar;
protected:
    int protectedVar;
private:
    int privateVar;
};

class Derivada : private Base {
public:
    void mostrar() {
        cout << "Acceso en Derivada:" << endl;
        cout << "publicVar: " << publicVar << endl; // Accesible
        cout << "protectedVar: " << protectedVar << endl; // Accesible
        // cout << "privateVar: " << privateVar << endl; // No accesible
    }
};

int main() {
    Derivada obj;
    // obj.publicVar = 10; // No accesible desde fuera de la clase derivada
    // obj.protectedVar = 20; // No accesible desde fuera de la clase derivada
    obj.mostrar();

    return 0;
}
<---Ejemplo de Herencia Privada Result--->
<---Ejemplo Básico de Sobrecarga de Funciones--->
```cpp
#include <iostream>
using namespace std;

class Base {
public:
    void mostrar() {
        cout << "Mostrar sin parámetros en la clase Base" << endl;
    }

    void mostrar(int x) {
        cout << "Mostrar con un parámetro en la clase Base: " << x << endl;
    }
};

int main() {
    Base b;
    b.mostrar();
    b.mostrar(10);

    return 0;
}
<---Ejemplo Básico de Sobrecarga de Funciones Result--->
<---Ejemplo de Sobrecarga de Funciones en Herencia--->
```cpp
#include <iostream>
using namespace std;

class Base {
public:
    void mostrar() {
        cout << "Mostrar sin parámetros en la clase Base" << endl;
    }

    void mostrar(int x) {
        cout << "Mostrar con un parámetro en la clase Base: " << x << endl;
    }
};

class Derivada : public Base {
public:
    void mostrar(double y) {
        cout << "Mostrar con un parámetro double en la clase Derivada: " << y << endl;
    }
};

int main() {
    Derivada d;
    d.mostrar();       // Llama a Base::mostrar()
    d.mostrar(10);     // Llama a Base::mostrar(int)
    d.mostrar(3.14);   // Llama a Derivada::mostrar(double)

    return 0;
}
<---Ejemplo de Sobrecarga de Funciones en Herencia Result--->
<---Ejemplo de Uso de `using`--->
```cpp
#include <iostream>
using namespace std;

class Base {
public:
    void mostrar() {
        cout << "Mostrar sin parámetros en la clase Base" << endl;
    }

    void mostrar(int x) {
        cout << "Mostrar con un parámetro en la clase Base: " << x << endl;
    }
};

class Derivada : public Base {
public:
    using Base::mostrar; // Hacer visibles las funciones sobrecargadas de la clase base

    void mostrar(double y) {
        cout << "Mostrar con un parámetro double en la clase Derivada: " << y << endl;
    }
};

int main() {
    Derivada d;
    d.mostrar();       // Llama a Base::mostrar()
    d.mostrar(10);     // Llama a Base::mostrar(int)
    d.mostrar(3.14);   // Llama a Derivada::mostrar(double)

    return 0;
}
<---Ejemplo de Uso de `using` Result--->
<---Ejemplo de Sobrecarga de Operadores en Herencia--->
```cpp
#include <iostream>
using namespace std;

class Base {
public:
    virtual void mostrar() const {
        cout << "Mostrar en la clase Base" << endl;
    }

    virtual void operador() const {
        cout << "Operador en la clase Base" << endl;
    }
};

class Derivada : public Base {
public:
    void mostrar() const override {
        cout << "Mostrar en la clase Derivada" << endl;
    }

    void operador() const override {
        cout << "Operador en la clase Derivada" << endl;
    }
};

int main() {
    Base* ptrBase = new Derivada();
    ptrBase->mostrar();    // Llama a Derivada::mostrar()
    ptrBase->operador();   // Llama a Derivada::operador()

    delete ptrBase;
    return 0;
}
<---Ejemplo de Sobrecarga de Operadores en Herencia Result--->
<---Sintaxis Básica--->
```cpp
class Base {
public:
    virtual void funcion() {
        // Implementación de la clase base
    }
};

class Derivada : public Base {
public:
    void funcion() override {
        // Implementación de la clase derivada
    }
};
```cpp
#include <iostream>
using namespace std;

class Animal {
public:
    virtual void hacerSonido() const {
        cout << "El animal hace un sonido" << endl;
    }
};

class Perro : public Animal {
public:
    void hacerSonido() const override {
        cout << "El perro ladra" << endl;
    }
};

class Gato : public Animal {
public:
    void hacerSonido() const override {
        cout << "El gato maúlla" << endl;
    }
};

void hacerSonidoAnimal(const Animal& animal) {
    animal.hacerSonido();
}

int main() {
    Animal a;
    Perro p;
    Gato g;

    hacerSonidoAnimal(a); // Llama a Animal::hacerSonido()
    hacerSonidoAnimal(p); // Llama a Perro::hacerSonido()
    hacerSonidoAnimal(g); // Llama a Gato::hacerSonido()

    return 0;
}
<---Sintaxis Básica Result--->
<---Ejemplo de Polimorfismo--->
```cpp
#include <iostream>
#include <vector>
using namespace std;

class Animal {
public:
    virtual void hacerSonido() const {
        cout << "El animal hace un sonido" << endl;
    }
};

class Perro : public Animal {
public:
    void hacerSonido() const override {
        cout << "El perro ladra" << endl;
    }
};

class Gato : public Animal {
public:
    void hacerSonido() const override {
        cout << "El gato maúlla" << endl;
    }
};

int main() {
    vector<Animal*> animales;
    animales.push_back(new Animal());
    animales.push_back(new Perro());
    animales.push_back(new Gato());

    for (const auto& animal : animales) {
        animal->hacerSonido(); // Llama a la versión apropiada de hacerSonido()
    }

    // Liberar memoria
    for (const auto& animal : animales) {
        delete animal;
    }

    return 0;
}
<---Ejemplo de Polimorfismo Result--->
<---Ejemplo de `final`--->
```cpp
#include <iostream>
using namespace std;

class Base {
public:
    virtual void mostrar() const final {
        cout << "Mostrar en la clase Base" << endl;
    }
};

class Derivada : public Base {
public:
    // void mostrar() const override { // Error: no se puede anular una función final
    //     cout << "Mostrar en la clase Derivada" << endl;
    // }
};

int main() {
    Derivada d;
    d.mostrar(); // Llama a Base::mostrar()

    return 0;
}
<---Ejemplo de `final` Result--->
<---Ejemplo de Sobrecarga y Anulación--->
```cpp
#include <iostream>
using namespace std;

class Base {
public:
    virtual void funcion(int x) {
        cout << "Base::funcion(int): " << x << endl;
    }

    void funcion(double y) {
        cout << "Base::funcion(double): " << y << endl;
    }
};

class Derivada : public Base {
public:
    void funcion(int x) override {
        cout << "Derivada::funcion(int): " << x << endl;
    }

    // Sobrecarga, no anulación
    void funcion(string s) {
        cout << "Derivada::funcion(string): " << s << endl;
    }
};

int main() {
    Derivada d;
    d.funcion(10);        // Llama a Derivada::funcion(int)
    d.funcion(3.14);      // Llama a Base::funcion(double)
    d.funcion("Hola");    // Llama a Derivada::funcion(string)

    return 0;
}
<---Ejemplo de Sobrecarga y Anulación Result--->
<---Ejemplo de Funciones Virtuales Puras--->
```cpp
#include <iostream>
using namespace std;

class Animal {
public:
    virtual void hacerSonido() const = 0; // Función virtual pura
};

class Perro : public Animal {
public:
    void hacerSonido() const override {
        cout << "El perro ladra" << endl;
    }
};

class Gato : public Animal {
public:
    void hacerSonido() const override {
        cout << "El gato maúlla" << endl;
    }
};

void hacerSonidoAnimal(const Animal& animal) {
    animal.hacerSonido();
}

int main() {
    // Animal a; // Error: no se puede instanciar una clase abstracta
    Perro p;
    Gato g;

    hacerSonidoAnimal(p); // Llama a Perro::hacerSonido()
    hacerSonidoAnimal(g); // Llama a Gato::hacerSonido()

    return 0;
}
<---Ejemplo de Funciones Virtuales Puras Result--->
<---Ejemplo de Virtualidad y Constructores--->
```cpp
#include <iostream>
using namespace std;

class Base {
public:
    Base() {
        imprimir();
    }

    virtual void imprimir() const {
        cout << "Base::imprimir()" << endl;
    }
};

class Derivada : public Base {
public:
    Derivada() {
        imprimir();
    }

    void imprimir() const override {
        cout << "Derivada::imprimir()" << endl;
    }
};

int main() {
    Derivada d;
    return 0;
}
<---Ejemplo de Virtualidad y Constructores Result--->
<---Ejemplo de Invocación de Destructores--->
```cpp
#include <iostream>
using namespace std;

class Base {
public:
    Base() {
        cout << "Constructor de Base" << endl;
    }
    ~Base() {
        cout << "Destructor de Base" << endl;
    }
};

class Intermedia : public Base {
public:
    Intermedia() {
        cout << "Constructor de Intermedia" << endl;
    }
    ~Intermedia() {
        cout << "Destructor de Intermedia" << endl;
    }
};

class Derivada : public Intermedia {
public:
    Derivada() {
        cout << "Constructor de Derivada" << endl;
    }
    ~Derivada() {
        cout << "Destructor de Derivada" << endl;
    }
};

int main() {
    Derivada obj;
    return 0;
}
<---Ejemplo de Invocación de Destructores Result--->
<---Ejemplo de Destructor Virtual--->
```cpp
#include <iostream>
using namespace std;

class Base {
public:
    Base() {
        cout << "Constructor de Base" << endl;
    }
    virtual ~Base() {
        cout << "Destructor de Base" << endl;
    }
};

class Derivada : public Base {
public:
    Derivada() {
        cout << "Constructor de Derivada" << endl;
    }
    ~Derivada() {
        cout << "Destructor de Derivada" << endl;
    }
};

int main() {
    Base* obj = new Derivada();
    delete obj;
    return 0;
}
<---Ejemplo de Destructor Virtual Result--->
<---Ejemplo de Lista de Inicialización del Constructor--->
```cpp
#include <iostream>
using namespace std;

class Base {
private:
    int valorBase;
public:
    Base(int v) : valorBase(v) {
        cout << "Constructor de Base con valor " << valorBase << endl;
    }
};

class Derivada : public Base {
private:
    int valorDerivada;
public:
    Derivada(int vb, int vd) : Base(vb), valorDerivada(vd) {
        cout << "Constructor de Derivada con valor " << valorDerivada << endl;
    }
};

int main() {
    Derivada obj(10, 20);
    return 0;
}
<---Ejemplo de Lista de Inicialización del Constructor Result--->
<---Ejemplo Sin Destructor Virtual--->
```cpp
#include <iostream>
using namespace std;

class Base {
public:
    Base() {
        cout << "Constructor de Base" << endl;
    }
    ~Base() {
        cout << "Destructor de Base" << endl;
    }
};

class Derivada : public Base {
public:
    Derivada() {
        cout << "Constructor de Derivada" << endl;
    }
    ~Derivada() {
        cout << "Destructor de Derivada" << endl;
    }
};

int main() {
    Base* obj = new Derivada();
    delete obj; // Solo llama a ~Base(), no a ~Derivada()
    return 0;
}
```cpp
#include <iostream>
using namespace std;

class Base {
public:
    Base() {
        cout << "Constructor de Base" << endl;
    }
    virtual ~Base() {
        cout << "Destructor de Base" << endl;
    }
};

class Derivada : public Base {
public:
    Derivada() {
        cout << "Constructor de Derivada" << endl;
    }
    ~Derivada() {
        cout << "Destructor de Derivada" << endl;
    }
};

int main() {
    Base* obj = new Derivada();
    delete obj; // Llama a ~Derivada() y luego a ~Base()
    return 0;
}
```cpp
#include <iostream>
using namespace std;

class Animal {
public:
    virtual void hacerSonido() const = 0; // Función virtual pura
    virtual ~Animal() {
        cout << "Destructor de Animal" << endl;
    }
};

class Perro : public Animal {
public:
    void hacerSonido() const override {
        cout << "El perro ladra" << endl;
    }
    ~Perro() {
        cout << "Destructor de Perro" << endl;
    }
};

class Gato : public Animal {
public:
    void hacerSonido() const override {
        cout << "El gato maúlla" << endl;
    }
    ~Gato() {
        cout << "Destructor de Gato" << endl;
    }
};

int main() {
    Animal* p = new Perro();
    Animal* g = new Gato();
    delete p; // Llama a ~Perro() y luego a ~Animal()
    delete g; // Llama a ~Gato() y luego a ~Animal()
    return 0;
}
<---Ejemplo Sin Destructor Virtual Result--->
<---Tipos de Polimorfismo en C++--->
<---Tipos de Polimorfismo en C++ Result--->
<---Ejemplo de Polimorfismo de Inclusión--->
```cpp
#include <iostream>
using namespace std;

class Animal {
public:
    virtual void hacerSonido() const {
        cout << "El animal hace un sonido" << endl;
    }
};

class Perro : public Animal {
public:
    void hacerSonido() const override {
        cout << "El perro ladra" << endl;
    }
};

class Gato : public Animal {
public:
    void hacerSonido() const override {
        cout << "El gato maúlla" << endl;
    }
};

void hacerSonidoAnimal(const Animal& animal) {
    animal.hacerSonido();
}

int main() {
    Animal a;
    Perro p;
    Gato g;

    hacerSonidoAnimal(a); // Llama a Animal::hacerSonido()
    hacerSonidoAnimal(p); // Llama a Perro::hacerSonido()
    hacerSonidoAnimal(g); // Llama a Gato::hacerSonido()

    return 0;
}
<---Ejemplo de Polimorfismo de Inclusión Result--->
<---Ejemplo de Clase Abstracta--->
```cpp
#include <iostream>
using namespace std;

class Animal {
public:
    virtual void hacerSonido() const = 0; // Función virtual pura
};

class Perro : public Animal {
public:
    void hacerSonido() const override {
        cout << "El perro ladra" << endl;
    }
};

class Gato : public Animal {
public:
    void hacerSonido() const override {
        cout << "El gato maúlla" << endl;
    }
};

void hacerSonidoAnimal(const Animal& animal) {
    animal.hacerSonido();
}

int main() {
    // Animal a; // Error: no se puede instanciar una clase abstracta
    Perro p;
    Gato g;

    hacerSonidoAnimal(p); // Llama a Perro::hacerSonido()
    hacerSonidoAnimal(g); // Llama a Gato::hacerSonido()

    return 0;
}
<---Ejemplo de Clase Abstracta Result--->
<---Ejemplo con Colección Polimórfica--->
```cpp
#include <iostream>
#include <vector>
using namespace std;

class Animal {
public:
    virtual void hacerSonido() const = 0; // Función virtual pura
    virtual ~Animal() {}
};

class Perro : public Animal {
public:
    void hacerSonido() const override {
        cout << "El perro ladra" << endl;
    }
};

class Gato : public Animal {
public:
    void hacerSonido() const override {
        cout << "El gato maúlla" << endl;
    }
};

int main() {
    vector<Animal*> animales;
    animales.push_back(new Perro());
    animales.push_back(new Gato());

    for (const auto& animal : animales) {
        animal->hacerSonido(); // Llama a la implementación apropiada
    }

    // Liberar memoria
    for (const auto& animal : animales) {
        delete animal;
    }

    return 0;
}
<---Ejemplo con Colección Polimórfica Result--->
<---Ejemplo Básico de Herencia--->
```cpp
#include <iostream>
using namespace std;

class Animal {
public:
    void comer() {
        cout << "El animal está comiendo." << endl;
    }
};

class Perro : public Animal {
public:
    void ladrar() {
        cout << "El perro está ladrando." << endl;
    }
};

int main() {
    Perro miPerro;
    miPerro.comer(); // Método heredado de la clase base
    miPerro.ladrar(); // Método de la clase derivada

    return 0;
}
<---Ejemplo Básico de Herencia Result--->
<---Ejemplo de Diferentes Modos de Herencia--->
```cpp
#include <iostream>
using namespace std;

class Base {
public:
    int publicVar;
protected:
    int protectedVar;
private:
    int privateVar;
};

class DerivadaPublic : public Base {
    // publicVar es public
    // protectedVar es protected
    // privateVar no es accesible
};

class DerivadaProtected : protected Base {
    // publicVar es protected
    // protectedVar es protected
    // privateVar no es accesible
};

class DerivadaPrivate : private Base {
    // publicVar es private
    // protectedVar es private
    // privateVar no es accesible
};

int main() {
    DerivadaPublic objPublic;
    objPublic.publicVar = 10; // Accesible
    // objPublic.protectedVar = 20; // No accesible
    // objPublic.privateVar = 30; // No accesible

    DerivadaProtected objProtected;
    // objProtected.publicVar = 10; // No accesible
    // objProtected.protectedVar = 20; // No accesible

    DerivadaPrivate objPrivate;
    // objPrivate.publicVar = 10; // No accesible
    // objPrivate.protectedVar = 20; // No accesible

    return 0;
}
<---Ejemplo de Diferentes Modos de Herencia Result--->
<---Sintaxis Básica de una Clase--->
```cpp
class NombreClase {
public:
    // Atributos
    tipo_atributo nombre_atributo;

    // Métodos
    tipo_retorno nombre_metodo(parametros);

    // Otros componentes, como constructores, destructores, etc.
};
<---Sintaxis Básica de una Clase Result--->
<---Ejemplo de una Clase Básica--->
```cpp
#include <iostream>
using namespace std;

class Persona {
public:
    string nombre;
    int edad;

    // Constructor
    Persona(string n, int e) : nombre(n), edad(e) {}

    // Método para mostrar información
    void mostrarInformacion() const {
        cout << "Nombre: " << nombre << ", Edad: " << edad << endl;
    }
};

int main() {
    Persona juan("Juan", 30);
    juan.mostrarInformacion();

    return 0;
}
<---Ejemplo de una Clase Básica Result--->
<---Ejemplo de una Clase Base--->
```cpp
#include <iostream>
using namespace std;

class Animal {
public:
    void comer() const {
        cout << "El animal está comiendo." << endl;
    }

    void dormir() const {
        cout << "El animal está durmiendo." << endl;
    }
};
<---Ejemplo de una Clase Base Result--->
<---Sintaxis Básica de una Clase Derivada--->
```cpp
class ClaseDerivada : public ClaseBase {
public:
    // Atributos y métodos adicionales
};
<---Sintaxis Básica de una Clase Derivada Result--->
<---Ejemplo de una Clase Derivada--->
```cpp
#include <iostream>
using namespace std;

class Animal {
public:
    void comer() const {
        cout << "El animal está comiendo." << endl;
    }

    void dormir() const {
        cout << "El animal está durmiendo." << endl;
    }
};

class Perro : public Animal {
public:
    void ladrar() const {
        cout << "El perro está ladrando." << endl;
    }
};

int main() {
    Perro miPerro;
    miPerro.comer(); // Método heredado de la clase base
    miPerro.dormir(); // Método heredado de la clase base
    miPerro.ladrar(); // Método de la clase derivada

    return 0;
}
<---Ejemplo de una Clase Derivada Result--->
<---Especificadores de Acceso--->
<---Especificadores de Acceso Result--->
<---Ejemplo de Acceso a Miembros de la Clase Base--->
```cpp
#include <iostream>
using namespace std;

class Base {
public:
    int publicVar;

protected:
    int protectedVar;

private:
    int privateVar;
};

class DerivadaPublic : public Base {
public:
    void mostrar() {
        cout << "Acceso en DerivadaPublic:" << endl;
        cout << "publicVar: " << publicVar << endl; // Accesible
        cout << "protectedVar: " << protectedVar << endl; // Accesible
        // cout << "privateVar: " << privateVar << endl; // No accesible
    }
};

class DerivadaProtected : protected Base {
public:
    void mostrar() {
        cout << "Acceso en DerivadaProtected:" << endl;
        cout << "publicVar: " << publicVar << endl; // Accesible
        cout << "protectedVar: " << protectedVar << endl; // Accesible
        // cout << "privateVar: " << privateVar << endl; // No accesible
    }
};

class DerivadaPrivate : private Base {
public:
    void mostrar() {
        cout << "Acceso en DerivadaPrivate:" << endl;
        cout << "publicVar: " << publicVar << endl; // Accesible
        cout << "protectedVar: " << protectedVar << endl; // Accesible
        // cout << "privateVar: " << privateVar << endl; // No accesible
    }
};

int main() {
    DerivadaPublic objPublic;
    objPublic.publicVar = 10;
    objPublic.mostrar();

    DerivadaProtected objProtected;
    // objProtected.publicVar = 20; // No accesible desde fuera de la clase derivada
    objProtected.mostrar();

    DerivadaPrivate objPrivate;
    // objPrivate.publicVar = 30; // No accesible desde fuera de la clase derivada
    objPrivate.mostrar();

    return 0;
}
<---Ejemplo de Acceso a Miembros de la Clase Base Result--->
<---Constructores de Clases Derivadas--->
<---Constructores de Clases Derivadas Result--->
<---Ejemplo de Creación de Objetos de la Clase Derivada--->
```cpp
#include <iostream>
using namespace std;

class Base {
protected:
    int baseVar;

public:
    // Constructor de la clase base
    Base(int v) : baseVar(v) {
        cout << "Constructor de la clase Base llamado con valor " << baseVar << endl;
    }

    void mostrarBase() const {
        cout << "Valor de baseVar: " << baseVar << endl;
    }
};

class Derivada : public Base {
private:
    int derivadaVar;

public:
    // Constructor de la clase derivada
    Derivada(int baseVal, int derivadaVal) : Base(baseVal), derivadaVar(derivadaVal) {
        cout << "Constructor de la clase Derivada llamado con valor " << derivadaVar << endl;
    }

    void mostrarDerivada() const {
        mostrarBase();
        cout << "Valor de derivadaVar: " << derivadaVar << endl;
    }
};

int main() {
    Derivada obj(10, 20);
    obj.mostrarDerivada();

    return 0;
}
<---Ejemplo de Creación de Objetos de la Clase Derivada Result--->
<---Ejemplo de Invocación de Constructores--->
```cpp
#include <iostream>
using namespace std;

class Base {
public:
    Base() {
        cout << "Constructor de Base" << endl;
    }
};

class Intermedia : public Base {
public:
    Intermedia() {
        cout << "Constructor de Intermedia" << endl;
    }
};

class Derivada : public Intermedia {
public:
    Derivada() {
        cout << "Constructor de Derivada" << endl;
    }
};

int main() {
    Derivada obj;
    return 0;
}
<---Ejemplo de Invocación de Constructores Result--->
<---Ejemplo de Herencia Simple--->
```cpp
#include <iostream>
using namespace std;

class Animal {
public:
    void comer() {
        cout << "El animal está comiendo." << endl;
    }
};

class Perro : public Animal {
public:
    void ladrar() {
        cout << "El perro está ladrando." << endl;
    }
};

int main() {
    Perro miPerro;
    miPerro.comer(); // Método heredado de la clase base
    miPerro.ladrar(); // Método de la clase derivada

    return 0;
}
<---Ejemplo de Herencia Simple Result--->
<---Ejemplo de Herencia Múltiple--->
```cpp
#include <iostream>
using namespace std;

class Animal {
public:
    void comer() {
        cout << "El animal está comiendo." << endl;
    }
};

class Mascota {
public:
    void jugar() {
        cout << "La mascota está jugando." << endl;
    }
};

class Perro : public Animal, public Mascota {
public:
    void ladrar() {
        cout << "El perro está ladrando." << endl;
    }
};

int main() {
    Perro miPerro;
    miPerro.comer(); // Método heredado de Animal
    miPerro.jugar(); // Método heredado de Mascota
    miPerro.ladrar(); // Método de la clase derivada

    return 0;
}
<---Ejemplo de Herencia Múltiple Result--->
<---Ejemplo de Herencia Multinivel--->
```cpp
#include <iostream>
using namespace std;

class Animal {
public:
    void comer() {
        cout << "El animal está comiendo." << endl;
    }
};

class Mamifero : public Animal {
public:
    void amamantar() {
        cout << "El mamífero está amamantando." << endl;
    }
};

class Perro : public Mamifero {
public:
    void ladrar() {
        cout << "El perro está ladrando." << endl;
    }
};

int main() {
    Perro miPerro;
    miPerro.comer(); // Método heredado de Animal
    miPerro.amamantar(); // Método heredado de Mamifero
    miPerro.ladrar(); // Método de la clase derivada

    return 0;
}
<---Ejemplo de Herencia Multinivel Result--->
<---Ejemplo de Herencia Jerárquica--->
```cpp
#include <iostream>
using namespace std;

class Animal {
public:
    void comer() {
        cout << "El animal está comiendo." << endl;
    }
};

class Perro : public Animal {
public:
    void ladrar() {
        cout << "El perro está ladrando." << endl;
    }
};

class Gato : public Animal {
public:
    void maullar() {
        cout << "El gato está maullando." << endl;
    }
};

int main() {
    Perro miPerro;
    miPerro.comer(); // Método heredado de Animal
    miPerro.ladrar(); // Método de la clase derivada

    Gato miGato;
    miGato.comer(); // Método heredado de Animal
    miGato.maullar(); // Método de la clase derivada

    return 0;
}
<---Ejemplo de Herencia Jerárquica Result--->
<---Ejemplo de Herencia Híbrida--->
```cpp
#include <iostream>
using namespace std;

class Animal {
public:
    void comer() {
        cout << "El animal está comiendo." << endl;
    }
};

class Mascota {
public:
    void jugar() {
        cout << "La mascota está jugando." << endl;
    }
};

class Mamifero : public Animal {
public:
    void amamantar() {
        cout << "El mamífero está amamantando." << endl;
    }
};

class Perro : public Mamifero, public Mascota {
public:
    void ladrar() {
        cout << "El perro está ladrando." << endl;
    }
};

int main() {
    Perro miPerro;
    miPerro.comer(); // Método heredado de Animal a través de Mamifero
    miPerro.amamantar(); // Método heredado de Mamifero
    miPerro.jugar(); // Método heredado de Mascota
    miPerro.ladrar(); // Método de la clase derivada

    return 0;
}
<---Ejemplo de Herencia Híbrida Result--->
<---Ejemplo de Herencia Pública--->
```cpp
#include <iostream>
using namespace std;

class Base {
public:
    int publicVar;
protected:
    int protectedVar;
private:
    int privateVar;
};

class Derivada : public Base {
public:
    void mostrar() {
        cout << "Acceso en Derivada:" << endl;
        cout << "publicVar: " << publicVar << endl; // Accesible
        cout << "protectedVar: " << protectedVar << endl; // Accesible
        // cout << "privateVar: " << privateVar << endl; // No accesible
    }
};

int main() {
    Derivada obj;
    obj.publicVar = 10;
    // obj.protectedVar = 20; // No accesible desde fuera de la clase derivada
    obj.mostrar();

    return 0;
}
<---Ejemplo de Herencia Pública Result--->
<---Ejemplo de Herencia Protegida--->
```cpp
#include <iostream>
using namespace std;

class Base {
public:
    int publicVar;
protected:
    int protectedVar;
private:
    int privateVar;
};

class Derivada : protected Base {
public:
    void mostrar() {
        cout << "Acceso en Derivada:" << endl;
        cout << "publicVar: " << publicVar << endl; // Accesible
        cout << "protectedVar: " << protectedVar << endl; // Accesible
        // cout << "privateVar: " << privateVar << endl; // No accesible
    }
};

int main() {
    Derivada obj;
    // obj.publicVar = 10; // No accesible desde fuera de la clase derivada
    // obj.protectedVar = 20; // No accesible desde fuera de la clase derivada
    obj.mostrar();

    return 0;
}
<---Ejemplo de Herencia Protegida Result--->
<---Ejemplo de Herencia Privada--->
```cpp
#include <iostream>
using namespace std;

class Base {
public:
    int publicVar;
protected:
    int protectedVar;
private:
    int privateVar;
};

class Derivada : private Base {
public:
    void mostrar() {
        cout << "Acceso en Derivada:" << endl;
        cout << "publicVar: " << publicVar << endl; // Accesible
        cout << "protectedVar: " << protectedVar << endl; // Accesible
        // cout << "privateVar: " << privateVar << endl; // No accesible
    }
};

int main() {
    Derivada obj;
    // obj.publicVar = 10; // No accesible desde fuera de la clase derivada
    // obj.protectedVar = 20; // No accesible desde fuera de la clase derivada
    obj.mostrar();

    return 0;
}
<---Ejemplo de Herencia Privada Result--->
<---Ejemplo Básico de Sobrecarga de Funciones--->
```cpp
#include <iostream>
using namespace std;

class Base {
public:
    void mostrar() {
        cout << "Mostrar sin parámetros en la clase Base" << endl;
    }

    void mostrar(int x) {
        cout << "Mostrar con un parámetro en la clase Base: " << x << endl;
    }
};

int main() {
    Base b;
    b.mostrar();
    b.mostrar(10);

    return 0;
}
<---Ejemplo Básico de Sobrecarga de Funciones Result--->
<---Ejemplo de Sobrecarga de Funciones en Herencia--->
```cpp
#include <iostream>
using namespace std;

class Base {
public:
    void mostrar() {
        cout << "Mostrar sin parámetros en la clase Base" << endl;
    }

    void mostrar(int x) {
        cout << "Mostrar con un parámetro en la clase Base: " << x << endl;
    }
};

class Derivada : public Base {
public:
    void mostrar(double y) {
        cout << "Mostrar con un parámetro double en la clase Derivada: " << y << endl;
    }
};

int main() {
    Derivada d;
    d.mostrar();       // Llama a Base::mostrar()
    d.mostrar(10);     // Llama a Base::mostrar(int)
    d.mostrar(3.14);   // Llama a Derivada::mostrar(double)

    return 0;
}
<---Ejemplo de Sobrecarga de Funciones en Herencia Result--->
<---Ejemplo de Uso de `using`--->
```cpp
#include <iostream>
using namespace std;

class Base {
public:
    void mostrar() {
        cout << "Mostrar sin parámetros en la clase Base" << endl;
    }

    void mostrar(int x) {
        cout << "Mostrar con un parámetro en la clase Base: " << x << endl;
    }
};

class Derivada : public Base {
public:
    using Base::mostrar; // Hacer visibles las funciones sobrecargadas de la clase base

    void mostrar(double y) {
        cout << "Mostrar con un parámetro double en la clase Derivada: " << y << endl;
    }
};

int main() {
    Derivada d;
    d.mostrar();       // Llama a Base::mostrar()
    d.mostrar(10);     // Llama a Base::mostrar(int)
    d.mostrar(3.14);   // Llama a Derivada::mostrar(double)

    return 0;
}
<---Ejemplo de Uso de `using` Result--->
<---Ejemplo de Sobrecarga de Operadores en Herencia--->
```cpp
#include <iostream>
using namespace std;

class Base {
public:
    virtual void mostrar() const {
        cout << "Mostrar en la clase Base" << endl;
    }

    virtual void operador() const {
        cout << "Operador en la clase Base" << endl;
    }
};

class Derivada : public Base {
public:
    void mostrar() const override {
        cout << "Mostrar en la clase Derivada" << endl;
    }

    void operador() const override {
        cout << "Operador en la clase Derivada" << endl;
    }
};

int main() {
    Base* ptrBase = new Derivada();
    ptrBase->mostrar();    // Llama a Derivada::mostrar()
    ptrBase->operador();   // Llama a Derivada::operador()

    delete ptrBase;
    return 0;
}
<---Ejemplo de Sobrecarga de Operadores en Herencia Result--->
<---Sintaxis Básica--->
```cpp
class Base {
public:
    virtual void funcion() {
        // Implementación de la clase base
    }
};

class Derivada : public Base {
public:
    void funcion() override {
        // Implementación de la clase derivada
    }
};
```cpp
#include <iostream>
using namespace std;

class Animal {
public:
    virtual void hacerSonido() const {
        cout << "El animal hace un sonido" << endl;
    }
};

class Perro : public Animal {
public:
    void hacerSonido() const override {
        cout << "El perro ladra" << endl;
    }
};

class Gato : public Animal {
public:
    void hacerSonido() const override {
        cout << "El gato maúlla" << endl;
    }
};

void hacerSonidoAnimal(const Animal& animal) {
    animal.hacerSonido();
}

int main() {
    Animal a;
    Perro p;
    Gato g;

    hacerSonidoAnimal(a); // Llama a Animal::hacerSonido()
    hacerSonidoAnimal(p); // Llama a Perro::hacerSonido()
    hacerSonidoAnimal(g); // Llama a Gato::hacerSonido()

    return 0;
}
<---Sintaxis Básica Result--->
<---Ejemplo de Polimorfismo--->
```cpp
#include <iostream>
#include <vector>
using namespace std;

class Animal {
public:
    virtual void hacerSonido() const {
        cout << "El animal hace un sonido" << endl;
    }
};

class Perro : public Animal {
public:
    void hacerSonido() const override {
        cout << "El perro ladra" << endl;
    }
};

class Gato : public Animal {
public:
    void hacerSonido() const override {
        cout << "El gato maúlla" << endl;
    }
};

int main() {
    vector<Animal*> animales;
    animales.push_back(new Animal());
    animales.push_back(new Perro());
    animales.push_back(new Gato());

    for (const auto& animal : animales) {
        animal->hacerSonido(); // Llama a la versión apropiada de hacerSonido()
    }

    // Liberar memoria
    for (const auto& animal : animales) {
        delete animal;
    }

    return 0;
}
<---Ejemplo de Polimorfismo Result--->
<---Ejemplo de `final`--->
```cpp
#include <iostream>
using namespace std;

class Base {
public:
    virtual void mostrar() const final {
        cout << "Mostrar en la clase Base" << endl;
    }
};

class Derivada : public Base {
public:
    // void mostrar() const override { // Error: no se puede anular una función final
    //     cout << "Mostrar en la clase Derivada" << endl;
    // }
};

int main() {
    Derivada d;
    d.mostrar(); // Llama a Base::mostrar()

    return 0;
}
<---Ejemplo de `final` Result--->
<---Ejemplo de Sobrecarga y Anulación--->
```cpp
#include <iostream>
using namespace std;

class Base {
public:
    virtual void funcion(int x) {
        cout << "Base::funcion(int): " << x << endl;
    }

    void funcion(double y) {
        cout << "Base::funcion(double): " << y << endl;
    }
};

class Derivada : public Base {
public:
    void funcion(int x) override {
        cout << "Derivada::funcion(int): " << x << endl;
    }

    // Sobrecarga, no anulación
    void funcion(string s) {
        cout << "Derivada::funcion(string): " << s << endl;
    }
};

int main() {
    Derivada d;
    d.funcion(10);        // Llama a Derivada::funcion(int)
    d.funcion(3.14);      // Llama a Base::funcion(double)
    d.funcion("Hola");    // Llama a Derivada::funcion(string)

    return 0;
}
<---Ejemplo de Sobrecarga y Anulación Result--->
<---Ejemplo de Funciones Virtuales Puras--->
```cpp
#include <iostream>
using namespace std;

class Animal {
public:
    virtual void hacerSonido() const = 0; // Función virtual pura
};

class Perro : public Animal {
public:
    void hacerSonido() const override {
        cout << "El perro ladra" << endl;
    }
};

class Gato : public Animal {
public:
    void hacerSonido() const override {
        cout << "El gato maúlla" << endl;
    }
};

void hacerSonidoAnimal(const Animal& animal) {
    animal.hacerSonido();
}

int main() {
    // Animal a; // Error: no se puede instanciar una clase abstracta
    Perro p;
    Gato g;

    hacerSonidoAnimal(p); // Llama a Perro::hacerSonido()
    hacerSonidoAnimal(g); // Llama a Gato::hacerSonido()

    return 0;
}
<---Ejemplo de Funciones Virtuales Puras Result--->
<---Ejemplo de Virtualidad y Constructores--->
```cpp
#include <iostream>
using namespace std;

class Base {
public:
    Base() {
        imprimir();
    }

    virtual void imprimir() const {
        cout << "Base::imprimir()" << endl;
    }
};

class Derivada : public Base {
public:
    Derivada() {
        imprimir();
    }

    void imprimir() const override {
        cout << "Derivada::imprimir()" << endl;
    }
};

int main() {
    Derivada d;
    return 0;
}
<---Ejemplo de Virtualidad y Constructores Result--->
<---Ejemplo de Invocación de Destructores--->
```cpp
#include <iostream>
using namespace std;

class Base {
public:
    Base() {
        cout << "Constructor de Base" << endl;
    }
    ~Base() {
        cout << "Destructor de Base" << endl;
    }
};

class Intermedia : public Base {
public:
    Intermedia() {
        cout << "Constructor de Intermedia" << endl;
    }
    ~Intermedia() {
        cout << "Destructor de Intermedia" << endl;
    }
};

class Derivada : public Intermedia {
public:
    Derivada() {
        cout << "Constructor de Derivada" << endl;
    }
    ~Derivada() {
        cout << "Destructor de Derivada" << endl;
    }
};

int main() {
    Derivada obj;
    return 0;
}
<---Ejemplo de Invocación de Destructores Result--->
<---Ejemplo de Destructor Virtual--->
```cpp
#include <iostream>
using namespace std;

class Base {
public:
    Base() {
        cout << "Constructor de Base" << endl;
    }
    virtual ~Base() {
        cout << "Destructor de Base" << endl;
    }
};

class Derivada : public Base {
public:
    Derivada() {
        cout << "Constructor de Derivada" << endl;
    }
    ~Derivada() {
        cout << "Destructor de Derivada" << endl;
    }
};

int main() {
    Base* obj = new Derivada();
    delete obj;
    return 0;
}
<---Ejemplo de Destructor Virtual Result--->
<---Ejemplo de Lista de Inicialización del Constructor--->
```cpp
#include <iostream>
using namespace std;

class Base {
private:
    int valorBase;
public:
    Base(int v) : valorBase(v) {
        cout << "Constructor de Base con valor " << valorBase << endl;
    }
};

class Derivada : public Base {
private:
    int valorDerivada;
public:
    Derivada(int vb, int vd) : Base(vb), valorDerivada(vd) {
        cout << "Constructor de Derivada con valor " << valorDerivada << endl;
    }
};

int main() {
    Derivada obj(10, 20);
    return 0;
}
<---Ejemplo de Lista de Inicialización del Constructor Result--->
<---Ejemplo Sin Destructor Virtual--->
```cpp
#include <iostream>
using namespace std;

class Base {
public:
    Base() {
        cout << "Constructor de Base" << endl;
    }
    ~Base() {
        cout << "Destructor de Base" << endl;
    }
};

class Derivada : public Base {
public:
    Derivada() {
        cout << "Constructor de Derivada" << endl;
    }
    ~Derivada() {
        cout << "Destructor de Derivada" << endl;
    }
};

int main() {
    Base* obj = new Derivada();
    delete obj; // Solo llama a ~Base(), no a ~Derivada()
    return 0;
}
```cpp
#include <iostream>
using namespace std;

class Base {
public:
    Base() {
        cout << "Constructor de Base" << endl;
    }
    virtual ~Base() {
        cout << "Destructor de Base" << endl;
    }
};

class Derivada : public Base {
public:
    Derivada() {
        cout << "Constructor de Derivada" << endl;
    }
    ~Derivada() {
        cout << "Destructor de Derivada" << endl;
    }
};

int main() {
    Base* obj = new Derivada();
    delete obj; // Llama a ~Derivada() y luego a ~Base()
    return 0;
}
```cpp
#include <iostream>
using namespace std;

class Animal {
public:
    virtual void hacerSonido() const = 0; // Función virtual pura
    virtual ~Animal() {
        cout << "Destructor de Animal" << endl;
    }
};

class Perro : public Animal {
public:
    void hacerSonido() const override {
        cout << "El perro ladra" << endl;
    }
    ~Perro() {
        cout << "Destructor de Perro" << endl;
    }
};

class Gato : public Animal {
public:
    void hacerSonido() const override {
        cout << "El gato maúlla" << endl;
    }
    ~Gato() {
        cout << "Destructor de Gato" << endl;
    }
};

int main() {
    Animal* p = new Perro();
    Animal* g = new Gato();
    delete p; // Llama a ~Perro() y luego a ~Animal()
    delete g; // Llama a ~Gato() y luego a ~Animal()
    return 0;
}
<---Ejemplo Sin Destructor Virtual Result--->
<---Tipos de Polimorfismo en C++--->
<---Tipos de Polimorfismo en C++ Result--->
<---Ejemplo de Polimorfismo de Inclusión--->
```cpp
#include <iostream>
using namespace std;

class Animal {
public:
    virtual void hacerSonido() const {
        cout << "El animal hace un sonido" << endl;
    }
};

class Perro : public Animal {
public:
    void hacerSonido() const override {
        cout << "El perro ladra" << endl;
    }
};

class Gato : public Animal {
public:
    void hacerSonido() const override {
        cout << "El gato maúlla" << endl;
    }
};

void hacerSonidoAnimal(const Animal& animal) {
    animal.hacerSonido();
}

int main() {
    Animal a;
    Perro p;
    Gato g;

    hacerSonidoAnimal(a); // Llama a Animal::hacerSonido()
    hacerSonidoAnimal(p); // Llama a Perro::hacerSonido()
    hacerSonidoAnimal(g); // Llama a Gato::hacerSonido()

    return 0;
}
<---Ejemplo de Polimorfismo de Inclusión Result--->
<---Ejemplo de Clase Abstracta--->
```cpp
#include <iostream>
using namespace std;

class Animal {
public:
    virtual void hacerSonido() const = 0; // Función virtual pura
};

class Perro : public Animal {
public:
    void hacerSonido() const override {
        cout << "El perro ladra" << endl;
    }
};

class Gato : public Animal {
public:
    void hacerSonido() const override {
        cout << "El gato maúlla" << endl;
    }
};

void hacerSonidoAnimal(const Animal& animal) {
    animal.hacerSonido();
}

int main() {
    // Animal a; // Error: no se puede instanciar una clase abstracta
    Perro p;
    Gato g;

    hacerSonidoAnimal(p); // Llama a Perro::hacerSonido()
    hacerSonidoAnimal(g); // Llama a Gato::hacerSonido()

    return 0;
}
<---Ejemplo de Clase Abstracta Result--->
<---Ejemplo con Colección Polimórfica--->
```cpp
#include <iostream>
#include <vector>
using namespace std;

class Animal {
public:
    virtual void hacerSonido() const = 0; // Función virtual pura
    virtual ~Animal() {}
};

class Perro : public Animal {
public:
    void hacerSonido() const override {
        cout << "El perro ladra" << endl;
    }
};

class Gato : public Animal {
public:
    void hacerSonido() const override {
        cout << "El gato maúlla" << endl;
    }
};

int main() {
    vector<Animal*> animales;
    animales.push_back(new Perro());
    animales.push_back(new Gato());

    for (const auto& animal : animales) {
        animal->hacerSonido(); // Llama a la implementación apropiada
    }

    // Liberar memoria
    for (const auto& animal : animales) {
        delete animal;
    }

    return 0;
}
<---Ejemplo con Colección Polimórfica Result--->
<---Sobrecarga de Funciones--->
```cpp
#include <iostream>
using namespace std;

class Sobrecarga {
public:
    void imprimir(int i) {
        cout << "Entero: " << i << endl;
    }

    void imprimir(double d) {
        cout << "Doble: " << d << endl;
    }

    void imprimir(const string& s) {
        cout << "Cadena: " << s << endl;
    }
};

int main() {
    Sobrecarga obj;
    obj.imprimir(10);
    obj.imprimir(3.14);
    obj.imprimir("Hola");
    return 0;
}
<---Sobrecarga de Funciones Result--->
<---Plantillas (Templates)--->
```cpp
#include <iostream>
using namespace std;

template <typename T>
void imprimir(T valor) {
    cout << "Valor: " << valor << endl;
}

int main() {
    imprimir(10);
    imprimir(3.14);
    imprimir("Hola");
    return 0;
}
<---Plantillas (Templates) Result--->
<---Ejemplo de Polimorfismo Dinámico--->
```cpp
#include <iostream>
using namespace std;

class Animal {
public:
    virtual void hacerSonido() const {
        cout << "El animal hace un sonido" << endl;
    }
    virtual ~Animal() {}
};

class Perro : public Animal {
public:
    void hacerSonido() const override {
        cout << "El perro ladra" << endl;
    }
};

class Gato : public Animal {
public:
    void hacerSonido() const override {
        cout << "El gato maúlla" << endl;
    }
};

void hacerSonidoAnimal(const Animal& animal) {
    animal.hacerSonido();
}

int main() {
    Animal* a = new Animal();
    Animal* p = new Perro();
    Animal* g = new Gato();

    hacerSonidoAnimal(*a); // Llama a Animal::hacerSonido()
    hacerSonidoAnimal(*p); // Llama a Perro::hacerSonido()
    hacerSonidoAnimal(*g); // Llama a Gato::hacerSonido()

    delete a;
    delete p;
    delete g;
    return 0;
}
<---Ejemplo de Polimorfismo Dinámico Result--->
