<---EXPLANATION--->
### Algoritmos de la Biblioteca Estándar: `std::max` y `std::min`

Las funciones `std::max` y `std::min` son parte de la biblioteca estándar de C++ y se utilizan para encontrar el mayor y el menor de dos valores, respectivamente. También existen versiones de estas funciones que operan sobre rangos de elementos. Estas funciones son parte del encabezado `<algorithm>`.

#### Sintaxis de `std::max` y `std::min`

##### `std::max`

```cpp
#include <algorithm>

template <class T>
const T& max(const T& a, const T& b);

template <class T, class Compare>
const T& max(const T& a, const T& b, Compare comp);

template <class ForwardIt>
ForwardIt max_element(ForwardIt first, ForwardIt last);

template <class ForwardIt, class Compare>
ForwardIt max_element(ForwardIt first, ForwardIt last, Compare comp);
```

##### `std::min`

```cpp
#include <algorithm>

template <class T>
const T& min(const T& a, const T& b);

template <class T, class Compare>
const T& min(const T& a, const T& b, Compare comp);

template <class ForwardIt>
ForwardIt min_element(ForwardIt first, ForwardIt last);

template <class ForwardIt, class Compare>
ForwardIt min_element(ForwardIt first, ForwardIt last, Compare comp);
```

#### Descripción

- **`std::max` y `std::min`:** Devuelven el mayor y el menor de dos valores, respectivamente. Se puede proporcionar una función de comparación personalizada.
- **`std::max_element` y `std::min_element`:** Encuentran el mayor y el menor elemento en un rango de elementos, respectivamente. Se puede proporcionar una función de comparación personalizada.

#### Ejemplo de Uso de `std::max` y `std::min`

##### Ejemplo Básico con Dos Valores

```cpp
#include <iostream>
#include <algorithm>

int main() {
    int a = 10, b = 20;

    // Encontrar el valor máximo
    int maxVal = std::max(a, b);
    std::cout << "El mayor de " << a << " y " << b << " es " << maxVal << std::endl;

    // Encontrar el valor mínimo
    int minVal = std::min(a, b);
    std::cout << "El menor de " << a << " y " << b << " es " << minVal << std::endl;

    return 0;
}
```

En este ejemplo:
- `std::max(a, b)` devuelve el mayor de `a` y `b`.
- `std::min(a, b)` devuelve el menor de `a` y `b`.

##### Ejemplo con Comparación Personalizada

```cpp
#include <iostream>
#include <algorithm>
#include <string>

int main() {
    std::string s1 = "apple", s2 = "orange";

    // Comparar las cadenas por longitud
    auto maxLen = std::max(s1, s2, [](const std::string& lhs, const std::string& rhs) {
        return lhs.size() < rhs.size();
    });

    std::cout << "La cadena con mayor longitud es: " << maxLen << std::endl;

    return 0;
}
```

En este ejemplo:
- Se usa una lambda para comparar las cadenas por su longitud.

#### Uso de `std::max_element` y `std::min_element`

##### Ejemplo Básico con un Rango de Elementos

```cpp
#include <iostream>
#include <vector>
#include <algorithm>

int main() {
    std::vector<int> vec = {1, 2, 3, 4, 5};

    // Encontrar el elemento máximo
    auto maxIt = std::max_element(vec.begin(), vec.end());
    std::cout << "El elemento máximo es: " << *maxIt << std::endl;

    // Encontrar el elemento mínimo
    auto minIt = std::min_element(vec.begin(), vec.end());
    std::cout << "El elemento mínimo es: " << *minIt << std::endl;

    return 0;
}
```

En este ejemplo:
- `std::max_element(vec.begin(), vec.end())` devuelve un iterador al elemento máximo en el vector.
- `std::min_element(vec.begin(), vec.end())` devuelve un iterador al elemento mínimo en el vector.

##### Ejemplo con Comparación Personalizada

```cpp
#include <iostream>
#include <vector>
#include <algorithm>

struct Punto {
    int x, y;
};

bool compararPorDistancia(const Punto& p1, const Punto& p2) {
    return (p1.x * p1.x + p1.y * p1.y) < (p2.x * p2.x + p2.y * p2.y);
}

int main() {
    std::vector<Punto> puntos = {{1, 2}, {3, 4}, {0, 5}, {-1, -1}};

    // Encontrar el punto más lejano del origen
    auto maxIt = std::max_element(puntos.begin(), puntos.end(), compararPorDistancia);
    std::cout << "El punto más lejano es: (" << maxIt->x << ", " << maxIt->y << ")" << std::endl;

    // Encontrar el punto más cercano al origen
    auto minIt = std::min_element(puntos.begin(), puntos.end(), compararPorDistancia);
    std::cout << "El punto más cercano es: (" << minIt->x << ", " << minIt->y << ")" << std::endl;

    return 0;
}
```

En este ejemplo:
- `compararPorDistancia` es una función que compara dos puntos por su distancia al origen.
- `std::max_element` y `std::min_element` usan esta función para encontrar el punto más lejano y el más cercano, respectivamente.

### Consideraciones

- **Rendimiento:** `std::max` y `std::min` operan en tiempo constante, mientras que `std::max_element` y `std::min_element` tienen un rendimiento lineal respecto al número de elementos en el rango.
- **Flexibilidad:** Se pueden usar con cualquier tipo de datos que soporte las operaciones de comparación necesarias.

### Conclusión

`std::max` y `std::min` son funciones útiles de la biblioteca estándar de C++ para encontrar el mayor y el menor de dos valores, respectivamente. `std::max_element` y `std::min_element` extienden esta funcionalidad para operar sobre rangos de elementos. La capacidad de proporcionar funciones de comparación personalizadas hace que estos algoritmos sean extremadamente flexibles y poderosos, permitiendo su uso en una amplia variedad de escenarios de programación.
<---FILES--->
`std::max`
`std::max` Result
`std::min`
`std::min` Result
Ejemplo Básico con Dos Valores
Ejemplo Básico con Dos Valores Result
Ejemplo con Comparación Personalizada
Ejemplo con Comparación Personalizada Result
Ejemplo Básico con un Rango de Elementos
Ejemplo Básico con un Rango de Elementos Result
<---`std::max`--->
```cpp
#include <algorithm>

template <class T>
const T& max(const T& a, const T& b);

template <class T, class Compare>
const T& max(const T& a, const T& b, Compare comp);

template <class ForwardIt>
ForwardIt max_element(ForwardIt first, ForwardIt last);

template <class ForwardIt, class Compare>
ForwardIt max_element(ForwardIt first, ForwardIt last, Compare comp);
<---`std::max` Result--->
<---`std::min`--->
```cpp
#include <algorithm>

template <class T>
const T& min(const T& a, const T& b);

template <class T, class Compare>
const T& min(const T& a, const T& b, Compare comp);

template <class ForwardIt>
ForwardIt min_element(ForwardIt first, ForwardIt last);

template <class ForwardIt, class Compare>
ForwardIt min_element(ForwardIt first, ForwardIt last, Compare comp);
<---`std::min` Result--->
<---Ejemplo Básico con Dos Valores--->
```cpp
#include <iostream>
#include <algorithm>

int main() {
    int a = 10, b = 20;

    // Encontrar el valor máximo
    int maxVal = std::max(a, b);
    std::cout << "El mayor de " << a << " y " << b << " es " << maxVal << std::endl;

    // Encontrar el valor mínimo
    int minVal = std::min(a, b);
    std::cout << "El menor de " << a << " y " << b << " es " << minVal << std::endl;

    return 0;
}
<---Ejemplo Básico con Dos Valores Result--->
<---Ejemplo con Comparación Personalizada--->
```cpp
#include <iostream>
#include <vector>
#include <algorithm>

struct Punto {
    int x, y;
};

bool compararPorDistancia(const Punto& p1, const Punto& p2) {
    return (p1.x * p1.x + p1.y * p1.y) < (p2.x * p2.x + p2.y * p2.y);
}

int main() {
    std::vector<Punto> puntos = {{1, 2}, {3, 4}, {0, 5}, {-1, -1}};

    // Encontrar el punto más lejano del origen
    auto maxIt = std::max_element(puntos.begin(), puntos.end(), compararPorDistancia);
    std::cout << "El punto más lejano es: (" << maxIt->x << ", " << maxIt->y << ")" << std::endl;

    // Encontrar el punto más cercano al origen
    auto minIt = std::min_element(puntos.begin(), puntos.end(), compararPorDistancia);
    std::cout << "El punto más cercano es: (" << minIt->x << ", " << minIt->y << ")" << std::endl;

    return 0;
}
<---Ejemplo con Comparación Personalizada Result--->
<---Ejemplo Básico con un Rango de Elementos--->
```cpp
#include <iostream>
#include <vector>
#include <algorithm>

int main() {
    std::vector<int> vec = {1, 2, 3, 4, 5};

    // Encontrar el elemento máximo
    auto maxIt = std::max_element(vec.begin(), vec.end());
    std::cout << "El elemento máximo es: " << *maxIt << std::endl;

    // Encontrar el elemento mínimo
    auto minIt = std::min_element(vec.begin(), vec.end());
    std::cout << "El elemento mínimo es: " << *minIt << std::endl;

    return 0;
}
<---Ejemplo Básico con un Rango de Elementos Result--->
