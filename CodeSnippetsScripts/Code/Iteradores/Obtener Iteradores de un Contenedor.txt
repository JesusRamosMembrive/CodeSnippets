<---EXPLANATION--->
### Iteradores en C++

Los iteradores son una abstracción fundamental en C++ que permiten recorrer y manipular elementos en contenedores (como arrays, vectores, listas, etc.). Funcionan de manera similar a los punteros y proporcionan una interfaz unificada para acceder a los elementos de los contenedores de la biblioteca estándar de C++.

#### Introducción a los Iteradores

Un iterador es un objeto que apunta a un elemento dentro de un contenedor y permite recorrer los elementos del contenedor de una manera secuencial. Los iteradores se utilizan de manera extensiva en los algoritmos de la biblioteca estándar de C++ (STL).

##### Tipos de Iteradores

1. **Input Iterators:** Permiten leer elementos de una secuencia.
2. **Output Iterators:** Permiten escribir elementos en una secuencia.
3. **Forward Iterators:** Permiten avanzar en la secuencia y leer o escribir elementos.
4. **Bidirectional Iterators:** Permiten avanzar y retroceder en la secuencia.
5. **Random Access Iterators:** Permiten acceso aleatorio a cualquier elemento en la secuencia.

##### Ejemplo Básico

```cpp
#include <iostream>
#include <vector>

int main() {
    std::vector<int> vec = {1, 2, 3, 4, 5};

    // Iterador que apunta al primer elemento del vector
    std::vector<int>::iterator it = vec.begin();

    // Recorrer el vector usando el iterador
    while (it != vec.end()) {
        std::cout << *it << " ";
        ++it;  // Avanzar al siguiente elemento
    }
    std::cout << std::endl;

    return 0;
}
```

En este ejemplo:
- `std::vector<int>::iterator` es el tipo de iterador para `std::vector<int>`.
- `vec.begin()` devuelve un iterador al primer elemento del vector.
- `vec.end()` devuelve un iterador al elemento después del último elemento del vector.
- `*it` desreferencia el iterador para acceder al valor del elemento.

#### Beneficios de Usar Iteradores

1. **Abstracción:** Proporcionan una interfaz unificada para acceder y manipular elementos en diferentes tipos de contenedores sin necesidad de conocer la implementación interna del contenedor.
2. **Flexibilidad:** Permiten recorrer contenedores de manera eficiente, utilizando el mismo código para diferentes tipos de contenedores.
3. **Compatibilidad con Algoritmos STL:** Los iteradores se integran perfectamente con los algoritmos de la STL, como `std::sort`, `std::find`, `std::for_each`, etc.
4. **Encapsulamiento:** Ocultan los detalles de la estructura del contenedor, proporcionando una forma segura y conveniente de acceder a sus elementos.

#### Ejemplo con Algoritmos de la STL

```cpp
#include <iostream>
#include <vector>
#include <algorithm>

int main() {
    std::vector<int> vec = {5, 2, 8, 1, 3};

    // Ordenar el vector usando std::sort
    std::sort(vec.begin(), vec.end());

    // Encontrar un elemento usando std::find
    auto it = std::find(vec.begin(), vec.end(), 8);

    if (it != vec.end()) {
        std::cout << "Elemento encontrado: " << *it << std::endl;
    } else {
        std::cout << "Elemento no encontrado" << std::endl;
    }

    return 0;
}
```

En este ejemplo:
- `std::sort` ordena el vector usando iteradores.
- `std::find` busca un elemento en el vector y devuelve un iterador al elemento si se encuentra, o `vec.end()` si no se encuentra.

#### Iteradores Constantes

Los iteradores constantes (`const_iterator`) se utilizan para recorrer contenedores sin modificar los elementos.

##### Ejemplo de Iteradores Constantes

```cpp
#include <iostream>
#include <vector>

int main() {
    std::vector<int> vec = {1, 2, 3, 4, 5};

    // Iterador constante
    std::vector<int>::const_iterator it = vec.cbegin();

    // Recorrer el vector usando el iterador constante
    while (it != vec.cend()) {
        std::cout << *it << " ";
        ++it;
    }
    std::cout << std::endl;

    return 0;
}
```

En este ejemplo:
- `std::vector<int>::const_iterator` es el tipo de iterador constante para `std::vector<int>`.
- `vec.cbegin()` devuelve un iterador constante al primer elemento del vector.
- `vec.cend()` devuelve un iterador constante al elemento después del último elemento del vector.

### Conclusión

Los iteradores son una herramienta poderosa y flexible en C++ que permiten recorrer y manipular elementos en contenedores de manera eficiente y abstracta. Proporcionan una interfaz unificada que facilita la compatibilidad con los algoritmos de la STL y permite escribir código genérico que funciona con diferentes tipos de contenedores. Entender y utilizar iteradores correctamente es esencial para aprovechar al máximo las capacidades de la biblioteca estándar de C++ y escribir código limpio y eficiente.
### Iteradores de Entrada en C++

Los **iteradores de entrada** (input iterators) son uno de los tipos de iteradores en C++ que se utilizan para leer datos secuencialmente de una secuencia. Estos iteradores permiten recorrer una secuencia de datos y leer cada elemento una vez, y son especialmente útiles cuando se trabaja con flujos de entrada como archivos o entradas estándar.

#### Características de los Iteradores de Entrada

1. **Lectura Secuencial:** Permiten leer los elementos de una secuencia en orden.
2. **No Modificables:** No se pueden usar para modificar los elementos de la secuencia.
3. **Un Solo Paso:** Cada elemento puede ser leído una vez; no se garantiza que puedan retroceder.
4. **Igualdad y Desigualdad:** Pueden compararse con otros iteradores de entrada usando `==` y `!=`.

#### Ejemplo con Flujos de Entrada

Los iteradores de entrada son comúnmente utilizados con flujos de entrada como `std::istream`.

##### Ejemplo Básico con `std::istream_iterator`

```cpp
#include <iostream>
#include <iterator>
#include <vector>
#include <algorithm>

int main() {
    std::cout << "Ingrese números separados por espacios (Ctrl+D para terminar): ";

    // Crear un istream_iterator para leer desde std::cin
    std::istream_iterator<int> inicio(std::cin);
    std::istream_iterator<int> fin;  // Iterador de fin predeterminado

    // Leer todos los números ingresados en un vector
    std::vector<int> numeros(inicio, fin);

    // Mostrar los números leídos
    std::cout << "Números ingresados: ";
    for (int numero : numeros) {
        std::cout << numero << " ";
    }
    std::cout << std::endl;

    return 0;
}
```

En este ejemplo:
- `std::istream_iterator<int>` se utiliza para crear un iterador de entrada que lee `int` desde `std::cin`.
- Los números ingresados se almacenan en un `std::vector<int>` utilizando el rango `[inicio, fin]`.

#### Uso en Algoritmos de la STL

Los iteradores de entrada pueden ser utilizados en algoritmos de la STL que requieren la lectura de datos de una secuencia.

##### Ejemplo con `std::copy`

```cpp
#include <iostream>
#include <iterator>
#include <vector>
#include <algorithm>

int main() {
    std::cout << "Ingrese números separados por espacios (Ctrl+D para terminar): ";

    // Crear un istream_iterator para leer desde std::cin
    std::istream_iterator<int> inicio(std::cin);
    std::istream_iterator<int> fin;  // Iterador de fin predeterminado

    // Crear un vector para almacenar los números leídos
    std::vector<int> numeros;

    // Usar std::copy para leer los números en el vector
    std::copy(inicio, fin, std::back_inserter(numeros));

    // Mostrar los números leídos
    std::cout << "Números ingresados: ";
    for (int numero : numeros) {
        std::cout << numero << " ";
    }
    std::cout << std::endl;

    return 0;
}
```

En este ejemplo:
- `std::copy` se utiliza para copiar los números leídos desde el flujo de entrada a un vector utilizando un iterador de entrada.

#### Implementación Personalizada de un Iterador de Entrada

Aunque `std::istream_iterator` es una implementación estándar, es posible definir iteradores de entrada personalizados.

##### Ejemplo de Implementación Personalizada

```cpp
#include <iostream>
#include <iterator>

class InputIterator : public std::iterator<std::input_iterator_tag, int> {
    std::istream* in;
    int value;

public:
    InputIterator(std::istream& s) : in(&s) {
        ++(*this);  // Leer el primer valor
    }

    InputIterator() : in(nullptr) {}

    bool operator==(const InputIterator& other) const {
        return in == other.in;
    }

    bool operator!=(const InputIterator& other) const {
        return !(*this == other);
    }

    int operator*() const {
        return value;
    }

    InputIterator& operator++() {
        if (in && !(*in >> value)) {
            in = nullptr;  // Alcanzó el final de la secuencia
        }
        return *this;
    }
};

int main() {
    std::cout << "Ingrese números separados por espacios (Ctrl+D para terminar): ";

    // Usar el iterador de entrada personalizado para leer desde std::cin
    InputIterator inicio(std::cin);
    InputIterator fin;

    // Leer todos los números ingresados en un vector
    std::vector<int> numeros(inicio, fin);

    // Mostrar los números leídos
    std::cout << "Números ingresados: ";
    for (int numero : numeros) {
        std::cout << numero << " ";
    }
    std::cout << std::endl;

    return 0;
}
```

En este ejemplo:
- `InputIterator` es un iterador de entrada personalizado que lee `int` desde un flujo de entrada.
- Se define sobrecargando los operadores necesarios para cumplir con los requisitos de un iterador de entrada.

### Conclusión

Los iteradores de entrada son una herramienta poderosa en C++ para leer datos secuencialmente de una fuente de entrada. Permiten una lectura eficiente y son esenciales para trabajar con flujos de entrada en algoritmos de la STL. Entender cómo utilizar y, si es necesario, implementar iteradores de entrada personalizados, es fundamental para escribir código C++ robusto y eficiente.
### Iteradores de Salida en C++

Los **iteradores de salida** (output iterators) son una categoría de iteradores en C++ que permiten escribir datos secuencialmente en una secuencia. Son esencialmente la contraparte de los iteradores de entrada y se utilizan cuando se necesita producir o generar datos, escribiéndolos en contenedores o flujos de salida.

#### Características de los Iteradores de Salida

1. **Escritura Secuencial:** Permiten escribir elementos en una secuencia en orden.
2. **No Lectura:** No se pueden usar para leer los elementos de la secuencia.
3. **Un Solo Paso:** Cada posición puede ser escrita una vez; no se garantiza que puedan retroceder.
4. **Igualdad y Desigualdad:** Pueden compararse con otros iteradores de salida usando `==` y `!=`.

#### Ejemplo con Flujos de Salida

Los iteradores de salida son comúnmente utilizados con flujos de salida como `std::ostream`.

##### Ejemplo Básico con `std::ostream_iterator`

```cpp
#include <iostream>
#include <iterator>
#include <vector>

int main() {
    std::vector<int> numeros = {1, 2, 3, 4, 5};

    // Crear un ostream_iterator para escribir en std::cout
    std::ostream_iterator<int> salida(std::cout, " ");

    // Usar el iterador de salida para escribir los números
    for (int numero : numeros) {
        *salida = numero;
        ++salida;
    }
    std::cout << std::endl;

    return 0;
}
```

En este ejemplo:
- `std::ostream_iterator<int>` se utiliza para crear un iterador de salida que escribe `int` en `std::cout`.
- Los números en el vector `numeros` se escriben en la salida estándar utilizando el iterador de salida.

#### Uso en Algoritmos de la STL

Los iteradores de salida pueden ser utilizados en algoritmos de la STL que producen datos.

##### Ejemplo con `std::copy`

```cpp
#include <iostream>
#include <iterator>
#include <vector>
#include <algorithm>

int main() {
    std::vector<int> numeros = {5, 2, 8, 1, 3};

    // Crear un ostream_iterator para escribir en std::cout
    std::ostream_iterator<int> salida(std::cout, " ");

    // Usar std::copy para escribir los números en std::cout
    std::copy(numeros.begin(), numeros.end(), salida);
    std::cout << std::endl;

    return 0;
}
```

En este ejemplo:
- `std::copy` se utiliza para copiar los números del vector `numeros` a la salida estándar utilizando un iterador de salida.

#### Implementación Personalizada de un Iterador de Salida

Aunque `std::ostream_iterator` es una implementación estándar, es posible definir iteradores de salida personalizados.

##### Ejemplo de Implementación Personalizada

```cpp
#include <iostream>
#include <iterator>
#include <vector>

class OutputIterator : public std::iterator<std::output_iterator_tag, void, void, void, void> {
    std::ostream* out;
    std::string delimiter;

public:
    OutputIterator(std::ostream& s, const std::string& delim = " ") : out(&s), delimiter(delim) {}

    OutputIterator& operator=(int value) {
        *out << value << delimiter;
        return *this;
    }

    OutputIterator& operator*() {
        return *this;
    }

    OutputIterator& operator++() {
        return *this;
    }

    OutputIterator& operator++(int) {
        return *this;
    }
};

int main() {
    std::vector<int> numeros = {1, 2, 3, 4, 5};

    // Usar el iterador de salida personalizado para escribir en std::cout
    OutputIterator salida(std::cout, " - ");

    for (int numero : numeros) {
        *salida = numero;
        ++salida;
    }
    std::cout << std::endl;

    return 0;
}
```

En este ejemplo:
- `OutputIterator` es un iterador de salida personalizado que escribe `int` en un flujo de salida con un delimitador específico.
- Se define sobrecargando los operadores necesarios para cumplir con los requisitos de un iterador de salida.

### Conclusión

Los iteradores de salida son una herramienta esencial en C++ para generar y escribir datos secuencialmente en contenedores o flujos de salida. Proporcionan una interfaz unificada para producir datos, lo que facilita su uso en combinación con los algoritmos de la STL. Entender cómo utilizar y, si es necesario, implementar iteradores de salida personalizados es crucial para escribir código C++ robusto y eficiente, especialmente cuando se trabaja con generación y producción de datos.
### Iteradores de Avance en C++

Los **iteradores de avance** (forward iterators) son una categoría de iteradores en C++ que permiten avanzar en una secuencia y leer o escribir elementos en esa secuencia. A diferencia de los iteradores de entrada y salida, los iteradores de avance soportan tanto la lectura como la escritura y permiten recorrer una secuencia en una única dirección.

#### Características de los Iteradores de Avance

1. **Lectura y Escritura:** Permiten leer y escribir elementos en la secuencia.
2. **Unidireccional:** Permiten avanzar en la secuencia, pero no retroceder.
3. **Multipasada:** Se garantiza que se pueden recorrer múltiples veces, lo que significa que se pueden copiar y cada copia puede recorrer la secuencia independientemente.
4. **Igualdad y Desigualdad:** Pueden compararse con otros iteradores de avance usando `==` y `!=`.

#### Uso de Iteradores de Avance

Los iteradores de avance son comúnmente utilizados en contenedores como `std::forward_list`, pero también son compatibles con otros contenedores de la STL que proporcionan iteradores más potentes, como `std::vector` y `std::list`.

##### Ejemplo Básico con `std::forward_list`

```cpp
#include <iostream>
#include <forward_list>

int main() {
    std::forward_list<int> flist = {1, 2, 3, 4, 5};

    // Iterador de avance
    std::forward_list<int>::iterator it = flist.begin();

    // Recorrer y mostrar los elementos
    while (it != flist.end()) {
        std::cout << *it << " ";
        ++it;
    }
    std::cout << std::endl;

    return 0;
}
```

En este ejemplo:
- `std::forward_list<int>::iterator` es el tipo de iterador de avance para `std::forward_list<int>`.
- `flist.begin()` devuelve un iterador al primer elemento de la lista.
- `flist.end()` devuelve un iterador al elemento después del último elemento de la lista.

#### Algoritmos de la STL con Iteradores de Avance

Los iteradores de avance pueden ser utilizados en muchos algoritmos de la STL que requieren la capacidad de leer y escribir elementos en una secuencia.

##### Ejemplo con `std::find`

```cpp
#include <iostream>
#include <forward_list>
#include <algorithm>

int main() {
    std::forward_list<int> flist = {5, 3, 8, 1, 9};

    // Buscar un elemento usando std::find
    auto it = std::find(flist.begin(), flist.end(), 8);

    if (it != flist.end()) {
        std::cout << "Elemento encontrado: " << *it << std::endl;
    } else {
        std::cout << "Elemento no encontrado" << std::endl;
    }

    return 0;
}
```

En este ejemplo:
- `std::find` se utiliza para buscar un elemento en la lista utilizando iteradores de avance.

##### Ejemplo con `std::transform`

```cpp
#include <iostream>
#include <forward_list>
#include <algorithm>

int main() {
    std::forward_list<int> flist = {1, 2, 3, 4, 5};
    std::forward_list<int> resultado;

    // Reservar espacio en la lista de resultado
    resultado.resize(flist.size());

    // Usar std::transform para multiplicar cada elemento por 2
    std::transform(flist.begin(), flist.end(), resultado.begin(), [](int x) {
        return x * 2;
    });

    // Mostrar los resultados
    for (const auto& val : resultado) {
        std::cout << val << " ";
    }
    std::cout << std::endl;

    return 0;
}
```

En este ejemplo:
- `std::transform` se utiliza para multiplicar cada elemento de `flist` por 2 y almacenar los resultados en `resultado`.

#### Iteradores Constantes de Avance

Los iteradores constantes de avance (`const_forward_iterator`) se utilizan para recorrer contenedores sin modificar los elementos.

##### Ejemplo de Iteradores Constantes

```cpp
#include <iostream>
#include <forward_list>

int main() {
    std::forward_list<int> flist = {1, 2, 3, 4, 5};

    // Iterador constante de avance
    std::forward_list<int>::const_iterator it = flist.cbegin();

    // Recorrer y mostrar los elementos
    while (it != flist.cend()) {
        std::cout << *it << " ";
        ++it;
    }
    std::cout << std::endl;

    return 0;
}
```

En este ejemplo:
- `std::forward_list<int>::const_iterator` es el tipo de iterador constante de avance para `std::forward_list<int>`.
- `flist.cbegin()` devuelve un iterador constante al primer elemento de la lista.
- `flist.cend()` devuelve un iterador constante al elemento después del último elemento de la lista.

### Conclusión

Los iteradores de avance son una herramienta versátil en C++ que permiten recorrer y manipular elementos en una secuencia de manera unidireccional. Proporcionan una interfaz unificada para acceder y modificar elementos en diferentes tipos de contenedores, y se integran bien con los algoritmos de la STL. Entender cómo utilizar iteradores de avance y sus constantes correctamente es esencial para escribir código C++ robusto y eficiente.
### Iteradores Bidireccionales en C++

Los **iteradores bidireccionales** son una categoría de iteradores en C++ que permiten recorrer una secuencia en ambas direcciones: hacia adelante y hacia atrás. A diferencia de los iteradores de avance, los iteradores bidireccionales soportan tanto el incremento como el decremento, lo que los hace más flexibles y potentes para manipular contenedores.

#### Características de los Iteradores Bidireccionales

1. **Lectura y Escritura:** Permiten leer y escribir elementos en la secuencia.
2. **Bidireccionalidad:** Permiten avanzar y retroceder en la secuencia.
3. **Multipasada:** Se garantiza que se pueden recorrer múltiples veces, lo que significa que se pueden copiar y cada copia puede recorrer la secuencia independientemente.
4. **Igualdad y Desigualdad:** Pueden compararse con otros iteradores bidireccionales usando `==` y `!=`.

#### Uso de Iteradores Bidireccionales

Los iteradores bidireccionales son comúnmente utilizados en contenedores como `std::list`, `std::set`, y `std::map`.

##### Ejemplo Básico con `std::list`

```cpp
#include <iostream>
#include <list>

int main() {
    std::list<int> lst = {1, 2, 3, 4, 5};

    // Iterador bidireccional
    std::list<int>::iterator it = lst.begin();

    // Recorrer y mostrar los elementos hacia adelante
    std::cout << "Adelante: ";
    while (it != lst.end()) {
        std::cout << *it << " ";
        ++it;
    }
    std::cout << std::endl;

    // Recorrer y mostrar los elementos hacia atrás
    std::cout << "Atrás: ";
    it = lst.end();
    do {
        --it;
        std::cout << *it << " ";
    } while (it != lst.begin());
    std::cout << std::endl;

    return 0;
}
```

En este ejemplo:
- `std::list<int>::iterator` es el tipo de iterador bidireccional para `std::list<int>`.
- El iterador se usa para recorrer la lista tanto hacia adelante como hacia atrás.

#### Algoritmos de la STL con Iteradores Bidireccionales

Los iteradores bidireccionales pueden ser utilizados en muchos algoritmos de la STL que requieren la capacidad de leer y escribir elementos en ambas direcciones.

##### Ejemplo con `std::reverse`

```cpp
#include <iostream>
#include <list>
#include <algorithm>

int main() {
    std::list<int> lst = {5, 3, 8, 1, 9};

    // Usar std::reverse para invertir la lista
    std::reverse(lst.begin(), lst.end());

    // Mostrar los elementos de la lista invertida
    for (const int& val : lst) {
        std::cout << val << " ";
    }
    std::cout << std::endl;

    return 0;
}
```

En este ejemplo:
- `std::reverse` se utiliza para invertir los elementos de la lista utilizando iteradores bidireccionales.

#### Iteradores Constantes Bidireccionales

Los iteradores constantes bidireccionales (`const_bidirectional_iterator`) se utilizan para recorrer contenedores sin modificar los elementos.

##### Ejemplo de Iteradores Constantes

```cpp
#include <iostream>
#include <list>

int main() {
    std::list<int> lst = {1, 2, 3, 4, 5};

    // Iterador constante bidireccional
    std::list<int>::const_iterator it = lst.cbegin();

    // Recorrer y mostrar los elementos hacia adelante
    std::cout << "Adelante: ";
    while (it != lst.cend()) {
        std::cout << *it << " ";
        ++it;
    }
    std::cout << std::endl;

    // Recorrer y mostrar los elementos hacia atrás
    std::cout << "Atrás: ";
    it = lst.cend();
    do {
        --it;
        std::cout << *it << " ";
    } while (it != lst.cbegin());
    std::cout << std::endl;

    return 0;
}
```

En este ejemplo:
- `std::list<int>::const_iterator` es el tipo de iterador constante bidireccional para `std::list<int>`.
- El iterador constante se usa para recorrer la lista tanto hacia adelante como hacia atrás sin modificar los elementos.

### Implementación Personalizada de un Iterador Bidireccional

Si es necesario, se pueden definir iteradores bidireccionales personalizados para estructuras de datos no estándar.

##### Ejemplo de Implementación Personalizada

```cpp
#include <iostream>
#include <iterator>
#include <vector>

template <typename T>
class BidirectionalIterator : public std::iterator<std::bidirectional_iterator_tag, T> {
    T* ptr;

public:
    BidirectionalIterator(T* p = nullptr) : ptr(p) {}

    T& operator*() const { return *ptr; }
    T* operator->() const { return ptr; }

    BidirectionalIterator& operator++() {
        ++ptr;
        return *this;
    }

    BidirectionalIterator operator++(int) {
        BidirectionalIterator temp = *this;
        ++(*this);
        return temp;
    }

    BidirectionalIterator& operator--() {
        --ptr;
        return *this;
    }

    BidirectionalIterator operator--(int) {
        BidirectionalIterator temp = *this;
        --(*this);
        return temp;
    }

    bool operator==(const BidirectionalIterator& other) const {
        return ptr == other.ptr;
    }

    bool operator!=(const BidirectionalIterator& other) const {
        return ptr != other.ptr;
    }
};

int main() {
    std::vector<int> vec = {1, 2, 3, 4, 5};

    BidirectionalIterator<int> itBegin(vec.data());
    BidirectionalIterator<int> itEnd(vec.data() + vec.size());

    // Recorrer y mostrar los elementos hacia adelante
    std::cout << "Adelante: ";
    for (auto it = itBegin; it != itEnd; ++it) {
        std::cout << *it << " ";
    }
    std::cout << std::endl;

    // Recorrer y mostrar los elementos hacia atrás
    std::cout << "Atrás: ";
    for (auto it = itEnd; it != itBegin;) {
        --it;
        std::cout << *it << " ";
    }
    std::cout << std::endl;

    return 0;
}
```

En este ejemplo:
- `BidirectionalIterator` es un iterador bidireccional personalizado que puede recorrer un `std::vector<int>` tanto hacia adelante como hacia atrás.

### Conclusión

Los iteradores bidireccionales son una herramienta flexible y poderosa en C++ que permiten recorrer y manipular elementos en una secuencia en ambas direcciones. Proporcionan una interfaz unificada para acceder y modificar elementos en diferentes tipos de contenedores y se integran bien con los algoritmos de la STL. Comprender cómo utilizar y, si es necesario, implementar iteradores bidireccionales personalizados es esencial para escribir código C++ robusto y eficiente.
### Obtener Iteradores de un Contenedor en C++

En C++, los contenedores de la biblioteca estándar (STL) proporcionan métodos para obtener iteradores que permiten recorrer y manipular los elementos dentro del contenedor. Los métodos más comunes para obtener iteradores son `begin()`, `end()`, `cbegin()`, y `cend()`. Aquí se describen estos métodos y se presentan ejemplos prácticos de su uso.

#### Métodos para Obtener Iteradores

1. **`begin()` y `end()`:** Devuelven un iterador al primer elemento y un iterador al elemento siguiente al último, respectivamente. Estos métodos permiten la modificación de los elementos del contenedor.
2. **`cbegin()` y `cend()`:** Devuelven un iterador constante al primer elemento y un iterador constante al elemento siguiente al último, respectivamente. Estos métodos no permiten la modificación de los elementos del contenedor.

### Ejemplos Prácticos

#### Uso de `begin()` y `end()`

Estos métodos se utilizan para obtener iteradores que permiten recorrer y modificar los elementos de un contenedor.

##### Ejemplo con `std::vector`

```cpp
#include <iostream>
#include <vector>

int main() {
    std::vector<int> vec = {1, 2, 3, 4, 5};

    // Obtener iteradores a los elementos del vector
    std::vector<int>::iterator itBegin = vec.begin();
    std::vector<int>::iterator itEnd = vec.end();

    // Recorrer y modificar los elementos del vector
    for (auto it = itBegin; it != itEnd; ++it) {
        *it *= 2;  // Duplicar cada elemento
    }

    // Mostrar los elementos modificados
    for (const auto& val : vec) {
        std::cout << val << " ";
    }
    std::cout << std::endl;

    return 0;
}
```

En este ejemplo:
- `vec.begin()` devuelve un iterador al primer elemento del vector.
- `vec.end()` devuelve un iterador al elemento siguiente al último del vector.
- Los elementos del vector se duplican utilizando el iterador.

#### Uso de `cbegin()` y `cend()`

Estos métodos se utilizan para obtener iteradores constantes que permiten recorrer los elementos de un contenedor sin modificarlos.

##### Ejemplo con `std::vector`

```cpp
#include <iostream>
#include <vector>

int main() {
    std::vector<int> vec = {1, 2, 3, 4, 5};

    // Obtener iteradores constantes a los elementos del vector
    std::vector<int>::const_iterator itBegin = vec.cbegin();
    std::vector<int>::const_iterator itEnd = vec.cend();

    // Recorrer y mostrar los elementos del vector sin modificarlos
    for (auto it = itBegin; it != itEnd; ++it) {
        std::cout << *it << " ";
    }
    std::cout << std::endl;

    return 0;
}
```

En este ejemplo:
- `vec.cbegin()` devuelve un iterador constante al primer elemento del vector.
- `vec.cend()` devuelve un iterador constante al elemento siguiente al último del vector.
- Los elementos del vector se muestran sin modificarse utilizando el iterador constante.

#### Uso con Otros Contenedores de la STL

Los métodos `begin()`, `end()`, `cbegin()`, y `cend()` también se pueden utilizar con otros contenedores de la STL como `std::list`, `std::set`, `std::map`, etc.

##### Ejemplo con `std::list`

```cpp
#include <iostream>
#include <list>

int main() {
    std::list<int> lst = {1, 2, 3, 4, 5};

    // Obtener iteradores a los elementos de la lista
    std::list<int>::iterator itBegin = lst.begin();
    std::list<int>::iterator itEnd = lst.end();

    // Recorrer y modificar los elementos de la lista
    for (auto it = itBegin; it != itEnd; ++it) {
        *it *= 2;  // Duplicar cada elemento
    }

    // Mostrar los elementos modificados
    for (const auto& val : lst) {
        std::cout << val << " ";
    }
    std::cout << std::endl;

    return 0;
}
```

En este ejemplo:
- `lst.begin()` devuelve un iterador al primer elemento de la lista.
- `lst.end()` devuelve un iterador al elemento siguiente al último de la lista.
- Los elementos de la lista se duplican utilizando el iterador.

#### Uso con `std::map`

```cpp
#include <iostream>
#include <map>

int main() {
    std::map<int, std::string> mapa = {{1, "uno"}, {2, "dos"}, {3, "tres"}};

    // Obtener iteradores a los elementos del mapa
    std::map<int, std::string>::iterator itBegin = mapa.begin();
    std::map<int, std::string>::iterator itEnd = mapa.end();

    // Recorrer y modificar los valores del mapa
    for (auto it = itBegin; it != itEnd; ++it) {
        it->second = "modificado";  // Modificar cada valor
    }

    // Mostrar los elementos modificados
    for (const auto& par : mapa) {
        std::cout << par.first << ": " << par.second << std::endl;
    }

    return 0;
}
```

En este ejemplo:
- `mapa.begin()` devuelve un iterador al primer elemento del mapa.
- `mapa.end()` devuelve un iterador al elemento siguiente al último del mapa.
- Los valores del mapa se modifican utilizando el iterador.

### Conclusión

Los métodos `begin()`, `end()`, `cbegin()`, y `cend()` proporcionan una manera uniforme de obtener iteradores para recorrer y manipular elementos en los contenedores de la STL. Estos iteradores permiten una navegación eficiente y segura a través de los elementos del contenedor, ya sea para lectura o modificación. Comprender cómo obtener y utilizar estos iteradores es fundamental para aprovechar al máximo las capacidades de la biblioteca estándar de C++ y escribir código robusto y eficiente.
<---FILES--->
Tipos de Iteradores
Tipos de Iteradores Result
Ejemplo Básico
Ejemplo Básico Result
Ejemplo de Iteradores Constantes
Ejemplo de Iteradores Constantes Result
Tipos de Iteradores
Tipos de Iteradores Result
Ejemplo Básico
Ejemplo Básico Result
Ejemplo de Iteradores Constantes
Ejemplo de Iteradores Constantes Result
Ejemplo Básico con `std::istream_iterator`
Ejemplo Básico con `std::istream_iterator` Result
Ejemplo con `std::copy`
Ejemplo con `std::copy` Result
Ejemplo de Implementación Personalizada
Ejemplo de Implementación Personalizada Result
Tipos de Iteradores
Tipos de Iteradores Result
Ejemplo Básico
Ejemplo Básico Result
Ejemplo de Iteradores Constantes
Ejemplo de Iteradores Constantes Result
Ejemplo Básico con `std::istream_iterator`
Ejemplo Básico con `std::istream_iterator` Result
Ejemplo con `std::copy`
Ejemplo con `std::copy` Result
Ejemplo de Implementación Personalizada
Ejemplo de Implementación Personalizada Result
Ejemplo Básico con `std::ostream_iterator`
Ejemplo Básico con `std::ostream_iterator` Result
Tipos de Iteradores
Tipos de Iteradores Result
Ejemplo Básico
Ejemplo Básico Result
Ejemplo de Iteradores Constantes
Ejemplo de Iteradores Constantes Result
Ejemplo Básico con `std::istream_iterator`
Ejemplo Básico con `std::istream_iterator` Result
Ejemplo con `std::copy`
Ejemplo con `std::copy` Result
Ejemplo de Implementación Personalizada
Ejemplo de Implementación Personalizada Result
Ejemplo Básico con `std::ostream_iterator`
Ejemplo Básico con `std::ostream_iterator` Result
Ejemplo Básico con `std::forward_list`
Ejemplo Básico con `std::forward_list` Result
Ejemplo con `std::find`
Ejemplo con `std::find` Result
Ejemplo con `std::transform`
Ejemplo con `std::transform` Result
Tipos de Iteradores
Tipos de Iteradores Result
Ejemplo Básico
Ejemplo Básico Result
Ejemplo de Iteradores Constantes
Ejemplo de Iteradores Constantes Result
Ejemplo Básico con `std::istream_iterator`
Ejemplo Básico con `std::istream_iterator` Result
Ejemplo con `std::copy`
Ejemplo con `std::copy` Result
Ejemplo de Implementación Personalizada
Ejemplo de Implementación Personalizada Result
Ejemplo Básico con `std::ostream_iterator`
Ejemplo Básico con `std::ostream_iterator` Result
Ejemplo Básico con `std::forward_list`
Ejemplo Básico con `std::forward_list` Result
Ejemplo con `std::find`
Ejemplo con `std::find` Result
Ejemplo con `std::transform`
Ejemplo con `std::transform` Result
Ejemplo Básico con `std::list`
Ejemplo Básico con `std::list` Result
Ejemplo con `std::reverse`
Ejemplo con `std::reverse` Result
Tipos de Iteradores
Tipos de Iteradores Result
Ejemplo Básico
Ejemplo Básico Result
Ejemplo de Iteradores Constantes
Ejemplo de Iteradores Constantes Result
Ejemplo Básico con `std::istream_iterator`
Ejemplo Básico con `std::istream_iterator` Result
Ejemplo con `std::copy`
Ejemplo con `std::copy` Result
Ejemplo de Implementación Personalizada
Ejemplo de Implementación Personalizada Result
Ejemplo Básico con `std::ostream_iterator`
Ejemplo Básico con `std::ostream_iterator` Result
Ejemplo Básico con `std::forward_list`
Ejemplo Básico con `std::forward_list` Result
Ejemplo con `std::find`
Ejemplo con `std::find` Result
Ejemplo con `std::transform`
Ejemplo con `std::transform` Result
Ejemplo Básico con `std::list`
Ejemplo Básico con `std::list` Result
Ejemplo con `std::reverse`
Ejemplo con `std::reverse` Result
Ejemplo con `std::vector`
Ejemplo con `std::vector` Result
Ejemplo con `std::list`
Ejemplo con `std::list` Result
<---Tipos de Iteradores--->
<---Tipos de Iteradores Result--->
<---Ejemplo Básico--->
```cpp
#include <iostream>
#include <vector>

int main() {
    std::vector<int> vec = {1, 2, 3, 4, 5};

    // Iterador que apunta al primer elemento del vector
    std::vector<int>::iterator it = vec.begin();

    // Recorrer el vector usando el iterador
    while (it != vec.end()) {
        std::cout << *it << " ";
        ++it;  // Avanzar al siguiente elemento
    }
    std::cout << std::endl;

    return 0;
}
```cpp
#include <iostream>
#include <vector>
#include <algorithm>

int main() {
    std::vector<int> vec = {5, 2, 8, 1, 3};

    // Ordenar el vector usando std::sort
    std::sort(vec.begin(), vec.end());

    // Encontrar un elemento usando std::find
    auto it = std::find(vec.begin(), vec.end(), 8);

    if (it != vec.end()) {
        std::cout << "Elemento encontrado: " << *it << std::endl;
    } else {
        std::cout << "Elemento no encontrado" << std::endl;
    }

    return 0;
}
<---Ejemplo Básico Result--->
<---Ejemplo de Iteradores Constantes--->
```cpp
#include <iostream>
#include <vector>

int main() {
    std::vector<int> vec = {1, 2, 3, 4, 5};

    // Iterador constante
    std::vector<int>::const_iterator it = vec.cbegin();

    // Recorrer el vector usando el iterador constante
    while (it != vec.cend()) {
        std::cout << *it << " ";
        ++it;
    }
    std::cout << std::endl;

    return 0;
}
<---Ejemplo de Iteradores Constantes Result--->
<---Tipos de Iteradores--->
<---Tipos de Iteradores Result--->
<---Ejemplo Básico--->
```cpp
#include <iostream>
#include <vector>

int main() {
    std::vector<int> vec = {1, 2, 3, 4, 5};

    // Iterador que apunta al primer elemento del vector
    std::vector<int>::iterator it = vec.begin();

    // Recorrer el vector usando el iterador
    while (it != vec.end()) {
        std::cout << *it << " ";
        ++it;  // Avanzar al siguiente elemento
    }
    std::cout << std::endl;

    return 0;
}
```cpp
#include <iostream>
#include <vector>
#include <algorithm>

int main() {
    std::vector<int> vec = {5, 2, 8, 1, 3};

    // Ordenar el vector usando std::sort
    std::sort(vec.begin(), vec.end());

    // Encontrar un elemento usando std::find
    auto it = std::find(vec.begin(), vec.end(), 8);

    if (it != vec.end()) {
        std::cout << "Elemento encontrado: " << *it << std::endl;
    } else {
        std::cout << "Elemento no encontrado" << std::endl;
    }

    return 0;
}
<---Ejemplo Básico Result--->
<---Ejemplo de Iteradores Constantes--->
```cpp
#include <iostream>
#include <vector>

int main() {
    std::vector<int> vec = {1, 2, 3, 4, 5};

    // Iterador constante
    std::vector<int>::const_iterator it = vec.cbegin();

    // Recorrer el vector usando el iterador constante
    while (it != vec.cend()) {
        std::cout << *it << " ";
        ++it;
    }
    std::cout << std::endl;

    return 0;
}
<---Ejemplo de Iteradores Constantes Result--->
<---Ejemplo Básico con `std::istream_iterator`--->
```cpp
#include <iostream>
#include <iterator>
#include <vector>
#include <algorithm>

int main() {
    std::cout << "Ingrese números separados por espacios (Ctrl+D para terminar): ";

    // Crear un istream_iterator para leer desde std::cin
    std::istream_iterator<int> inicio(std::cin);
    std::istream_iterator<int> fin;  // Iterador de fin predeterminado

    // Leer todos los números ingresados en un vector
    std::vector<int> numeros(inicio, fin);

    // Mostrar los números leídos
    std::cout << "Números ingresados: ";
    for (int numero : numeros) {
        std::cout << numero << " ";
    }
    std::cout << std::endl;

    return 0;
}
<---Ejemplo Básico con `std::istream_iterator` Result--->
<---Ejemplo con `std::copy`--->
```cpp
#include <iostream>
#include <iterator>
#include <vector>
#include <algorithm>

int main() {
    std::cout << "Ingrese números separados por espacios (Ctrl+D para terminar): ";

    // Crear un istream_iterator para leer desde std::cin
    std::istream_iterator<int> inicio(std::cin);
    std::istream_iterator<int> fin;  // Iterador de fin predeterminado

    // Crear un vector para almacenar los números leídos
    std::vector<int> numeros;

    // Usar std::copy para leer los números en el vector
    std::copy(inicio, fin, std::back_inserter(numeros));

    // Mostrar los números leídos
    std::cout << "Números ingresados: ";
    for (int numero : numeros) {
        std::cout << numero << " ";
    }
    std::cout << std::endl;

    return 0;
}
<---Ejemplo con `std::copy` Result--->
<---Ejemplo de Implementación Personalizada--->
```cpp
#include <iostream>
#include <iterator>

class InputIterator : public std::iterator<std::input_iterator_tag, int> {
    std::istream* in;
    int value;

public:
    InputIterator(std::istream& s) : in(&s) {
        ++(*this);  // Leer el primer valor
    }

    InputIterator() : in(nullptr) {}

    bool operator==(const InputIterator& other) const {
        return in == other.in;
    }

    bool operator!=(const InputIterator& other) const {
        return !(*this == other);
    }

    int operator*() const {
        return value;
    }

    InputIterator& operator++() {
        if (in && !(*in >> value)) {
            in = nullptr;  // Alcanzó el final de la secuencia
        }
        return *this;
    }
};

int main() {
    std::cout << "Ingrese números separados por espacios (Ctrl+D para terminar): ";

    // Usar el iterador de entrada personalizado para leer desde std::cin
    InputIterator inicio(std::cin);
    InputIterator fin;

    // Leer todos los números ingresados en un vector
    std::vector<int> numeros(inicio, fin);

    // Mostrar los números leídos
    std::cout << "Números ingresados: ";
    for (int numero : numeros) {
        std::cout << numero << " ";
    }
    std::cout << std::endl;

    return 0;
}
<---Ejemplo de Implementación Personalizada Result--->
<---Tipos de Iteradores--->
<---Tipos de Iteradores Result--->
<---Ejemplo Básico--->
```cpp
#include <iostream>
#include <vector>

int main() {
    std::vector<int> vec = {1, 2, 3, 4, 5};

    // Iterador que apunta al primer elemento del vector
    std::vector<int>::iterator it = vec.begin();

    // Recorrer el vector usando el iterador
    while (it != vec.end()) {
        std::cout << *it << " ";
        ++it;  // Avanzar al siguiente elemento
    }
    std::cout << std::endl;

    return 0;
}
```cpp
#include <iostream>
#include <vector>
#include <algorithm>

int main() {
    std::vector<int> vec = {5, 2, 8, 1, 3};

    // Ordenar el vector usando std::sort
    std::sort(vec.begin(), vec.end());

    // Encontrar un elemento usando std::find
    auto it = std::find(vec.begin(), vec.end(), 8);

    if (it != vec.end()) {
        std::cout << "Elemento encontrado: " << *it << std::endl;
    } else {
        std::cout << "Elemento no encontrado" << std::endl;
    }

    return 0;
}
<---Ejemplo Básico Result--->
<---Ejemplo de Iteradores Constantes--->
```cpp
#include <iostream>
#include <vector>

int main() {
    std::vector<int> vec = {1, 2, 3, 4, 5};

    // Iterador constante
    std::vector<int>::const_iterator it = vec.cbegin();

    // Recorrer el vector usando el iterador constante
    while (it != vec.cend()) {
        std::cout << *it << " ";
        ++it;
    }
    std::cout << std::endl;

    return 0;
}
<---Ejemplo de Iteradores Constantes Result--->
<---Ejemplo Básico con `std::istream_iterator`--->
```cpp
#include <iostream>
#include <iterator>
#include <vector>
#include <algorithm>

int main() {
    std::cout << "Ingrese números separados por espacios (Ctrl+D para terminar): ";

    // Crear un istream_iterator para leer desde std::cin
    std::istream_iterator<int> inicio(std::cin);
    std::istream_iterator<int> fin;  // Iterador de fin predeterminado

    // Leer todos los números ingresados en un vector
    std::vector<int> numeros(inicio, fin);

    // Mostrar los números leídos
    std::cout << "Números ingresados: ";
    for (int numero : numeros) {
        std::cout << numero << " ";
    }
    std::cout << std::endl;

    return 0;
}
<---Ejemplo Básico con `std::istream_iterator` Result--->
<---Ejemplo con `std::copy`--->
```cpp
#include <iostream>
#include <iterator>
#include <vector>
#include <algorithm>

int main() {
    std::vector<int> numeros = {5, 2, 8, 1, 3};

    // Crear un ostream_iterator para escribir en std::cout
    std::ostream_iterator<int> salida(std::cout, " ");

    // Usar std::copy para escribir los números en std::cout
    std::copy(numeros.begin(), numeros.end(), salida);
    std::cout << std::endl;

    return 0;
}
<---Ejemplo con `std::copy` Result--->
<---Ejemplo de Implementación Personalizada--->
```cpp
#include <iostream>
#include <iterator>
#include <vector>

class OutputIterator : public std::iterator<std::output_iterator_tag, void, void, void, void> {
    std::ostream* out;
    std::string delimiter;

public:
    OutputIterator(std::ostream& s, const std::string& delim = " ") : out(&s), delimiter(delim) {}

    OutputIterator& operator=(int value) {
        *out << value << delimiter;
        return *this;
    }

    OutputIterator& operator*() {
        return *this;
    }

    OutputIterator& operator++() {
        return *this;
    }

    OutputIterator& operator++(int) {
        return *this;
    }
};

int main() {
    std::vector<int> numeros = {1, 2, 3, 4, 5};

    // Usar el iterador de salida personalizado para escribir en std::cout
    OutputIterator salida(std::cout, " - ");

    for (int numero : numeros) {
        *salida = numero;
        ++salida;
    }
    std::cout << std::endl;

    return 0;
}
<---Ejemplo de Implementación Personalizada Result--->
<---Ejemplo Básico con `std::ostream_iterator`--->
```cpp
#include <iostream>
#include <iterator>
#include <vector>

int main() {
    std::vector<int> numeros = {1, 2, 3, 4, 5};

    // Crear un ostream_iterator para escribir en std::cout
    std::ostream_iterator<int> salida(std::cout, " ");

    // Usar el iterador de salida para escribir los números
    for (int numero : numeros) {
        *salida = numero;
        ++salida;
    }
    std::cout << std::endl;

    return 0;
}
<---Ejemplo Básico con `std::ostream_iterator` Result--->
<---Tipos de Iteradores--->
<---Tipos de Iteradores Result--->
<---Ejemplo Básico--->
```cpp
#include <iostream>
#include <vector>

int main() {
    std::vector<int> vec = {1, 2, 3, 4, 5};

    // Iterador que apunta al primer elemento del vector
    std::vector<int>::iterator it = vec.begin();

    // Recorrer el vector usando el iterador
    while (it != vec.end()) {
        std::cout << *it << " ";
        ++it;  // Avanzar al siguiente elemento
    }
    std::cout << std::endl;

    return 0;
}
```cpp
#include <iostream>
#include <vector>
#include <algorithm>

int main() {
    std::vector<int> vec = {5, 2, 8, 1, 3};

    // Ordenar el vector usando std::sort
    std::sort(vec.begin(), vec.end());

    // Encontrar un elemento usando std::find
    auto it = std::find(vec.begin(), vec.end(), 8);

    if (it != vec.end()) {
        std::cout << "Elemento encontrado: " << *it << std::endl;
    } else {
        std::cout << "Elemento no encontrado" << std::endl;
    }

    return 0;
}
<---Ejemplo Básico Result--->
<---Ejemplo de Iteradores Constantes--->
```cpp
#include <iostream>
#include <forward_list>

int main() {
    std::forward_list<int> flist = {1, 2, 3, 4, 5};

    // Iterador constante de avance
    std::forward_list<int>::const_iterator it = flist.cbegin();

    // Recorrer y mostrar los elementos
    while (it != flist.cend()) {
        std::cout << *it << " ";
        ++it;
    }
    std::cout << std::endl;

    return 0;
}
<---Ejemplo de Iteradores Constantes Result--->
<---Ejemplo Básico con `std::istream_iterator`--->
```cpp
#include <iostream>
#include <iterator>
#include <vector>
#include <algorithm>

int main() {
    std::cout << "Ingrese números separados por espacios (Ctrl+D para terminar): ";

    // Crear un istream_iterator para leer desde std::cin
    std::istream_iterator<int> inicio(std::cin);
    std::istream_iterator<int> fin;  // Iterador de fin predeterminado

    // Leer todos los números ingresados en un vector
    std::vector<int> numeros(inicio, fin);

    // Mostrar los números leídos
    std::cout << "Números ingresados: ";
    for (int numero : numeros) {
        std::cout << numero << " ";
    }
    std::cout << std::endl;

    return 0;
}
<---Ejemplo Básico con `std::istream_iterator` Result--->
<---Ejemplo con `std::copy`--->
```cpp
#include <iostream>
#include <iterator>
#include <vector>
#include <algorithm>

int main() {
    std::vector<int> numeros = {5, 2, 8, 1, 3};

    // Crear un ostream_iterator para escribir en std::cout
    std::ostream_iterator<int> salida(std::cout, " ");

    // Usar std::copy para escribir los números en std::cout
    std::copy(numeros.begin(), numeros.end(), salida);
    std::cout << std::endl;

    return 0;
}
<---Ejemplo con `std::copy` Result--->
<---Ejemplo de Implementación Personalizada--->
```cpp
#include <iostream>
#include <iterator>
#include <vector>

class OutputIterator : public std::iterator<std::output_iterator_tag, void, void, void, void> {
    std::ostream* out;
    std::string delimiter;

public:
    OutputIterator(std::ostream& s, const std::string& delim = " ") : out(&s), delimiter(delim) {}

    OutputIterator& operator=(int value) {
        *out << value << delimiter;
        return *this;
    }

    OutputIterator& operator*() {
        return *this;
    }

    OutputIterator& operator++() {
        return *this;
    }

    OutputIterator& operator++(int) {
        return *this;
    }
};

int main() {
    std::vector<int> numeros = {1, 2, 3, 4, 5};

    // Usar el iterador de salida personalizado para escribir en std::cout
    OutputIterator salida(std::cout, " - ");

    for (int numero : numeros) {
        *salida = numero;
        ++salida;
    }
    std::cout << std::endl;

    return 0;
}
<---Ejemplo de Implementación Personalizada Result--->
<---Ejemplo Básico con `std::ostream_iterator`--->
```cpp
#include <iostream>
#include <iterator>
#include <vector>

int main() {
    std::vector<int> numeros = {1, 2, 3, 4, 5};

    // Crear un ostream_iterator para escribir en std::cout
    std::ostream_iterator<int> salida(std::cout, " ");

    // Usar el iterador de salida para escribir los números
    for (int numero : numeros) {
        *salida = numero;
        ++salida;
    }
    std::cout << std::endl;

    return 0;
}
<---Ejemplo Básico con `std::ostream_iterator` Result--->
<---Ejemplo Básico con `std::forward_list`--->
```cpp
#include <iostream>
#include <forward_list>

int main() {
    std::forward_list<int> flist = {1, 2, 3, 4, 5};

    // Iterador de avance
    std::forward_list<int>::iterator it = flist.begin();

    // Recorrer y mostrar los elementos
    while (it != flist.end()) {
        std::cout << *it << " ";
        ++it;
    }
    std::cout << std::endl;

    return 0;
}
<---Ejemplo Básico con `std::forward_list` Result--->
<---Ejemplo con `std::find`--->
```cpp
#include <iostream>
#include <forward_list>
#include <algorithm>

int main() {
    std::forward_list<int> flist = {5, 3, 8, 1, 9};

    // Buscar un elemento usando std::find
    auto it = std::find(flist.begin(), flist.end(), 8);

    if (it != flist.end()) {
        std::cout << "Elemento encontrado: " << *it << std::endl;
    } else {
        std::cout << "Elemento no encontrado" << std::endl;
    }

    return 0;
}
<---Ejemplo con `std::find` Result--->
<---Ejemplo con `std::transform`--->
```cpp
#include <iostream>
#include <forward_list>
#include <algorithm>

int main() {
    std::forward_list<int> flist = {1, 2, 3, 4, 5};
    std::forward_list<int> resultado;

    // Reservar espacio en la lista de resultado
    resultado.resize(flist.size());

    // Usar std::transform para multiplicar cada elemento por 2
    std::transform(flist.begin(), flist.end(), resultado.begin(), [](int x) {
        return x * 2;
    });

    // Mostrar los resultados
    for (const auto& val : resultado) {
        std::cout << val << " ";
    }
    std::cout << std::endl;

    return 0;
}
<---Ejemplo con `std::transform` Result--->
<---Tipos de Iteradores--->
<---Tipos de Iteradores Result--->
<---Ejemplo Básico--->
```cpp
#include <iostream>
#include <vector>

int main() {
    std::vector<int> vec = {1, 2, 3, 4, 5};

    // Iterador que apunta al primer elemento del vector
    std::vector<int>::iterator it = vec.begin();

    // Recorrer el vector usando el iterador
    while (it != vec.end()) {
        std::cout << *it << " ";
        ++it;  // Avanzar al siguiente elemento
    }
    std::cout << std::endl;

    return 0;
}
```cpp
#include <iostream>
#include <vector>
#include <algorithm>

int main() {
    std::vector<int> vec = {5, 2, 8, 1, 3};

    // Ordenar el vector usando std::sort
    std::sort(vec.begin(), vec.end());

    // Encontrar un elemento usando std::find
    auto it = std::find(vec.begin(), vec.end(), 8);

    if (it != vec.end()) {
        std::cout << "Elemento encontrado: " << *it << std::endl;
    } else {
        std::cout << "Elemento no encontrado" << std::endl;
    }

    return 0;
}
<---Ejemplo Básico Result--->
<---Ejemplo de Iteradores Constantes--->
```cpp
#include <iostream>
#include <list>

int main() {
    std::list<int> lst = {1, 2, 3, 4, 5};

    // Iterador constante bidireccional
    std::list<int>::const_iterator it = lst.cbegin();

    // Recorrer y mostrar los elementos hacia adelante
    std::cout << "Adelante: ";
    while (it != lst.cend()) {
        std::cout << *it << " ";
        ++it;
    }
    std::cout << std::endl;

    // Recorrer y mostrar los elementos hacia atrás
    std::cout << "Atrás: ";
    it = lst.cend();
    do {
        --it;
        std::cout << *it << " ";
    } while (it != lst.cbegin());
    std::cout << std::endl;

    return 0;
}
<---Ejemplo de Iteradores Constantes Result--->
<---Ejemplo Básico con `std::istream_iterator`--->
```cpp
#include <iostream>
#include <iterator>
#include <vector>
#include <algorithm>

int main() {
    std::cout << "Ingrese números separados por espacios (Ctrl+D para terminar): ";

    // Crear un istream_iterator para leer desde std::cin
    std::istream_iterator<int> inicio(std::cin);
    std::istream_iterator<int> fin;  // Iterador de fin predeterminado

    // Leer todos los números ingresados en un vector
    std::vector<int> numeros(inicio, fin);

    // Mostrar los números leídos
    std::cout << "Números ingresados: ";
    for (int numero : numeros) {
        std::cout << numero << " ";
    }
    std::cout << std::endl;

    return 0;
}
<---Ejemplo Básico con `std::istream_iterator` Result--->
<---Ejemplo con `std::copy`--->
```cpp
#include <iostream>
#include <iterator>
#include <vector>
#include <algorithm>

int main() {
    std::vector<int> numeros = {5, 2, 8, 1, 3};

    // Crear un ostream_iterator para escribir en std::cout
    std::ostream_iterator<int> salida(std::cout, " ");

    // Usar std::copy para escribir los números en std::cout
    std::copy(numeros.begin(), numeros.end(), salida);
    std::cout << std::endl;

    return 0;
}
<---Ejemplo con `std::copy` Result--->
<---Ejemplo de Implementación Personalizada--->
```cpp
#include <iostream>
#include <iterator>
#include <vector>

template <typename T>
class BidirectionalIterator : public std::iterator<std::bidirectional_iterator_tag, T> {
    T* ptr;

public:
    BidirectionalIterator(T* p = nullptr) : ptr(p) {}

    T& operator*() const { return *ptr; }
    T* operator->() const { return ptr; }

    BidirectionalIterator& operator++() {
        ++ptr;
        return *this;
    }

    BidirectionalIterator operator++(int) {
        BidirectionalIterator temp = *this;
        ++(*this);
        return temp;
    }

    BidirectionalIterator& operator--() {
        --ptr;
        return *this;
    }

    BidirectionalIterator operator--(int) {
        BidirectionalIterator temp = *this;
        --(*this);
        return temp;
    }

    bool operator==(const BidirectionalIterator& other) const {
        return ptr == other.ptr;
    }

    bool operator!=(const BidirectionalIterator& other) const {
        return ptr != other.ptr;
    }
};

int main() {
    std::vector<int> vec = {1, 2, 3, 4, 5};

    BidirectionalIterator<int> itBegin(vec.data());
    BidirectionalIterator<int> itEnd(vec.data() + vec.size());

    // Recorrer y mostrar los elementos hacia adelante
    std::cout << "Adelante: ";
    for (auto it = itBegin; it != itEnd; ++it) {
        std::cout << *it << " ";
    }
    std::cout << std::endl;

    // Recorrer y mostrar los elementos hacia atrás
    std::cout << "Atrás: ";
    for (auto it = itEnd; it != itBegin;) {
        --it;
        std::cout << *it << " ";
    }
    std::cout << std::endl;

    return 0;
}
<---Ejemplo de Implementación Personalizada Result--->
<---Ejemplo Básico con `std::ostream_iterator`--->
```cpp
#include <iostream>
#include <iterator>
#include <vector>

int main() {
    std::vector<int> numeros = {1, 2, 3, 4, 5};

    // Crear un ostream_iterator para escribir en std::cout
    std::ostream_iterator<int> salida(std::cout, " ");

    // Usar el iterador de salida para escribir los números
    for (int numero : numeros) {
        *salida = numero;
        ++salida;
    }
    std::cout << std::endl;

    return 0;
}
<---Ejemplo Básico con `std::ostream_iterator` Result--->
<---Ejemplo Básico con `std::forward_list`--->
```cpp
#include <iostream>
#include <forward_list>

int main() {
    std::forward_list<int> flist = {1, 2, 3, 4, 5};

    // Iterador de avance
    std::forward_list<int>::iterator it = flist.begin();

    // Recorrer y mostrar los elementos
    while (it != flist.end()) {
        std::cout << *it << " ";
        ++it;
    }
    std::cout << std::endl;

    return 0;
}
<---Ejemplo Básico con `std::forward_list` Result--->
<---Ejemplo con `std::find`--->
```cpp
#include <iostream>
#include <forward_list>
#include <algorithm>

int main() {
    std::forward_list<int> flist = {5, 3, 8, 1, 9};

    // Buscar un elemento usando std::find
    auto it = std::find(flist.begin(), flist.end(), 8);

    if (it != flist.end()) {
        std::cout << "Elemento encontrado: " << *it << std::endl;
    } else {
        std::cout << "Elemento no encontrado" << std::endl;
    }

    return 0;
}
<---Ejemplo con `std::find` Result--->
<---Ejemplo con `std::transform`--->
```cpp
#include <iostream>
#include <forward_list>
#include <algorithm>

int main() {
    std::forward_list<int> flist = {1, 2, 3, 4, 5};
    std::forward_list<int> resultado;

    // Reservar espacio en la lista de resultado
    resultado.resize(flist.size());

    // Usar std::transform para multiplicar cada elemento por 2
    std::transform(flist.begin(), flist.end(), resultado.begin(), [](int x) {
        return x * 2;
    });

    // Mostrar los resultados
    for (const auto& val : resultado) {
        std::cout << val << " ";
    }
    std::cout << std::endl;

    return 0;
}
<---Ejemplo con `std::transform` Result--->
<---Ejemplo Básico con `std::list`--->
```cpp
#include <iostream>
#include <list>

int main() {
    std::list<int> lst = {1, 2, 3, 4, 5};

    // Iterador bidireccional
    std::list<int>::iterator it = lst.begin();

    // Recorrer y mostrar los elementos hacia adelante
    std::cout << "Adelante: ";
    while (it != lst.end()) {
        std::cout << *it << " ";
        ++it;
    }
    std::cout << std::endl;

    // Recorrer y mostrar los elementos hacia atrás
    std::cout << "Atrás: ";
    it = lst.end();
    do {
        --it;
        std::cout << *it << " ";
    } while (it != lst.begin());
    std::cout << std::endl;

    return 0;
}
<---Ejemplo Básico con `std::list` Result--->
<---Ejemplo con `std::reverse`--->
```cpp
#include <iostream>
#include <list>
#include <algorithm>

int main() {
    std::list<int> lst = {5, 3, 8, 1, 9};

    // Usar std::reverse para invertir la lista
    std::reverse(lst.begin(), lst.end());

    // Mostrar los elementos de la lista invertida
    for (const int& val : lst) {
        std::cout << val << " ";
    }
    std::cout << std::endl;

    return 0;
}
<---Ejemplo con `std::reverse` Result--->
<---Tipos de Iteradores--->
<---Tipos de Iteradores Result--->
<---Ejemplo Básico--->
```cpp
#include <iostream>
#include <vector>

int main() {
    std::vector<int> vec = {1, 2, 3, 4, 5};

    // Iterador que apunta al primer elemento del vector
    std::vector<int>::iterator it = vec.begin();

    // Recorrer el vector usando el iterador
    while (it != vec.end()) {
        std::cout << *it << " ";
        ++it;  // Avanzar al siguiente elemento
    }
    std::cout << std::endl;

    return 0;
}
```cpp
#include <iostream>
#include <vector>
#include <algorithm>

int main() {
    std::vector<int> vec = {5, 2, 8, 1, 3};

    // Ordenar el vector usando std::sort
    std::sort(vec.begin(), vec.end());

    // Encontrar un elemento usando std::find
    auto it = std::find(vec.begin(), vec.end(), 8);

    if (it != vec.end()) {
        std::cout << "Elemento encontrado: " << *it << std::endl;
    } else {
        std::cout << "Elemento no encontrado" << std::endl;
    }

    return 0;
}
<---Ejemplo Básico Result--->
<---Ejemplo de Iteradores Constantes--->
```cpp
#include <iostream>
#include <list>

int main() {
    std::list<int> lst = {1, 2, 3, 4, 5};

    // Iterador constante bidireccional
    std::list<int>::const_iterator it = lst.cbegin();

    // Recorrer y mostrar los elementos hacia adelante
    std::cout << "Adelante: ";
    while (it != lst.cend()) {
        std::cout << *it << " ";
        ++it;
    }
    std::cout << std::endl;

    // Recorrer y mostrar los elementos hacia atrás
    std::cout << "Atrás: ";
    it = lst.cend();
    do {
        --it;
        std::cout << *it << " ";
    } while (it != lst.cbegin());
    std::cout << std::endl;

    return 0;
}
<---Ejemplo de Iteradores Constantes Result--->
<---Ejemplo Básico con `std::istream_iterator`--->
```cpp
#include <iostream>
#include <iterator>
#include <vector>
#include <algorithm>

int main() {
    std::cout << "Ingrese números separados por espacios (Ctrl+D para terminar): ";

    // Crear un istream_iterator para leer desde std::cin
    std::istream_iterator<int> inicio(std::cin);
    std::istream_iterator<int> fin;  // Iterador de fin predeterminado

    // Leer todos los números ingresados en un vector
    std::vector<int> numeros(inicio, fin);

    // Mostrar los números leídos
    std::cout << "Números ingresados: ";
    for (int numero : numeros) {
        std::cout << numero << " ";
    }
    std::cout << std::endl;

    return 0;
}
<---Ejemplo Básico con `std::istream_iterator` Result--->
<---Ejemplo con `std::copy`--->
```cpp
#include <iostream>
#include <iterator>
#include <vector>
#include <algorithm>

int main() {
    std::vector<int> numeros = {5, 2, 8, 1, 3};

    // Crear un ostream_iterator para escribir en std::cout
    std::ostream_iterator<int> salida(std::cout, " ");

    // Usar std::copy para escribir los números en std::cout
    std::copy(numeros.begin(), numeros.end(), salida);
    std::cout << std::endl;

    return 0;
}
<---Ejemplo con `std::copy` Result--->
<---Ejemplo de Implementación Personalizada--->
```cpp
#include <iostream>
#include <iterator>
#include <vector>

template <typename T>
class BidirectionalIterator : public std::iterator<std::bidirectional_iterator_tag, T> {
    T* ptr;

public:
    BidirectionalIterator(T* p = nullptr) : ptr(p) {}

    T& operator*() const { return *ptr; }
    T* operator->() const { return ptr; }

    BidirectionalIterator& operator++() {
        ++ptr;
        return *this;
    }

    BidirectionalIterator operator++(int) {
        BidirectionalIterator temp = *this;
        ++(*this);
        return temp;
    }

    BidirectionalIterator& operator--() {
        --ptr;
        return *this;
    }

    BidirectionalIterator operator--(int) {
        BidirectionalIterator temp = *this;
        --(*this);
        return temp;
    }

    bool operator==(const BidirectionalIterator& other) const {
        return ptr == other.ptr;
    }

    bool operator!=(const BidirectionalIterator& other) const {
        return ptr != other.ptr;
    }
};

int main() {
    std::vector<int> vec = {1, 2, 3, 4, 5};

    BidirectionalIterator<int> itBegin(vec.data());
    BidirectionalIterator<int> itEnd(vec.data() + vec.size());

    // Recorrer y mostrar los elementos hacia adelante
    std::cout << "Adelante: ";
    for (auto it = itBegin; it != itEnd; ++it) {
        std::cout << *it << " ";
    }
    std::cout << std::endl;

    // Recorrer y mostrar los elementos hacia atrás
    std::cout << "Atrás: ";
    for (auto it = itEnd; it != itBegin;) {
        --it;
        std::cout << *it << " ";
    }
    std::cout << std::endl;

    return 0;
}
<---Ejemplo de Implementación Personalizada Result--->
<---Ejemplo Básico con `std::ostream_iterator`--->
```cpp
#include <iostream>
#include <iterator>
#include <vector>

int main() {
    std::vector<int> numeros = {1, 2, 3, 4, 5};

    // Crear un ostream_iterator para escribir en std::cout
    std::ostream_iterator<int> salida(std::cout, " ");

    // Usar el iterador de salida para escribir los números
    for (int numero : numeros) {
        *salida = numero;
        ++salida;
    }
    std::cout << std::endl;

    return 0;
}
<---Ejemplo Básico con `std::ostream_iterator` Result--->
<---Ejemplo Básico con `std::forward_list`--->
```cpp
#include <iostream>
#include <forward_list>

int main() {
    std::forward_list<int> flist = {1, 2, 3, 4, 5};

    // Iterador de avance
    std::forward_list<int>::iterator it = flist.begin();

    // Recorrer y mostrar los elementos
    while (it != flist.end()) {
        std::cout << *it << " ";
        ++it;
    }
    std::cout << std::endl;

    return 0;
}
<---Ejemplo Básico con `std::forward_list` Result--->
<---Ejemplo con `std::find`--->
```cpp
#include <iostream>
#include <forward_list>
#include <algorithm>

int main() {
    std::forward_list<int> flist = {5, 3, 8, 1, 9};

    // Buscar un elemento usando std::find
    auto it = std::find(flist.begin(), flist.end(), 8);

    if (it != flist.end()) {
        std::cout << "Elemento encontrado: " << *it << std::endl;
    } else {
        std::cout << "Elemento no encontrado" << std::endl;
    }

    return 0;
}
<---Ejemplo con `std::find` Result--->
<---Ejemplo con `std::transform`--->
```cpp
#include <iostream>
#include <forward_list>
#include <algorithm>

int main() {
    std::forward_list<int> flist = {1, 2, 3, 4, 5};
    std::forward_list<int> resultado;

    // Reservar espacio en la lista de resultado
    resultado.resize(flist.size());

    // Usar std::transform para multiplicar cada elemento por 2
    std::transform(flist.begin(), flist.end(), resultado.begin(), [](int x) {
        return x * 2;
    });

    // Mostrar los resultados
    for (const auto& val : resultado) {
        std::cout << val << " ";
    }
    std::cout << std::endl;

    return 0;
}
<---Ejemplo con `std::transform` Result--->
<---Ejemplo Básico con `std::list`--->
```cpp
#include <iostream>
#include <list>

int main() {
    std::list<int> lst = {1, 2, 3, 4, 5};

    // Iterador bidireccional
    std::list<int>::iterator it = lst.begin();

    // Recorrer y mostrar los elementos hacia adelante
    std::cout << "Adelante: ";
    while (it != lst.end()) {
        std::cout << *it << " ";
        ++it;
    }
    std::cout << std::endl;

    // Recorrer y mostrar los elementos hacia atrás
    std::cout << "Atrás: ";
    it = lst.end();
    do {
        --it;
        std::cout << *it << " ";
    } while (it != lst.begin());
    std::cout << std::endl;

    return 0;
}
<---Ejemplo Básico con `std::list` Result--->
<---Ejemplo con `std::reverse`--->
```cpp
#include <iostream>
#include <list>
#include <algorithm>

int main() {
    std::list<int> lst = {5, 3, 8, 1, 9};

    // Usar std::reverse para invertir la lista
    std::reverse(lst.begin(), lst.end());

    // Mostrar los elementos de la lista invertida
    for (const int& val : lst) {
        std::cout << val << " ";
    }
    std::cout << std::endl;

    return 0;
}
<---Ejemplo con `std::reverse` Result--->
<---Ejemplo con `std::vector`--->
```cpp
#include <iostream>
#include <vector>

int main() {
    std::vector<int> vec = {1, 2, 3, 4, 5};

    // Obtener iteradores constantes a los elementos del vector
    std::vector<int>::const_iterator itBegin = vec.cbegin();
    std::vector<int>::const_iterator itEnd = vec.cend();

    // Recorrer y mostrar los elementos del vector sin modificarlos
    for (auto it = itBegin; it != itEnd; ++it) {
        std::cout << *it << " ";
    }
    std::cout << std::endl;

    return 0;
}
<---Ejemplo con `std::vector` Result--->
<---Ejemplo con `std::list`--->
```cpp
#include <iostream>
#include <list>

int main() {
    std::list<int> lst = {1, 2, 3, 4, 5};

    // Obtener iteradores a los elementos de la lista
    std::list<int>::iterator itBegin = lst.begin();
    std::list<int>::iterator itEnd = lst.end();

    // Recorrer y modificar los elementos de la lista
    for (auto it = itBegin; it != itEnd; ++it) {
        *it *= 2;  // Duplicar cada elemento
    }

    // Mostrar los elementos modificados
    for (const auto& val : lst) {
        std::cout << val << " ";
    }
    std::cout << std::endl;

    return 0;
}
```cpp
#include <iostream>
#include <map>

int main() {
    std::map<int, std::string> mapa = {{1, "uno"}, {2, "dos"}, {3, "tres"}};

    // Obtener iteradores a los elementos del mapa
    std::map<int, std::string>::iterator itBegin = mapa.begin();
    std::map<int, std::string>::iterator itEnd = mapa.end();

    // Recorrer y modificar los valores del mapa
    for (auto it = itBegin; it != itEnd; ++it) {
        it->second = "modificado";  // Modificar cada valor
    }

    // Mostrar los elementos modificados
    for (const auto& par : mapa) {
        std::cout << par.first << ": " << par.second << std::endl;
    }

    return 0;
}
<---Ejemplo con `std::list` Result--->
