<---EXPLANATION--->
### Operaciones Permitidas en el Ámbito de Contenedores en C++

Los contenedores en C++ proporcionan una variedad de operaciones que permiten la manipulación eficiente de los elementos que almacenan. Estas operaciones incluyen la inserción, eliminación, acceso y modificación de elementos, así como la consulta del tamaño y la capacidad del contenedor. Aquí se describen las operaciones comunes disponibles para los contenedores estándar en C++.

#### Operaciones Comunes para Todos los Contenedores

1. **Inserción de Elementos**
2. **Eliminación de Elementos**
3. **Acceso a Elementos**
4. **Modificación de Elementos**
5. **Consulta de Tamaño y Capacidad**
6. **Iteradores**
7. **Otras Operaciones Específicas de Contenedores**

### 1. Inserción de Elementos

##### `push_back()`

Inserta un elemento al final del contenedor.

```cpp
#include <vector>
#include <iostream>

int main() {
    std::vector<int> vec;
    vec.push_back(1);
    vec.push_back(2);
    vec.push_back(3);

    for (int v : vec) {
        std::cout << v << " ";
    }
    std::cout << std::endl;

    return 0;
}
```

##### `insert()`

Inserta un elemento o un rango de elementos en una posición específica.

```cpp
#include <list>
#include <iostream>

int main() {
    std::list<int> lst = {1, 2, 3};
    auto it = lst.begin();
    ++it;
    lst.insert(it, 4);  // Inserta 4 antes de 2

    for (int v : lst) {
        std::cout << v << " ";
    }
    std::cout << std::endl;

    return 0;
}
```

### 2. Eliminación de Elementos

##### `pop_back()`

Elimina el último elemento del contenedor.

```cpp
#include <vector>
#include <iostream>

int main() {
    std::vector<int> vec = {1, 2, 3};
    vec.pop_back();

    for (int v : vec) {
        std::cout << v << " ";
    }
    std::cout << std::endl;

    return 0;
}
```

##### `erase()`

Elimina un elemento o un rango de elementos de una posición específica.

```cpp
#include <list>
#include <iostream>

int main() {
    std::list<int> lst = {1, 2, 3};
    auto it = lst.begin();
    ++it;
    lst.erase(it);  // Elimina 2

    for (int v : lst) {
        std::cout << v << " ";
    }
    std::cout << std::endl;

    return 0;
}
```

### 3. Acceso a Elementos

##### `front()`

Accede al primer elemento del contenedor.

```cpp
#include <deque>
#include <iostream>

int main() {
    std::deque<int> deq = {1, 2, 3};
    std::cout << "Primer elemento: " << deq.front() << std::endl;

    return 0;
}
```

##### `back()`

Accede al último elemento del contenedor.

```cpp
#include <deque>
#include <iostream>

int main() {
    std::deque<int> deq = {1, 2, 3};
    std::cout << "Último elemento: " << deq.back() << std::endl;

    return 0;
}
```

##### `operator[]` y `at()`

Acceden a un elemento en una posición específica (sólo para contenedores con acceso aleatorio como `std::vector` y `std::deque`).

```cpp
#include <vector>
#include <iostream>

int main() {
    std::vector<int> vec = {1, 2, 3};
    std::cout << "Elemento en la posición 1: " << vec[1] << std::endl;
    std::cout << "Elemento en la posición 2: " << vec.at(2) << std::endl;

    return 0;
}
```

### 4. Modificación de Elementos

Los elementos pueden ser modificados directamente a través de los iteradores o referencias obtenidas mediante `front()`, `back()`, `operator[]`, `at()`, o iteradores.

```cpp
#include <vector>
#include <iostream>

int main() {
    std::vector<int> vec = {1, 2, 3};
    vec[1] = 10;  // Modifica el segundo elemento

    for (int v : vec) {
        std::cout << v << " ";
    }
    std::cout << std::endl;

    return 0;
}
```

### 5. Consulta de Tamaño y Capacidad

##### `size()`

Devuelve el número de elementos en el contenedor.

```cpp
#include <vector>
#include <iostream>

int main() {
    std::vector<int> vec = {1, 2, 3};
    std::cout << "Tamaño: " << vec.size() << std::endl;

    return 0;
}
```

##### `capacity()`

Devuelve la capacidad actual del contenedor (sólo para `std::vector` y `std::deque`).

```cpp
#include <vector>
#include <iostream>

int main() {
    std::vector<int> vec = {1, 2, 3};
    std::cout << "Capacidad: " << vec.capacity() << std::endl;

    return 0;
}
```

##### `empty()`

Comprueba si el contenedor está vacío.

```cpp
#include <vector>
#include <iostream>

int main() {
    std::vector<int> vec;
    std::cout << "Está vacío: " << vec.empty() << std::endl;

    return 0;
}
```

### 6. Iteradores

##### `begin()` y `end()`

Devuelven iteradores al primer elemento y al elemento después del último, respectivamente.

```cpp
#include <vector>
#include <iostream>

int main() {
    std::vector<int> vec = {1, 2, 3};

    for (auto it = vec.begin(); it != vec.end(); ++it) {
        std::cout << *it << " ";
    }
    std::cout << std::endl;

    return 0;
}
```

##### `cbegin()` y `cend()`

Devuelven iteradores constantes al primer elemento y al elemento después del último, respectivamente.

```cpp
#include <vector>
#include <iostream>

int main() {
    std::vector<int> vec = {1, 2, 3};

    for (auto it = vec.cbegin(); it != vec.cend(); ++it) {
        std::cout << *it << " ";
    }
    std::cout << std::endl;

    return 0;
}
```

### 7. Otras Operaciones Específicas de Contenedores

##### `std::map` y `std::set`

- **`find()`**: Busca un elemento con una clave específica.
- **`count()`**: Devuelve el número de elementos con una clave específica.

```cpp
#include <map>
#include <iostream>

int main() {
    std::map<int, std::string> mapa = {{1, "uno"}, {2, "dos"}, {3, "tres"}};
    auto it = mapa.find(2);
    if (it != mapa.end()) {
        std::cout << "Encontrado: " << it->second << std::endl;
    }

    std::cout << "Número de elementos con clave 2: " << mapa.count(2) << std::endl;

    return 0;
}
```

##### `std::queue` y `std::stack`

- **`push()`**: Inserta un elemento al final (cola) o en la parte superior (pila).
- **`pop()`**: Elimina el primer elemento (cola) o el elemento superior (pila).

```cpp
#include <queue>
#include <iostream>

int main() {
    std::queue<int> q;
    q.push(1);
    q.push(2);
    q.push(3);

    std::cout << "Frente: " << q.front() << std::endl;
    q.pop();
    std::cout << "Frente después de pop: " << q.front() << std::endl;

    return 0;
}
```

### Conclusión

Los contenedores de la biblioteca estándar de C++ proporcionan una amplia gama de operaciones para manipular sus elementos de manera eficiente y segura. Comprender cómo usar estas operaciones es esencial para escribir código C++ robusto y eficiente. Estas operaciones permiten la inserción, eliminación, acceso, modificación de elementos, consulta de tamaño y capacidad, y el uso de iteradores para recorrer los elementos de los contenedores.
<---FILES--->
`push_back()`
`push_back()` Result
`insert()`
`insert()` Result
`pop_back()`
`pop_back()` Result
`erase()`
`erase()` Result
`front()`
`front()` Result
`back()`
`back()` Result
`operator[]` y `at()`
`operator[]` y `at()` Result
`size()`
`size()` Result
`capacity()`
`capacity()` Result
`empty()`
`empty()` Result
`begin()` y `end()`
`begin()` y `end()` Result
`cbegin()` y `cend()`
`cbegin()` y `cend()` Result
`std::map` y `std::set`
`std::map` y `std::set` Result
`std::queue` y `std::stack`
`std::queue` y `std::stack` Result
<---`push_back()`--->
```cpp
#include <vector>
#include <iostream>

int main() {
    std::vector<int> vec;
    vec.push_back(1);
    vec.push_back(2);
    vec.push_back(3);

    for (int v : vec) {
        std::cout << v << " ";
    }
    std::cout << std::endl;

    return 0;
}
<---`push_back()` Result--->
<---`insert()`--->
```cpp
#include <list>
#include <iostream>

int main() {
    std::list<int> lst = {1, 2, 3};
    auto it = lst.begin();
    ++it;
    lst.insert(it, 4);  // Inserta 4 antes de 2

    for (int v : lst) {
        std::cout << v << " ";
    }
    std::cout << std::endl;

    return 0;
}
<---`insert()` Result--->
<---`pop_back()`--->
```cpp
#include <vector>
#include <iostream>

int main() {
    std::vector<int> vec = {1, 2, 3};
    vec.pop_back();

    for (int v : vec) {
        std::cout << v << " ";
    }
    std::cout << std::endl;

    return 0;
}
<---`pop_back()` Result--->
<---`erase()`--->
```cpp
#include <list>
#include <iostream>

int main() {
    std::list<int> lst = {1, 2, 3};
    auto it = lst.begin();
    ++it;
    lst.erase(it);  // Elimina 2

    for (int v : lst) {
        std::cout << v << " ";
    }
    std::cout << std::endl;

    return 0;
}
<---`erase()` Result--->
<---`front()`--->
```cpp
#include <deque>
#include <iostream>

int main() {
    std::deque<int> deq = {1, 2, 3};
    std::cout << "Primer elemento: " << deq.front() << std::endl;

    return 0;
}
<---`front()` Result--->
<---`back()`--->
```cpp
#include <deque>
#include <iostream>

int main() {
    std::deque<int> deq = {1, 2, 3};
    std::cout << "Último elemento: " << deq.back() << std::endl;

    return 0;
}
<---`back()` Result--->
<---`operator[]` y `at()`--->
```cpp
#include <vector>
#include <iostream>

int main() {
    std::vector<int> vec = {1, 2, 3};
    std::cout << "Elemento en la posición 1: " << vec[1] << std::endl;
    std::cout << "Elemento en la posición 2: " << vec.at(2) << std::endl;

    return 0;
}
```cpp
#include <vector>
#include <iostream>

int main() {
    std::vector<int> vec = {1, 2, 3};
    vec[1] = 10;  // Modifica el segundo elemento

    for (int v : vec) {
        std::cout << v << " ";
    }
    std::cout << std::endl;

    return 0;
}
<---`operator[]` y `at()` Result--->
<---`size()`--->
```cpp
#include <vector>
#include <iostream>

int main() {
    std::vector<int> vec = {1, 2, 3};
    std::cout << "Tamaño: " << vec.size() << std::endl;

    return 0;
}
<---`size()` Result--->
<---`capacity()`--->
```cpp
#include <vector>
#include <iostream>

int main() {
    std::vector<int> vec = {1, 2, 3};
    std::cout << "Capacidad: " << vec.capacity() << std::endl;

    return 0;
}
<---`capacity()` Result--->
<---`empty()`--->
```cpp
#include <vector>
#include <iostream>

int main() {
    std::vector<int> vec;
    std::cout << "Está vacío: " << vec.empty() << std::endl;

    return 0;
}
<---`empty()` Result--->
<---`begin()` y `end()`--->
```cpp
#include <vector>
#include <iostream>

int main() {
    std::vector<int> vec = {1, 2, 3};

    for (auto it = vec.begin(); it != vec.end(); ++it) {
        std::cout << *it << " ";
    }
    std::cout << std::endl;

    return 0;
}
<---`begin()` y `end()` Result--->
<---`cbegin()` y `cend()`--->
```cpp
#include <vector>
#include <iostream>

int main() {
    std::vector<int> vec = {1, 2, 3};

    for (auto it = vec.cbegin(); it != vec.cend(); ++it) {
        std::cout << *it << " ";
    }
    std::cout << std::endl;

    return 0;
}
<---`cbegin()` y `cend()` Result--->
<---`std::map` y `std::set`--->
```cpp
#include <map>
#include <iostream>

int main() {
    std::map<int, std::string> mapa = {{1, "uno"}, {2, "dos"}, {3, "tres"}};
    auto it = mapa.find(2);
    if (it != mapa.end()) {
        std::cout << "Encontrado: " << it->second << std::endl;
    }

    std::cout << "Número de elementos con clave 2: " << mapa.count(2) << std::endl;

    return 0;
}
<---`std::map` y `std::set` Result--->
<---`std::queue` y `std::stack`--->
```cpp
#include <queue>
#include <iostream>

int main() {
    std::queue<int> q;
    q.push(1);
    q.push(2);
    q.push(3);

    std::cout << "Frente: " << q.front() << std::endl;
    q.pop();
    std::cout << "Frente después de pop: " << q.front() << std::endl;

    return 0;
}
<---`std::queue` y `std::stack` Result--->
