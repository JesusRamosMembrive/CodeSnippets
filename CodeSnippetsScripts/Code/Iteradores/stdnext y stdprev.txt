<---EXPLANATION--->
### Iteradores en C++

Los iteradores son una abstracción fundamental en C++ que permiten recorrer y manipular elementos en contenedores (como arrays, vectores, listas, etc.). Funcionan de manera similar a los punteros y proporcionan una interfaz unificada para acceder a los elementos de los contenedores de la biblioteca estándar de C++.

#### Introducción a los Iteradores

Un iterador es un objeto que apunta a un elemento dentro de un contenedor y permite recorrer los elementos del contenedor de una manera secuencial. Los iteradores se utilizan de manera extensiva en los algoritmos de la biblioteca estándar de C++ (STL).

##### Tipos de Iteradores

1. **Input Iterators:** Permiten leer elementos de una secuencia.
2. **Output Iterators:** Permiten escribir elementos en una secuencia.
3. **Forward Iterators:** Permiten avanzar en la secuencia y leer o escribir elementos.
4. **Bidirectional Iterators:** Permiten avanzar y retroceder en la secuencia.
5. **Random Access Iterators:** Permiten acceso aleatorio a cualquier elemento en la secuencia.

##### Ejemplo Básico

```cpp
#include <iostream>
#include <vector>

int main() {
    std::vector<int> vec = {1, 2, 3, 4, 5};

    // Iterador que apunta al primer elemento del vector
    std::vector<int>::iterator it = vec.begin();

    // Recorrer el vector usando el iterador
    while (it != vec.end()) {
        std::cout << *it << " ";
        ++it;  // Avanzar al siguiente elemento
    }
    std::cout << std::endl;

    return 0;
}
```

En este ejemplo:
- `std::vector<int>::iterator` es el tipo de iterador para `std::vector<int>`.
- `vec.begin()` devuelve un iterador al primer elemento del vector.
- `vec.end()` devuelve un iterador al elemento después del último elemento del vector.
- `*it` desreferencia el iterador para acceder al valor del elemento.

#### Beneficios de Usar Iteradores

1. **Abstracción:** Proporcionan una interfaz unificada para acceder y manipular elementos en diferentes tipos de contenedores sin necesidad de conocer la implementación interna del contenedor.
2. **Flexibilidad:** Permiten recorrer contenedores de manera eficiente, utilizando el mismo código para diferentes tipos de contenedores.
3. **Compatibilidad con Algoritmos STL:** Los iteradores se integran perfectamente con los algoritmos de la STL, como `std::sort`, `std::find`, `std::for_each`, etc.
4. **Encapsulamiento:** Ocultan los detalles de la estructura del contenedor, proporcionando una forma segura y conveniente de acceder a sus elementos.

#### Ejemplo con Algoritmos de la STL

```cpp
#include <iostream>
#include <vector>
#include <algorithm>

int main() {
    std::vector<int> vec = {5, 2, 8, 1, 3};

    // Ordenar el vector usando std::sort
    std::sort(vec.begin(), vec.end());

    // Encontrar un elemento usando std::find
    auto it = std::find(vec.begin(), vec.end(), 8);

    if (it != vec.end()) {
        std::cout << "Elemento encontrado: " << *it << std::endl;
    } else {
        std::cout << "Elemento no encontrado" << std::endl;
    }

    return 0;
}
```

En este ejemplo:
- `std::sort` ordena el vector usando iteradores.
- `std::find` busca un elemento en el vector y devuelve un iterador al elemento si se encuentra, o `vec.end()` si no se encuentra.

#### Iteradores Constantes

Los iteradores constantes (`const_iterator`) se utilizan para recorrer contenedores sin modificar los elementos.

##### Ejemplo de Iteradores Constantes

```cpp
#include <iostream>
#include <vector>

int main() {
    std::vector<int> vec = {1, 2, 3, 4, 5};

    // Iterador constante
    std::vector<int>::const_iterator it = vec.cbegin();

    // Recorrer el vector usando el iterador constante
    while (it != vec.cend()) {
        std::cout << *it << " ";
        ++it;
    }
    std::cout << std::endl;

    return 0;
}
```

En este ejemplo:
- `std::vector<int>::const_iterator` es el tipo de iterador constante para `std::vector<int>`.
- `vec.cbegin()` devuelve un iterador constante al primer elemento del vector.
- `vec.cend()` devuelve un iterador constante al elemento después del último elemento del vector.

### Conclusión

Los iteradores son una herramienta poderosa y flexible en C++ que permiten recorrer y manipular elementos en contenedores de manera eficiente y abstracta. Proporcionan una interfaz unificada que facilita la compatibilidad con los algoritmos de la STL y permite escribir código genérico que funciona con diferentes tipos de contenedores. Entender y utilizar iteradores correctamente es esencial para aprovechar al máximo las capacidades de la biblioteca estándar de C++ y escribir código limpio y eficiente.
### Iteradores de Entrada en C++

Los **iteradores de entrada** (input iterators) son uno de los tipos de iteradores en C++ que se utilizan para leer datos secuencialmente de una secuencia. Estos iteradores permiten recorrer una secuencia de datos y leer cada elemento una vez, y son especialmente útiles cuando se trabaja con flujos de entrada como archivos o entradas estándar.

#### Características de los Iteradores de Entrada

1. **Lectura Secuencial:** Permiten leer los elementos de una secuencia en orden.
2. **No Modificables:** No se pueden usar para modificar los elementos de la secuencia.
3. **Un Solo Paso:** Cada elemento puede ser leído una vez; no se garantiza que puedan retroceder.
4. **Igualdad y Desigualdad:** Pueden compararse con otros iteradores de entrada usando `==` y `!=`.

#### Ejemplo con Flujos de Entrada

Los iteradores de entrada son comúnmente utilizados con flujos de entrada como `std::istream`.

##### Ejemplo Básico con `std::istream_iterator`

```cpp
#include <iostream>
#include <iterator>
#include <vector>
#include <algorithm>

int main() {
    std::cout << "Ingrese números separados por espacios (Ctrl+D para terminar): ";

    // Crear un istream_iterator para leer desde std::cin
    std::istream_iterator<int> inicio(std::cin);
    std::istream_iterator<int> fin;  // Iterador de fin predeterminado

    // Leer todos los números ingresados en un vector
    std::vector<int> numeros(inicio, fin);

    // Mostrar los números leídos
    std::cout << "Números ingresados: ";
    for (int numero : numeros) {
        std::cout << numero << " ";
    }
    std::cout << std::endl;

    return 0;
}
```

En este ejemplo:
- `std::istream_iterator<int>` se utiliza para crear un iterador de entrada que lee `int` desde `std::cin`.
- Los números ingresados se almacenan en un `std::vector<int>` utilizando el rango `[inicio, fin]`.

#### Uso en Algoritmos de la STL

Los iteradores de entrada pueden ser utilizados en algoritmos de la STL que requieren la lectura de datos de una secuencia.

##### Ejemplo con `std::copy`

```cpp
#include <iostream>
#include <iterator>
#include <vector>
#include <algorithm>

int main() {
    std::cout << "Ingrese números separados por espacios (Ctrl+D para terminar): ";

    // Crear un istream_iterator para leer desde std::cin
    std::istream_iterator<int> inicio(std::cin);
    std::istream_iterator<int> fin;  // Iterador de fin predeterminado

    // Crear un vector para almacenar los números leídos
    std::vector<int> numeros;

    // Usar std::copy para leer los números en el vector
    std::copy(inicio, fin, std::back_inserter(numeros));

    // Mostrar los números leídos
    std::cout << "Números ingresados: ";
    for (int numero : numeros) {
        std::cout << numero << " ";
    }
    std::cout << std::endl;

    return 0;
}
```

En este ejemplo:
- `std::copy` se utiliza para copiar los números leídos desde el flujo de entrada a un vector utilizando un iterador de entrada.

#### Implementación Personalizada de un Iterador de Entrada

Aunque `std::istream_iterator` es una implementación estándar, es posible definir iteradores de entrada personalizados.

##### Ejemplo de Implementación Personalizada

```cpp
#include <iostream>
#include <iterator>

class InputIterator : public std::iterator<std::input_iterator_tag, int> {
    std::istream* in;
    int value;

public:
    InputIterator(std::istream& s) : in(&s) {
        ++(*this);  // Leer el primer valor
    }

    InputIterator() : in(nullptr) {}

    bool operator==(const InputIterator& other) const {
        return in == other.in;
    }

    bool operator!=(const InputIterator& other) const {
        return !(*this == other);
    }

    int operator*() const {
        return value;
    }

    InputIterator& operator++() {
        if (in && !(*in >> value)) {
            in = nullptr;  // Alcanzó el final de la secuencia
        }
        return *this;
    }
};

int main() {
    std::cout << "Ingrese números separados por espacios (Ctrl+D para terminar): ";

    // Usar el iterador de entrada personalizado para leer desde std::cin
    InputIterator inicio(std::cin);
    InputIterator fin;

    // Leer todos los números ingresados en un vector
    std::vector<int> numeros(inicio, fin);

    // Mostrar los números leídos
    std::cout << "Números ingresados: ";
    for (int numero : numeros) {
        std::cout << numero << " ";
    }
    std::cout << std::endl;

    return 0;
}
```

En este ejemplo:
- `InputIterator` es un iterador de entrada personalizado que lee `int` desde un flujo de entrada.
- Se define sobrecargando los operadores necesarios para cumplir con los requisitos de un iterador de entrada.

### Conclusión

Los iteradores de entrada son una herramienta poderosa en C++ para leer datos secuencialmente de una fuente de entrada. Permiten una lectura eficiente y son esenciales para trabajar con flujos de entrada en algoritmos de la STL. Entender cómo utilizar y, si es necesario, implementar iteradores de entrada personalizados, es fundamental para escribir código C++ robusto y eficiente.
### Iteradores de Salida en C++

Los **iteradores de salida** (output iterators) son una categoría de iteradores en C++ que permiten escribir datos secuencialmente en una secuencia. Son esencialmente la contraparte de los iteradores de entrada y se utilizan cuando se necesita producir o generar datos, escribiéndolos en contenedores o flujos de salida.

#### Características de los Iteradores de Salida

1. **Escritura Secuencial:** Permiten escribir elementos en una secuencia en orden.
2. **No Lectura:** No se pueden usar para leer los elementos de la secuencia.
3. **Un Solo Paso:** Cada posición puede ser escrita una vez; no se garantiza que puedan retroceder.
4. **Igualdad y Desigualdad:** Pueden compararse con otros iteradores de salida usando `==` y `!=`.

#### Ejemplo con Flujos de Salida

Los iteradores de salida son comúnmente utilizados con flujos de salida como `std::ostream`.

##### Ejemplo Básico con `std::ostream_iterator`

```cpp
#include <iostream>
#include <iterator>
#include <vector>

int main() {
    std::vector<int> numeros = {1, 2, 3, 4, 5};

    // Crear un ostream_iterator para escribir en std::cout
    std::ostream_iterator<int> salida(std::cout, " ");

    // Usar el iterador de salida para escribir los números
    for (int numero : numeros) {
        *salida = numero;
        ++salida;
    }
    std::cout << std::endl;

    return 0;
}
```

En este ejemplo:
- `std::ostream_iterator<int>` se utiliza para crear un iterador de salida que escribe `int` en `std::cout`.
- Los números en el vector `numeros` se escriben en la salida estándar utilizando el iterador de salida.

#### Uso en Algoritmos de la STL

Los iteradores de salida pueden ser utilizados en algoritmos de la STL que producen datos.

##### Ejemplo con `std::copy`

```cpp
#include <iostream>
#include <iterator>
#include <vector>
#include <algorithm>

int main() {
    std::vector<int> numeros = {5, 2, 8, 1, 3};

    // Crear un ostream_iterator para escribir en std::cout
    std::ostream_iterator<int> salida(std::cout, " ");

    // Usar std::copy para escribir los números en std::cout
    std::copy(numeros.begin(), numeros.end(), salida);
    std::cout << std::endl;

    return 0;
}
```

En este ejemplo:
- `std::copy` se utiliza para copiar los números del vector `numeros` a la salida estándar utilizando un iterador de salida.

#### Implementación Personalizada de un Iterador de Salida

Aunque `std::ostream_iterator` es una implementación estándar, es posible definir iteradores de salida personalizados.

##### Ejemplo de Implementación Personalizada

```cpp
#include <iostream>
#include <iterator>
#include <vector>

class OutputIterator : public std::iterator<std::output_iterator_tag, void, void, void, void> {
    std::ostream* out;
    std::string delimiter;

public:
    OutputIterator(std::ostream& s, const std::string& delim = " ") : out(&s), delimiter(delim) {}

    OutputIterator& operator=(int value) {
        *out << value << delimiter;
        return *this;
    }

    OutputIterator& operator*() {
        return *this;
    }

    OutputIterator& operator++() {
        return *this;
    }

    OutputIterator& operator++(int) {
        return *this;
    }
};

int main() {
    std::vector<int> numeros = {1, 2, 3, 4, 5};

    // Usar el iterador de salida personalizado para escribir en std::cout
    OutputIterator salida(std::cout, " - ");

    for (int numero : numeros) {
        *salida = numero;
        ++salida;
    }
    std::cout << std::endl;

    return 0;
}
```

En este ejemplo:
- `OutputIterator` es un iterador de salida personalizado que escribe `int` en un flujo de salida con un delimitador específico.
- Se define sobrecargando los operadores necesarios para cumplir con los requisitos de un iterador de salida.

### Conclusión

Los iteradores de salida son una herramienta esencial en C++ para generar y escribir datos secuencialmente en contenedores o flujos de salida. Proporcionan una interfaz unificada para producir datos, lo que facilita su uso en combinación con los algoritmos de la STL. Entender cómo utilizar y, si es necesario, implementar iteradores de salida personalizados es crucial para escribir código C++ robusto y eficiente, especialmente cuando se trabaja con generación y producción de datos.
### Iteradores de Avance en C++

Los **iteradores de avance** (forward iterators) son una categoría de iteradores en C++ que permiten avanzar en una secuencia y leer o escribir elementos en esa secuencia. A diferencia de los iteradores de entrada y salida, los iteradores de avance soportan tanto la lectura como la escritura y permiten recorrer una secuencia en una única dirección.

#### Características de los Iteradores de Avance

1. **Lectura y Escritura:** Permiten leer y escribir elementos en la secuencia.
2. **Unidireccional:** Permiten avanzar en la secuencia, pero no retroceder.
3. **Multipasada:** Se garantiza que se pueden recorrer múltiples veces, lo que significa que se pueden copiar y cada copia puede recorrer la secuencia independientemente.
4. **Igualdad y Desigualdad:** Pueden compararse con otros iteradores de avance usando `==` y `!=`.

#### Uso de Iteradores de Avance

Los iteradores de avance son comúnmente utilizados en contenedores como `std::forward_list`, pero también son compatibles con otros contenedores de la STL que proporcionan iteradores más potentes, como `std::vector` y `std::list`.

##### Ejemplo Básico con `std::forward_list`

```cpp
#include <iostream>
#include <forward_list>

int main() {
    std::forward_list<int> flist = {1, 2, 3, 4, 5};

    // Iterador de avance
    std::forward_list<int>::iterator it = flist.begin();

    // Recorrer y mostrar los elementos
    while (it != flist.end()) {
        std::cout << *it << " ";
        ++it;
    }
    std::cout << std::endl;

    return 0;
}
```

En este ejemplo:
- `std::forward_list<int>::iterator` es el tipo de iterador de avance para `std::forward_list<int>`.
- `flist.begin()` devuelve un iterador al primer elemento de la lista.
- `flist.end()` devuelve un iterador al elemento después del último elemento de la lista.

#### Algoritmos de la STL con Iteradores de Avance

Los iteradores de avance pueden ser utilizados en muchos algoritmos de la STL que requieren la capacidad de leer y escribir elementos en una secuencia.

##### Ejemplo con `std::find`

```cpp
#include <iostream>
#include <forward_list>
#include <algorithm>

int main() {
    std::forward_list<int> flist = {5, 3, 8, 1, 9};

    // Buscar un elemento usando std::find
    auto it = std::find(flist.begin(), flist.end(), 8);

    if (it != flist.end()) {
        std::cout << "Elemento encontrado: " << *it << std::endl;
    } else {
        std::cout << "Elemento no encontrado" << std::endl;
    }

    return 0;
}
```

En este ejemplo:
- `std::find` se utiliza para buscar un elemento en la lista utilizando iteradores de avance.

##### Ejemplo con `std::transform`

```cpp
#include <iostream>
#include <forward_list>
#include <algorithm>

int main() {
    std::forward_list<int> flist = {1, 2, 3, 4, 5};
    std::forward_list<int> resultado;

    // Reservar espacio en la lista de resultado
    resultado.resize(flist.size());

    // Usar std::transform para multiplicar cada elemento por 2
    std::transform(flist.begin(), flist.end(), resultado.begin(), [](int x) {
        return x * 2;
    });

    // Mostrar los resultados
    for (const auto& val : resultado) {
        std::cout << val << " ";
    }
    std::cout << std::endl;

    return 0;
}
```

En este ejemplo:
- `std::transform` se utiliza para multiplicar cada elemento de `flist` por 2 y almacenar los resultados en `resultado`.

#### Iteradores Constantes de Avance

Los iteradores constantes de avance (`const_forward_iterator`) se utilizan para recorrer contenedores sin modificar los elementos.

##### Ejemplo de Iteradores Constantes

```cpp
#include <iostream>
#include <forward_list>

int main() {
    std::forward_list<int> flist = {1, 2, 3, 4, 5};

    // Iterador constante de avance
    std::forward_list<int>::const_iterator it = flist.cbegin();

    // Recorrer y mostrar los elementos
    while (it != flist.cend()) {
        std::cout << *it << " ";
        ++it;
    }
    std::cout << std::endl;

    return 0;
}
```

En este ejemplo:
- `std::forward_list<int>::const_iterator` es el tipo de iterador constante de avance para `std::forward_list<int>`.
- `flist.cbegin()` devuelve un iterador constante al primer elemento de la lista.
- `flist.cend()` devuelve un iterador constante al elemento después del último elemento de la lista.

### Conclusión

Los iteradores de avance son una herramienta versátil en C++ que permiten recorrer y manipular elementos en una secuencia de manera unidireccional. Proporcionan una interfaz unificada para acceder y modificar elementos en diferentes tipos de contenedores, y se integran bien con los algoritmos de la STL. Entender cómo utilizar iteradores de avance y sus constantes correctamente es esencial para escribir código C++ robusto y eficiente.
### Iteradores Bidireccionales en C++

Los **iteradores bidireccionales** son una categoría de iteradores en C++ que permiten recorrer una secuencia en ambas direcciones: hacia adelante y hacia atrás. A diferencia de los iteradores de avance, los iteradores bidireccionales soportan tanto el incremento como el decremento, lo que los hace más flexibles y potentes para manipular contenedores.

#### Características de los Iteradores Bidireccionales

1. **Lectura y Escritura:** Permiten leer y escribir elementos en la secuencia.
2. **Bidireccionalidad:** Permiten avanzar y retroceder en la secuencia.
3. **Multipasada:** Se garantiza que se pueden recorrer múltiples veces, lo que significa que se pueden copiar y cada copia puede recorrer la secuencia independientemente.
4. **Igualdad y Desigualdad:** Pueden compararse con otros iteradores bidireccionales usando `==` y `!=`.

#### Uso de Iteradores Bidireccionales

Los iteradores bidireccionales son comúnmente utilizados en contenedores como `std::list`, `std::set`, y `std::map`.

##### Ejemplo Básico con `std::list`

```cpp
#include <iostream>
#include <list>

int main() {
    std::list<int> lst = {1, 2, 3, 4, 5};

    // Iterador bidireccional
    std::list<int>::iterator it = lst.begin();

    // Recorrer y mostrar los elementos hacia adelante
    std::cout << "Adelante: ";
    while (it != lst.end()) {
        std::cout << *it << " ";
        ++it;
    }
    std::cout << std::endl;

    // Recorrer y mostrar los elementos hacia atrás
    std::cout << "Atrás: ";
    it = lst.end();
    do {
        --it;
        std::cout << *it << " ";
    } while (it != lst.begin());
    std::cout << std::endl;

    return 0;
}
```

En este ejemplo:
- `std::list<int>::iterator` es el tipo de iterador bidireccional para `std::list<int>`.
- El iterador se usa para recorrer la lista tanto hacia adelante como hacia atrás.

#### Algoritmos de la STL con Iteradores Bidireccionales

Los iteradores bidireccionales pueden ser utilizados en muchos algoritmos de la STL que requieren la capacidad de leer y escribir elementos en ambas direcciones.

##### Ejemplo con `std::reverse`

```cpp
#include <iostream>
#include <list>
#include <algorithm>

int main() {
    std::list<int> lst = {5, 3, 8, 1, 9};

    // Usar std::reverse para invertir la lista
    std::reverse(lst.begin(), lst.end());

    // Mostrar los elementos de la lista invertida
    for (const int& val : lst) {
        std::cout << val << " ";
    }
    std::cout << std::endl;

    return 0;
}
```

En este ejemplo:
- `std::reverse` se utiliza para invertir los elementos de la lista utilizando iteradores bidireccionales.

#### Iteradores Constantes Bidireccionales

Los iteradores constantes bidireccionales (`const_bidirectional_iterator`) se utilizan para recorrer contenedores sin modificar los elementos.

##### Ejemplo de Iteradores Constantes

```cpp
#include <iostream>
#include <list>

int main() {
    std::list<int> lst = {1, 2, 3, 4, 5};

    // Iterador constante bidireccional
    std::list<int>::const_iterator it = lst.cbegin();

    // Recorrer y mostrar los elementos hacia adelante
    std::cout << "Adelante: ";
    while (it != lst.cend()) {
        std::cout << *it << " ";
        ++it;
    }
    std::cout << std::endl;

    // Recorrer y mostrar los elementos hacia atrás
    std::cout << "Atrás: ";
    it = lst.cend();
    do {
        --it;
        std::cout << *it << " ";
    } while (it != lst.cbegin());
    std::cout << std::endl;

    return 0;
}
```

En este ejemplo:
- `std::list<int>::const_iterator` es el tipo de iterador constante bidireccional para `std::list<int>`.
- El iterador constante se usa para recorrer la lista tanto hacia adelante como hacia atrás sin modificar los elementos.

### Implementación Personalizada de un Iterador Bidireccional

Si es necesario, se pueden definir iteradores bidireccionales personalizados para estructuras de datos no estándar.

##### Ejemplo de Implementación Personalizada

```cpp
#include <iostream>
#include <iterator>
#include <vector>

template <typename T>
class BidirectionalIterator : public std::iterator<std::bidirectional_iterator_tag, T> {
    T* ptr;

public:
    BidirectionalIterator(T* p = nullptr) : ptr(p) {}

    T& operator*() const { return *ptr; }
    T* operator->() const { return ptr; }

    BidirectionalIterator& operator++() {
        ++ptr;
        return *this;
    }

    BidirectionalIterator operator++(int) {
        BidirectionalIterator temp = *this;
        ++(*this);
        return temp;
    }

    BidirectionalIterator& operator--() {
        --ptr;
        return *this;
    }

    BidirectionalIterator operator--(int) {
        BidirectionalIterator temp = *this;
        --(*this);
        return temp;
    }

    bool operator==(const BidirectionalIterator& other) const {
        return ptr == other.ptr;
    }

    bool operator!=(const BidirectionalIterator& other) const {
        return ptr != other.ptr;
    }
};

int main() {
    std::vector<int> vec = {1, 2, 3, 4, 5};

    BidirectionalIterator<int> itBegin(vec.data());
    BidirectionalIterator<int> itEnd(vec.data() + vec.size());

    // Recorrer y mostrar los elementos hacia adelante
    std::cout << "Adelante: ";
    for (auto it = itBegin; it != itEnd; ++it) {
        std::cout << *it << " ";
    }
    std::cout << std::endl;

    // Recorrer y mostrar los elementos hacia atrás
    std::cout << "Atrás: ";
    for (auto it = itEnd; it != itBegin;) {
        --it;
        std::cout << *it << " ";
    }
    std::cout << std::endl;

    return 0;
}
```

En este ejemplo:
- `BidirectionalIterator` es un iterador bidireccional personalizado que puede recorrer un `std::vector<int>` tanto hacia adelante como hacia atrás.

### Conclusión

Los iteradores bidireccionales son una herramienta flexible y poderosa en C++ que permiten recorrer y manipular elementos en una secuencia en ambas direcciones. Proporcionan una interfaz unificada para acceder y modificar elementos en diferentes tipos de contenedores y se integran bien con los algoritmos de la STL. Comprender cómo utilizar y, si es necesario, implementar iteradores bidireccionales personalizados es esencial para escribir código C++ robusto y eficiente.
### Obtener Iteradores de un Contenedor en C++

En C++, los contenedores de la biblioteca estándar (STL) proporcionan métodos para obtener iteradores que permiten recorrer y manipular los elementos dentro del contenedor. Los métodos más comunes para obtener iteradores son `begin()`, `end()`, `cbegin()`, y `cend()`. Aquí se describen estos métodos y se presentan ejemplos prácticos de su uso.

#### Métodos para Obtener Iteradores

1. **`begin()` y `end()`:** Devuelven un iterador al primer elemento y un iterador al elemento siguiente al último, respectivamente. Estos métodos permiten la modificación de los elementos del contenedor.
2. **`cbegin()` y `cend()`:** Devuelven un iterador constante al primer elemento y un iterador constante al elemento siguiente al último, respectivamente. Estos métodos no permiten la modificación de los elementos del contenedor.

### Ejemplos Prácticos

#### Uso de `begin()` y `end()`

Estos métodos se utilizan para obtener iteradores que permiten recorrer y modificar los elementos de un contenedor.

##### Ejemplo con `std::vector`

```cpp
#include <iostream>
#include <vector>

int main() {
    std::vector<int> vec = {1, 2, 3, 4, 5};

    // Obtener iteradores a los elementos del vector
    std::vector<int>::iterator itBegin = vec.begin();
    std::vector<int>::iterator itEnd = vec.end();

    // Recorrer y modificar los elementos del vector
    for (auto it = itBegin; it != itEnd; ++it) {
        *it *= 2;  // Duplicar cada elemento
    }

    // Mostrar los elementos modificados
    for (const auto& val : vec) {
        std::cout << val << " ";
    }
    std::cout << std::endl;

    return 0;
}
```

En este ejemplo:
- `vec.begin()` devuelve un iterador al primer elemento del vector.
- `vec.end()` devuelve un iterador al elemento siguiente al último del vector.
- Los elementos del vector se duplican utilizando el iterador.

#### Uso de `cbegin()` y `cend()`

Estos métodos se utilizan para obtener iteradores constantes que permiten recorrer los elementos de un contenedor sin modificarlos.

##### Ejemplo con `std::vector`

```cpp
#include <iostream>
#include <vector>

int main() {
    std::vector<int> vec = {1, 2, 3, 4, 5};

    // Obtener iteradores constantes a los elementos del vector
    std::vector<int>::const_iterator itBegin = vec.cbegin();
    std::vector<int>::const_iterator itEnd = vec.cend();

    // Recorrer y mostrar los elementos del vector sin modificarlos
    for (auto it = itBegin; it != itEnd; ++it) {
        std::cout << *it << " ";
    }
    std::cout << std::endl;

    return 0;
}
```

En este ejemplo:
- `vec.cbegin()` devuelve un iterador constante al primer elemento del vector.
- `vec.cend()` devuelve un iterador constante al elemento siguiente al último del vector.
- Los elementos del vector se muestran sin modificarse utilizando el iterador constante.

#### Uso con Otros Contenedores de la STL

Los métodos `begin()`, `end()`, `cbegin()`, y `cend()` también se pueden utilizar con otros contenedores de la STL como `std::list`, `std::set`, `std::map`, etc.

##### Ejemplo con `std::list`

```cpp
#include <iostream>
#include <list>

int main() {
    std::list<int> lst = {1, 2, 3, 4, 5};

    // Obtener iteradores a los elementos de la lista
    std::list<int>::iterator itBegin = lst.begin();
    std::list<int>::iterator itEnd = lst.end();

    // Recorrer y modificar los elementos de la lista
    for (auto it = itBegin; it != itEnd; ++it) {
        *it *= 2;  // Duplicar cada elemento
    }

    // Mostrar los elementos modificados
    for (const auto& val : lst) {
        std::cout << val << " ";
    }
    std::cout << std::endl;

    return 0;
}
```

En este ejemplo:
- `lst.begin()` devuelve un iterador al primer elemento de la lista.
- `lst.end()` devuelve un iterador al elemento siguiente al último de la lista.
- Los elementos de la lista se duplican utilizando el iterador.

#### Uso con `std::map`

```cpp
#include <iostream>
#include <map>

int main() {
    std::map<int, std::string> mapa = {{1, "uno"}, {2, "dos"}, {3, "tres"}};

    // Obtener iteradores a los elementos del mapa
    std::map<int, std::string>::iterator itBegin = mapa.begin();
    std::map<int, std::string>::iterator itEnd = mapa.end();

    // Recorrer y modificar los valores del mapa
    for (auto it = itBegin; it != itEnd; ++it) {
        it->second = "modificado";  // Modificar cada valor
    }

    // Mostrar los elementos modificados
    for (const auto& par : mapa) {
        std::cout << par.first << ": " << par.second << std::endl;
    }

    return 0;
}
```

En este ejemplo:
- `mapa.begin()` devuelve un iterador al primer elemento del mapa.
- `mapa.end()` devuelve un iterador al elemento siguiente al último del mapa.
- Los valores del mapa se modifican utilizando el iterador.

### Conclusión

Los métodos `begin()`, `end()`, `cbegin()`, y `cend()` proporcionan una manera uniforme de obtener iteradores para recorrer y manipular elementos en los contenedores de la STL. Estos iteradores permiten una navegación eficiente y segura a través de los elementos del contenedor, ya sea para lectura o modificación. Comprender cómo obtener y utilizar estos iteradores es fundamental para aprovechar al máximo las capacidades de la biblioteca estándar de C++ y escribir código robusto y eficiente.
### Operaciones Permitidas en el Ámbito de Contenedores en C++

Los contenedores en C++ proporcionan una variedad de operaciones que permiten la manipulación eficiente de los elementos que almacenan. Estas operaciones incluyen la inserción, eliminación, acceso y modificación de elementos, así como la consulta del tamaño y la capacidad del contenedor. Aquí se describen las operaciones comunes disponibles para los contenedores estándar en C++.

#### Operaciones Comunes para Todos los Contenedores

1. **Inserción de Elementos**
2. **Eliminación de Elementos**
3. **Acceso a Elementos**
4. **Modificación de Elementos**
5. **Consulta de Tamaño y Capacidad**
6. **Iteradores**
7. **Otras Operaciones Específicas de Contenedores**

### 1. Inserción de Elementos

##### `push_back()`

Inserta un elemento al final del contenedor.

```cpp
#include <vector>
#include <iostream>

int main() {
    std::vector<int> vec;
    vec.push_back(1);
    vec.push_back(2);
    vec.push_back(3);

    for (int v : vec) {
        std::cout << v << " ";
    }
    std::cout << std::endl;

    return 0;
}
```

##### `insert()`

Inserta un elemento o un rango de elementos en una posición específica.

```cpp
#include <list>
#include <iostream>

int main() {
    std::list<int> lst = {1, 2, 3};
    auto it = lst.begin();
    ++it;
    lst.insert(it, 4);  // Inserta 4 antes de 2

    for (int v : lst) {
        std::cout << v << " ";
    }
    std::cout << std::endl;

    return 0;
}
```

### 2. Eliminación de Elementos

##### `pop_back()`

Elimina el último elemento del contenedor.

```cpp
#include <vector>
#include <iostream>

int main() {
    std::vector<int> vec = {1, 2, 3};
    vec.pop_back();

    for (int v : vec) {
        std::cout << v << " ";
    }
    std::cout << std::endl;

    return 0;
}
```

##### `erase()`

Elimina un elemento o un rango de elementos de una posición específica.

```cpp
#include <list>
#include <iostream>

int main() {
    std::list<int> lst = {1, 2, 3};
    auto it = lst.begin();
    ++it;
    lst.erase(it);  // Elimina 2

    for (int v : lst) {
        std::cout << v << " ";
    }
    std::cout << std::endl;

    return 0;
}
```

### 3. Acceso a Elementos

##### `front()`

Accede al primer elemento del contenedor.

```cpp
#include <deque>
#include <iostream>

int main() {
    std::deque<int> deq = {1, 2, 3};
    std::cout << "Primer elemento: " << deq.front() << std::endl;

    return 0;
}
```

##### `back()`

Accede al último elemento del contenedor.

```cpp
#include <deque>
#include <iostream>

int main() {
    std::deque<int> deq = {1, 2, 3};
    std::cout << "Último elemento: " << deq.back() << std::endl;

    return 0;
}
```

##### `operator[]` y `at()`

Acceden a un elemento en una posición específica (sólo para contenedores con acceso aleatorio como `std::vector` y `std::deque`).

```cpp
#include <vector>
#include <iostream>

int main() {
    std::vector<int> vec = {1, 2, 3};
    std::cout << "Elemento en la posición 1: " << vec[1] << std::endl;
    std::cout << "Elemento en la posición 2: " << vec.at(2) << std::endl;

    return 0;
}
```

### 4. Modificación de Elementos

Los elementos pueden ser modificados directamente a través de los iteradores o referencias obtenidas mediante `front()`, `back()`, `operator[]`, `at()`, o iteradores.

```cpp
#include <vector>
#include <iostream>

int main() {
    std::vector<int> vec = {1, 2, 3};
    vec[1] = 10;  // Modifica el segundo elemento

    for (int v : vec) {
        std::cout << v << " ";
    }
    std::cout << std::endl;

    return 0;
}
```

### 5. Consulta de Tamaño y Capacidad

##### `size()`

Devuelve el número de elementos en el contenedor.

```cpp
#include <vector>
#include <iostream>

int main() {
    std::vector<int> vec = {1, 2, 3};
    std::cout << "Tamaño: " << vec.size() << std::endl;

    return 0;
}
```

##### `capacity()`

Devuelve la capacidad actual del contenedor (sólo para `std::vector` y `std::deque`).

```cpp
#include <vector>
#include <iostream>

int main() {
    std::vector<int> vec = {1, 2, 3};
    std::cout << "Capacidad: " << vec.capacity() << std::endl;

    return 0;
}
```

##### `empty()`

Comprueba si el contenedor está vacío.

```cpp
#include <vector>
#include <iostream>

int main() {
    std::vector<int> vec;
    std::cout << "Está vacío: " << vec.empty() << std::endl;

    return 0;
}
```

### 6. Iteradores

##### `begin()` y `end()`

Devuelven iteradores al primer elemento y al elemento después del último, respectivamente.

```cpp
#include <vector>
#include <iostream>

int main() {
    std::vector<int> vec = {1, 2, 3};

    for (auto it = vec.begin(); it != vec.end(); ++it) {
        std::cout << *it << " ";
    }
    std::cout << std::endl;

    return 0;
}
```

##### `cbegin()` y `cend()`

Devuelven iteradores constantes al primer elemento y al elemento después del último, respectivamente.

```cpp
#include <vector>
#include <iostream>

int main() {
    std::vector<int> vec = {1, 2, 3};

    for (auto it = vec.cbegin(); it != vec.cend(); ++it) {
        std::cout << *it << " ";
    }
    std::cout << std::endl;

    return 0;
}
```

### 7. Otras Operaciones Específicas de Contenedores

##### `std::map` y `std::set`

- **`find()`**: Busca un elemento con una clave específica.
- **`count()`**: Devuelve el número de elementos con una clave específica.

```cpp
#include <map>
#include <iostream>

int main() {
    std::map<int, std::string> mapa = {{1, "uno"}, {2, "dos"}, {3, "tres"}};
    auto it = mapa.find(2);
    if (it != mapa.end()) {
        std::cout << "Encontrado: " << it->second << std::endl;
    }

    std::cout << "Número de elementos con clave 2: " << mapa.count(2) << std::endl;

    return 0;
}
```

##### `std::queue` y `std::stack`

- **`push()`**: Inserta un elemento al final (cola) o en la parte superior (pila).
- **`pop()`**: Elimina el primer elemento (cola) o el elemento superior (pila).

```cpp
#include <queue>
#include <iostream>

int main() {
    std::queue<int> q;
    q.push(1);
    q.push(2);
    q.push(3);

    std::cout << "Frente: " << q.front() << std::endl;
    q.pop();
    std::cout << "Frente después de pop: " << q.front() << std::endl;

    return 0;
}
```

### Conclusión

Los contenedores de la biblioteca estándar de C++ proporcionan una amplia gama de operaciones para manipular sus elementos de manera eficiente y segura. Comprender cómo usar estas operaciones es esencial para escribir código C++ robusto y eficiente. Estas operaciones permiten la inserción, eliminación, acceso, modificación de elementos, consulta de tamaño y capacidad, y el uso de iteradores para recorrer los elementos de los contenedores.
### Uso de Iteradores en Bucles `for` y `while` en C++

Los iteradores son una herramienta poderosa en C++ para recorrer los elementos de los contenedores de la biblioteca estándar (STL) de manera eficiente. Los iteradores se pueden utilizar tanto en bucles `for` como en bucles `while` para acceder y manipular los elementos de un contenedor.

#### Uso de Iteradores en Bucles `for`

El bucle `for` es una forma común y concisa de recorrer elementos en un contenedor utilizando iteradores.

##### Ejemplo con `std::vector` y Bucle `for`

```cpp
#include <iostream>
#include <vector>

int main() {
    std::vector<int> vec = {1, 2, 3, 4, 5};

    // Uso de iteradores en un bucle for
    for (std::vector<int>::iterator it = vec.begin(); it != vec.end(); ++it) {
        std::cout << *it << " ";
    }
    std::cout << std::endl;

    return 0;
}
```

En este ejemplo:
- `vec.begin()` devuelve un iterador al primer elemento del vector.
- `vec.end()` devuelve un iterador al elemento siguiente al último del vector.
- El bucle `for` recorre el vector desde el primer elemento hasta el elemento anterior al `end()`.

##### Ejemplo con Iteradores Constantes

```cpp
#include <iostream>
#include <vector>

int main() {
    std::vector<int> vec = {1, 2, 3, 4, 5};

    // Uso de iteradores constantes en un bucle for
    for (std::vector<int>::const_iterator it = vec.cbegin(); it != vec.cend(); ++it) {
        std::cout << *it << " ";
    }
    std::cout << std::endl;

    return 0;
}
```

En este ejemplo:
- `vec.cbegin()` devuelve un iterador constante al primer elemento del vector.
- `vec.cend()` devuelve un iterador constante al elemento siguiente al último del vector.
- El bucle `for` recorre el vector sin modificar sus elementos.

#### Uso de Iteradores en Bucles `while`

El bucle `while` proporciona una alternativa más explícita y flexible para recorrer elementos en un contenedor utilizando iteradores.

##### Ejemplo con `std::list` y Bucle `while`

```cpp
#include <iostream>
#include <list>

int main() {
    std::list<int> lst = {1, 2, 3, 4, 5};

    // Uso de iteradores en un bucle while
    std::list<int>::iterator it = lst.begin();
    while (it != lst.end()) {
        std::cout << *it << " ";
        ++it;
    }
    std::cout << std::endl;

    return 0;
}
```

En este ejemplo:
- `lst.begin()` devuelve un iterador al primer elemento de la lista.
- `lst.end()` devuelve un iterador al elemento siguiente al último de la lista.
- El bucle `while` recorre la lista desde el primer elemento hasta el elemento anterior al `end()`.

##### Ejemplo con Iteradores Constantes

```cpp
#include <iostream>
#include <list>

int main() {
    std::list<int> lst = {1, 2, 3, 4, 5};

    // Uso de iteradores constantes en un bucle while
    std::list<int>::const_iterator it = lst.cbegin();
    while (it != lst.cend()) {
        std::cout << *it << " ";
        ++it;
    }
    std::cout << std::endl;

    return 0;
}
```

En este ejemplo:
- `lst.cbegin()` devuelve un iterador constante al primer elemento de la lista.
- `lst.cend()` devuelve un iterador constante al elemento siguiente al último de la lista.
- El bucle `while` recorre la lista sin modificar sus elementos.

#### Uso de Iteradores Bidireccionales en Bucles

Los iteradores bidireccionales permiten recorrer contenedores en ambas direcciones, lo que es útil en algunos casos.

##### Ejemplo con `std::list` y Bucle `for` en Ambas Direcciones

```cpp
#include <iostream>
#include <list>

int main() {
    std::list<int> lst = {1, 2, 3, 4, 5};

    // Recorrer hacia adelante
    for (std::list<int>::iterator it = lst.begin(); it != lst.end(); ++it) {
        std::cout << *it << " ";
    }
    std::cout << std::endl;

    // Recorrer hacia atrás
    for (std::list<int>::iterator it = --lst.end(); it != --lst.begin(); --it) {
        std::cout << *it << " ";
    }
    std::cout << *lst.begin() << std::endl;  // Imprimir el primer elemento por separado

    return 0;
}
```

En este ejemplo:
- El primer bucle `for` recorre la lista hacia adelante.
- El segundo bucle `for` recorre la lista hacia atrás utilizando iteradores bidireccionales.

### Conclusión

El uso de iteradores en bucles `for` y `while` proporciona una manera flexible y eficiente de recorrer y manipular los elementos de un contenedor en C++. Los iteradores permiten una navegación segura y eficiente a través de los elementos del contenedor, ya sea para lectura o modificación. Comprender cómo utilizar iteradores con diferentes tipos de bucles es esencial para escribir código C++ robusto y eficiente.
### Diferencia entre Iterar con Índices y con Iteradores en C++

Iterar sobre los elementos de un contenedor se puede hacer utilizando índices o utilizando iteradores. Ambas técnicas tienen sus propias ventajas y desventajas, y su uso depende del tipo de contenedor y del contexto en el que se está programando. A continuación, se describen las diferencias clave entre iterar con índices y con iteradores.

#### Iterar con Índices

Iterar con índices es una técnica comúnmente utilizada con contenedores que soportan acceso aleatorio, como arrays y `std::vector`. En esta técnica, se utilizan índices para acceder a los elementos del contenedor.

##### Ventajas de Iterar con Índices

1. **Simplicidad:** La sintaxis es sencilla y directa.
2. **Acceso Directo:** Permite acceso directo a los elementos del contenedor mediante su posición.

##### Desventajas de Iterar con Índices

1. **Limitado a Contenedores con Acceso Aleatorio:** No es aplicable a todos los tipos de contenedores, como `std::list`, `std::set`, o `std::map`.
2. **Errores de Rango:** Es propenso a errores de acceso fuera de rango si no se manejan correctamente los límites del bucle.

##### Ejemplo de Iteración con Índices

```cpp
#include <iostream>
#include <vector>

int main() {
    std::vector<int> vec = {1, 2, 3, 4, 5};

    // Iterar con índices
    for (size_t i = 0; i < vec.size(); ++i) {
        std::cout << vec[i] << " ";
    }
    std::cout << std::endl;

    return 0;
}
```

#### Iterar con Iteradores

Los iteradores proporcionan una manera más generalizada y flexible de recorrer contenedores. Funcionan con cualquier tipo de contenedor que proporcione iteradores, no solo aquellos con acceso aleatorio.

##### Ventajas de Iterar con Iteradores

1. **Generalidad:** Funciona con cualquier tipo de contenedor de la STL, incluyendo `std::list`, `std::set`, y `std::map`.
2. **Seguridad:** Menos propenso a errores de rango, ya que los iteradores proporcionan métodos seguros como `begin()` y `end()`.
3. **Flexibilidad:** Permite operaciones adicionales como la modificación de elementos y la inserción/eliminación durante la iteración en contenedores que lo permiten.

##### Desventajas de Iterar con Iteradores

1. **Complejidad:** La sintaxis puede ser más compleja y menos intuitiva que el uso de índices, especialmente para principiantes.
2. **Menor Eficiencia en Algunos Casos:** Para contenedores con acceso aleatorio, el uso de índices puede ser más eficiente.

##### Ejemplo de Iteración con Iteradores

```cpp
#include <iostream>
#include <vector>

int main() {
    std::vector<int> vec = {1, 2, 3, 4, 5};

    // Iterar con iteradores
    for (std::vector<int>::iterator it = vec.begin(); it != vec.end(); ++it) {
        std::cout << *it << " ";
    }
    std::cout << std::endl;

    return 0;
}
```

### Comparación Directa

#### Con `std::vector`

##### Iteración con Índices

```cpp
#include <iostream>
#include <vector>

int main() {
    std::vector<int> vec = {1, 2, 3, 4, 5};

    // Iterar con índices
    for (size_t i = 0; i < vec.size(); ++i) {
        std::cout << vec[i] << " ";
    }
    std::cout << std::endl;

    return 0;
}
```

##### Iteración con Iteradores

```cpp
#include <iostream>
#include <vector>

int main() {
    std::vector<int> vec = {1, 2, 3, 4, 5};

    // Iterar con iteradores
    for (std::vector<int>::iterator it = vec.begin(); it != vec.end(); ++it) {
        std::cout << *it << " ";
    }
    std::cout << std::endl;

    return 0;
}
```

#### Con `std::list`

##### Iteración con Iteradores (No se puede usar índices)

```cpp
#include <iostream>
#include <list>

int main() {
    std::list<int> lst = {1, 2, 3, 4, 5};

    // Iterar con iteradores
    for (std::list<int>::iterator it = lst.begin(); it != lst.end(); ++it) {
        std::cout << *it << " ";
    }
    std::cout << std::endl;

    return 0;
}
```

### Conclusión

Iterar con índices y con iteradores son técnicas útiles en C++, cada una con sus propias ventajas y desventajas. La elección entre usar índices o iteradores depende del tipo de contenedor y del contexto específico en el que se está programando.

- **Índices:** Son más simples y directos, pero están limitados a contenedores con acceso aleatorio y son más propensos a errores de rango.
- **Iteradores:** Son más generales y seguros, funcionando con cualquier contenedor de la STL y proporcionando mayor flexibilidad, aunque pueden ser más complejos de utilizar.

Comprender cuándo y cómo utilizar cada técnica es esencial para escribir código C++ eficiente, seguro y adaptable a diferentes tipos de contenedores.
### `std::advance` y `std::distance` en C++

Las funciones `std::advance` y `std::distance` son utilidades de la biblioteca estándar de C++ que proporcionan operaciones convenientes sobre iteradores. Estas funciones son parte del encabezado `<iterator>` y se utilizan para manipular y calcular distancias entre iteradores de manera eficiente.

#### `std::advance`

`std::advance` es una función que incrementa o decrementa un iterador por un número especificado de pasos. Es útil cuando se necesita mover un iterador una cantidad específica de posiciones sin escribir bucles explícitos.

##### Sintaxis

```cpp
#include <iterator>

template <class InputIterator, class Distance>
void advance(InputIterator& it, Distance n);
```

##### Ejemplo de Uso de `std::advance`

```cpp
#include <iostream>
#include <vector>
#include <iterator>

int main() {
    std::vector<int> vec = {1, 2, 3, 4, 5};

    // Iterador al primer elemento
    std::vector<int>::iterator it = vec.begin();

    // Avanzar el iterador 3 posiciones
    std::advance(it, 3);

    // Mostrar el valor del elemento apuntado por el iterador
    std::cout << "Elemento en la posición 3: " << *it << std::endl;

    return 0;
}
```

En este ejemplo:
- `std::advance(it, 3)` mueve el iterador `it` tres posiciones hacia adelante en el vector.

#### `std::distance`

`std::distance` es una función que calcula la distancia (el número de pasos) entre dos iteradores. Es útil cuando se necesita conocer cuántos elementos hay entre dos iteradores.

##### Sintaxis

```cpp
#include <iterator>

template <class InputIterator>
typename std::iterator_traits<InputIterator>::difference_type
distance(InputIterator first, InputIterator last);
```

##### Ejemplo de Uso de `std::distance`

```cpp
#include <iostream>
#include <vector>
#include <iterator>

int main() {
    std::vector<int> vec = {1, 2, 3, 4, 5};

    // Iteradores al primer y al cuarto elemento
    std::vector<int>::iterator it1 = vec.begin();
    std::vector<int>::iterator it2 = vec.begin();
    std::advance(it2, 3);

    // Calcular la distancia entre it1 y it2
    std::cout << "Distancia entre it1 e it2: " << std::distance(it1, it2) << std::endl;

    return 0;
}
```

En este ejemplo:
- `std::distance(it1, it2)` calcula el número de elementos entre los iteradores `it1` e `it2`.

### Uso Combinado de `std::advance` y `std::distance`

A menudo, `std::advance` y `std::distance` se pueden usar juntos para realizar operaciones más complejas con iteradores.

##### Ejemplo Combinado

```cpp
#include <iostream>
#include <list>
#include <iterator>

int main() {
    std::list<int> lst = {10, 20, 30, 40, 50, 60, 70, 80, 90, 100};

    // Iterador al inicio de la lista
    std::list<int>::iterator it1 = lst.begin();

    // Avanzar el iterador 5 posiciones
    std::advance(it1, 5);

    // Iterador al final de la lista
    std::list<int>::iterator it2 = lst.end();

    // Calcular la distancia entre it1 y it2
    std::cout << "Distancia entre it1 e it2: " << std::distance(it1, it2) << std::endl;

    return 0;
}
```

En este ejemplo:
- `std::advance(it1, 5)` mueve el iterador `it1` cinco posiciones hacia adelante en la lista.
- `std::distance(it1, it2)` calcula la distancia entre `it1` e `it2`, que es el número de elementos desde la sexta posición hasta el final de la lista.

### Consideraciones de Eficiencia

- **`std::advance`:** Para iteradores de acceso aleatorio (como los de `std::vector`), `std::advance` es muy eficiente porque simplemente agrega el desplazamiento al iterador. Para iteradores de otros tipos (como los de `std::list`), puede ser menos eficiente porque debe recorrer la secuencia paso a paso.
- **`std::distance`:** Similar a `std::advance`, es muy eficiente para iteradores de acceso aleatorio porque puede calcular la distancia en tiempo constante. Para otros tipos de iteradores, la eficiencia depende de tener que recorrer la secuencia para contar los elementos.

### Conclusión

`std::advance` y `std::distance` son funciones muy útiles para manipular y calcular posiciones de iteradores de manera eficiente en C++. Permiten escribir código más limpio y legible, evitando la necesidad de bucles explícitos para mover iteradores o calcular distancias entre ellos. Comprender cómo y cuándo usar estas funciones es esencial para trabajar de manera efectiva con iteradores en C++.
### `std::next` y `std::prev` en C++

Las funciones `std::next` y `std::prev` son utilidades de la biblioteca estándar de C++ que proporcionan una forma conveniente de obtener iteradores desplazados desde una posición dada. Estas funciones son parte del encabezado `<iterator>` y permiten avanzar o retroceder iteradores sin modificar el iterador original.

#### `std::next`

`std::next` devuelve un iterador que es el resultado de avanzar un iterador dado un número específico de posiciones. No modifica el iterador original.

##### Sintaxis

```cpp
#include <iterator>

template <class ForwardIterator>
ForwardIterator next(ForwardIterator it, typename std::iterator_traits<ForwardIterator>::difference_type n = 1);
```

- `it`: El iterador desde el cual se comenzará.
- `n`: El número de posiciones a avanzar (por defecto es 1).

##### Ejemplo de Uso de `std::next`

```cpp
#include <iostream>
#include <vector>
#include <iterator>

int main() {
    std::vector<int> vec = {10, 20, 30, 40, 50};

    // Obtener un iterador 3 posiciones adelante desde el comienzo
    auto it = std::next(vec.begin(), 3);

    // Mostrar el valor del elemento apuntado por el nuevo iterador
    std::cout << "Elemento en la posición 3: " << *it << std::endl;

    return 0;
}
```

En este ejemplo:
- `std::next(vec.begin(), 3)` devuelve un iterador que apunta al cuarto elemento del vector.

#### `std::prev`

`std::prev` devuelve un iterador que es el resultado de retroceder un iterador dado un número específico de posiciones. No modifica el iterador original.

##### Sintaxis

```cpp
#include <iterator>

template <class BidirectionalIterator>
BidirectionalIterator prev(BidirectionalIterator it, typename std::iterator_traits<BidirectionalIterator>::difference_type n = 1);
```

- `it`: El iterador desde el cual se comenzará.
- `n`: El número de posiciones a retroceder (por defecto es 1).

##### Ejemplo de Uso de `std::prev`

```cpp
#include <iostream>
#include <list>
#include <iterator>

int main() {
    std::list<int> lst = {10, 20, 30, 40, 50};

    // Obtener un iterador 2 posiciones atrás desde el final
    auto it = std::prev(lst.end(), 2);

    // Mostrar el valor del elemento apuntado por el nuevo iterador
    std::cout << "Elemento 2 posiciones antes del final: " << *it << std::endl;

    return 0;
}
```

En este ejemplo:
- `std::prev(lst.end(), 2)` devuelve un iterador que apunta al cuarto elemento de la lista (penúltimo elemento).

### Uso Combinado de `std::next` y `std::prev`

A menudo, `std::next` y `std::prev` se pueden usar juntos para realizar operaciones más complejas con iteradores.

##### Ejemplo Combinado

```cpp
#include <iostream>
#include <vector>
#include <iterator>

int main() {
    std::vector<int> vec = {10, 20, 30, 40, 50};

    // Obtener iteradores avanzando y retrocediendo
    auto it1 = std::next(vec.begin(), 2);  // Avanzar 2 posiciones desde el inicio
    auto it2 = std::prev(vec.end(), 3);    // Retroceder 3 posiciones desde el final

    // Mostrar los valores apuntados por los iteradores
    std::cout << "Elemento en la posición 2 desde el inicio: " << *it1 << std::endl;
    std::cout << "Elemento en la posición 3 desde el final: " << *it2 << std::endl;

    return 0;
}
```

En este ejemplo:
- `std::next(vec.begin(), 2)` obtiene un iterador al tercer elemento del vector.
- `std::prev(vec.end(), 3)` obtiene un iterador al tercer elemento desde el final del vector.

### Consideraciones de Eficiencia

- **`std::next`:** Es muy eficiente para iteradores de acceso aleatorio como los de `std::vector`, ya que puede calcular la nueva posición en tiempo constante. Para otros tipos de iteradores, puede ser menos eficiente porque debe avanzar paso a paso.
- **`std::prev`:** Similar a `std::next`, es eficiente para iteradores bidireccionales y de acceso aleatorio. Para otros tipos de iteradores, puede requerir retroceder paso a paso.

### Conclusión

`std::next` y `std::prev` son funciones muy útiles de la biblioteca estándar de C++ que permiten obtener iteradores desplazados sin modificar el iterador original. Son especialmente útiles cuando se necesita avanzar o retroceder iteradores de manera eficiente y legible. Comprender cómo y cuándo usar estas funciones es esencial para trabajar de manera efectiva con iteradores en C++.
<---FILES--->
Tipos de Iteradores
Tipos de Iteradores Result
Ejemplo Básico
Ejemplo Básico Result
Ejemplo de Iteradores Constantes
Ejemplo de Iteradores Constantes Result
Tipos de Iteradores
Tipos de Iteradores Result
Ejemplo Básico
Ejemplo Básico Result
Ejemplo de Iteradores Constantes
Ejemplo de Iteradores Constantes Result
Ejemplo Básico con `std::istream_iterator`
Ejemplo Básico con `std::istream_iterator` Result
Ejemplo con `std::copy`
Ejemplo con `std::copy` Result
Ejemplo de Implementación Personalizada
Ejemplo de Implementación Personalizada Result
Tipos de Iteradores
Tipos de Iteradores Result
Ejemplo Básico
Ejemplo Básico Result
Ejemplo de Iteradores Constantes
Ejemplo de Iteradores Constantes Result
Ejemplo Básico con `std::istream_iterator`
Ejemplo Básico con `std::istream_iterator` Result
Ejemplo con `std::copy`
Ejemplo con `std::copy` Result
Ejemplo de Implementación Personalizada
Ejemplo de Implementación Personalizada Result
Ejemplo Básico con `std::ostream_iterator`
Ejemplo Básico con `std::ostream_iterator` Result
Tipos de Iteradores
Tipos de Iteradores Result
Ejemplo Básico
Ejemplo Básico Result
Ejemplo de Iteradores Constantes
Ejemplo de Iteradores Constantes Result
Ejemplo Básico con `std::istream_iterator`
Ejemplo Básico con `std::istream_iterator` Result
Ejemplo con `std::copy`
Ejemplo con `std::copy` Result
Ejemplo de Implementación Personalizada
Ejemplo de Implementación Personalizada Result
Ejemplo Básico con `std::ostream_iterator`
Ejemplo Básico con `std::ostream_iterator` Result
Ejemplo Básico con `std::forward_list`
Ejemplo Básico con `std::forward_list` Result
Ejemplo con `std::find`
Ejemplo con `std::find` Result
Ejemplo con `std::transform`
Ejemplo con `std::transform` Result
Tipos de Iteradores
Tipos de Iteradores Result
Ejemplo Básico
Ejemplo Básico Result
Ejemplo de Iteradores Constantes
Ejemplo de Iteradores Constantes Result
Ejemplo Básico con `std::istream_iterator`
Ejemplo Básico con `std::istream_iterator` Result
Ejemplo con `std::copy`
Ejemplo con `std::copy` Result
Ejemplo de Implementación Personalizada
Ejemplo de Implementación Personalizada Result
Ejemplo Básico con `std::ostream_iterator`
Ejemplo Básico con `std::ostream_iterator` Result
Ejemplo Básico con `std::forward_list`
Ejemplo Básico con `std::forward_list` Result
Ejemplo con `std::find`
Ejemplo con `std::find` Result
Ejemplo con `std::transform`
Ejemplo con `std::transform` Result
Ejemplo Básico con `std::list`
Ejemplo Básico con `std::list` Result
Ejemplo con `std::reverse`
Ejemplo con `std::reverse` Result
Tipos de Iteradores
Tipos de Iteradores Result
Ejemplo Básico
Ejemplo Básico Result
Ejemplo de Iteradores Constantes
Ejemplo de Iteradores Constantes Result
Ejemplo Básico con `std::istream_iterator`
Ejemplo Básico con `std::istream_iterator` Result
Ejemplo con `std::copy`
Ejemplo con `std::copy` Result
Ejemplo de Implementación Personalizada
Ejemplo de Implementación Personalizada Result
Ejemplo Básico con `std::ostream_iterator`
Ejemplo Básico con `std::ostream_iterator` Result
Ejemplo Básico con `std::forward_list`
Ejemplo Básico con `std::forward_list` Result
Ejemplo con `std::find`
Ejemplo con `std::find` Result
Ejemplo con `std::transform`
Ejemplo con `std::transform` Result
Ejemplo Básico con `std::list`
Ejemplo Básico con `std::list` Result
Ejemplo con `std::reverse`
Ejemplo con `std::reverse` Result
Ejemplo con `std::vector`
Ejemplo con `std::vector` Result
Ejemplo con `std::list`
Ejemplo con `std::list` Result
Tipos de Iteradores
Tipos de Iteradores Result
Ejemplo Básico
Ejemplo Básico Result
Ejemplo de Iteradores Constantes
Ejemplo de Iteradores Constantes Result
Ejemplo Básico con `std::istream_iterator`
Ejemplo Básico con `std::istream_iterator` Result
Ejemplo con `std::copy`
Ejemplo con `std::copy` Result
Ejemplo de Implementación Personalizada
Ejemplo de Implementación Personalizada Result
Ejemplo Básico con `std::ostream_iterator`
Ejemplo Básico con `std::ostream_iterator` Result
Ejemplo Básico con `std::forward_list`
Ejemplo Básico con `std::forward_list` Result
Ejemplo con `std::find`
Ejemplo con `std::find` Result
Ejemplo con `std::transform`
Ejemplo con `std::transform` Result
Ejemplo Básico con `std::list`
Ejemplo Básico con `std::list` Result
Ejemplo con `std::reverse`
Ejemplo con `std::reverse` Result
Ejemplo con `std::vector`
Ejemplo con `std::vector` Result
Ejemplo con `std::list`
Ejemplo con `std::list` Result
`push_back()`
`push_back()` Result
`insert()`
`insert()` Result
`pop_back()`
`pop_back()` Result
`erase()`
`erase()` Result
`front()`
`front()` Result
`back()`
`back()` Result
`operator[]` y `at()`
`operator[]` y `at()` Result
`size()`
`size()` Result
`capacity()`
`capacity()` Result
`empty()`
`empty()` Result
`begin()` y `end()`
`begin()` y `end()` Result
`cbegin()` y `cend()`
`cbegin()` y `cend()` Result
`std::map` y `std::set`
`std::map` y `std::set` Result
`std::queue` y `std::stack`
`std::queue` y `std::stack` Result
Tipos de Iteradores
Tipos de Iteradores Result
Ejemplo Básico
Ejemplo Básico Result
Ejemplo de Iteradores Constantes
Ejemplo de Iteradores Constantes Result
Ejemplo Básico con `std::istream_iterator`
Ejemplo Básico con `std::istream_iterator` Result
Ejemplo con `std::copy`
Ejemplo con `std::copy` Result
Ejemplo de Implementación Personalizada
Ejemplo de Implementación Personalizada Result
Ejemplo Básico con `std::ostream_iterator`
Ejemplo Básico con `std::ostream_iterator` Result
Ejemplo Básico con `std::forward_list`
Ejemplo Básico con `std::forward_list` Result
Ejemplo con `std::find`
Ejemplo con `std::find` Result
Ejemplo con `std::transform`
Ejemplo con `std::transform` Result
Ejemplo Básico con `std::list`
Ejemplo Básico con `std::list` Result
Ejemplo con `std::reverse`
Ejemplo con `std::reverse` Result
Ejemplo con `std::vector`
Ejemplo con `std::vector` Result
Ejemplo con `std::list`
Ejemplo con `std::list` Result
`push_back()`
`push_back()` Result
`insert()`
`insert()` Result
`pop_back()`
`pop_back()` Result
`erase()`
`erase()` Result
`front()`
`front()` Result
`back()`
`back()` Result
`operator[]` y `at()`
`operator[]` y `at()` Result
`size()`
`size()` Result
`capacity()`
`capacity()` Result
`empty()`
`empty()` Result
`begin()` y `end()`
`begin()` y `end()` Result
`cbegin()` y `cend()`
`cbegin()` y `cend()` Result
`std::map` y `std::set`
`std::map` y `std::set` Result
`std::queue` y `std::stack`
`std::queue` y `std::stack` Result
Ejemplo con `std::vector` y Bucle `for`
Ejemplo con `std::vector` y Bucle `for` Result
Ejemplo con Iteradores Constantes
Ejemplo con Iteradores Constantes Result
Ejemplo con `std::list` y Bucle `while`
Ejemplo con `std::list` y Bucle `while` Result
Ejemplo con `std::list` y Bucle `for` en Ambas Direcciones
Ejemplo con `std::list` y Bucle `for` en Ambas Direcciones Result
Tipos de Iteradores
Tipos de Iteradores Result
Ejemplo Básico
Ejemplo Básico Result
Ejemplo de Iteradores Constantes
Ejemplo de Iteradores Constantes Result
Ejemplo Básico con `std::istream_iterator`
Ejemplo Básico con `std::istream_iterator` Result
Ejemplo con `std::copy`
Ejemplo con `std::copy` Result
Ejemplo de Implementación Personalizada
Ejemplo de Implementación Personalizada Result
Ejemplo Básico con `std::ostream_iterator`
Ejemplo Básico con `std::ostream_iterator` Result
Ejemplo Básico con `std::forward_list`
Ejemplo Básico con `std::forward_list` Result
Ejemplo con `std::find`
Ejemplo con `std::find` Result
Ejemplo con `std::transform`
Ejemplo con `std::transform` Result
Ejemplo Básico con `std::list`
Ejemplo Básico con `std::list` Result
Ejemplo con `std::reverse`
Ejemplo con `std::reverse` Result
Ejemplo con `std::vector`
Ejemplo con `std::vector` Result
Ejemplo con `std::list`
Ejemplo con `std::list` Result
`push_back()`
`push_back()` Result
`insert()`
`insert()` Result
`pop_back()`
`pop_back()` Result
`erase()`
`erase()` Result
`front()`
`front()` Result
`back()`
`back()` Result
`operator[]` y `at()`
`operator[]` y `at()` Result
`size()`
`size()` Result
`capacity()`
`capacity()` Result
`empty()`
`empty()` Result
`begin()` y `end()`
`begin()` y `end()` Result
`cbegin()` y `cend()`
`cbegin()` y `cend()` Result
`std::map` y `std::set`
`std::map` y `std::set` Result
`std::queue` y `std::stack`
`std::queue` y `std::stack` Result
Ejemplo con `std::vector` y Bucle `for`
Ejemplo con `std::vector` y Bucle `for` Result
Ejemplo con Iteradores Constantes
Ejemplo con Iteradores Constantes Result
Ejemplo con `std::list` y Bucle `while`
Ejemplo con `std::list` y Bucle `while` Result
Ejemplo con `std::list` y Bucle `for` en Ambas Direcciones
Ejemplo con `std::list` y Bucle `for` en Ambas Direcciones Result
Ventajas de Iterar con Índices
Ventajas de Iterar con Índices Result
Desventajas de Iterar con Índices
Desventajas de Iterar con Índices Result
Ejemplo de Iteración con Índices
Ejemplo de Iteración con Índices Result
Ventajas de Iterar con Iteradores
Ventajas de Iterar con Iteradores Result
Desventajas de Iterar con Iteradores
Desventajas de Iterar con Iteradores Result
Ejemplo de Iteración con Iteradores
Ejemplo de Iteración con Iteradores Result
Iteración con Índices
Iteración con Índices Result
Iteración con Iteradores
Iteración con Iteradores Result
Iteración con Iteradores (No se puede usar índices)
Iteración con Iteradores (No se puede usar índices) Result
Tipos de Iteradores
Tipos de Iteradores Result
Ejemplo Básico
Ejemplo Básico Result
Ejemplo de Iteradores Constantes
Ejemplo de Iteradores Constantes Result
Ejemplo Básico con `std::istream_iterator`
Ejemplo Básico con `std::istream_iterator` Result
Ejemplo con `std::copy`
Ejemplo con `std::copy` Result
Ejemplo de Implementación Personalizada
Ejemplo de Implementación Personalizada Result
Ejemplo Básico con `std::ostream_iterator`
Ejemplo Básico con `std::ostream_iterator` Result
Ejemplo Básico con `std::forward_list`
Ejemplo Básico con `std::forward_list` Result
Ejemplo con `std::find`
Ejemplo con `std::find` Result
Ejemplo con `std::transform`
Ejemplo con `std::transform` Result
Ejemplo Básico con `std::list`
Ejemplo Básico con `std::list` Result
Ejemplo con `std::reverse`
Ejemplo con `std::reverse` Result
Ejemplo con `std::vector`
Ejemplo con `std::vector` Result
Ejemplo con `std::list`
Ejemplo con `std::list` Result
`push_back()`
`push_back()` Result
`insert()`
`insert()` Result
`pop_back()`
`pop_back()` Result
`erase()`
`erase()` Result
`front()`
`front()` Result
`back()`
`back()` Result
`operator[]` y `at()`
`operator[]` y `at()` Result
`size()`
`size()` Result
`capacity()`
`capacity()` Result
`empty()`
`empty()` Result
`begin()` y `end()`
`begin()` y `end()` Result
`cbegin()` y `cend()`
`cbegin()` y `cend()` Result
`std::map` y `std::set`
`std::map` y `std::set` Result
`std::queue` y `std::stack`
`std::queue` y `std::stack` Result
Ejemplo con `std::vector` y Bucle `for`
Ejemplo con `std::vector` y Bucle `for` Result
Ejemplo con Iteradores Constantes
Ejemplo con Iteradores Constantes Result
Ejemplo con `std::list` y Bucle `while`
Ejemplo con `std::list` y Bucle `while` Result
Ejemplo con `std::list` y Bucle `for` en Ambas Direcciones
Ejemplo con `std::list` y Bucle `for` en Ambas Direcciones Result
Ventajas de Iterar con Índices
Ventajas de Iterar con Índices Result
Desventajas de Iterar con Índices
Desventajas de Iterar con Índices Result
Ejemplo de Iteración con Índices
Ejemplo de Iteración con Índices Result
Ventajas de Iterar con Iteradores
Ventajas de Iterar con Iteradores Result
Desventajas de Iterar con Iteradores
Desventajas de Iterar con Iteradores Result
Ejemplo de Iteración con Iteradores
Ejemplo de Iteración con Iteradores Result
Iteración con Índices
Iteración con Índices Result
Iteración con Iteradores
Iteración con Iteradores Result
Iteración con Iteradores (No se puede usar índices)
Iteración con Iteradores (No se puede usar índices) Result
Sintaxis
Sintaxis Result
Ejemplo de Uso de `std::advance`
Ejemplo de Uso de `std::advance` Result
Ejemplo de Uso de `std::distance`
Ejemplo de Uso de `std::distance` Result
Ejemplo Combinado
Ejemplo Combinado Result
Tipos de Iteradores
Tipos de Iteradores Result
Ejemplo Básico
Ejemplo Básico Result
Ejemplo de Iteradores Constantes
Ejemplo de Iteradores Constantes Result
Ejemplo Básico con `std::istream_iterator`
Ejemplo Básico con `std::istream_iterator` Result
Ejemplo con `std::copy`
Ejemplo con `std::copy` Result
Ejemplo de Implementación Personalizada
Ejemplo de Implementación Personalizada Result
Ejemplo Básico con `std::ostream_iterator`
Ejemplo Básico con `std::ostream_iterator` Result
Ejemplo Básico con `std::forward_list`
Ejemplo Básico con `std::forward_list` Result
Ejemplo con `std::find`
Ejemplo con `std::find` Result
Ejemplo con `std::transform`
Ejemplo con `std::transform` Result
Ejemplo Básico con `std::list`
Ejemplo Básico con `std::list` Result
Ejemplo con `std::reverse`
Ejemplo con `std::reverse` Result
Ejemplo con `std::vector`
Ejemplo con `std::vector` Result
Ejemplo con `std::list`
Ejemplo con `std::list` Result
`push_back()`
`push_back()` Result
`insert()`
`insert()` Result
`pop_back()`
`pop_back()` Result
`erase()`
`erase()` Result
`front()`
`front()` Result
`back()`
`back()` Result
`operator[]` y `at()`
`operator[]` y `at()` Result
`size()`
`size()` Result
`capacity()`
`capacity()` Result
`empty()`
`empty()` Result
`begin()` y `end()`
`begin()` y `end()` Result
`cbegin()` y `cend()`
`cbegin()` y `cend()` Result
`std::map` y `std::set`
`std::map` y `std::set` Result
`std::queue` y `std::stack`
`std::queue` y `std::stack` Result
Ejemplo con `std::vector` y Bucle `for`
Ejemplo con `std::vector` y Bucle `for` Result
Ejemplo con Iteradores Constantes
Ejemplo con Iteradores Constantes Result
Ejemplo con `std::list` y Bucle `while`
Ejemplo con `std::list` y Bucle `while` Result
Ejemplo con `std::list` y Bucle `for` en Ambas Direcciones
Ejemplo con `std::list` y Bucle `for` en Ambas Direcciones Result
Ventajas de Iterar con Índices
Ventajas de Iterar con Índices Result
Desventajas de Iterar con Índices
Desventajas de Iterar con Índices Result
Ejemplo de Iteración con Índices
Ejemplo de Iteración con Índices Result
Ventajas de Iterar con Iteradores
Ventajas de Iterar con Iteradores Result
Desventajas de Iterar con Iteradores
Desventajas de Iterar con Iteradores Result
Ejemplo de Iteración con Iteradores
Ejemplo de Iteración con Iteradores Result
Iteración con Índices
Iteración con Índices Result
Iteración con Iteradores
Iteración con Iteradores Result
Iteración con Iteradores (No se puede usar índices)
Iteración con Iteradores (No se puede usar índices) Result
Sintaxis
Sintaxis Result
Ejemplo de Uso de `std::advance`
Ejemplo de Uso de `std::advance` Result
Ejemplo de Uso de `std::distance`
Ejemplo de Uso de `std::distance` Result
Ejemplo Combinado
Ejemplo Combinado Result
Ejemplo de Uso de `std::next`
Ejemplo de Uso de `std::next` Result
Ejemplo de Uso de `std::prev`
Ejemplo de Uso de `std::prev` Result
<---Tipos de Iteradores--->
<---Tipos de Iteradores Result--->
<---Ejemplo Básico--->
```cpp
#include <iostream>
#include <vector>

int main() {
    std::vector<int> vec = {1, 2, 3, 4, 5};

    // Iterador que apunta al primer elemento del vector
    std::vector<int>::iterator it = vec.begin();

    // Recorrer el vector usando el iterador
    while (it != vec.end()) {
        std::cout << *it << " ";
        ++it;  // Avanzar al siguiente elemento
    }
    std::cout << std::endl;

    return 0;
}
```cpp
#include <iostream>
#include <vector>
#include <algorithm>

int main() {
    std::vector<int> vec = {5, 2, 8, 1, 3};

    // Ordenar el vector usando std::sort
    std::sort(vec.begin(), vec.end());

    // Encontrar un elemento usando std::find
    auto it = std::find(vec.begin(), vec.end(), 8);

    if (it != vec.end()) {
        std::cout << "Elemento encontrado: " << *it << std::endl;
    } else {
        std::cout << "Elemento no encontrado" << std::endl;
    }

    return 0;
}
<---Ejemplo Básico Result--->
<---Ejemplo de Iteradores Constantes--->
```cpp
#include <iostream>
#include <vector>

int main() {
    std::vector<int> vec = {1, 2, 3, 4, 5};

    // Iterador constante
    std::vector<int>::const_iterator it = vec.cbegin();

    // Recorrer el vector usando el iterador constante
    while (it != vec.cend()) {
        std::cout << *it << " ";
        ++it;
    }
    std::cout << std::endl;

    return 0;
}
<---Ejemplo de Iteradores Constantes Result--->
<---Tipos de Iteradores--->
<---Tipos de Iteradores Result--->
<---Ejemplo Básico--->
```cpp
#include <iostream>
#include <vector>

int main() {
    std::vector<int> vec = {1, 2, 3, 4, 5};

    // Iterador que apunta al primer elemento del vector
    std::vector<int>::iterator it = vec.begin();

    // Recorrer el vector usando el iterador
    while (it != vec.end()) {
        std::cout << *it << " ";
        ++it;  // Avanzar al siguiente elemento
    }
    std::cout << std::endl;

    return 0;
}
```cpp
#include <iostream>
#include <vector>
#include <algorithm>

int main() {
    std::vector<int> vec = {5, 2, 8, 1, 3};

    // Ordenar el vector usando std::sort
    std::sort(vec.begin(), vec.end());

    // Encontrar un elemento usando std::find
    auto it = std::find(vec.begin(), vec.end(), 8);

    if (it != vec.end()) {
        std::cout << "Elemento encontrado: " << *it << std::endl;
    } else {
        std::cout << "Elemento no encontrado" << std::endl;
    }

    return 0;
}
<---Ejemplo Básico Result--->
<---Ejemplo de Iteradores Constantes--->
```cpp
#include <iostream>
#include <vector>

int main() {
    std::vector<int> vec = {1, 2, 3, 4, 5};

    // Iterador constante
    std::vector<int>::const_iterator it = vec.cbegin();

    // Recorrer el vector usando el iterador constante
    while (it != vec.cend()) {
        std::cout << *it << " ";
        ++it;
    }
    std::cout << std::endl;

    return 0;
}
<---Ejemplo de Iteradores Constantes Result--->
<---Ejemplo Básico con `std::istream_iterator`--->
```cpp
#include <iostream>
#include <iterator>
#include <vector>
#include <algorithm>

int main() {
    std::cout << "Ingrese números separados por espacios (Ctrl+D para terminar): ";

    // Crear un istream_iterator para leer desde std::cin
    std::istream_iterator<int> inicio(std::cin);
    std::istream_iterator<int> fin;  // Iterador de fin predeterminado

    // Leer todos los números ingresados en un vector
    std::vector<int> numeros(inicio, fin);

    // Mostrar los números leídos
    std::cout << "Números ingresados: ";
    for (int numero : numeros) {
        std::cout << numero << " ";
    }
    std::cout << std::endl;

    return 0;
}
<---Ejemplo Básico con `std::istream_iterator` Result--->
<---Ejemplo con `std::copy`--->
```cpp
#include <iostream>
#include <iterator>
#include <vector>
#include <algorithm>

int main() {
    std::cout << "Ingrese números separados por espacios (Ctrl+D para terminar): ";

    // Crear un istream_iterator para leer desde std::cin
    std::istream_iterator<int> inicio(std::cin);
    std::istream_iterator<int> fin;  // Iterador de fin predeterminado

    // Crear un vector para almacenar los números leídos
    std::vector<int> numeros;

    // Usar std::copy para leer los números en el vector
    std::copy(inicio, fin, std::back_inserter(numeros));

    // Mostrar los números leídos
    std::cout << "Números ingresados: ";
    for (int numero : numeros) {
        std::cout << numero << " ";
    }
    std::cout << std::endl;

    return 0;
}
<---Ejemplo con `std::copy` Result--->
<---Ejemplo de Implementación Personalizada--->
```cpp
#include <iostream>
#include <iterator>

class InputIterator : public std::iterator<std::input_iterator_tag, int> {
    std::istream* in;
    int value;

public:
    InputIterator(std::istream& s) : in(&s) {
        ++(*this);  // Leer el primer valor
    }

    InputIterator() : in(nullptr) {}

    bool operator==(const InputIterator& other) const {
        return in == other.in;
    }

    bool operator!=(const InputIterator& other) const {
        return !(*this == other);
    }

    int operator*() const {
        return value;
    }

    InputIterator& operator++() {
        if (in && !(*in >> value)) {
            in = nullptr;  // Alcanzó el final de la secuencia
        }
        return *this;
    }
};

int main() {
    std::cout << "Ingrese números separados por espacios (Ctrl+D para terminar): ";

    // Usar el iterador de entrada personalizado para leer desde std::cin
    InputIterator inicio(std::cin);
    InputIterator fin;

    // Leer todos los números ingresados en un vector
    std::vector<int> numeros(inicio, fin);

    // Mostrar los números leídos
    std::cout << "Números ingresados: ";
    for (int numero : numeros) {
        std::cout << numero << " ";
    }
    std::cout << std::endl;

    return 0;
}
<---Ejemplo de Implementación Personalizada Result--->
<---Tipos de Iteradores--->
<---Tipos de Iteradores Result--->
<---Ejemplo Básico--->
```cpp
#include <iostream>
#include <vector>

int main() {
    std::vector<int> vec = {1, 2, 3, 4, 5};

    // Iterador que apunta al primer elemento del vector
    std::vector<int>::iterator it = vec.begin();

    // Recorrer el vector usando el iterador
    while (it != vec.end()) {
        std::cout << *it << " ";
        ++it;  // Avanzar al siguiente elemento
    }
    std::cout << std::endl;

    return 0;
}
```cpp
#include <iostream>
#include <vector>
#include <algorithm>

int main() {
    std::vector<int> vec = {5, 2, 8, 1, 3};

    // Ordenar el vector usando std::sort
    std::sort(vec.begin(), vec.end());

    // Encontrar un elemento usando std::find
    auto it = std::find(vec.begin(), vec.end(), 8);

    if (it != vec.end()) {
        std::cout << "Elemento encontrado: " << *it << std::endl;
    } else {
        std::cout << "Elemento no encontrado" << std::endl;
    }

    return 0;
}
<---Ejemplo Básico Result--->
<---Ejemplo de Iteradores Constantes--->
```cpp
#include <iostream>
#include <vector>

int main() {
    std::vector<int> vec = {1, 2, 3, 4, 5};

    // Iterador constante
    std::vector<int>::const_iterator it = vec.cbegin();

    // Recorrer el vector usando el iterador constante
    while (it != vec.cend()) {
        std::cout << *it << " ";
        ++it;
    }
    std::cout << std::endl;

    return 0;
}
<---Ejemplo de Iteradores Constantes Result--->
<---Ejemplo Básico con `std::istream_iterator`--->
```cpp
#include <iostream>
#include <iterator>
#include <vector>
#include <algorithm>

int main() {
    std::cout << "Ingrese números separados por espacios (Ctrl+D para terminar): ";

    // Crear un istream_iterator para leer desde std::cin
    std::istream_iterator<int> inicio(std::cin);
    std::istream_iterator<int> fin;  // Iterador de fin predeterminado

    // Leer todos los números ingresados en un vector
    std::vector<int> numeros(inicio, fin);

    // Mostrar los números leídos
    std::cout << "Números ingresados: ";
    for (int numero : numeros) {
        std::cout << numero << " ";
    }
    std::cout << std::endl;

    return 0;
}
<---Ejemplo Básico con `std::istream_iterator` Result--->
<---Ejemplo con `std::copy`--->
```cpp
#include <iostream>
#include <iterator>
#include <vector>
#include <algorithm>

int main() {
    std::vector<int> numeros = {5, 2, 8, 1, 3};

    // Crear un ostream_iterator para escribir en std::cout
    std::ostream_iterator<int> salida(std::cout, " ");

    // Usar std::copy para escribir los números en std::cout
    std::copy(numeros.begin(), numeros.end(), salida);
    std::cout << std::endl;

    return 0;
}
<---Ejemplo con `std::copy` Result--->
<---Ejemplo de Implementación Personalizada--->
```cpp
#include <iostream>
#include <iterator>
#include <vector>

class OutputIterator : public std::iterator<std::output_iterator_tag, void, void, void, void> {
    std::ostream* out;
    std::string delimiter;

public:
    OutputIterator(std::ostream& s, const std::string& delim = " ") : out(&s), delimiter(delim) {}

    OutputIterator& operator=(int value) {
        *out << value << delimiter;
        return *this;
    }

    OutputIterator& operator*() {
        return *this;
    }

    OutputIterator& operator++() {
        return *this;
    }

    OutputIterator& operator++(int) {
        return *this;
    }
};

int main() {
    std::vector<int> numeros = {1, 2, 3, 4, 5};

    // Usar el iterador de salida personalizado para escribir en std::cout
    OutputIterator salida(std::cout, " - ");

    for (int numero : numeros) {
        *salida = numero;
        ++salida;
    }
    std::cout << std::endl;

    return 0;
}
<---Ejemplo de Implementación Personalizada Result--->
<---Ejemplo Básico con `std::ostream_iterator`--->
```cpp
#include <iostream>
#include <iterator>
#include <vector>

int main() {
    std::vector<int> numeros = {1, 2, 3, 4, 5};

    // Crear un ostream_iterator para escribir en std::cout
    std::ostream_iterator<int> salida(std::cout, " ");

    // Usar el iterador de salida para escribir los números
    for (int numero : numeros) {
        *salida = numero;
        ++salida;
    }
    std::cout << std::endl;

    return 0;
}
<---Ejemplo Básico con `std::ostream_iterator` Result--->
<---Tipos de Iteradores--->
<---Tipos de Iteradores Result--->
<---Ejemplo Básico--->
```cpp
#include <iostream>
#include <vector>

int main() {
    std::vector<int> vec = {1, 2, 3, 4, 5};

    // Iterador que apunta al primer elemento del vector
    std::vector<int>::iterator it = vec.begin();

    // Recorrer el vector usando el iterador
    while (it != vec.end()) {
        std::cout << *it << " ";
        ++it;  // Avanzar al siguiente elemento
    }
    std::cout << std::endl;

    return 0;
}
```cpp
#include <iostream>
#include <vector>
#include <algorithm>

int main() {
    std::vector<int> vec = {5, 2, 8, 1, 3};

    // Ordenar el vector usando std::sort
    std::sort(vec.begin(), vec.end());

    // Encontrar un elemento usando std::find
    auto it = std::find(vec.begin(), vec.end(), 8);

    if (it != vec.end()) {
        std::cout << "Elemento encontrado: " << *it << std::endl;
    } else {
        std::cout << "Elemento no encontrado" << std::endl;
    }

    return 0;
}
<---Ejemplo Básico Result--->
<---Ejemplo de Iteradores Constantes--->
```cpp
#include <iostream>
#include <forward_list>

int main() {
    std::forward_list<int> flist = {1, 2, 3, 4, 5};

    // Iterador constante de avance
    std::forward_list<int>::const_iterator it = flist.cbegin();

    // Recorrer y mostrar los elementos
    while (it != flist.cend()) {
        std::cout << *it << " ";
        ++it;
    }
    std::cout << std::endl;

    return 0;
}
<---Ejemplo de Iteradores Constantes Result--->
<---Ejemplo Básico con `std::istream_iterator`--->
```cpp
#include <iostream>
#include <iterator>
#include <vector>
#include <algorithm>

int main() {
    std::cout << "Ingrese números separados por espacios (Ctrl+D para terminar): ";

    // Crear un istream_iterator para leer desde std::cin
    std::istream_iterator<int> inicio(std::cin);
    std::istream_iterator<int> fin;  // Iterador de fin predeterminado

    // Leer todos los números ingresados en un vector
    std::vector<int> numeros(inicio, fin);

    // Mostrar los números leídos
    std::cout << "Números ingresados: ";
    for (int numero : numeros) {
        std::cout << numero << " ";
    }
    std::cout << std::endl;

    return 0;
}
<---Ejemplo Básico con `std::istream_iterator` Result--->
<---Ejemplo con `std::copy`--->
```cpp
#include <iostream>
#include <iterator>
#include <vector>
#include <algorithm>

int main() {
    std::vector<int> numeros = {5, 2, 8, 1, 3};

    // Crear un ostream_iterator para escribir en std::cout
    std::ostream_iterator<int> salida(std::cout, " ");

    // Usar std::copy para escribir los números en std::cout
    std::copy(numeros.begin(), numeros.end(), salida);
    std::cout << std::endl;

    return 0;
}
<---Ejemplo con `std::copy` Result--->
<---Ejemplo de Implementación Personalizada--->
```cpp
#include <iostream>
#include <iterator>
#include <vector>

class OutputIterator : public std::iterator<std::output_iterator_tag, void, void, void, void> {
    std::ostream* out;
    std::string delimiter;

public:
    OutputIterator(std::ostream& s, const std::string& delim = " ") : out(&s), delimiter(delim) {}

    OutputIterator& operator=(int value) {
        *out << value << delimiter;
        return *this;
    }

    OutputIterator& operator*() {
        return *this;
    }

    OutputIterator& operator++() {
        return *this;
    }

    OutputIterator& operator++(int) {
        return *this;
    }
};

int main() {
    std::vector<int> numeros = {1, 2, 3, 4, 5};

    // Usar el iterador de salida personalizado para escribir en std::cout
    OutputIterator salida(std::cout, " - ");

    for (int numero : numeros) {
        *salida = numero;
        ++salida;
    }
    std::cout << std::endl;

    return 0;
}
<---Ejemplo de Implementación Personalizada Result--->
<---Ejemplo Básico con `std::ostream_iterator`--->
```cpp
#include <iostream>
#include <iterator>
#include <vector>

int main() {
    std::vector<int> numeros = {1, 2, 3, 4, 5};

    // Crear un ostream_iterator para escribir en std::cout
    std::ostream_iterator<int> salida(std::cout, " ");

    // Usar el iterador de salida para escribir los números
    for (int numero : numeros) {
        *salida = numero;
        ++salida;
    }
    std::cout << std::endl;

    return 0;
}
<---Ejemplo Básico con `std::ostream_iterator` Result--->
<---Ejemplo Básico con `std::forward_list`--->
```cpp
#include <iostream>
#include <forward_list>

int main() {
    std::forward_list<int> flist = {1, 2, 3, 4, 5};

    // Iterador de avance
    std::forward_list<int>::iterator it = flist.begin();

    // Recorrer y mostrar los elementos
    while (it != flist.end()) {
        std::cout << *it << " ";
        ++it;
    }
    std::cout << std::endl;

    return 0;
}
<---Ejemplo Básico con `std::forward_list` Result--->
<---Ejemplo con `std::find`--->
```cpp
#include <iostream>
#include <forward_list>
#include <algorithm>

int main() {
    std::forward_list<int> flist = {5, 3, 8, 1, 9};

    // Buscar un elemento usando std::find
    auto it = std::find(flist.begin(), flist.end(), 8);

    if (it != flist.end()) {
        std::cout << "Elemento encontrado: " << *it << std::endl;
    } else {
        std::cout << "Elemento no encontrado" << std::endl;
    }

    return 0;
}
<---Ejemplo con `std::find` Result--->
<---Ejemplo con `std::transform`--->
```cpp
#include <iostream>
#include <forward_list>
#include <algorithm>

int main() {
    std::forward_list<int> flist = {1, 2, 3, 4, 5};
    std::forward_list<int> resultado;

    // Reservar espacio en la lista de resultado
    resultado.resize(flist.size());

    // Usar std::transform para multiplicar cada elemento por 2
    std::transform(flist.begin(), flist.end(), resultado.begin(), [](int x) {
        return x * 2;
    });

    // Mostrar los resultados
    for (const auto& val : resultado) {
        std::cout << val << " ";
    }
    std::cout << std::endl;

    return 0;
}
<---Ejemplo con `std::transform` Result--->
<---Tipos de Iteradores--->
<---Tipos de Iteradores Result--->
<---Ejemplo Básico--->
```cpp
#include <iostream>
#include <vector>

int main() {
    std::vector<int> vec = {1, 2, 3, 4, 5};

    // Iterador que apunta al primer elemento del vector
    std::vector<int>::iterator it = vec.begin();

    // Recorrer el vector usando el iterador
    while (it != vec.end()) {
        std::cout << *it << " ";
        ++it;  // Avanzar al siguiente elemento
    }
    std::cout << std::endl;

    return 0;
}
```cpp
#include <iostream>
#include <vector>
#include <algorithm>

int main() {
    std::vector<int> vec = {5, 2, 8, 1, 3};

    // Ordenar el vector usando std::sort
    std::sort(vec.begin(), vec.end());

    // Encontrar un elemento usando std::find
    auto it = std::find(vec.begin(), vec.end(), 8);

    if (it != vec.end()) {
        std::cout << "Elemento encontrado: " << *it << std::endl;
    } else {
        std::cout << "Elemento no encontrado" << std::endl;
    }

    return 0;
}
<---Ejemplo Básico Result--->
<---Ejemplo de Iteradores Constantes--->
```cpp
#include <iostream>
#include <list>

int main() {
    std::list<int> lst = {1, 2, 3, 4, 5};

    // Iterador constante bidireccional
    std::list<int>::const_iterator it = lst.cbegin();

    // Recorrer y mostrar los elementos hacia adelante
    std::cout << "Adelante: ";
    while (it != lst.cend()) {
        std::cout << *it << " ";
        ++it;
    }
    std::cout << std::endl;

    // Recorrer y mostrar los elementos hacia atrás
    std::cout << "Atrás: ";
    it = lst.cend();
    do {
        --it;
        std::cout << *it << " ";
    } while (it != lst.cbegin());
    std::cout << std::endl;

    return 0;
}
<---Ejemplo de Iteradores Constantes Result--->
<---Ejemplo Básico con `std::istream_iterator`--->
```cpp
#include <iostream>
#include <iterator>
#include <vector>
#include <algorithm>

int main() {
    std::cout << "Ingrese números separados por espacios (Ctrl+D para terminar): ";

    // Crear un istream_iterator para leer desde std::cin
    std::istream_iterator<int> inicio(std::cin);
    std::istream_iterator<int> fin;  // Iterador de fin predeterminado

    // Leer todos los números ingresados en un vector
    std::vector<int> numeros(inicio, fin);

    // Mostrar los números leídos
    std::cout << "Números ingresados: ";
    for (int numero : numeros) {
        std::cout << numero << " ";
    }
    std::cout << std::endl;

    return 0;
}
<---Ejemplo Básico con `std::istream_iterator` Result--->
<---Ejemplo con `std::copy`--->
```cpp
#include <iostream>
#include <iterator>
#include <vector>
#include <algorithm>

int main() {
    std::vector<int> numeros = {5, 2, 8, 1, 3};

    // Crear un ostream_iterator para escribir en std::cout
    std::ostream_iterator<int> salida(std::cout, " ");

    // Usar std::copy para escribir los números en std::cout
    std::copy(numeros.begin(), numeros.end(), salida);
    std::cout << std::endl;

    return 0;
}
<---Ejemplo con `std::copy` Result--->
<---Ejemplo de Implementación Personalizada--->
```cpp
#include <iostream>
#include <iterator>
#include <vector>

template <typename T>
class BidirectionalIterator : public std::iterator<std::bidirectional_iterator_tag, T> {
    T* ptr;

public:
    BidirectionalIterator(T* p = nullptr) : ptr(p) {}

    T& operator*() const { return *ptr; }
    T* operator->() const { return ptr; }

    BidirectionalIterator& operator++() {
        ++ptr;
        return *this;
    }

    BidirectionalIterator operator++(int) {
        BidirectionalIterator temp = *this;
        ++(*this);
        return temp;
    }

    BidirectionalIterator& operator--() {
        --ptr;
        return *this;
    }

    BidirectionalIterator operator--(int) {
        BidirectionalIterator temp = *this;
        --(*this);
        return temp;
    }

    bool operator==(const BidirectionalIterator& other) const {
        return ptr == other.ptr;
    }

    bool operator!=(const BidirectionalIterator& other) const {
        return ptr != other.ptr;
    }
};

int main() {
    std::vector<int> vec = {1, 2, 3, 4, 5};

    BidirectionalIterator<int> itBegin(vec.data());
    BidirectionalIterator<int> itEnd(vec.data() + vec.size());

    // Recorrer y mostrar los elementos hacia adelante
    std::cout << "Adelante: ";
    for (auto it = itBegin; it != itEnd; ++it) {
        std::cout << *it << " ";
    }
    std::cout << std::endl;

    // Recorrer y mostrar los elementos hacia atrás
    std::cout << "Atrás: ";
    for (auto it = itEnd; it != itBegin;) {
        --it;
        std::cout << *it << " ";
    }
    std::cout << std::endl;

    return 0;
}
<---Ejemplo de Implementación Personalizada Result--->
<---Ejemplo Básico con `std::ostream_iterator`--->
```cpp
#include <iostream>
#include <iterator>
#include <vector>

int main() {
    std::vector<int> numeros = {1, 2, 3, 4, 5};

    // Crear un ostream_iterator para escribir en std::cout
    std::ostream_iterator<int> salida(std::cout, " ");

    // Usar el iterador de salida para escribir los números
    for (int numero : numeros) {
        *salida = numero;
        ++salida;
    }
    std::cout << std::endl;

    return 0;
}
<---Ejemplo Básico con `std::ostream_iterator` Result--->
<---Ejemplo Básico con `std::forward_list`--->
```cpp
#include <iostream>
#include <forward_list>

int main() {
    std::forward_list<int> flist = {1, 2, 3, 4, 5};

    // Iterador de avance
    std::forward_list<int>::iterator it = flist.begin();

    // Recorrer y mostrar los elementos
    while (it != flist.end()) {
        std::cout << *it << " ";
        ++it;
    }
    std::cout << std::endl;

    return 0;
}
<---Ejemplo Básico con `std::forward_list` Result--->
<---Ejemplo con `std::find`--->
```cpp
#include <iostream>
#include <forward_list>
#include <algorithm>

int main() {
    std::forward_list<int> flist = {5, 3, 8, 1, 9};

    // Buscar un elemento usando std::find
    auto it = std::find(flist.begin(), flist.end(), 8);

    if (it != flist.end()) {
        std::cout << "Elemento encontrado: " << *it << std::endl;
    } else {
        std::cout << "Elemento no encontrado" << std::endl;
    }

    return 0;
}
<---Ejemplo con `std::find` Result--->
<---Ejemplo con `std::transform`--->
```cpp
#include <iostream>
#include <forward_list>
#include <algorithm>

int main() {
    std::forward_list<int> flist = {1, 2, 3, 4, 5};
    std::forward_list<int> resultado;

    // Reservar espacio en la lista de resultado
    resultado.resize(flist.size());

    // Usar std::transform para multiplicar cada elemento por 2
    std::transform(flist.begin(), flist.end(), resultado.begin(), [](int x) {
        return x * 2;
    });

    // Mostrar los resultados
    for (const auto& val : resultado) {
        std::cout << val << " ";
    }
    std::cout << std::endl;

    return 0;
}
<---Ejemplo con `std::transform` Result--->
<---Ejemplo Básico con `std::list`--->
```cpp
#include <iostream>
#include <list>

int main() {
    std::list<int> lst = {1, 2, 3, 4, 5};

    // Iterador bidireccional
    std::list<int>::iterator it = lst.begin();

    // Recorrer y mostrar los elementos hacia adelante
    std::cout << "Adelante: ";
    while (it != lst.end()) {
        std::cout << *it << " ";
        ++it;
    }
    std::cout << std::endl;

    // Recorrer y mostrar los elementos hacia atrás
    std::cout << "Atrás: ";
    it = lst.end();
    do {
        --it;
        std::cout << *it << " ";
    } while (it != lst.begin());
    std::cout << std::endl;

    return 0;
}
<---Ejemplo Básico con `std::list` Result--->
<---Ejemplo con `std::reverse`--->
```cpp
#include <iostream>
#include <list>
#include <algorithm>

int main() {
    std::list<int> lst = {5, 3, 8, 1, 9};

    // Usar std::reverse para invertir la lista
    std::reverse(lst.begin(), lst.end());

    // Mostrar los elementos de la lista invertida
    for (const int& val : lst) {
        std::cout << val << " ";
    }
    std::cout << std::endl;

    return 0;
}
<---Ejemplo con `std::reverse` Result--->
<---Tipos de Iteradores--->
<---Tipos de Iteradores Result--->
<---Ejemplo Básico--->
```cpp
#include <iostream>
#include <vector>

int main() {
    std::vector<int> vec = {1, 2, 3, 4, 5};

    // Iterador que apunta al primer elemento del vector
    std::vector<int>::iterator it = vec.begin();

    // Recorrer el vector usando el iterador
    while (it != vec.end()) {
        std::cout << *it << " ";
        ++it;  // Avanzar al siguiente elemento
    }
    std::cout << std::endl;

    return 0;
}
```cpp
#include <iostream>
#include <vector>
#include <algorithm>

int main() {
    std::vector<int> vec = {5, 2, 8, 1, 3};

    // Ordenar el vector usando std::sort
    std::sort(vec.begin(), vec.end());

    // Encontrar un elemento usando std::find
    auto it = std::find(vec.begin(), vec.end(), 8);

    if (it != vec.end()) {
        std::cout << "Elemento encontrado: " << *it << std::endl;
    } else {
        std::cout << "Elemento no encontrado" << std::endl;
    }

    return 0;
}
<---Ejemplo Básico Result--->
<---Ejemplo de Iteradores Constantes--->
```cpp
#include <iostream>
#include <list>

int main() {
    std::list<int> lst = {1, 2, 3, 4, 5};

    // Iterador constante bidireccional
    std::list<int>::const_iterator it = lst.cbegin();

    // Recorrer y mostrar los elementos hacia adelante
    std::cout << "Adelante: ";
    while (it != lst.cend()) {
        std::cout << *it << " ";
        ++it;
    }
    std::cout << std::endl;

    // Recorrer y mostrar los elementos hacia atrás
    std::cout << "Atrás: ";
    it = lst.cend();
    do {
        --it;
        std::cout << *it << " ";
    } while (it != lst.cbegin());
    std::cout << std::endl;

    return 0;
}
<---Ejemplo de Iteradores Constantes Result--->
<---Ejemplo Básico con `std::istream_iterator`--->
```cpp
#include <iostream>
#include <iterator>
#include <vector>
#include <algorithm>

int main() {
    std::cout << "Ingrese números separados por espacios (Ctrl+D para terminar): ";

    // Crear un istream_iterator para leer desde std::cin
    std::istream_iterator<int> inicio(std::cin);
    std::istream_iterator<int> fin;  // Iterador de fin predeterminado

    // Leer todos los números ingresados en un vector
    std::vector<int> numeros(inicio, fin);

    // Mostrar los números leídos
    std::cout << "Números ingresados: ";
    for (int numero : numeros) {
        std::cout << numero << " ";
    }
    std::cout << std::endl;

    return 0;
}
<---Ejemplo Básico con `std::istream_iterator` Result--->
<---Ejemplo con `std::copy`--->
```cpp
#include <iostream>
#include <iterator>
#include <vector>
#include <algorithm>

int main() {
    std::vector<int> numeros = {5, 2, 8, 1, 3};

    // Crear un ostream_iterator para escribir en std::cout
    std::ostream_iterator<int> salida(std::cout, " ");

    // Usar std::copy para escribir los números en std::cout
    std::copy(numeros.begin(), numeros.end(), salida);
    std::cout << std::endl;

    return 0;
}
<---Ejemplo con `std::copy` Result--->
<---Ejemplo de Implementación Personalizada--->
```cpp
#include <iostream>
#include <iterator>
#include <vector>

template <typename T>
class BidirectionalIterator : public std::iterator<std::bidirectional_iterator_tag, T> {
    T* ptr;

public:
    BidirectionalIterator(T* p = nullptr) : ptr(p) {}

    T& operator*() const { return *ptr; }
    T* operator->() const { return ptr; }

    BidirectionalIterator& operator++() {
        ++ptr;
        return *this;
    }

    BidirectionalIterator operator++(int) {
        BidirectionalIterator temp = *this;
        ++(*this);
        return temp;
    }

    BidirectionalIterator& operator--() {
        --ptr;
        return *this;
    }

    BidirectionalIterator operator--(int) {
        BidirectionalIterator temp = *this;
        --(*this);
        return temp;
    }

    bool operator==(const BidirectionalIterator& other) const {
        return ptr == other.ptr;
    }

    bool operator!=(const BidirectionalIterator& other) const {
        return ptr != other.ptr;
    }
};

int main() {
    std::vector<int> vec = {1, 2, 3, 4, 5};

    BidirectionalIterator<int> itBegin(vec.data());
    BidirectionalIterator<int> itEnd(vec.data() + vec.size());

    // Recorrer y mostrar los elementos hacia adelante
    std::cout << "Adelante: ";
    for (auto it = itBegin; it != itEnd; ++it) {
        std::cout << *it << " ";
    }
    std::cout << std::endl;

    // Recorrer y mostrar los elementos hacia atrás
    std::cout << "Atrás: ";
    for (auto it = itEnd; it != itBegin;) {
        --it;
        std::cout << *it << " ";
    }
    std::cout << std::endl;

    return 0;
}
<---Ejemplo de Implementación Personalizada Result--->
<---Ejemplo Básico con `std::ostream_iterator`--->
```cpp
#include <iostream>
#include <iterator>
#include <vector>

int main() {
    std::vector<int> numeros = {1, 2, 3, 4, 5};

    // Crear un ostream_iterator para escribir en std::cout
    std::ostream_iterator<int> salida(std::cout, " ");

    // Usar el iterador de salida para escribir los números
    for (int numero : numeros) {
        *salida = numero;
        ++salida;
    }
    std::cout << std::endl;

    return 0;
}
<---Ejemplo Básico con `std::ostream_iterator` Result--->
<---Ejemplo Básico con `std::forward_list`--->
```cpp
#include <iostream>
#include <forward_list>

int main() {
    std::forward_list<int> flist = {1, 2, 3, 4, 5};

    // Iterador de avance
    std::forward_list<int>::iterator it = flist.begin();

    // Recorrer y mostrar los elementos
    while (it != flist.end()) {
        std::cout << *it << " ";
        ++it;
    }
    std::cout << std::endl;

    return 0;
}
<---Ejemplo Básico con `std::forward_list` Result--->
<---Ejemplo con `std::find`--->
```cpp
#include <iostream>
#include <forward_list>
#include <algorithm>

int main() {
    std::forward_list<int> flist = {5, 3, 8, 1, 9};

    // Buscar un elemento usando std::find
    auto it = std::find(flist.begin(), flist.end(), 8);

    if (it != flist.end()) {
        std::cout << "Elemento encontrado: " << *it << std::endl;
    } else {
        std::cout << "Elemento no encontrado" << std::endl;
    }

    return 0;
}
<---Ejemplo con `std::find` Result--->
<---Ejemplo con `std::transform`--->
```cpp
#include <iostream>
#include <forward_list>
#include <algorithm>

int main() {
    std::forward_list<int> flist = {1, 2, 3, 4, 5};
    std::forward_list<int> resultado;

    // Reservar espacio en la lista de resultado
    resultado.resize(flist.size());

    // Usar std::transform para multiplicar cada elemento por 2
    std::transform(flist.begin(), flist.end(), resultado.begin(), [](int x) {
        return x * 2;
    });

    // Mostrar los resultados
    for (const auto& val : resultado) {
        std::cout << val << " ";
    }
    std::cout << std::endl;

    return 0;
}
<---Ejemplo con `std::transform` Result--->
<---Ejemplo Básico con `std::list`--->
```cpp
#include <iostream>
#include <list>

int main() {
    std::list<int> lst = {1, 2, 3, 4, 5};

    // Iterador bidireccional
    std::list<int>::iterator it = lst.begin();

    // Recorrer y mostrar los elementos hacia adelante
    std::cout << "Adelante: ";
    while (it != lst.end()) {
        std::cout << *it << " ";
        ++it;
    }
    std::cout << std::endl;

    // Recorrer y mostrar los elementos hacia atrás
    std::cout << "Atrás: ";
    it = lst.end();
    do {
        --it;
        std::cout << *it << " ";
    } while (it != lst.begin());
    std::cout << std::endl;

    return 0;
}
<---Ejemplo Básico con `std::list` Result--->
<---Ejemplo con `std::reverse`--->
```cpp
#include <iostream>
#include <list>
#include <algorithm>

int main() {
    std::list<int> lst = {5, 3, 8, 1, 9};

    // Usar std::reverse para invertir la lista
    std::reverse(lst.begin(), lst.end());

    // Mostrar los elementos de la lista invertida
    for (const int& val : lst) {
        std::cout << val << " ";
    }
    std::cout << std::endl;

    return 0;
}
<---Ejemplo con `std::reverse` Result--->
<---Ejemplo con `std::vector`--->
```cpp
#include <iostream>
#include <vector>

int main() {
    std::vector<int> vec = {1, 2, 3, 4, 5};

    // Obtener iteradores constantes a los elementos del vector
    std::vector<int>::const_iterator itBegin = vec.cbegin();
    std::vector<int>::const_iterator itEnd = vec.cend();

    // Recorrer y mostrar los elementos del vector sin modificarlos
    for (auto it = itBegin; it != itEnd; ++it) {
        std::cout << *it << " ";
    }
    std::cout << std::endl;

    return 0;
}
<---Ejemplo con `std::vector` Result--->
<---Ejemplo con `std::list`--->
```cpp
#include <iostream>
#include <list>

int main() {
    std::list<int> lst = {1, 2, 3, 4, 5};

    // Obtener iteradores a los elementos de la lista
    std::list<int>::iterator itBegin = lst.begin();
    std::list<int>::iterator itEnd = lst.end();

    // Recorrer y modificar los elementos de la lista
    for (auto it = itBegin; it != itEnd; ++it) {
        *it *= 2;  // Duplicar cada elemento
    }

    // Mostrar los elementos modificados
    for (const auto& val : lst) {
        std::cout << val << " ";
    }
    std::cout << std::endl;

    return 0;
}
```cpp
#include <iostream>
#include <map>

int main() {
    std::map<int, std::string> mapa = {{1, "uno"}, {2, "dos"}, {3, "tres"}};

    // Obtener iteradores a los elementos del mapa
    std::map<int, std::string>::iterator itBegin = mapa.begin();
    std::map<int, std::string>::iterator itEnd = mapa.end();

    // Recorrer y modificar los valores del mapa
    for (auto it = itBegin; it != itEnd; ++it) {
        it->second = "modificado";  // Modificar cada valor
    }

    // Mostrar los elementos modificados
    for (const auto& par : mapa) {
        std::cout << par.first << ": " << par.second << std::endl;
    }

    return 0;
}
<---Ejemplo con `std::list` Result--->
<---Tipos de Iteradores--->
<---Tipos de Iteradores Result--->
<---Ejemplo Básico--->
```cpp
#include <iostream>
#include <vector>

int main() {
    std::vector<int> vec = {1, 2, 3, 4, 5};

    // Iterador que apunta al primer elemento del vector
    std::vector<int>::iterator it = vec.begin();

    // Recorrer el vector usando el iterador
    while (it != vec.end()) {
        std::cout << *it << " ";
        ++it;  // Avanzar al siguiente elemento
    }
    std::cout << std::endl;

    return 0;
}
```cpp
#include <iostream>
#include <vector>
#include <algorithm>

int main() {
    std::vector<int> vec = {5, 2, 8, 1, 3};

    // Ordenar el vector usando std::sort
    std::sort(vec.begin(), vec.end());

    // Encontrar un elemento usando std::find
    auto it = std::find(vec.begin(), vec.end(), 8);

    if (it != vec.end()) {
        std::cout << "Elemento encontrado: " << *it << std::endl;
    } else {
        std::cout << "Elemento no encontrado" << std::endl;
    }

    return 0;
}
<---Ejemplo Básico Result--->
<---Ejemplo de Iteradores Constantes--->
```cpp
#include <iostream>
#include <list>

int main() {
    std::list<int> lst = {1, 2, 3, 4, 5};

    // Iterador constante bidireccional
    std::list<int>::const_iterator it = lst.cbegin();

    // Recorrer y mostrar los elementos hacia adelante
    std::cout << "Adelante: ";
    while (it != lst.cend()) {
        std::cout << *it << " ";
        ++it;
    }
    std::cout << std::endl;

    // Recorrer y mostrar los elementos hacia atrás
    std::cout << "Atrás: ";
    it = lst.cend();
    do {
        --it;
        std::cout << *it << " ";
    } while (it != lst.cbegin());
    std::cout << std::endl;

    return 0;
}
<---Ejemplo de Iteradores Constantes Result--->
<---Ejemplo Básico con `std::istream_iterator`--->
```cpp
#include <iostream>
#include <iterator>
#include <vector>
#include <algorithm>

int main() {
    std::cout << "Ingrese números separados por espacios (Ctrl+D para terminar): ";

    // Crear un istream_iterator para leer desde std::cin
    std::istream_iterator<int> inicio(std::cin);
    std::istream_iterator<int> fin;  // Iterador de fin predeterminado

    // Leer todos los números ingresados en un vector
    std::vector<int> numeros(inicio, fin);

    // Mostrar los números leídos
    std::cout << "Números ingresados: ";
    for (int numero : numeros) {
        std::cout << numero << " ";
    }
    std::cout << std::endl;

    return 0;
}
<---Ejemplo Básico con `std::istream_iterator` Result--->
<---Ejemplo con `std::copy`--->
```cpp
#include <iostream>
#include <iterator>
#include <vector>
#include <algorithm>

int main() {
    std::vector<int> numeros = {5, 2, 8, 1, 3};

    // Crear un ostream_iterator para escribir en std::cout
    std::ostream_iterator<int> salida(std::cout, " ");

    // Usar std::copy para escribir los números en std::cout
    std::copy(numeros.begin(), numeros.end(), salida);
    std::cout << std::endl;

    return 0;
}
<---Ejemplo con `std::copy` Result--->
<---Ejemplo de Implementación Personalizada--->
```cpp
#include <iostream>
#include <iterator>
#include <vector>

template <typename T>
class BidirectionalIterator : public std::iterator<std::bidirectional_iterator_tag, T> {
    T* ptr;

public:
    BidirectionalIterator(T* p = nullptr) : ptr(p) {}

    T& operator*() const { return *ptr; }
    T* operator->() const { return ptr; }

    BidirectionalIterator& operator++() {
        ++ptr;
        return *this;
    }

    BidirectionalIterator operator++(int) {
        BidirectionalIterator temp = *this;
        ++(*this);
        return temp;
    }

    BidirectionalIterator& operator--() {
        --ptr;
        return *this;
    }

    BidirectionalIterator operator--(int) {
        BidirectionalIterator temp = *this;
        --(*this);
        return temp;
    }

    bool operator==(const BidirectionalIterator& other) const {
        return ptr == other.ptr;
    }

    bool operator!=(const BidirectionalIterator& other) const {
        return ptr != other.ptr;
    }
};

int main() {
    std::vector<int> vec = {1, 2, 3, 4, 5};

    BidirectionalIterator<int> itBegin(vec.data());
    BidirectionalIterator<int> itEnd(vec.data() + vec.size());

    // Recorrer y mostrar los elementos hacia adelante
    std::cout << "Adelante: ";
    for (auto it = itBegin; it != itEnd; ++it) {
        std::cout << *it << " ";
    }
    std::cout << std::endl;

    // Recorrer y mostrar los elementos hacia atrás
    std::cout << "Atrás: ";
    for (auto it = itEnd; it != itBegin;) {
        --it;
        std::cout << *it << " ";
    }
    std::cout << std::endl;

    return 0;
}
<---Ejemplo de Implementación Personalizada Result--->
<---Ejemplo Básico con `std::ostream_iterator`--->
```cpp
#include <iostream>
#include <iterator>
#include <vector>

int main() {
    std::vector<int> numeros = {1, 2, 3, 4, 5};

    // Crear un ostream_iterator para escribir en std::cout
    std::ostream_iterator<int> salida(std::cout, " ");

    // Usar el iterador de salida para escribir los números
    for (int numero : numeros) {
        *salida = numero;
        ++salida;
    }
    std::cout << std::endl;

    return 0;
}
<---Ejemplo Básico con `std::ostream_iterator` Result--->
<---Ejemplo Básico con `std::forward_list`--->
```cpp
#include <iostream>
#include <forward_list>

int main() {
    std::forward_list<int> flist = {1, 2, 3, 4, 5};

    // Iterador de avance
    std::forward_list<int>::iterator it = flist.begin();

    // Recorrer y mostrar los elementos
    while (it != flist.end()) {
        std::cout << *it << " ";
        ++it;
    }
    std::cout << std::endl;

    return 0;
}
<---Ejemplo Básico con `std::forward_list` Result--->
<---Ejemplo con `std::find`--->
```cpp
#include <iostream>
#include <forward_list>
#include <algorithm>

int main() {
    std::forward_list<int> flist = {5, 3, 8, 1, 9};

    // Buscar un elemento usando std::find
    auto it = std::find(flist.begin(), flist.end(), 8);

    if (it != flist.end()) {
        std::cout << "Elemento encontrado: " << *it << std::endl;
    } else {
        std::cout << "Elemento no encontrado" << std::endl;
    }

    return 0;
}
<---Ejemplo con `std::find` Result--->
<---Ejemplo con `std::transform`--->
```cpp
#include <iostream>
#include <forward_list>
#include <algorithm>

int main() {
    std::forward_list<int> flist = {1, 2, 3, 4, 5};
    std::forward_list<int> resultado;

    // Reservar espacio en la lista de resultado
    resultado.resize(flist.size());

    // Usar std::transform para multiplicar cada elemento por 2
    std::transform(flist.begin(), flist.end(), resultado.begin(), [](int x) {
        return x * 2;
    });

    // Mostrar los resultados
    for (const auto& val : resultado) {
        std::cout << val << " ";
    }
    std::cout << std::endl;

    return 0;
}
<---Ejemplo con `std::transform` Result--->
<---Ejemplo Básico con `std::list`--->
```cpp
#include <iostream>
#include <list>

int main() {
    std::list<int> lst = {1, 2, 3, 4, 5};

    // Iterador bidireccional
    std::list<int>::iterator it = lst.begin();

    // Recorrer y mostrar los elementos hacia adelante
    std::cout << "Adelante: ";
    while (it != lst.end()) {
        std::cout << *it << " ";
        ++it;
    }
    std::cout << std::endl;

    // Recorrer y mostrar los elementos hacia atrás
    std::cout << "Atrás: ";
    it = lst.end();
    do {
        --it;
        std::cout << *it << " ";
    } while (it != lst.begin());
    std::cout << std::endl;

    return 0;
}
<---Ejemplo Básico con `std::list` Result--->
<---Ejemplo con `std::reverse`--->
```cpp
#include <iostream>
#include <list>
#include <algorithm>

int main() {
    std::list<int> lst = {5, 3, 8, 1, 9};

    // Usar std::reverse para invertir la lista
    std::reverse(lst.begin(), lst.end());

    // Mostrar los elementos de la lista invertida
    for (const int& val : lst) {
        std::cout << val << " ";
    }
    std::cout << std::endl;

    return 0;
}
<---Ejemplo con `std::reverse` Result--->
<---Ejemplo con `std::vector`--->
```cpp
#include <iostream>
#include <vector>

int main() {
    std::vector<int> vec = {1, 2, 3, 4, 5};

    // Obtener iteradores constantes a los elementos del vector
    std::vector<int>::const_iterator itBegin = vec.cbegin();
    std::vector<int>::const_iterator itEnd = vec.cend();

    // Recorrer y mostrar los elementos del vector sin modificarlos
    for (auto it = itBegin; it != itEnd; ++it) {
        std::cout << *it << " ";
    }
    std::cout << std::endl;

    return 0;
}
<---Ejemplo con `std::vector` Result--->
<---Ejemplo con `std::list`--->
```cpp
#include <iostream>
#include <list>

int main() {
    std::list<int> lst = {1, 2, 3, 4, 5};

    // Obtener iteradores a los elementos de la lista
    std::list<int>::iterator itBegin = lst.begin();
    std::list<int>::iterator itEnd = lst.end();

    // Recorrer y modificar los elementos de la lista
    for (auto it = itBegin; it != itEnd; ++it) {
        *it *= 2;  // Duplicar cada elemento
    }

    // Mostrar los elementos modificados
    for (const auto& val : lst) {
        std::cout << val << " ";
    }
    std::cout << std::endl;

    return 0;
}
```cpp
#include <iostream>
#include <map>

int main() {
    std::map<int, std::string> mapa = {{1, "uno"}, {2, "dos"}, {3, "tres"}};

    // Obtener iteradores a los elementos del mapa
    std::map<int, std::string>::iterator itBegin = mapa.begin();
    std::map<int, std::string>::iterator itEnd = mapa.end();

    // Recorrer y modificar los valores del mapa
    for (auto it = itBegin; it != itEnd; ++it) {
        it->second = "modificado";  // Modificar cada valor
    }

    // Mostrar los elementos modificados
    for (const auto& par : mapa) {
        std::cout << par.first << ": " << par.second << std::endl;
    }

    return 0;
}
<---Ejemplo con `std::list` Result--->
<---`push_back()`--->
```cpp
#include <vector>
#include <iostream>

int main() {
    std::vector<int> vec;
    vec.push_back(1);
    vec.push_back(2);
    vec.push_back(3);

    for (int v : vec) {
        std::cout << v << " ";
    }
    std::cout << std::endl;

    return 0;
}
<---`push_back()` Result--->
<---`insert()`--->
```cpp
#include <list>
#include <iostream>

int main() {
    std::list<int> lst = {1, 2, 3};
    auto it = lst.begin();
    ++it;
    lst.insert(it, 4);  // Inserta 4 antes de 2

    for (int v : lst) {
        std::cout << v << " ";
    }
    std::cout << std::endl;

    return 0;
}
<---`insert()` Result--->
<---`pop_back()`--->
```cpp
#include <vector>
#include <iostream>

int main() {
    std::vector<int> vec = {1, 2, 3};
    vec.pop_back();

    for (int v : vec) {
        std::cout << v << " ";
    }
    std::cout << std::endl;

    return 0;
}
<---`pop_back()` Result--->
<---`erase()`--->
```cpp
#include <list>
#include <iostream>

int main() {
    std::list<int> lst = {1, 2, 3};
    auto it = lst.begin();
    ++it;
    lst.erase(it);  // Elimina 2

    for (int v : lst) {
        std::cout << v << " ";
    }
    std::cout << std::endl;

    return 0;
}
<---`erase()` Result--->
<---`front()`--->
```cpp
#include <deque>
#include <iostream>

int main() {
    std::deque<int> deq = {1, 2, 3};
    std::cout << "Primer elemento: " << deq.front() << std::endl;

    return 0;
}
<---`front()` Result--->
<---`back()`--->
```cpp
#include <deque>
#include <iostream>

int main() {
    std::deque<int> deq = {1, 2, 3};
    std::cout << "Último elemento: " << deq.back() << std::endl;

    return 0;
}
<---`back()` Result--->
<---`operator[]` y `at()`--->
```cpp
#include <vector>
#include <iostream>

int main() {
    std::vector<int> vec = {1, 2, 3};
    std::cout << "Elemento en la posición 1: " << vec[1] << std::endl;
    std::cout << "Elemento en la posición 2: " << vec.at(2) << std::endl;

    return 0;
}
```cpp
#include <vector>
#include <iostream>

int main() {
    std::vector<int> vec = {1, 2, 3};
    vec[1] = 10;  // Modifica el segundo elemento

    for (int v : vec) {
        std::cout << v << " ";
    }
    std::cout << std::endl;

    return 0;
}
<---`operator[]` y `at()` Result--->
<---`size()`--->
```cpp
#include <vector>
#include <iostream>

int main() {
    std::vector<int> vec = {1, 2, 3};
    std::cout << "Tamaño: " << vec.size() << std::endl;

    return 0;
}
<---`size()` Result--->
<---`capacity()`--->
```cpp
#include <vector>
#include <iostream>

int main() {
    std::vector<int> vec = {1, 2, 3};
    std::cout << "Capacidad: " << vec.capacity() << std::endl;

    return 0;
}
<---`capacity()` Result--->
<---`empty()`--->
```cpp
#include <vector>
#include <iostream>

int main() {
    std::vector<int> vec;
    std::cout << "Está vacío: " << vec.empty() << std::endl;

    return 0;
}
<---`empty()` Result--->
<---`begin()` y `end()`--->
```cpp
#include <vector>
#include <iostream>

int main() {
    std::vector<int> vec = {1, 2, 3};

    for (auto it = vec.begin(); it != vec.end(); ++it) {
        std::cout << *it << " ";
    }
    std::cout << std::endl;

    return 0;
}
<---`begin()` y `end()` Result--->
<---`cbegin()` y `cend()`--->
```cpp
#include <vector>
#include <iostream>

int main() {
    std::vector<int> vec = {1, 2, 3};

    for (auto it = vec.cbegin(); it != vec.cend(); ++it) {
        std::cout << *it << " ";
    }
    std::cout << std::endl;

    return 0;
}
<---`cbegin()` y `cend()` Result--->
<---`std::map` y `std::set`--->
```cpp
#include <map>
#include <iostream>

int main() {
    std::map<int, std::string> mapa = {{1, "uno"}, {2, "dos"}, {3, "tres"}};
    auto it = mapa.find(2);
    if (it != mapa.end()) {
        std::cout << "Encontrado: " << it->second << std::endl;
    }

    std::cout << "Número de elementos con clave 2: " << mapa.count(2) << std::endl;

    return 0;
}
<---`std::map` y `std::set` Result--->
<---`std::queue` y `std::stack`--->
```cpp
#include <queue>
#include <iostream>

int main() {
    std::queue<int> q;
    q.push(1);
    q.push(2);
    q.push(3);

    std::cout << "Frente: " << q.front() << std::endl;
    q.pop();
    std::cout << "Frente después de pop: " << q.front() << std::endl;

    return 0;
}
<---`std::queue` y `std::stack` Result--->
<---Tipos de Iteradores--->
<---Tipos de Iteradores Result--->
<---Ejemplo Básico--->
```cpp
#include <iostream>
#include <vector>

int main() {
    std::vector<int> vec = {1, 2, 3, 4, 5};

    // Iterador que apunta al primer elemento del vector
    std::vector<int>::iterator it = vec.begin();

    // Recorrer el vector usando el iterador
    while (it != vec.end()) {
        std::cout << *it << " ";
        ++it;  // Avanzar al siguiente elemento
    }
    std::cout << std::endl;

    return 0;
}
```cpp
#include <iostream>
#include <vector>
#include <algorithm>

int main() {
    std::vector<int> vec = {5, 2, 8, 1, 3};

    // Ordenar el vector usando std::sort
    std::sort(vec.begin(), vec.end());

    // Encontrar un elemento usando std::find
    auto it = std::find(vec.begin(), vec.end(), 8);

    if (it != vec.end()) {
        std::cout << "Elemento encontrado: " << *it << std::endl;
    } else {
        std::cout << "Elemento no encontrado" << std::endl;
    }

    return 0;
}
<---Ejemplo Básico Result--->
<---Ejemplo de Iteradores Constantes--->
```cpp
#include <iostream>
#include <list>

int main() {
    std::list<int> lst = {1, 2, 3, 4, 5};

    // Iterador constante bidireccional
    std::list<int>::const_iterator it = lst.cbegin();

    // Recorrer y mostrar los elementos hacia adelante
    std::cout << "Adelante: ";
    while (it != lst.cend()) {
        std::cout << *it << " ";
        ++it;
    }
    std::cout << std::endl;

    // Recorrer y mostrar los elementos hacia atrás
    std::cout << "Atrás: ";
    it = lst.cend();
    do {
        --it;
        std::cout << *it << " ";
    } while (it != lst.cbegin());
    std::cout << std::endl;

    return 0;
}
<---Ejemplo de Iteradores Constantes Result--->
<---Ejemplo Básico con `std::istream_iterator`--->
```cpp
#include <iostream>
#include <iterator>
#include <vector>
#include <algorithm>

int main() {
    std::cout << "Ingrese números separados por espacios (Ctrl+D para terminar): ";

    // Crear un istream_iterator para leer desde std::cin
    std::istream_iterator<int> inicio(std::cin);
    std::istream_iterator<int> fin;  // Iterador de fin predeterminado

    // Leer todos los números ingresados en un vector
    std::vector<int> numeros(inicio, fin);

    // Mostrar los números leídos
    std::cout << "Números ingresados: ";
    for (int numero : numeros) {
        std::cout << numero << " ";
    }
    std::cout << std::endl;

    return 0;
}
<---Ejemplo Básico con `std::istream_iterator` Result--->
<---Ejemplo con `std::copy`--->
```cpp
#include <iostream>
#include <iterator>
#include <vector>
#include <algorithm>

int main() {
    std::vector<int> numeros = {5, 2, 8, 1, 3};

    // Crear un ostream_iterator para escribir en std::cout
    std::ostream_iterator<int> salida(std::cout, " ");

    // Usar std::copy para escribir los números en std::cout
    std::copy(numeros.begin(), numeros.end(), salida);
    std::cout << std::endl;

    return 0;
}
<---Ejemplo con `std::copy` Result--->
<---Ejemplo de Implementación Personalizada--->
```cpp
#include <iostream>
#include <iterator>
#include <vector>

template <typename T>
class BidirectionalIterator : public std::iterator<std::bidirectional_iterator_tag, T> {
    T* ptr;

public:
    BidirectionalIterator(T* p = nullptr) : ptr(p) {}

    T& operator*() const { return *ptr; }
    T* operator->() const { return ptr; }

    BidirectionalIterator& operator++() {
        ++ptr;
        return *this;
    }

    BidirectionalIterator operator++(int) {
        BidirectionalIterator temp = *this;
        ++(*this);
        return temp;
    }

    BidirectionalIterator& operator--() {
        --ptr;
        return *this;
    }

    BidirectionalIterator operator--(int) {
        BidirectionalIterator temp = *this;
        --(*this);
        return temp;
    }

    bool operator==(const BidirectionalIterator& other) const {
        return ptr == other.ptr;
    }

    bool operator!=(const BidirectionalIterator& other) const {
        return ptr != other.ptr;
    }
};

int main() {
    std::vector<int> vec = {1, 2, 3, 4, 5};

    BidirectionalIterator<int> itBegin(vec.data());
    BidirectionalIterator<int> itEnd(vec.data() + vec.size());

    // Recorrer y mostrar los elementos hacia adelante
    std::cout << "Adelante: ";
    for (auto it = itBegin; it != itEnd; ++it) {
        std::cout << *it << " ";
    }
    std::cout << std::endl;

    // Recorrer y mostrar los elementos hacia atrás
    std::cout << "Atrás: ";
    for (auto it = itEnd; it != itBegin;) {
        --it;
        std::cout << *it << " ";
    }
    std::cout << std::endl;

    return 0;
}
<---Ejemplo de Implementación Personalizada Result--->
<---Ejemplo Básico con `std::ostream_iterator`--->
```cpp
#include <iostream>
#include <iterator>
#include <vector>

int main() {
    std::vector<int> numeros = {1, 2, 3, 4, 5};

    // Crear un ostream_iterator para escribir en std::cout
    std::ostream_iterator<int> salida(std::cout, " ");

    // Usar el iterador de salida para escribir los números
    for (int numero : numeros) {
        *salida = numero;
        ++salida;
    }
    std::cout << std::endl;

    return 0;
}
<---Ejemplo Básico con `std::ostream_iterator` Result--->
<---Ejemplo Básico con `std::forward_list`--->
```cpp
#include <iostream>
#include <forward_list>

int main() {
    std::forward_list<int> flist = {1, 2, 3, 4, 5};

    // Iterador de avance
    std::forward_list<int>::iterator it = flist.begin();

    // Recorrer y mostrar los elementos
    while (it != flist.end()) {
        std::cout << *it << " ";
        ++it;
    }
    std::cout << std::endl;

    return 0;
}
<---Ejemplo Básico con `std::forward_list` Result--->
<---Ejemplo con `std::find`--->
```cpp
#include <iostream>
#include <forward_list>
#include <algorithm>

int main() {
    std::forward_list<int> flist = {5, 3, 8, 1, 9};

    // Buscar un elemento usando std::find
    auto it = std::find(flist.begin(), flist.end(), 8);

    if (it != flist.end()) {
        std::cout << "Elemento encontrado: " << *it << std::endl;
    } else {
        std::cout << "Elemento no encontrado" << std::endl;
    }

    return 0;
}
<---Ejemplo con `std::find` Result--->
<---Ejemplo con `std::transform`--->
```cpp
#include <iostream>
#include <forward_list>
#include <algorithm>

int main() {
    std::forward_list<int> flist = {1, 2, 3, 4, 5};
    std::forward_list<int> resultado;

    // Reservar espacio en la lista de resultado
    resultado.resize(flist.size());

    // Usar std::transform para multiplicar cada elemento por 2
    std::transform(flist.begin(), flist.end(), resultado.begin(), [](int x) {
        return x * 2;
    });

    // Mostrar los resultados
    for (const auto& val : resultado) {
        std::cout << val << " ";
    }
    std::cout << std::endl;

    return 0;
}
<---Ejemplo con `std::transform` Result--->
<---Ejemplo Básico con `std::list`--->
```cpp
#include <iostream>
#include <list>

int main() {
    std::list<int> lst = {1, 2, 3, 4, 5};

    // Iterador bidireccional
    std::list<int>::iterator it = lst.begin();

    // Recorrer y mostrar los elementos hacia adelante
    std::cout << "Adelante: ";
    while (it != lst.end()) {
        std::cout << *it << " ";
        ++it;
    }
    std::cout << std::endl;

    // Recorrer y mostrar los elementos hacia atrás
    std::cout << "Atrás: ";
    it = lst.end();
    do {
        --it;
        std::cout << *it << " ";
    } while (it != lst.begin());
    std::cout << std::endl;

    return 0;
}
<---Ejemplo Básico con `std::list` Result--->
<---Ejemplo con `std::reverse`--->
```cpp
#include <iostream>
#include <list>
#include <algorithm>

int main() {
    std::list<int> lst = {5, 3, 8, 1, 9};

    // Usar std::reverse para invertir la lista
    std::reverse(lst.begin(), lst.end());

    // Mostrar los elementos de la lista invertida
    for (const int& val : lst) {
        std::cout << val << " ";
    }
    std::cout << std::endl;

    return 0;
}
<---Ejemplo con `std::reverse` Result--->
<---Ejemplo con `std::vector`--->
```cpp
#include <iostream>
#include <vector>

int main() {
    std::vector<int> vec = {1, 2, 3, 4, 5};

    // Obtener iteradores constantes a los elementos del vector
    std::vector<int>::const_iterator itBegin = vec.cbegin();
    std::vector<int>::const_iterator itEnd = vec.cend();

    // Recorrer y mostrar los elementos del vector sin modificarlos
    for (auto it = itBegin; it != itEnd; ++it) {
        std::cout << *it << " ";
    }
    std::cout << std::endl;

    return 0;
}
<---Ejemplo con `std::vector` Result--->
<---Ejemplo con `std::list`--->
```cpp
#include <iostream>
#include <list>

int main() {
    std::list<int> lst = {1, 2, 3, 4, 5};

    // Obtener iteradores a los elementos de la lista
    std::list<int>::iterator itBegin = lst.begin();
    std::list<int>::iterator itEnd = lst.end();

    // Recorrer y modificar los elementos de la lista
    for (auto it = itBegin; it != itEnd; ++it) {
        *it *= 2;  // Duplicar cada elemento
    }

    // Mostrar los elementos modificados
    for (const auto& val : lst) {
        std::cout << val << " ";
    }
    std::cout << std::endl;

    return 0;
}
```cpp
#include <iostream>
#include <map>

int main() {
    std::map<int, std::string> mapa = {{1, "uno"}, {2, "dos"}, {3, "tres"}};

    // Obtener iteradores a los elementos del mapa
    std::map<int, std::string>::iterator itBegin = mapa.begin();
    std::map<int, std::string>::iterator itEnd = mapa.end();

    // Recorrer y modificar los valores del mapa
    for (auto it = itBegin; it != itEnd; ++it) {
        it->second = "modificado";  // Modificar cada valor
    }

    // Mostrar los elementos modificados
    for (const auto& par : mapa) {
        std::cout << par.first << ": " << par.second << std::endl;
    }

    return 0;
}
<---Ejemplo con `std::list` Result--->
<---`push_back()`--->
```cpp
#include <vector>
#include <iostream>

int main() {
    std::vector<int> vec;
    vec.push_back(1);
    vec.push_back(2);
    vec.push_back(3);

    for (int v : vec) {
        std::cout << v << " ";
    }
    std::cout << std::endl;

    return 0;
}
<---`push_back()` Result--->
<---`insert()`--->
```cpp
#include <list>
#include <iostream>

int main() {
    std::list<int> lst = {1, 2, 3};
    auto it = lst.begin();
    ++it;
    lst.insert(it, 4);  // Inserta 4 antes de 2

    for (int v : lst) {
        std::cout << v << " ";
    }
    std::cout << std::endl;

    return 0;
}
<---`insert()` Result--->
<---`pop_back()`--->
```cpp
#include <vector>
#include <iostream>

int main() {
    std::vector<int> vec = {1, 2, 3};
    vec.pop_back();

    for (int v : vec) {
        std::cout << v << " ";
    }
    std::cout << std::endl;

    return 0;
}
<---`pop_back()` Result--->
<---`erase()`--->
```cpp
#include <list>
#include <iostream>

int main() {
    std::list<int> lst = {1, 2, 3};
    auto it = lst.begin();
    ++it;
    lst.erase(it);  // Elimina 2

    for (int v : lst) {
        std::cout << v << " ";
    }
    std::cout << std::endl;

    return 0;
}
<---`erase()` Result--->
<---`front()`--->
```cpp
#include <deque>
#include <iostream>

int main() {
    std::deque<int> deq = {1, 2, 3};
    std::cout << "Primer elemento: " << deq.front() << std::endl;

    return 0;
}
<---`front()` Result--->
<---`back()`--->
```cpp
#include <deque>
#include <iostream>

int main() {
    std::deque<int> deq = {1, 2, 3};
    std::cout << "Último elemento: " << deq.back() << std::endl;

    return 0;
}
<---`back()` Result--->
<---`operator[]` y `at()`--->
```cpp
#include <vector>
#include <iostream>

int main() {
    std::vector<int> vec = {1, 2, 3};
    std::cout << "Elemento en la posición 1: " << vec[1] << std::endl;
    std::cout << "Elemento en la posición 2: " << vec.at(2) << std::endl;

    return 0;
}
```cpp
#include <vector>
#include <iostream>

int main() {
    std::vector<int> vec = {1, 2, 3};
    vec[1] = 10;  // Modifica el segundo elemento

    for (int v : vec) {
        std::cout << v << " ";
    }
    std::cout << std::endl;

    return 0;
}
<---`operator[]` y `at()` Result--->
<---`size()`--->
```cpp
#include <vector>
#include <iostream>

int main() {
    std::vector<int> vec = {1, 2, 3};
    std::cout << "Tamaño: " << vec.size() << std::endl;

    return 0;
}
<---`size()` Result--->
<---`capacity()`--->
```cpp
#include <vector>
#include <iostream>

int main() {
    std::vector<int> vec = {1, 2, 3};
    std::cout << "Capacidad: " << vec.capacity() << std::endl;

    return 0;
}
<---`capacity()` Result--->
<---`empty()`--->
```cpp
#include <vector>
#include <iostream>

int main() {
    std::vector<int> vec;
    std::cout << "Está vacío: " << vec.empty() << std::endl;

    return 0;
}
<---`empty()` Result--->
<---`begin()` y `end()`--->
```cpp
#include <vector>
#include <iostream>

int main() {
    std::vector<int> vec = {1, 2, 3};

    for (auto it = vec.begin(); it != vec.end(); ++it) {
        std::cout << *it << " ";
    }
    std::cout << std::endl;

    return 0;
}
<---`begin()` y `end()` Result--->
<---`cbegin()` y `cend()`--->
```cpp
#include <vector>
#include <iostream>

int main() {
    std::vector<int> vec = {1, 2, 3};

    for (auto it = vec.cbegin(); it != vec.cend(); ++it) {
        std::cout << *it << " ";
    }
    std::cout << std::endl;

    return 0;
}
<---`cbegin()` y `cend()` Result--->
<---`std::map` y `std::set`--->
```cpp
#include <map>
#include <iostream>

int main() {
    std::map<int, std::string> mapa = {{1, "uno"}, {2, "dos"}, {3, "tres"}};
    auto it = mapa.find(2);
    if (it != mapa.end()) {
        std::cout << "Encontrado: " << it->second << std::endl;
    }

    std::cout << "Número de elementos con clave 2: " << mapa.count(2) << std::endl;

    return 0;
}
<---`std::map` y `std::set` Result--->
<---`std::queue` y `std::stack`--->
```cpp
#include <queue>
#include <iostream>

int main() {
    std::queue<int> q;
    q.push(1);
    q.push(2);
    q.push(3);

    std::cout << "Frente: " << q.front() << std::endl;
    q.pop();
    std::cout << "Frente después de pop: " << q.front() << std::endl;

    return 0;
}
<---`std::queue` y `std::stack` Result--->
<---Ejemplo con `std::vector` y Bucle `for`--->
```cpp
#include <iostream>
#include <vector>

int main() {
    std::vector<int> vec = {1, 2, 3, 4, 5};

    // Uso de iteradores en un bucle for
    for (std::vector<int>::iterator it = vec.begin(); it != vec.end(); ++it) {
        std::cout << *it << " ";
    }
    std::cout << std::endl;

    return 0;
}
<---Ejemplo con `std::vector` y Bucle `for` Result--->
<---Ejemplo con Iteradores Constantes--->
```cpp
#include <iostream>
#include <list>

int main() {
    std::list<int> lst = {1, 2, 3, 4, 5};

    // Uso de iteradores constantes en un bucle while
    std::list<int>::const_iterator it = lst.cbegin();
    while (it != lst.cend()) {
        std::cout << *it << " ";
        ++it;
    }
    std::cout << std::endl;

    return 0;
}
<---Ejemplo con Iteradores Constantes Result--->
<---Ejemplo con `std::list` y Bucle `while`--->
```cpp
#include <iostream>
#include <list>

int main() {
    std::list<int> lst = {1, 2, 3, 4, 5};

    // Uso de iteradores en un bucle while
    std::list<int>::iterator it = lst.begin();
    while (it != lst.end()) {
        std::cout << *it << " ";
        ++it;
    }
    std::cout << std::endl;

    return 0;
}
<---Ejemplo con `std::list` y Bucle `while` Result--->
<---Ejemplo con `std::list` y Bucle `for` en Ambas Direcciones--->
```cpp
#include <iostream>
#include <list>

int main() {
    std::list<int> lst = {1, 2, 3, 4, 5};

    // Recorrer hacia adelante
    for (std::list<int>::iterator it = lst.begin(); it != lst.end(); ++it) {
        std::cout << *it << " ";
    }
    std::cout << std::endl;

    // Recorrer hacia atrás
    for (std::list<int>::iterator it = --lst.end(); it != --lst.begin(); --it) {
        std::cout << *it << " ";
    }
    std::cout << *lst.begin() << std::endl;  // Imprimir el primer elemento por separado

    return 0;
}
<---Ejemplo con `std::list` y Bucle `for` en Ambas Direcciones Result--->
<---Tipos de Iteradores--->
<---Tipos de Iteradores Result--->
<---Ejemplo Básico--->
```cpp
#include <iostream>
#include <vector>

int main() {
    std::vector<int> vec = {1, 2, 3, 4, 5};

    // Iterador que apunta al primer elemento del vector
    std::vector<int>::iterator it = vec.begin();

    // Recorrer el vector usando el iterador
    while (it != vec.end()) {
        std::cout << *it << " ";
        ++it;  // Avanzar al siguiente elemento
    }
    std::cout << std::endl;

    return 0;
}
```cpp
#include <iostream>
#include <vector>
#include <algorithm>

int main() {
    std::vector<int> vec = {5, 2, 8, 1, 3};

    // Ordenar el vector usando std::sort
    std::sort(vec.begin(), vec.end());

    // Encontrar un elemento usando std::find
    auto it = std::find(vec.begin(), vec.end(), 8);

    if (it != vec.end()) {
        std::cout << "Elemento encontrado: " << *it << std::endl;
    } else {
        std::cout << "Elemento no encontrado" << std::endl;
    }

    return 0;
}
<---Ejemplo Básico Result--->
<---Ejemplo de Iteradores Constantes--->
```cpp
#include <iostream>
#include <list>

int main() {
    std::list<int> lst = {1, 2, 3, 4, 5};

    // Iterador constante bidireccional
    std::list<int>::const_iterator it = lst.cbegin();

    // Recorrer y mostrar los elementos hacia adelante
    std::cout << "Adelante: ";
    while (it != lst.cend()) {
        std::cout << *it << " ";
        ++it;
    }
    std::cout << std::endl;

    // Recorrer y mostrar los elementos hacia atrás
    std::cout << "Atrás: ";
    it = lst.cend();
    do {
        --it;
        std::cout << *it << " ";
    } while (it != lst.cbegin());
    std::cout << std::endl;

    return 0;
}
<---Ejemplo de Iteradores Constantes Result--->
<---Ejemplo Básico con `std::istream_iterator`--->
```cpp
#include <iostream>
#include <iterator>
#include <vector>
#include <algorithm>

int main() {
    std::cout << "Ingrese números separados por espacios (Ctrl+D para terminar): ";

    // Crear un istream_iterator para leer desde std::cin
    std::istream_iterator<int> inicio(std::cin);
    std::istream_iterator<int> fin;  // Iterador de fin predeterminado

    // Leer todos los números ingresados en un vector
    std::vector<int> numeros(inicio, fin);

    // Mostrar los números leídos
    std::cout << "Números ingresados: ";
    for (int numero : numeros) {
        std::cout << numero << " ";
    }
    std::cout << std::endl;

    return 0;
}
<---Ejemplo Básico con `std::istream_iterator` Result--->
<---Ejemplo con `std::copy`--->
```cpp
#include <iostream>
#include <iterator>
#include <vector>
#include <algorithm>

int main() {
    std::vector<int> numeros = {5, 2, 8, 1, 3};

    // Crear un ostream_iterator para escribir en std::cout
    std::ostream_iterator<int> salida(std::cout, " ");

    // Usar std::copy para escribir los números en std::cout
    std::copy(numeros.begin(), numeros.end(), salida);
    std::cout << std::endl;

    return 0;
}
<---Ejemplo con `std::copy` Result--->
<---Ejemplo de Implementación Personalizada--->
```cpp
#include <iostream>
#include <iterator>
#include <vector>

template <typename T>
class BidirectionalIterator : public std::iterator<std::bidirectional_iterator_tag, T> {
    T* ptr;

public:
    BidirectionalIterator(T* p = nullptr) : ptr(p) {}

    T& operator*() const { return *ptr; }
    T* operator->() const { return ptr; }

    BidirectionalIterator& operator++() {
        ++ptr;
        return *this;
    }

    BidirectionalIterator operator++(int) {
        BidirectionalIterator temp = *this;
        ++(*this);
        return temp;
    }

    BidirectionalIterator& operator--() {
        --ptr;
        return *this;
    }

    BidirectionalIterator operator--(int) {
        BidirectionalIterator temp = *this;
        --(*this);
        return temp;
    }

    bool operator==(const BidirectionalIterator& other) const {
        return ptr == other.ptr;
    }

    bool operator!=(const BidirectionalIterator& other) const {
        return ptr != other.ptr;
    }
};

int main() {
    std::vector<int> vec = {1, 2, 3, 4, 5};

    BidirectionalIterator<int> itBegin(vec.data());
    BidirectionalIterator<int> itEnd(vec.data() + vec.size());

    // Recorrer y mostrar los elementos hacia adelante
    std::cout << "Adelante: ";
    for (auto it = itBegin; it != itEnd; ++it) {
        std::cout << *it << " ";
    }
    std::cout << std::endl;

    // Recorrer y mostrar los elementos hacia atrás
    std::cout << "Atrás: ";
    for (auto it = itEnd; it != itBegin;) {
        --it;
        std::cout << *it << " ";
    }
    std::cout << std::endl;

    return 0;
}
<---Ejemplo de Implementación Personalizada Result--->
<---Ejemplo Básico con `std::ostream_iterator`--->
```cpp
#include <iostream>
#include <iterator>
#include <vector>

int main() {
    std::vector<int> numeros = {1, 2, 3, 4, 5};

    // Crear un ostream_iterator para escribir en std::cout
    std::ostream_iterator<int> salida(std::cout, " ");

    // Usar el iterador de salida para escribir los números
    for (int numero : numeros) {
        *salida = numero;
        ++salida;
    }
    std::cout << std::endl;

    return 0;
}
<---Ejemplo Básico con `std::ostream_iterator` Result--->
<---Ejemplo Básico con `std::forward_list`--->
```cpp
#include <iostream>
#include <forward_list>

int main() {
    std::forward_list<int> flist = {1, 2, 3, 4, 5};

    // Iterador de avance
    std::forward_list<int>::iterator it = flist.begin();

    // Recorrer y mostrar los elementos
    while (it != flist.end()) {
        std::cout << *it << " ";
        ++it;
    }
    std::cout << std::endl;

    return 0;
}
<---Ejemplo Básico con `std::forward_list` Result--->
<---Ejemplo con `std::find`--->
```cpp
#include <iostream>
#include <forward_list>
#include <algorithm>

int main() {
    std::forward_list<int> flist = {5, 3, 8, 1, 9};

    // Buscar un elemento usando std::find
    auto it = std::find(flist.begin(), flist.end(), 8);

    if (it != flist.end()) {
        std::cout << "Elemento encontrado: " << *it << std::endl;
    } else {
        std::cout << "Elemento no encontrado" << std::endl;
    }

    return 0;
}
<---Ejemplo con `std::find` Result--->
<---Ejemplo con `std::transform`--->
```cpp
#include <iostream>
#include <forward_list>
#include <algorithm>

int main() {
    std::forward_list<int> flist = {1, 2, 3, 4, 5};
    std::forward_list<int> resultado;

    // Reservar espacio en la lista de resultado
    resultado.resize(flist.size());

    // Usar std::transform para multiplicar cada elemento por 2
    std::transform(flist.begin(), flist.end(), resultado.begin(), [](int x) {
        return x * 2;
    });

    // Mostrar los resultados
    for (const auto& val : resultado) {
        std::cout << val << " ";
    }
    std::cout << std::endl;

    return 0;
}
<---Ejemplo con `std::transform` Result--->
<---Ejemplo Básico con `std::list`--->
```cpp
#include <iostream>
#include <list>

int main() {
    std::list<int> lst = {1, 2, 3, 4, 5};

    // Iterador bidireccional
    std::list<int>::iterator it = lst.begin();

    // Recorrer y mostrar los elementos hacia adelante
    std::cout << "Adelante: ";
    while (it != lst.end()) {
        std::cout << *it << " ";
        ++it;
    }
    std::cout << std::endl;

    // Recorrer y mostrar los elementos hacia atrás
    std::cout << "Atrás: ";
    it = lst.end();
    do {
        --it;
        std::cout << *it << " ";
    } while (it != lst.begin());
    std::cout << std::endl;

    return 0;
}
<---Ejemplo Básico con `std::list` Result--->
<---Ejemplo con `std::reverse`--->
```cpp
#include <iostream>
#include <list>
#include <algorithm>

int main() {
    std::list<int> lst = {5, 3, 8, 1, 9};

    // Usar std::reverse para invertir la lista
    std::reverse(lst.begin(), lst.end());

    // Mostrar los elementos de la lista invertida
    for (const int& val : lst) {
        std::cout << val << " ";
    }
    std::cout << std::endl;

    return 0;
}
<---Ejemplo con `std::reverse` Result--->
<---Ejemplo con `std::vector`--->
```cpp
#include <iostream>
#include <vector>

int main() {
    std::vector<int> vec = {1, 2, 3, 4, 5};

    // Obtener iteradores constantes a los elementos del vector
    std::vector<int>::const_iterator itBegin = vec.cbegin();
    std::vector<int>::const_iterator itEnd = vec.cend();

    // Recorrer y mostrar los elementos del vector sin modificarlos
    for (auto it = itBegin; it != itEnd; ++it) {
        std::cout << *it << " ";
    }
    std::cout << std::endl;

    return 0;
}
<---Ejemplo con `std::vector` Result--->
<---Ejemplo con `std::list`--->
```cpp
#include <iostream>
#include <list>

int main() {
    std::list<int> lst = {1, 2, 3, 4, 5};

    // Obtener iteradores a los elementos de la lista
    std::list<int>::iterator itBegin = lst.begin();
    std::list<int>::iterator itEnd = lst.end();

    // Recorrer y modificar los elementos de la lista
    for (auto it = itBegin; it != itEnd; ++it) {
        *it *= 2;  // Duplicar cada elemento
    }

    // Mostrar los elementos modificados
    for (const auto& val : lst) {
        std::cout << val << " ";
    }
    std::cout << std::endl;

    return 0;
}
```cpp
#include <iostream>
#include <map>

int main() {
    std::map<int, std::string> mapa = {{1, "uno"}, {2, "dos"}, {3, "tres"}};

    // Obtener iteradores a los elementos del mapa
    std::map<int, std::string>::iterator itBegin = mapa.begin();
    std::map<int, std::string>::iterator itEnd = mapa.end();

    // Recorrer y modificar los valores del mapa
    for (auto it = itBegin; it != itEnd; ++it) {
        it->second = "modificado";  // Modificar cada valor
    }

    // Mostrar los elementos modificados
    for (const auto& par : mapa) {
        std::cout << par.first << ": " << par.second << std::endl;
    }

    return 0;
}
<---Ejemplo con `std::list` Result--->
<---`push_back()`--->
```cpp
#include <vector>
#include <iostream>

int main() {
    std::vector<int> vec;
    vec.push_back(1);
    vec.push_back(2);
    vec.push_back(3);

    for (int v : vec) {
        std::cout << v << " ";
    }
    std::cout << std::endl;

    return 0;
}
<---`push_back()` Result--->
<---`insert()`--->
```cpp
#include <list>
#include <iostream>

int main() {
    std::list<int> lst = {1, 2, 3};
    auto it = lst.begin();
    ++it;
    lst.insert(it, 4);  // Inserta 4 antes de 2

    for (int v : lst) {
        std::cout << v << " ";
    }
    std::cout << std::endl;

    return 0;
}
<---`insert()` Result--->
<---`pop_back()`--->
```cpp
#include <vector>
#include <iostream>

int main() {
    std::vector<int> vec = {1, 2, 3};
    vec.pop_back();

    for (int v : vec) {
        std::cout << v << " ";
    }
    std::cout << std::endl;

    return 0;
}
<---`pop_back()` Result--->
<---`erase()`--->
```cpp
#include <list>
#include <iostream>

int main() {
    std::list<int> lst = {1, 2, 3};
    auto it = lst.begin();
    ++it;
    lst.erase(it);  // Elimina 2

    for (int v : lst) {
        std::cout << v << " ";
    }
    std::cout << std::endl;

    return 0;
}
<---`erase()` Result--->
<---`front()`--->
```cpp
#include <deque>
#include <iostream>

int main() {
    std::deque<int> deq = {1, 2, 3};
    std::cout << "Primer elemento: " << deq.front() << std::endl;

    return 0;
}
<---`front()` Result--->
<---`back()`--->
```cpp
#include <deque>
#include <iostream>

int main() {
    std::deque<int> deq = {1, 2, 3};
    std::cout << "Último elemento: " << deq.back() << std::endl;

    return 0;
}
<---`back()` Result--->
<---`operator[]` y `at()`--->
```cpp
#include <vector>
#include <iostream>

int main() {
    std::vector<int> vec = {1, 2, 3};
    std::cout << "Elemento en la posición 1: " << vec[1] << std::endl;
    std::cout << "Elemento en la posición 2: " << vec.at(2) << std::endl;

    return 0;
}
```cpp
#include <vector>
#include <iostream>

int main() {
    std::vector<int> vec = {1, 2, 3};
    vec[1] = 10;  // Modifica el segundo elemento

    for (int v : vec) {
        std::cout << v << " ";
    }
    std::cout << std::endl;

    return 0;
}
<---`operator[]` y `at()` Result--->
<---`size()`--->
```cpp
#include <vector>
#include <iostream>

int main() {
    std::vector<int> vec = {1, 2, 3};
    std::cout << "Tamaño: " << vec.size() << std::endl;

    return 0;
}
<---`size()` Result--->
<---`capacity()`--->
```cpp
#include <vector>
#include <iostream>

int main() {
    std::vector<int> vec = {1, 2, 3};
    std::cout << "Capacidad: " << vec.capacity() << std::endl;

    return 0;
}
<---`capacity()` Result--->
<---`empty()`--->
```cpp
#include <vector>
#include <iostream>

int main() {
    std::vector<int> vec;
    std::cout << "Está vacío: " << vec.empty() << std::endl;

    return 0;
}
<---`empty()` Result--->
<---`begin()` y `end()`--->
```cpp
#include <vector>
#include <iostream>

int main() {
    std::vector<int> vec = {1, 2, 3};

    for (auto it = vec.begin(); it != vec.end(); ++it) {
        std::cout << *it << " ";
    }
    std::cout << std::endl;

    return 0;
}
<---`begin()` y `end()` Result--->
<---`cbegin()` y `cend()`--->
```cpp
#include <vector>
#include <iostream>

int main() {
    std::vector<int> vec = {1, 2, 3};

    for (auto it = vec.cbegin(); it != vec.cend(); ++it) {
        std::cout << *it << " ";
    }
    std::cout << std::endl;

    return 0;
}
<---`cbegin()` y `cend()` Result--->
<---`std::map` y `std::set`--->
```cpp
#include <map>
#include <iostream>

int main() {
    std::map<int, std::string> mapa = {{1, "uno"}, {2, "dos"}, {3, "tres"}};
    auto it = mapa.find(2);
    if (it != mapa.end()) {
        std::cout << "Encontrado: " << it->second << std::endl;
    }

    std::cout << "Número de elementos con clave 2: " << mapa.count(2) << std::endl;

    return 0;
}
<---`std::map` y `std::set` Result--->
<---`std::queue` y `std::stack`--->
```cpp
#include <queue>
#include <iostream>

int main() {
    std::queue<int> q;
    q.push(1);
    q.push(2);
    q.push(3);

    std::cout << "Frente: " << q.front() << std::endl;
    q.pop();
    std::cout << "Frente después de pop: " << q.front() << std::endl;

    return 0;
}
<---`std::queue` y `std::stack` Result--->
<---Ejemplo con `std::vector` y Bucle `for`--->
```cpp
#include <iostream>
#include <vector>

int main() {
    std::vector<int> vec = {1, 2, 3, 4, 5};

    // Uso de iteradores en un bucle for
    for (std::vector<int>::iterator it = vec.begin(); it != vec.end(); ++it) {
        std::cout << *it << " ";
    }
    std::cout << std::endl;

    return 0;
}
<---Ejemplo con `std::vector` y Bucle `for` Result--->
<---Ejemplo con Iteradores Constantes--->
```cpp
#include <iostream>
#include <list>

int main() {
    std::list<int> lst = {1, 2, 3, 4, 5};

    // Uso de iteradores constantes en un bucle while
    std::list<int>::const_iterator it = lst.cbegin();
    while (it != lst.cend()) {
        std::cout << *it << " ";
        ++it;
    }
    std::cout << std::endl;

    return 0;
}
<---Ejemplo con Iteradores Constantes Result--->
<---Ejemplo con `std::list` y Bucle `while`--->
```cpp
#include <iostream>
#include <list>

int main() {
    std::list<int> lst = {1, 2, 3, 4, 5};

    // Uso de iteradores en un bucle while
    std::list<int>::iterator it = lst.begin();
    while (it != lst.end()) {
        std::cout << *it << " ";
        ++it;
    }
    std::cout << std::endl;

    return 0;
}
<---Ejemplo con `std::list` y Bucle `while` Result--->
<---Ejemplo con `std::list` y Bucle `for` en Ambas Direcciones--->
```cpp
#include <iostream>
#include <list>

int main() {
    std::list<int> lst = {1, 2, 3, 4, 5};

    // Recorrer hacia adelante
    for (std::list<int>::iterator it = lst.begin(); it != lst.end(); ++it) {
        std::cout << *it << " ";
    }
    std::cout << std::endl;

    // Recorrer hacia atrás
    for (std::list<int>::iterator it = --lst.end(); it != --lst.begin(); --it) {
        std::cout << *it << " ";
    }
    std::cout << *lst.begin() << std::endl;  // Imprimir el primer elemento por separado

    return 0;
}
<---Ejemplo con `std::list` y Bucle `for` en Ambas Direcciones Result--->
<---Ventajas de Iterar con Índices--->
<---Ventajas de Iterar con Índices Result--->
<---Desventajas de Iterar con Índices--->
<---Desventajas de Iterar con Índices Result--->
<---Ejemplo de Iteración con Índices--->
```cpp
#include <iostream>
#include <vector>

int main() {
    std::vector<int> vec = {1, 2, 3, 4, 5};

    // Iterar con índices
    for (size_t i = 0; i < vec.size(); ++i) {
        std::cout << vec[i] << " ";
    }
    std::cout << std::endl;

    return 0;
}
<---Ejemplo de Iteración con Índices Result--->
<---Ventajas de Iterar con Iteradores--->
<---Ventajas de Iterar con Iteradores Result--->
<---Desventajas de Iterar con Iteradores--->
<---Desventajas de Iterar con Iteradores Result--->
<---Ejemplo de Iteración con Iteradores--->
```cpp
#include <iostream>
#include <vector>

int main() {
    std::vector<int> vec = {1, 2, 3, 4, 5};

    // Iterar con iteradores
    for (std::vector<int>::iterator it = vec.begin(); it != vec.end(); ++it) {
        std::cout << *it << " ";
    }
    std::cout << std::endl;

    return 0;
}
<---Ejemplo de Iteración con Iteradores Result--->
<---Iteración con Índices--->
```cpp
#include <iostream>
#include <vector>

int main() {
    std::vector<int> vec = {1, 2, 3, 4, 5};

    // Iterar con índices
    for (size_t i = 0; i < vec.size(); ++i) {
        std::cout << vec[i] << " ";
    }
    std::cout << std::endl;

    return 0;
}
<---Iteración con Índices Result--->
<---Iteración con Iteradores--->
```cpp
#include <iostream>
#include <vector>

int main() {
    std::vector<int> vec = {1, 2, 3, 4, 5};

    // Iterar con iteradores
    for (std::vector<int>::iterator it = vec.begin(); it != vec.end(); ++it) {
        std::cout << *it << " ";
    }
    std::cout << std::endl;

    return 0;
}
<---Iteración con Iteradores Result--->
<---Iteración con Iteradores (No se puede usar índices)--->
```cpp
#include <iostream>
#include <list>

int main() {
    std::list<int> lst = {1, 2, 3, 4, 5};

    // Iterar con iteradores
    for (std::list<int>::iterator it = lst.begin(); it != lst.end(); ++it) {
        std::cout << *it << " ";
    }
    std::cout << std::endl;

    return 0;
}
<---Iteración con Iteradores (No se puede usar índices) Result--->
<---Tipos de Iteradores--->
<---Tipos de Iteradores Result--->
<---Ejemplo Básico--->
```cpp
#include <iostream>
#include <vector>

int main() {
    std::vector<int> vec = {1, 2, 3, 4, 5};

    // Iterador que apunta al primer elemento del vector
    std::vector<int>::iterator it = vec.begin();

    // Recorrer el vector usando el iterador
    while (it != vec.end()) {
        std::cout << *it << " ";
        ++it;  // Avanzar al siguiente elemento
    }
    std::cout << std::endl;

    return 0;
}
```cpp
#include <iostream>
#include <vector>
#include <algorithm>

int main() {
    std::vector<int> vec = {5, 2, 8, 1, 3};

    // Ordenar el vector usando std::sort
    std::sort(vec.begin(), vec.end());

    // Encontrar un elemento usando std::find
    auto it = std::find(vec.begin(), vec.end(), 8);

    if (it != vec.end()) {
        std::cout << "Elemento encontrado: " << *it << std::endl;
    } else {
        std::cout << "Elemento no encontrado" << std::endl;
    }

    return 0;
}
<---Ejemplo Básico Result--->
<---Ejemplo de Iteradores Constantes--->
```cpp
#include <iostream>
#include <list>

int main() {
    std::list<int> lst = {1, 2, 3, 4, 5};

    // Iterador constante bidireccional
    std::list<int>::const_iterator it = lst.cbegin();

    // Recorrer y mostrar los elementos hacia adelante
    std::cout << "Adelante: ";
    while (it != lst.cend()) {
        std::cout << *it << " ";
        ++it;
    }
    std::cout << std::endl;

    // Recorrer y mostrar los elementos hacia atrás
    std::cout << "Atrás: ";
    it = lst.cend();
    do {
        --it;
        std::cout << *it << " ";
    } while (it != lst.cbegin());
    std::cout << std::endl;

    return 0;
}
<---Ejemplo de Iteradores Constantes Result--->
<---Ejemplo Básico con `std::istream_iterator`--->
```cpp
#include <iostream>
#include <iterator>
#include <vector>
#include <algorithm>

int main() {
    std::cout << "Ingrese números separados por espacios (Ctrl+D para terminar): ";

    // Crear un istream_iterator para leer desde std::cin
    std::istream_iterator<int> inicio(std::cin);
    std::istream_iterator<int> fin;  // Iterador de fin predeterminado

    // Leer todos los números ingresados en un vector
    std::vector<int> numeros(inicio, fin);

    // Mostrar los números leídos
    std::cout << "Números ingresados: ";
    for (int numero : numeros) {
        std::cout << numero << " ";
    }
    std::cout << std::endl;

    return 0;
}
<---Ejemplo Básico con `std::istream_iterator` Result--->
<---Ejemplo con `std::copy`--->
```cpp
#include <iostream>
#include <iterator>
#include <vector>
#include <algorithm>

int main() {
    std::vector<int> numeros = {5, 2, 8, 1, 3};

    // Crear un ostream_iterator para escribir en std::cout
    std::ostream_iterator<int> salida(std::cout, " ");

    // Usar std::copy para escribir los números en std::cout
    std::copy(numeros.begin(), numeros.end(), salida);
    std::cout << std::endl;

    return 0;
}
<---Ejemplo con `std::copy` Result--->
<---Ejemplo de Implementación Personalizada--->
```cpp
#include <iostream>
#include <iterator>
#include <vector>

template <typename T>
class BidirectionalIterator : public std::iterator<std::bidirectional_iterator_tag, T> {
    T* ptr;

public:
    BidirectionalIterator(T* p = nullptr) : ptr(p) {}

    T& operator*() const { return *ptr; }
    T* operator->() const { return ptr; }

    BidirectionalIterator& operator++() {
        ++ptr;
        return *this;
    }

    BidirectionalIterator operator++(int) {
        BidirectionalIterator temp = *this;
        ++(*this);
        return temp;
    }

    BidirectionalIterator& operator--() {
        --ptr;
        return *this;
    }

    BidirectionalIterator operator--(int) {
        BidirectionalIterator temp = *this;
        --(*this);
        return temp;
    }

    bool operator==(const BidirectionalIterator& other) const {
        return ptr == other.ptr;
    }

    bool operator!=(const BidirectionalIterator& other) const {
        return ptr != other.ptr;
    }
};

int main() {
    std::vector<int> vec = {1, 2, 3, 4, 5};

    BidirectionalIterator<int> itBegin(vec.data());
    BidirectionalIterator<int> itEnd(vec.data() + vec.size());

    // Recorrer y mostrar los elementos hacia adelante
    std::cout << "Adelante: ";
    for (auto it = itBegin; it != itEnd; ++it) {
        std::cout << *it << " ";
    }
    std::cout << std::endl;

    // Recorrer y mostrar los elementos hacia atrás
    std::cout << "Atrás: ";
    for (auto it = itEnd; it != itBegin;) {
        --it;
        std::cout << *it << " ";
    }
    std::cout << std::endl;

    return 0;
}
<---Ejemplo de Implementación Personalizada Result--->
<---Ejemplo Básico con `std::ostream_iterator`--->
```cpp
#include <iostream>
#include <iterator>
#include <vector>

int main() {
    std::vector<int> numeros = {1, 2, 3, 4, 5};

    // Crear un ostream_iterator para escribir en std::cout
    std::ostream_iterator<int> salida(std::cout, " ");

    // Usar el iterador de salida para escribir los números
    for (int numero : numeros) {
        *salida = numero;
        ++salida;
    }
    std::cout << std::endl;

    return 0;
}
<---Ejemplo Básico con `std::ostream_iterator` Result--->
<---Ejemplo Básico con `std::forward_list`--->
```cpp
#include <iostream>
#include <forward_list>

int main() {
    std::forward_list<int> flist = {1, 2, 3, 4, 5};

    // Iterador de avance
    std::forward_list<int>::iterator it = flist.begin();

    // Recorrer y mostrar los elementos
    while (it != flist.end()) {
        std::cout << *it << " ";
        ++it;
    }
    std::cout << std::endl;

    return 0;
}
<---Ejemplo Básico con `std::forward_list` Result--->
<---Ejemplo con `std::find`--->
```cpp
#include <iostream>
#include <forward_list>
#include <algorithm>

int main() {
    std::forward_list<int> flist = {5, 3, 8, 1, 9};

    // Buscar un elemento usando std::find
    auto it = std::find(flist.begin(), flist.end(), 8);

    if (it != flist.end()) {
        std::cout << "Elemento encontrado: " << *it << std::endl;
    } else {
        std::cout << "Elemento no encontrado" << std::endl;
    }

    return 0;
}
<---Ejemplo con `std::find` Result--->
<---Ejemplo con `std::transform`--->
```cpp
#include <iostream>
#include <forward_list>
#include <algorithm>

int main() {
    std::forward_list<int> flist = {1, 2, 3, 4, 5};
    std::forward_list<int> resultado;

    // Reservar espacio en la lista de resultado
    resultado.resize(flist.size());

    // Usar std::transform para multiplicar cada elemento por 2
    std::transform(flist.begin(), flist.end(), resultado.begin(), [](int x) {
        return x * 2;
    });

    // Mostrar los resultados
    for (const auto& val : resultado) {
        std::cout << val << " ";
    }
    std::cout << std::endl;

    return 0;
}
<---Ejemplo con `std::transform` Result--->
<---Ejemplo Básico con `std::list`--->
```cpp
#include <iostream>
#include <list>

int main() {
    std::list<int> lst = {1, 2, 3, 4, 5};

    // Iterador bidireccional
    std::list<int>::iterator it = lst.begin();

    // Recorrer y mostrar los elementos hacia adelante
    std::cout << "Adelante: ";
    while (it != lst.end()) {
        std::cout << *it << " ";
        ++it;
    }
    std::cout << std::endl;

    // Recorrer y mostrar los elementos hacia atrás
    std::cout << "Atrás: ";
    it = lst.end();
    do {
        --it;
        std::cout << *it << " ";
    } while (it != lst.begin());
    std::cout << std::endl;

    return 0;
}
<---Ejemplo Básico con `std::list` Result--->
<---Ejemplo con `std::reverse`--->
```cpp
#include <iostream>
#include <list>
#include <algorithm>

int main() {
    std::list<int> lst = {5, 3, 8, 1, 9};

    // Usar std::reverse para invertir la lista
    std::reverse(lst.begin(), lst.end());

    // Mostrar los elementos de la lista invertida
    for (const int& val : lst) {
        std::cout << val << " ";
    }
    std::cout << std::endl;

    return 0;
}
<---Ejemplo con `std::reverse` Result--->
<---Ejemplo con `std::vector`--->
```cpp
#include <iostream>
#include <vector>

int main() {
    std::vector<int> vec = {1, 2, 3, 4, 5};

    // Obtener iteradores constantes a los elementos del vector
    std::vector<int>::const_iterator itBegin = vec.cbegin();
    std::vector<int>::const_iterator itEnd = vec.cend();

    // Recorrer y mostrar los elementos del vector sin modificarlos
    for (auto it = itBegin; it != itEnd; ++it) {
        std::cout << *it << " ";
    }
    std::cout << std::endl;

    return 0;
}
<---Ejemplo con `std::vector` Result--->
<---Ejemplo con `std::list`--->
```cpp
#include <iostream>
#include <list>

int main() {
    std::list<int> lst = {1, 2, 3, 4, 5};

    // Obtener iteradores a los elementos de la lista
    std::list<int>::iterator itBegin = lst.begin();
    std::list<int>::iterator itEnd = lst.end();

    // Recorrer y modificar los elementos de la lista
    for (auto it = itBegin; it != itEnd; ++it) {
        *it *= 2;  // Duplicar cada elemento
    }

    // Mostrar los elementos modificados
    for (const auto& val : lst) {
        std::cout << val << " ";
    }
    std::cout << std::endl;

    return 0;
}
```cpp
#include <iostream>
#include <map>

int main() {
    std::map<int, std::string> mapa = {{1, "uno"}, {2, "dos"}, {3, "tres"}};

    // Obtener iteradores a los elementos del mapa
    std::map<int, std::string>::iterator itBegin = mapa.begin();
    std::map<int, std::string>::iterator itEnd = mapa.end();

    // Recorrer y modificar los valores del mapa
    for (auto it = itBegin; it != itEnd; ++it) {
        it->second = "modificado";  // Modificar cada valor
    }

    // Mostrar los elementos modificados
    for (const auto& par : mapa) {
        std::cout << par.first << ": " << par.second << std::endl;
    }

    return 0;
}
<---Ejemplo con `std::list` Result--->
<---`push_back()`--->
```cpp
#include <vector>
#include <iostream>

int main() {
    std::vector<int> vec;
    vec.push_back(1);
    vec.push_back(2);
    vec.push_back(3);

    for (int v : vec) {
        std::cout << v << " ";
    }
    std::cout << std::endl;

    return 0;
}
<---`push_back()` Result--->
<---`insert()`--->
```cpp
#include <list>
#include <iostream>

int main() {
    std::list<int> lst = {1, 2, 3};
    auto it = lst.begin();
    ++it;
    lst.insert(it, 4);  // Inserta 4 antes de 2

    for (int v : lst) {
        std::cout << v << " ";
    }
    std::cout << std::endl;

    return 0;
}
<---`insert()` Result--->
<---`pop_back()`--->
```cpp
#include <vector>
#include <iostream>

int main() {
    std::vector<int> vec = {1, 2, 3};
    vec.pop_back();

    for (int v : vec) {
        std::cout << v << " ";
    }
    std::cout << std::endl;

    return 0;
}
<---`pop_back()` Result--->
<---`erase()`--->
```cpp
#include <list>
#include <iostream>

int main() {
    std::list<int> lst = {1, 2, 3};
    auto it = lst.begin();
    ++it;
    lst.erase(it);  // Elimina 2

    for (int v : lst) {
        std::cout << v << " ";
    }
    std::cout << std::endl;

    return 0;
}
<---`erase()` Result--->
<---`front()`--->
```cpp
#include <deque>
#include <iostream>

int main() {
    std::deque<int> deq = {1, 2, 3};
    std::cout << "Primer elemento: " << deq.front() << std::endl;

    return 0;
}
<---`front()` Result--->
<---`back()`--->
```cpp
#include <deque>
#include <iostream>

int main() {
    std::deque<int> deq = {1, 2, 3};
    std::cout << "Último elemento: " << deq.back() << std::endl;

    return 0;
}
<---`back()` Result--->
<---`operator[]` y `at()`--->
```cpp
#include <vector>
#include <iostream>

int main() {
    std::vector<int> vec = {1, 2, 3};
    std::cout << "Elemento en la posición 1: " << vec[1] << std::endl;
    std::cout << "Elemento en la posición 2: " << vec.at(2) << std::endl;

    return 0;
}
```cpp
#include <vector>
#include <iostream>

int main() {
    std::vector<int> vec = {1, 2, 3};
    vec[1] = 10;  // Modifica el segundo elemento

    for (int v : vec) {
        std::cout << v << " ";
    }
    std::cout << std::endl;

    return 0;
}
<---`operator[]` y `at()` Result--->
<---`size()`--->
```cpp
#include <vector>
#include <iostream>

int main() {
    std::vector<int> vec = {1, 2, 3};
    std::cout << "Tamaño: " << vec.size() << std::endl;

    return 0;
}
<---`size()` Result--->
<---`capacity()`--->
```cpp
#include <vector>
#include <iostream>

int main() {
    std::vector<int> vec = {1, 2, 3};
    std::cout << "Capacidad: " << vec.capacity() << std::endl;

    return 0;
}
<---`capacity()` Result--->
<---`empty()`--->
```cpp
#include <vector>
#include <iostream>

int main() {
    std::vector<int> vec;
    std::cout << "Está vacío: " << vec.empty() << std::endl;

    return 0;
}
<---`empty()` Result--->
<---`begin()` y `end()`--->
```cpp
#include <vector>
#include <iostream>

int main() {
    std::vector<int> vec = {1, 2, 3};

    for (auto it = vec.begin(); it != vec.end(); ++it) {
        std::cout << *it << " ";
    }
    std::cout << std::endl;

    return 0;
}
<---`begin()` y `end()` Result--->
<---`cbegin()` y `cend()`--->
```cpp
#include <vector>
#include <iostream>

int main() {
    std::vector<int> vec = {1, 2, 3};

    for (auto it = vec.cbegin(); it != vec.cend(); ++it) {
        std::cout << *it << " ";
    }
    std::cout << std::endl;

    return 0;
}
<---`cbegin()` y `cend()` Result--->
<---`std::map` y `std::set`--->
```cpp
#include <map>
#include <iostream>

int main() {
    std::map<int, std::string> mapa = {{1, "uno"}, {2, "dos"}, {3, "tres"}};
    auto it = mapa.find(2);
    if (it != mapa.end()) {
        std::cout << "Encontrado: " << it->second << std::endl;
    }

    std::cout << "Número de elementos con clave 2: " << mapa.count(2) << std::endl;

    return 0;
}
<---`std::map` y `std::set` Result--->
<---`std::queue` y `std::stack`--->
```cpp
#include <queue>
#include <iostream>

int main() {
    std::queue<int> q;
    q.push(1);
    q.push(2);
    q.push(3);

    std::cout << "Frente: " << q.front() << std::endl;
    q.pop();
    std::cout << "Frente después de pop: " << q.front() << std::endl;

    return 0;
}
<---`std::queue` y `std::stack` Result--->
<---Ejemplo con `std::vector` y Bucle `for`--->
```cpp
#include <iostream>
#include <vector>

int main() {
    std::vector<int> vec = {1, 2, 3, 4, 5};

    // Uso de iteradores en un bucle for
    for (std::vector<int>::iterator it = vec.begin(); it != vec.end(); ++it) {
        std::cout << *it << " ";
    }
    std::cout << std::endl;

    return 0;
}
<---Ejemplo con `std::vector` y Bucle `for` Result--->
<---Ejemplo con Iteradores Constantes--->
```cpp
#include <iostream>
#include <list>

int main() {
    std::list<int> lst = {1, 2, 3, 4, 5};

    // Uso de iteradores constantes en un bucle while
    std::list<int>::const_iterator it = lst.cbegin();
    while (it != lst.cend()) {
        std::cout << *it << " ";
        ++it;
    }
    std::cout << std::endl;

    return 0;
}
<---Ejemplo con Iteradores Constantes Result--->
<---Ejemplo con `std::list` y Bucle `while`--->
```cpp
#include <iostream>
#include <list>

int main() {
    std::list<int> lst = {1, 2, 3, 4, 5};

    // Uso de iteradores en un bucle while
    std::list<int>::iterator it = lst.begin();
    while (it != lst.end()) {
        std::cout << *it << " ";
        ++it;
    }
    std::cout << std::endl;

    return 0;
}
<---Ejemplo con `std::list` y Bucle `while` Result--->
<---Ejemplo con `std::list` y Bucle `for` en Ambas Direcciones--->
```cpp
#include <iostream>
#include <list>

int main() {
    std::list<int> lst = {1, 2, 3, 4, 5};

    // Recorrer hacia adelante
    for (std::list<int>::iterator it = lst.begin(); it != lst.end(); ++it) {
        std::cout << *it << " ";
    }
    std::cout << std::endl;

    // Recorrer hacia atrás
    for (std::list<int>::iterator it = --lst.end(); it != --lst.begin(); --it) {
        std::cout << *it << " ";
    }
    std::cout << *lst.begin() << std::endl;  // Imprimir el primer elemento por separado

    return 0;
}
<---Ejemplo con `std::list` y Bucle `for` en Ambas Direcciones Result--->
<---Ventajas de Iterar con Índices--->
<---Ventajas de Iterar con Índices Result--->
<---Desventajas de Iterar con Índices--->
<---Desventajas de Iterar con Índices Result--->
<---Ejemplo de Iteración con Índices--->
```cpp
#include <iostream>
#include <vector>

int main() {
    std::vector<int> vec = {1, 2, 3, 4, 5};

    // Iterar con índices
    for (size_t i = 0; i < vec.size(); ++i) {
        std::cout << vec[i] << " ";
    }
    std::cout << std::endl;

    return 0;
}
<---Ejemplo de Iteración con Índices Result--->
<---Ventajas de Iterar con Iteradores--->
<---Ventajas de Iterar con Iteradores Result--->
<---Desventajas de Iterar con Iteradores--->
<---Desventajas de Iterar con Iteradores Result--->
<---Ejemplo de Iteración con Iteradores--->
```cpp
#include <iostream>
#include <vector>

int main() {
    std::vector<int> vec = {1, 2, 3, 4, 5};

    // Iterar con iteradores
    for (std::vector<int>::iterator it = vec.begin(); it != vec.end(); ++it) {
        std::cout << *it << " ";
    }
    std::cout << std::endl;

    return 0;
}
<---Ejemplo de Iteración con Iteradores Result--->
<---Iteración con Índices--->
```cpp
#include <iostream>
#include <vector>

int main() {
    std::vector<int> vec = {1, 2, 3, 4, 5};

    // Iterar con índices
    for (size_t i = 0; i < vec.size(); ++i) {
        std::cout << vec[i] << " ";
    }
    std::cout << std::endl;

    return 0;
}
<---Iteración con Índices Result--->
<---Iteración con Iteradores--->
```cpp
#include <iostream>
#include <vector>

int main() {
    std::vector<int> vec = {1, 2, 3, 4, 5};

    // Iterar con iteradores
    for (std::vector<int>::iterator it = vec.begin(); it != vec.end(); ++it) {
        std::cout << *it << " ";
    }
    std::cout << std::endl;

    return 0;
}
<---Iteración con Iteradores Result--->
<---Iteración con Iteradores (No se puede usar índices)--->
```cpp
#include <iostream>
#include <list>

int main() {
    std::list<int> lst = {1, 2, 3, 4, 5};

    // Iterar con iteradores
    for (std::list<int>::iterator it = lst.begin(); it != lst.end(); ++it) {
        std::cout << *it << " ";
    }
    std::cout << std::endl;

    return 0;
}
<---Iteración con Iteradores (No se puede usar índices) Result--->
<---Sintaxis--->
```cpp
#include <iterator>

template <class InputIterator>
typename std::iterator_traits<InputIterator>::difference_type
distance(InputIterator first, InputIterator last);
<---Sintaxis Result--->
<---Ejemplo de Uso de `std::advance`--->
```cpp
#include <iostream>
#include <vector>
#include <iterator>

int main() {
    std::vector<int> vec = {1, 2, 3, 4, 5};

    // Iterador al primer elemento
    std::vector<int>::iterator it = vec.begin();

    // Avanzar el iterador 3 posiciones
    std::advance(it, 3);

    // Mostrar el valor del elemento apuntado por el iterador
    std::cout << "Elemento en la posición 3: " << *it << std::endl;

    return 0;
}
<---Ejemplo de Uso de `std::advance` Result--->
<---Ejemplo de Uso de `std::distance`--->
```cpp
#include <iostream>
#include <vector>
#include <iterator>

int main() {
    std::vector<int> vec = {1, 2, 3, 4, 5};

    // Iteradores al primer y al cuarto elemento
    std::vector<int>::iterator it1 = vec.begin();
    std::vector<int>::iterator it2 = vec.begin();
    std::advance(it2, 3);

    // Calcular la distancia entre it1 y it2
    std::cout << "Distancia entre it1 e it2: " << std::distance(it1, it2) << std::endl;

    return 0;
}
<---Ejemplo de Uso de `std::distance` Result--->
<---Ejemplo Combinado--->
```cpp
#include <iostream>
#include <list>
#include <iterator>

int main() {
    std::list<int> lst = {10, 20, 30, 40, 50, 60, 70, 80, 90, 100};

    // Iterador al inicio de la lista
    std::list<int>::iterator it1 = lst.begin();

    // Avanzar el iterador 5 posiciones
    std::advance(it1, 5);

    // Iterador al final de la lista
    std::list<int>::iterator it2 = lst.end();

    // Calcular la distancia entre it1 y it2
    std::cout << "Distancia entre it1 e it2: " << std::distance(it1, it2) << std::endl;

    return 0;
}
<---Ejemplo Combinado Result--->
<---Tipos de Iteradores--->
<---Tipos de Iteradores Result--->
<---Ejemplo Básico--->
```cpp
#include <iostream>
#include <vector>

int main() {
    std::vector<int> vec = {1, 2, 3, 4, 5};

    // Iterador que apunta al primer elemento del vector
    std::vector<int>::iterator it = vec.begin();

    // Recorrer el vector usando el iterador
    while (it != vec.end()) {
        std::cout << *it << " ";
        ++it;  // Avanzar al siguiente elemento
    }
    std::cout << std::endl;

    return 0;
}
```cpp
#include <iostream>
#include <vector>
#include <algorithm>

int main() {
    std::vector<int> vec = {5, 2, 8, 1, 3};

    // Ordenar el vector usando std::sort
    std::sort(vec.begin(), vec.end());

    // Encontrar un elemento usando std::find
    auto it = std::find(vec.begin(), vec.end(), 8);

    if (it != vec.end()) {
        std::cout << "Elemento encontrado: " << *it << std::endl;
    } else {
        std::cout << "Elemento no encontrado" << std::endl;
    }

    return 0;
}
<---Ejemplo Básico Result--->
<---Ejemplo de Iteradores Constantes--->
```cpp
#include <iostream>
#include <list>

int main() {
    std::list<int> lst = {1, 2, 3, 4, 5};

    // Iterador constante bidireccional
    std::list<int>::const_iterator it = lst.cbegin();

    // Recorrer y mostrar los elementos hacia adelante
    std::cout << "Adelante: ";
    while (it != lst.cend()) {
        std::cout << *it << " ";
        ++it;
    }
    std::cout << std::endl;

    // Recorrer y mostrar los elementos hacia atrás
    std::cout << "Atrás: ";
    it = lst.cend();
    do {
        --it;
        std::cout << *it << " ";
    } while (it != lst.cbegin());
    std::cout << std::endl;

    return 0;
}
<---Ejemplo de Iteradores Constantes Result--->
<---Ejemplo Básico con `std::istream_iterator`--->
```cpp
#include <iostream>
#include <iterator>
#include <vector>
#include <algorithm>

int main() {
    std::cout << "Ingrese números separados por espacios (Ctrl+D para terminar): ";

    // Crear un istream_iterator para leer desde std::cin
    std::istream_iterator<int> inicio(std::cin);
    std::istream_iterator<int> fin;  // Iterador de fin predeterminado

    // Leer todos los números ingresados en un vector
    std::vector<int> numeros(inicio, fin);

    // Mostrar los números leídos
    std::cout << "Números ingresados: ";
    for (int numero : numeros) {
        std::cout << numero << " ";
    }
    std::cout << std::endl;

    return 0;
}
<---Ejemplo Básico con `std::istream_iterator` Result--->
<---Ejemplo con `std::copy`--->
```cpp
#include <iostream>
#include <iterator>
#include <vector>
#include <algorithm>

int main() {
    std::vector<int> numeros = {5, 2, 8, 1, 3};

    // Crear un ostream_iterator para escribir en std::cout
    std::ostream_iterator<int> salida(std::cout, " ");

    // Usar std::copy para escribir los números en std::cout
    std::copy(numeros.begin(), numeros.end(), salida);
    std::cout << std::endl;

    return 0;
}
<---Ejemplo con `std::copy` Result--->
<---Ejemplo de Implementación Personalizada--->
```cpp
#include <iostream>
#include <iterator>
#include <vector>

template <typename T>
class BidirectionalIterator : public std::iterator<std::bidirectional_iterator_tag, T> {
    T* ptr;

public:
    BidirectionalIterator(T* p = nullptr) : ptr(p) {}

    T& operator*() const { return *ptr; }
    T* operator->() const { return ptr; }

    BidirectionalIterator& operator++() {
        ++ptr;
        return *this;
    }

    BidirectionalIterator operator++(int) {
        BidirectionalIterator temp = *this;
        ++(*this);
        return temp;
    }

    BidirectionalIterator& operator--() {
        --ptr;
        return *this;
    }

    BidirectionalIterator operator--(int) {
        BidirectionalIterator temp = *this;
        --(*this);
        return temp;
    }

    bool operator==(const BidirectionalIterator& other) const {
        return ptr == other.ptr;
    }

    bool operator!=(const BidirectionalIterator& other) const {
        return ptr != other.ptr;
    }
};

int main() {
    std::vector<int> vec = {1, 2, 3, 4, 5};

    BidirectionalIterator<int> itBegin(vec.data());
    BidirectionalIterator<int> itEnd(vec.data() + vec.size());

    // Recorrer y mostrar los elementos hacia adelante
    std::cout << "Adelante: ";
    for (auto it = itBegin; it != itEnd; ++it) {
        std::cout << *it << " ";
    }
    std::cout << std::endl;

    // Recorrer y mostrar los elementos hacia atrás
    std::cout << "Atrás: ";
    for (auto it = itEnd; it != itBegin;) {
        --it;
        std::cout << *it << " ";
    }
    std::cout << std::endl;

    return 0;
}
<---Ejemplo de Implementación Personalizada Result--->
<---Ejemplo Básico con `std::ostream_iterator`--->
```cpp
#include <iostream>
#include <iterator>
#include <vector>

int main() {
    std::vector<int> numeros = {1, 2, 3, 4, 5};

    // Crear un ostream_iterator para escribir en std::cout
    std::ostream_iterator<int> salida(std::cout, " ");

    // Usar el iterador de salida para escribir los números
    for (int numero : numeros) {
        *salida = numero;
        ++salida;
    }
    std::cout << std::endl;

    return 0;
}
<---Ejemplo Básico con `std::ostream_iterator` Result--->
<---Ejemplo Básico con `std::forward_list`--->
```cpp
#include <iostream>
#include <forward_list>

int main() {
    std::forward_list<int> flist = {1, 2, 3, 4, 5};

    // Iterador de avance
    std::forward_list<int>::iterator it = flist.begin();

    // Recorrer y mostrar los elementos
    while (it != flist.end()) {
        std::cout << *it << " ";
        ++it;
    }
    std::cout << std::endl;

    return 0;
}
<---Ejemplo Básico con `std::forward_list` Result--->
<---Ejemplo con `std::find`--->
```cpp
#include <iostream>
#include <forward_list>
#include <algorithm>

int main() {
    std::forward_list<int> flist = {5, 3, 8, 1, 9};

    // Buscar un elemento usando std::find
    auto it = std::find(flist.begin(), flist.end(), 8);

    if (it != flist.end()) {
        std::cout << "Elemento encontrado: " << *it << std::endl;
    } else {
        std::cout << "Elemento no encontrado" << std::endl;
    }

    return 0;
}
<---Ejemplo con `std::find` Result--->
<---Ejemplo con `std::transform`--->
```cpp
#include <iostream>
#include <forward_list>
#include <algorithm>

int main() {
    std::forward_list<int> flist = {1, 2, 3, 4, 5};
    std::forward_list<int> resultado;

    // Reservar espacio en la lista de resultado
    resultado.resize(flist.size());

    // Usar std::transform para multiplicar cada elemento por 2
    std::transform(flist.begin(), flist.end(), resultado.begin(), [](int x) {
        return x * 2;
    });

    // Mostrar los resultados
    for (const auto& val : resultado) {
        std::cout << val << " ";
    }
    std::cout << std::endl;

    return 0;
}
<---Ejemplo con `std::transform` Result--->
<---Ejemplo Básico con `std::list`--->
```cpp
#include <iostream>
#include <list>

int main() {
    std::list<int> lst = {1, 2, 3, 4, 5};

    // Iterador bidireccional
    std::list<int>::iterator it = lst.begin();

    // Recorrer y mostrar los elementos hacia adelante
    std::cout << "Adelante: ";
    while (it != lst.end()) {
        std::cout << *it << " ";
        ++it;
    }
    std::cout << std::endl;

    // Recorrer y mostrar los elementos hacia atrás
    std::cout << "Atrás: ";
    it = lst.end();
    do {
        --it;
        std::cout << *it << " ";
    } while (it != lst.begin());
    std::cout << std::endl;

    return 0;
}
<---Ejemplo Básico con `std::list` Result--->
<---Ejemplo con `std::reverse`--->
```cpp
#include <iostream>
#include <list>
#include <algorithm>

int main() {
    std::list<int> lst = {5, 3, 8, 1, 9};

    // Usar std::reverse para invertir la lista
    std::reverse(lst.begin(), lst.end());

    // Mostrar los elementos de la lista invertida
    for (const int& val : lst) {
        std::cout << val << " ";
    }
    std::cout << std::endl;

    return 0;
}
<---Ejemplo con `std::reverse` Result--->
<---Ejemplo con `std::vector`--->
```cpp
#include <iostream>
#include <vector>

int main() {
    std::vector<int> vec = {1, 2, 3, 4, 5};

    // Obtener iteradores constantes a los elementos del vector
    std::vector<int>::const_iterator itBegin = vec.cbegin();
    std::vector<int>::const_iterator itEnd = vec.cend();

    // Recorrer y mostrar los elementos del vector sin modificarlos
    for (auto it = itBegin; it != itEnd; ++it) {
        std::cout << *it << " ";
    }
    std::cout << std::endl;

    return 0;
}
<---Ejemplo con `std::vector` Result--->
<---Ejemplo con `std::list`--->
```cpp
#include <iostream>
#include <list>

int main() {
    std::list<int> lst = {1, 2, 3, 4, 5};

    // Obtener iteradores a los elementos de la lista
    std::list<int>::iterator itBegin = lst.begin();
    std::list<int>::iterator itEnd = lst.end();

    // Recorrer y modificar los elementos de la lista
    for (auto it = itBegin; it != itEnd; ++it) {
        *it *= 2;  // Duplicar cada elemento
    }

    // Mostrar los elementos modificados
    for (const auto& val : lst) {
        std::cout << val << " ";
    }
    std::cout << std::endl;

    return 0;
}
```cpp
#include <iostream>
#include <map>

int main() {
    std::map<int, std::string> mapa = {{1, "uno"}, {2, "dos"}, {3, "tres"}};

    // Obtener iteradores a los elementos del mapa
    std::map<int, std::string>::iterator itBegin = mapa.begin();
    std::map<int, std::string>::iterator itEnd = mapa.end();

    // Recorrer y modificar los valores del mapa
    for (auto it = itBegin; it != itEnd; ++it) {
        it->second = "modificado";  // Modificar cada valor
    }

    // Mostrar los elementos modificados
    for (const auto& par : mapa) {
        std::cout << par.first << ": " << par.second << std::endl;
    }

    return 0;
}
<---Ejemplo con `std::list` Result--->
<---`push_back()`--->
```cpp
#include <vector>
#include <iostream>

int main() {
    std::vector<int> vec;
    vec.push_back(1);
    vec.push_back(2);
    vec.push_back(3);

    for (int v : vec) {
        std::cout << v << " ";
    }
    std::cout << std::endl;

    return 0;
}
<---`push_back()` Result--->
<---`insert()`--->
```cpp
#include <list>
#include <iostream>

int main() {
    std::list<int> lst = {1, 2, 3};
    auto it = lst.begin();
    ++it;
    lst.insert(it, 4);  // Inserta 4 antes de 2

    for (int v : lst) {
        std::cout << v << " ";
    }
    std::cout << std::endl;

    return 0;
}
<---`insert()` Result--->
<---`pop_back()`--->
```cpp
#include <vector>
#include <iostream>

int main() {
    std::vector<int> vec = {1, 2, 3};
    vec.pop_back();

    for (int v : vec) {
        std::cout << v << " ";
    }
    std::cout << std::endl;

    return 0;
}
<---`pop_back()` Result--->
<---`erase()`--->
```cpp
#include <list>
#include <iostream>

int main() {
    std::list<int> lst = {1, 2, 3};
    auto it = lst.begin();
    ++it;
    lst.erase(it);  // Elimina 2

    for (int v : lst) {
        std::cout << v << " ";
    }
    std::cout << std::endl;

    return 0;
}
<---`erase()` Result--->
<---`front()`--->
```cpp
#include <deque>
#include <iostream>

int main() {
    std::deque<int> deq = {1, 2, 3};
    std::cout << "Primer elemento: " << deq.front() << std::endl;

    return 0;
}
<---`front()` Result--->
<---`back()`--->
```cpp
#include <deque>
#include <iostream>

int main() {
    std::deque<int> deq = {1, 2, 3};
    std::cout << "Último elemento: " << deq.back() << std::endl;

    return 0;
}
<---`back()` Result--->
<---`operator[]` y `at()`--->
```cpp
#include <vector>
#include <iostream>

int main() {
    std::vector<int> vec = {1, 2, 3};
    std::cout << "Elemento en la posición 1: " << vec[1] << std::endl;
    std::cout << "Elemento en la posición 2: " << vec.at(2) << std::endl;

    return 0;
}
```cpp
#include <vector>
#include <iostream>

int main() {
    std::vector<int> vec = {1, 2, 3};
    vec[1] = 10;  // Modifica el segundo elemento

    for (int v : vec) {
        std::cout << v << " ";
    }
    std::cout << std::endl;

    return 0;
}
<---`operator[]` y `at()` Result--->
<---`size()`--->
```cpp
#include <vector>
#include <iostream>

int main() {
    std::vector<int> vec = {1, 2, 3};
    std::cout << "Tamaño: " << vec.size() << std::endl;

    return 0;
}
<---`size()` Result--->
<---`capacity()`--->
```cpp
#include <vector>
#include <iostream>

int main() {
    std::vector<int> vec = {1, 2, 3};
    std::cout << "Capacidad: " << vec.capacity() << std::endl;

    return 0;
}
<---`capacity()` Result--->
<---`empty()`--->
```cpp
#include <vector>
#include <iostream>

int main() {
    std::vector<int> vec;
    std::cout << "Está vacío: " << vec.empty() << std::endl;

    return 0;
}
<---`empty()` Result--->
<---`begin()` y `end()`--->
```cpp
#include <vector>
#include <iostream>

int main() {
    std::vector<int> vec = {1, 2, 3};

    for (auto it = vec.begin(); it != vec.end(); ++it) {
        std::cout << *it << " ";
    }
    std::cout << std::endl;

    return 0;
}
<---`begin()` y `end()` Result--->
<---`cbegin()` y `cend()`--->
```cpp
#include <vector>
#include <iostream>

int main() {
    std::vector<int> vec = {1, 2, 3};

    for (auto it = vec.cbegin(); it != vec.cend(); ++it) {
        std::cout << *it << " ";
    }
    std::cout << std::endl;

    return 0;
}
<---`cbegin()` y `cend()` Result--->
<---`std::map` y `std::set`--->
```cpp
#include <map>
#include <iostream>

int main() {
    std::map<int, std::string> mapa = {{1, "uno"}, {2, "dos"}, {3, "tres"}};
    auto it = mapa.find(2);
    if (it != mapa.end()) {
        std::cout << "Encontrado: " << it->second << std::endl;
    }

    std::cout << "Número de elementos con clave 2: " << mapa.count(2) << std::endl;

    return 0;
}
<---`std::map` y `std::set` Result--->
<---`std::queue` y `std::stack`--->
```cpp
#include <queue>
#include <iostream>

int main() {
    std::queue<int> q;
    q.push(1);
    q.push(2);
    q.push(3);

    std::cout << "Frente: " << q.front() << std::endl;
    q.pop();
    std::cout << "Frente después de pop: " << q.front() << std::endl;

    return 0;
}
<---`std::queue` y `std::stack` Result--->
<---Ejemplo con `std::vector` y Bucle `for`--->
```cpp
#include <iostream>
#include <vector>

int main() {
    std::vector<int> vec = {1, 2, 3, 4, 5};

    // Uso de iteradores en un bucle for
    for (std::vector<int>::iterator it = vec.begin(); it != vec.end(); ++it) {
        std::cout << *it << " ";
    }
    std::cout << std::endl;

    return 0;
}
<---Ejemplo con `std::vector` y Bucle `for` Result--->
<---Ejemplo con Iteradores Constantes--->
```cpp
#include <iostream>
#include <list>

int main() {
    std::list<int> lst = {1, 2, 3, 4, 5};

    // Uso de iteradores constantes en un bucle while
    std::list<int>::const_iterator it = lst.cbegin();
    while (it != lst.cend()) {
        std::cout << *it << " ";
        ++it;
    }
    std::cout << std::endl;

    return 0;
}
<---Ejemplo con Iteradores Constantes Result--->
<---Ejemplo con `std::list` y Bucle `while`--->
```cpp
#include <iostream>
#include <list>

int main() {
    std::list<int> lst = {1, 2, 3, 4, 5};

    // Uso de iteradores en un bucle while
    std::list<int>::iterator it = lst.begin();
    while (it != lst.end()) {
        std::cout << *it << " ";
        ++it;
    }
    std::cout << std::endl;

    return 0;
}
<---Ejemplo con `std::list` y Bucle `while` Result--->
<---Ejemplo con `std::list` y Bucle `for` en Ambas Direcciones--->
```cpp
#include <iostream>
#include <list>

int main() {
    std::list<int> lst = {1, 2, 3, 4, 5};

    // Recorrer hacia adelante
    for (std::list<int>::iterator it = lst.begin(); it != lst.end(); ++it) {
        std::cout << *it << " ";
    }
    std::cout << std::endl;

    // Recorrer hacia atrás
    for (std::list<int>::iterator it = --lst.end(); it != --lst.begin(); --it) {
        std::cout << *it << " ";
    }
    std::cout << *lst.begin() << std::endl;  // Imprimir el primer elemento por separado

    return 0;
}
<---Ejemplo con `std::list` y Bucle `for` en Ambas Direcciones Result--->
<---Ventajas de Iterar con Índices--->
<---Ventajas de Iterar con Índices Result--->
<---Desventajas de Iterar con Índices--->
<---Desventajas de Iterar con Índices Result--->
<---Ejemplo de Iteración con Índices--->
```cpp
#include <iostream>
#include <vector>

int main() {
    std::vector<int> vec = {1, 2, 3, 4, 5};

    // Iterar con índices
    for (size_t i = 0; i < vec.size(); ++i) {
        std::cout << vec[i] << " ";
    }
    std::cout << std::endl;

    return 0;
}
<---Ejemplo de Iteración con Índices Result--->
<---Ventajas de Iterar con Iteradores--->
<---Ventajas de Iterar con Iteradores Result--->
<---Desventajas de Iterar con Iteradores--->
<---Desventajas de Iterar con Iteradores Result--->
<---Ejemplo de Iteración con Iteradores--->
```cpp
#include <iostream>
#include <vector>

int main() {
    std::vector<int> vec = {1, 2, 3, 4, 5};

    // Iterar con iteradores
    for (std::vector<int>::iterator it = vec.begin(); it != vec.end(); ++it) {
        std::cout << *it << " ";
    }
    std::cout << std::endl;

    return 0;
}
<---Ejemplo de Iteración con Iteradores Result--->
<---Iteración con Índices--->
```cpp
#include <iostream>
#include <vector>

int main() {
    std::vector<int> vec = {1, 2, 3, 4, 5};

    // Iterar con índices
    for (size_t i = 0; i < vec.size(); ++i) {
        std::cout << vec[i] << " ";
    }
    std::cout << std::endl;

    return 0;
}
<---Iteración con Índices Result--->
<---Iteración con Iteradores--->
```cpp
#include <iostream>
#include <vector>

int main() {
    std::vector<int> vec = {1, 2, 3, 4, 5};

    // Iterar con iteradores
    for (std::vector<int>::iterator it = vec.begin(); it != vec.end(); ++it) {
        std::cout << *it << " ";
    }
    std::cout << std::endl;

    return 0;
}
<---Iteración con Iteradores Result--->
<---Iteración con Iteradores (No se puede usar índices)--->
```cpp
#include <iostream>
#include <list>

int main() {
    std::list<int> lst = {1, 2, 3, 4, 5};

    // Iterar con iteradores
    for (std::list<int>::iterator it = lst.begin(); it != lst.end(); ++it) {
        std::cout << *it << " ";
    }
    std::cout << std::endl;

    return 0;
}
<---Iteración con Iteradores (No se puede usar índices) Result--->
<---Sintaxis--->
```cpp
#include <iterator>

template <class BidirectionalIterator>
BidirectionalIterator prev(BidirectionalIterator it, typename std::iterator_traits<BidirectionalIterator>::difference_type n = 1);
<---Sintaxis Result--->
<---Ejemplo de Uso de `std::advance`--->
```cpp
#include <iostream>
#include <vector>
#include <iterator>

int main() {
    std::vector<int> vec = {1, 2, 3, 4, 5};

    // Iterador al primer elemento
    std::vector<int>::iterator it = vec.begin();

    // Avanzar el iterador 3 posiciones
    std::advance(it, 3);

    // Mostrar el valor del elemento apuntado por el iterador
    std::cout << "Elemento en la posición 3: " << *it << std::endl;

    return 0;
}
<---Ejemplo de Uso de `std::advance` Result--->
<---Ejemplo de Uso de `std::distance`--->
```cpp
#include <iostream>
#include <vector>
#include <iterator>

int main() {
    std::vector<int> vec = {1, 2, 3, 4, 5};

    // Iteradores al primer y al cuarto elemento
    std::vector<int>::iterator it1 = vec.begin();
    std::vector<int>::iterator it2 = vec.begin();
    std::advance(it2, 3);

    // Calcular la distancia entre it1 y it2
    std::cout << "Distancia entre it1 e it2: " << std::distance(it1, it2) << std::endl;

    return 0;
}
<---Ejemplo de Uso de `std::distance` Result--->
<---Ejemplo Combinado--->
```cpp
#include <iostream>
#include <vector>
#include <iterator>

int main() {
    std::vector<int> vec = {10, 20, 30, 40, 50};

    // Obtener iteradores avanzando y retrocediendo
    auto it1 = std::next(vec.begin(), 2);  // Avanzar 2 posiciones desde el inicio
    auto it2 = std::prev(vec.end(), 3);    // Retroceder 3 posiciones desde el final

    // Mostrar los valores apuntados por los iteradores
    std::cout << "Elemento en la posición 2 desde el inicio: " << *it1 << std::endl;
    std::cout << "Elemento en la posición 3 desde el final: " << *it2 << std::endl;

    return 0;
}
<---Ejemplo Combinado Result--->
<---Ejemplo de Uso de `std::next`--->
```cpp
#include <iostream>
#include <vector>
#include <iterator>

int main() {
    std::vector<int> vec = {10, 20, 30, 40, 50};

    // Obtener un iterador 3 posiciones adelante desde el comienzo
    auto it = std::next(vec.begin(), 3);

    // Mostrar el valor del elemento apuntado por el nuevo iterador
    std::cout << "Elemento en la posición 3: " << *it << std::endl;

    return 0;
}
<---Ejemplo de Uso de `std::next` Result--->
<---Ejemplo de Uso de `std::prev`--->
```cpp
#include <iostream>
#include <list>
#include <iterator>

int main() {
    std::list<int> lst = {10, 20, 30, 40, 50};

    // Obtener un iterador 2 posiciones atrás desde el final
    auto it = std::prev(lst.end(), 2);

    // Mostrar el valor del elemento apuntado por el nuevo iterador
    std::cout << "Elemento 2 posiciones antes del final: " << *it << std::endl;

    return 0;
}
<---Ejemplo de Uso de `std::prev` Result--->
