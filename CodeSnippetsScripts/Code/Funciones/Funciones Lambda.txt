<---EXPLANATION--->
### Funciones Lambda en C++

Las funciones lambda, introducidas en C++11, son funciones anónimas que permiten definir funciones en línea en el lugar donde se necesitan, sin tener que declararlas por separado. Las lambdas son útiles para pasar funciones como argumentos a otras funciones, especialmente en algoritmos de la biblioteca estándar, como `std::sort`, `std::for_each`, etc.

#### Sintaxis Básica de las Lambdas

La sintaxis básica de una lambda en C++ es la siguiente:

```cpp
[captura](parametros) -> tipo_retorno {
    // cuerpo de la lambda
};
```

- **Captura (`[]`):** Define el alcance de las variables externas que la lambda puede usar.
- **Parámetros (`()`):** Especifica los parámetros que la lambda toma (opcional).
- **Tipo de Retorno (`->`):** Define explícitamente el tipo de retorno de la lambda (opcional, usualmente deducido).
- **Cuerpo (`{}`):** El bloque de código que define el comportamiento de la lambda.

##### Ejemplo Básico

```cpp
#include <iostream>
using namespace std;

int main() {
    auto sumar = [](int a, int b) {
        return a + b;
    };

    cout << "La suma de 3 y 4 es: " << sumar(3, 4) << endl;

    return 0;
}
```

En este ejemplo, `sumar` es una lambda que toma dos enteros y devuelve su suma.

#### Captura de Variables

Las lambdas pueden capturar variables del entorno donde se definen. Existen diferentes modos de captura:

- **Por Valor (`[=]`):** Captura todas las variables usadas en la lambda por valor.
- **Por Referencia (`[&]`):** Captura todas las variables usadas en la lambda por referencia.
- **Captura Explícita:** Captura variables específicas por valor o referencia.

##### Ejemplo con Captura por Valor y Referencia

```cpp
#include <iostream>
using namespace std;

int main() {
    int x = 10;
    int y = 20;

    auto lambdaPorValor = [=]() {
        return x + y;
    };

    auto lambdaPorReferencia = [&]() {
        x++;
        y++;
    };

    cout << "Resultado (por valor): " << lambdaPorValor() << endl;

    lambdaPorReferencia();
    cout << "x: " << x << ", y: " << y << " (después de modificar por referencia)" << endl;

    return 0;
}
```

En este ejemplo:
- `lambdaPorValor` captura `x` y `y` por valor.
- `lambdaPorReferencia` captura `x` y `y` por referencia, permitiendo modificar sus valores.

#### Tipos de Retorno

Las lambdas pueden deducir su tipo de retorno automáticamente o especificarlo explícitamente.

##### Ejemplo con Tipo de Retorno Deducido y Especificado

```cpp
#include <iostream>
using namespace std;

int main() {
    auto sumar = [](int a, int b) {
        return a + b;
    };

    auto dividir = [](int a, int b) -> double {
        if (b == 0) {
            throw invalid_argument("División por cero");
        }
        return static_cast<double>(a) / b;
    };

    cout << "La suma de 3 y 4 es: " << sumar(3, 4) << endl;
    cout << "La división de 10 por 2 es: " << dividir(10, 2) << endl;

    return 0;
}
```

En este ejemplo, `sumar` tiene su tipo de retorno deducido automáticamente como `int`, mientras que `dividir` especifica explícitamente su tipo de retorno como `double`.

#### Uso en Algoritmos de la Biblioteca Estándar

Las lambdas son extremadamente útiles cuando se utilizan con algoritmos de la biblioteca estándar.

##### Ejemplo con `std::sort`

```cpp
#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;

int main() {
    vector<int> numeros = {5, 2, 9, 1, 5, 6};

    sort(numeros.begin(), numeros.end(), [](int a, int b) {
        return a < b;
    });

    cout << "Números ordenados: ";
    for (int num : numeros) {
        cout << num << " ";
    }
    cout << endl;

    return 0;
}
```

En este ejemplo, se usa una lambda para definir el criterio de ordenación en `std::sort`.

#### Lambdas Capturando por Valor y Modificables

Las lambdas pueden capturar variables por valor y modificarlas internamente usando la palabra clave `mutable`.

##### Ejemplo con `mutable`

```cpp
#include <iostream>
using namespace std;

int main() {
    int x = 10;

    auto modificar = [x]() mutable {
        x += 5;
        return x;
    };

    cout << "Resultado de la lambda mutable: " << modificar() << endl;
    cout << "Valor original de x: " << x << endl;

    return 0;
}
```

En este ejemplo, `modificar` captura `x` por valor pero usa `mutable` para permitir modificar la copia interna de `x`.

### Ejemplo Completo

A continuación, un ejemplo completo que demuestra el uso de lambdas en varias situaciones, incluyendo captura por valor, referencia, y uso en algoritmos de la biblioteca estándar.

```cpp
#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;

int main() {
    vector<int> numeros = {5, 2, 9, 1, 5, 6};

    // Lambda que captura por valor
    auto imprimir = [=]() {
        for (int num : numeros) {
            cout << num << " ";
        }
        cout << endl;
    };

    // Lambda que captura por referencia
    auto incrementar = [&]() {
        for (int& num : numeros) {
            num++;
        }
    };

    // Lambda con tipo de retorno deducido
    auto sumar = [](int a, int b) {
        return a + b;
    };

    // Lambda con tipo de retorno especificado
    auto dividir = [](int a, int b) -> double {
        if (b == 0) {
            throw invalid_argument("División por cero");
        }
        return static_cast<double>(a) / b;
    };

    cout << "Números originales: ";
    imprimir();

    incrementar();
    cout << "Números incrementados: ";
    imprimir();

    sort(numeros.begin(), numeros.end(), [](int a, int b) {
        return a < b;
    });
    cout << "Números ordenados: ";
    imprimir();

    cout << "La suma de 3 y 4 es: " << sumar(3, 4) << endl;
    cout << "La división de 10 por 2 es: " << dividir(10, 2) << endl;

    return 0;
}
```

### Conclusión

Las funciones lambda en C++ son una poderosa herramienta para definir funciones en línea de manera concisa y flexible. Facilitan el paso de funciones como argumentos a otras funciones y mejoran la legibilidad y mantenibilidad del código. Las lambdas pueden capturar variables por valor o por referencia y permiten deducir o especificar explícitamente el tipo de retorno. Con una comprensión sólida de las lambdas, los desarrolladores pueden escribir código C++ más limpio y eficiente.
<---FILES--->
Ejemplo Básico
Ejemplo Básico Result
Ejemplo con Captura por Valor y Referencia
Ejemplo con Captura por Valor y Referencia Result
Ejemplo con Tipo de Retorno Deducido y Especificado
Ejemplo con Tipo de Retorno Deducido y Especificado Result
Ejemplo con `std::sort`
Ejemplo con `std::sort` Result
Ejemplo con `mutable`
Ejemplo con `mutable` Result
<---Ejemplo Básico--->
```cpp
#include <iostream>
using namespace std;

int main() {
    auto sumar = [](int a, int b) {
        return a + b;
    };

    cout << "La suma de 3 y 4 es: " << sumar(3, 4) << endl;

    return 0;
}
<---Ejemplo Básico Result--->
<---Ejemplo con Captura por Valor y Referencia--->
```cpp
#include <iostream>
using namespace std;

int main() {
    int x = 10;
    int y = 20;

    auto lambdaPorValor = [=]() {
        return x + y;
    };

    auto lambdaPorReferencia = [&]() {
        x++;
        y++;
    };

    cout << "Resultado (por valor): " << lambdaPorValor() << endl;

    lambdaPorReferencia();
    cout << "x: " << x << ", y: " << y << " (después de modificar por referencia)" << endl;

    return 0;
}
<---Ejemplo con Captura por Valor y Referencia Result--->
<---Ejemplo con Tipo de Retorno Deducido y Especificado--->
```cpp
#include <iostream>
using namespace std;

int main() {
    auto sumar = [](int a, int b) {
        return a + b;
    };

    auto dividir = [](int a, int b) -> double {
        if (b == 0) {
            throw invalid_argument("División por cero");
        }
        return static_cast<double>(a) / b;
    };

    cout << "La suma de 3 y 4 es: " << sumar(3, 4) << endl;
    cout << "La división de 10 por 2 es: " << dividir(10, 2) << endl;

    return 0;
}
<---Ejemplo con Tipo de Retorno Deducido y Especificado Result--->
<---Ejemplo con `std::sort`--->
```cpp
#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;

int main() {
    vector<int> numeros = {5, 2, 9, 1, 5, 6};

    sort(numeros.begin(), numeros.end(), [](int a, int b) {
        return a < b;
    });

    cout << "Números ordenados: ";
    for (int num : numeros) {
        cout << num << " ";
    }
    cout << endl;

    return 0;
}
<---Ejemplo con `std::sort` Result--->
<---Ejemplo con `mutable`--->
```cpp
#include <iostream>
using namespace std;

int main() {
    int x = 10;

    auto modificar = [x]() mutable {
        x += 5;
        return x;
    };

    cout << "Resultado de la lambda mutable: " << modificar() << endl;
    cout << "Valor original de x: " << x << endl;

    return 0;
}
```cpp
#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;

int main() {
    vector<int> numeros = {5, 2, 9, 1, 5, 6};

    // Lambda que captura por valor
    auto imprimir = [=]() {
        for (int num : numeros) {
            cout << num << " ";
        }
        cout << endl;
    };

    // Lambda que captura por referencia
    auto incrementar = [&]() {
        for (int& num : numeros) {
            num++;
        }
    };

    // Lambda con tipo de retorno deducido
    auto sumar = [](int a, int b) {
        return a + b;
    };

    // Lambda con tipo de retorno especificado
    auto dividir = [](int a, int b) -> double {
        if (b == 0) {
            throw invalid_argument("División por cero");
        }
        return static_cast<double>(a) / b;
    };

    cout << "Números originales: ";
    imprimir();

    incrementar();
    cout << "Números incrementados: ";
    imprimir();

    sort(numeros.begin(), numeros.end(), [](int a, int b) {
        return a < b;
    });
    cout << "Números ordenados: ";
    imprimir();

    cout << "La suma de 3 y 4 es: " << sumar(3, 4) << endl;
    cout << "La división de 10 por 2 es: " << dividir(10, 2) << endl;

    return 0;
}
<---Ejemplo con `mutable` Result--->
