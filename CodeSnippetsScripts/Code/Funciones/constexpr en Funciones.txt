<---EXPLANATION--->
### Funciones y Procedimientos en C++: Definición y Declaración de Funciones

Las funciones en C++ son bloques de código que realizan una tarea específica y pueden ser llamadas desde diferentes partes de un programa. Definir y declarar funciones es fundamental para estructurar y modularizar el código, facilitando la reutilización y el mantenimiento.

#### Declaración de Funciones

La declaración de una función (también conocida como prototipo de función) informa al compilador sobre la existencia de una función antes de su definición real. La declaración incluye el tipo de retorno, el nombre de la función y los tipos de parámetros.

##### Sintaxis de la Declaración de Funciones

```cpp
tipo_retorno nombre_funcion(lista_de_parametros);
```

- **tipo_retorno**: El tipo de dato que devuelve la función.
- **nombre_funcion**: El identificador de la función.
- **lista_de_parametros**: Los tipos y nombres de los parámetros que acepta la función.

##### Ejemplo de Declaración de Función

```cpp
int sumar(int a, int b);
void mostrarMensaje(string mensaje);
```

En este ejemplo:
- `int sumar(int a, int b);` declara una función que toma dos enteros y devuelve un entero.
- `void mostrarMensaje(string mensaje);` declara una función que toma una cadena y no devuelve nada.

#### Definición de Funciones

La definición de una función proporciona el cuerpo de la función, es decir, el bloque de código que se ejecuta cuando se llama a la función. La definición incluye la declaración de la función y el bloque de código asociado.

##### Sintaxis de la Definición de Funciones

```cpp
tipo_retorno nombre_funcion(lista_de_parametros) {
    // Cuerpo de la función
}
```

##### Ejemplo de Definición de Función

```cpp
int sumar(int a, int b) {
    return a + b;
}

void mostrarMensaje(string mensaje) {
    cout << mensaje << endl;
}
```

En este ejemplo:
- `int sumar(int a, int b) { return a + b; }` define una función que suma dos enteros y devuelve el resultado.
- `void mostrarMensaje(string mensaje) { cout << mensaje << endl; }` define una función que muestra un mensaje en la consola.

#### Ejemplo Completo: Declaración y Definición de Funciones

```cpp
#include <iostream>
using namespace std;

// Declaraciones de funciones
int sumar(int a, int b);
void mostrarMensaje(string mensaje);

int main() {
    int resultado = sumar(5, 3);
    cout << "La suma es: " << resultado << endl;

    mostrarMensaje("Hola, mundo!");

    return 0;
}

// Definiciones de funciones
int sumar(int a, int b) {
    return a + b;
}

void mostrarMensaje(string mensaje) {
    cout << mensaje << endl;
}
```

En este ejemplo completo:
- Las funciones `sumar` y `mostrarMensaje` se declaran antes del `main`.
- Las definiciones de las funciones `sumar` y `mostrarMensaje` proporcionan los cuerpos de las funciones después del `main`.

#### Funciones con Parámetros por Valor y por Referencia

En C++, los parámetros de las funciones pueden pasarse por valor o por referencia.

##### Parámetros por Valor

Los parámetros por valor se copian en los parámetros de la función. Los cambios en los parámetros dentro de la función no afectan a los argumentos originales.

```cpp
void incrementarPorValor(int x) {
    x++;
}

int main() {
    int numero = 5;
    incrementarPorValor(numero);
    cout << "Número después de incrementar por valor: " << numero << endl; // Salida: 5
    return 0;
}
```

##### Parámetros por Referencia

Los parámetros por referencia permiten que la función modifique los argumentos originales. Se utilizan referencias (`&`) en la lista de parámetros.

```cpp
void incrementarPorReferencia(int& x) {
    x++;
}

int main() {
    int numero = 5;
    incrementarPorReferencia(numero);
    cout << "Número después de incrementar por referencia: " << numero << endl; // Salida: 6
    return 0;
}
```

#### Sobrecarga de Funciones

C++ permite la sobrecarga de funciones, es decir, varias funciones pueden tener el mismo nombre pero diferentes listas de parámetros.

##### Ejemplo de Sobrecarga de Funciones

```cpp
#include <iostream>
using namespace std;

int sumar(int a, int b) {
    return a + b;
}

double sumar(double a, double b) {
    return a + b;
}

int main() {
    cout << "Suma de enteros: " << sumar(3, 4) << endl;       // Llama a sumar(int, int)
    cout << "Suma de dobles: " << sumar(3.5, 2.5) << endl;    // Llama a sumar(double, double)
    return 0;
}
```

### Conclusión

Las funciones son una parte esencial de la programación en C++. Comprender cómo declarar y definir funciones, así como las diferencias entre pasar parámetros por valor y por referencia, permite escribir código modular, reutilizable y fácil de mantener. La sobrecarga de funciones añade flexibilidad, permitiendo definir múltiples versiones de una función para manejar diferentes tipos de datos o cantidades de parámetros. Con estas habilidades, los desarrolladores pueden estructurar mejor sus programas y resolver problemas de manera eficiente.
### Parámetros y Argumentos en C++

Los parámetros y argumentos son conceptos fundamentales en la programación de funciones. Los parámetros son variables en la definición de la función que actúan como marcadores de posición para los valores que se pasarán a la función cuando se llame. Los argumentos son los valores reales que se pasan a la función cuando se invoca.

#### Parámetros

Los parámetros se declaran en la definición de la función. Actúan como variables locales dentro del cuerpo de la función, permitiendo que la función opere con los valores proporcionados en la llamada.

##### Tipos de Parámetros

1. **Parámetros por Valor**
2. **Parámetros por Referencia**
3. **Parámetros por Puntero**
4. **Parámetros Predeterminados**

##### Parámetros por Valor

Cuando se pasan parámetros por valor, se copia el valor del argumento en el parámetro de la función. Los cambios hechos a los parámetros dentro de la función no afectan a los argumentos originales.

```cpp
void incrementarPorValor(int x) {
    x++;
    cout << "Dentro de la función: " << x << endl;
}

int main() {
    int numero = 5;
    incrementarPorValor(numero);
    cout << "Fuera de la función: " << numero << endl; // Salida: 5
    return 0;
}
```

##### Parámetros por Referencia

Cuando se pasan parámetros por referencia, se pasa la referencia del argumento a la función, permitiendo que la función modifique el valor original.

```cpp
void incrementarPorReferencia(int& x) {
    x++;
    cout << "Dentro de la función: " << x << endl;
}

int main() {
    int numero = 5;
    incrementarPorReferencia(numero);
    cout << "Fuera de la función: " << numero << endl; // Salida: 6
    return 0;
}
```

##### Parámetros por Puntero

Los punteros pueden utilizarse para pasar la dirección de una variable a una función, permitiendo que la función modifique la variable original.

```cpp
void incrementarPorPuntero(int* x) {
    (*x)++;
    cout << "Dentro de la función: " << *x << endl;
}

int main() {
    int numero = 5;
    incrementarPorPuntero(&numero);
    cout << "Fuera de la función: " << numero << endl; // Salida: 6
    return 0;
}
```

##### Parámetros Predeterminados

C++ permite especificar valores predeterminados para los parámetros. Si no se proporcionan argumentos para estos parámetros en la llamada a la función, se utilizan los valores predeterminados.

```cpp
void saludar(string nombre = "Mundo") {
    cout << "Hola, " << nombre << "!" << endl;
}

int main() {
    saludar(); // Usa el valor predeterminado: Mundo
    saludar("Juan"); // Usa el argumento proporcionado: Juan
    return 0;
}
```

#### Argumentos

Los argumentos son los valores que se pasan a la función cuando se invoca. Pueden ser constantes, variables, expresiones, o incluso llamadas a otras funciones.

##### Ejemplo de Argumentos

```cpp
int sumar(int a, int b) {
    return a + b;
}

int main() {
    int x = 5;
    int y = 3;
    int resultado = sumar(x, y); // x y y son los argumentos
    cout << "Resultado: " << resultado << endl;
    return 0;
}
```

En este ejemplo, `x` y `y` son argumentos cuando se llama a la función `sumar`.

### Funciones con Múltiples Parámetros

Las funciones pueden aceptar múltiples parámetros, lo que permite realizar operaciones más complejas.

##### Ejemplo con Múltiples Parámetros

```cpp
#include <iostream>
using namespace std;

void imprimirDatos(string nombre, int edad, double altura) {
    cout << "Nombre: " << nombre << endl;
    cout << "Edad: " << edad << endl;
    cout << "Altura: " << altura << " metros" << endl;
}

int main() {
    imprimirDatos("Juan", 30, 1.75);
    return 0;
}
```

### Paso de Parámetros por Constante

Es una buena práctica pasar parámetros por referencia constante cuando no se requiere modificar el argumento, especialmente para objetos grandes, para evitar copias innecesarias.

##### Ejemplo con Referencia Constante

```cpp
void mostrarMensaje(const string& mensaje) {
    cout << mensaje << endl;
}

int main() {
    string saludo = "Hola, Mundo!";
    mostrarMensaje(saludo);
    return 0;
}
```

### Conclusión

Entender la diferencia entre parámetros y argumentos, y cómo se pueden pasar a las funciones, es esencial para escribir funciones flexibles y eficientes en C++. El uso adecuado de parámetros por valor, referencia, puntero, y valores predeterminados permite a los desarrolladores manipular datos de diversas maneras, mejorar el rendimiento y mantener el código limpio y fácil de entender. Con estas habilidades, se puede maximizar la reutilización y modularidad del código en C++.
### Pasar Arrays como Argumentos en C++

Pasar arrays como argumentos a las funciones es una técnica común en C++ que permite a las funciones operar sobre colecciones de datos. A diferencia de otros lenguajes de programación, en C++ hay varias maneras de pasar arrays a las funciones, cada una con sus propias características y ventajas.

#### Pasar Arrays por Puntero

Cuando se pasa un array a una función, lo que realmente se pasa es un puntero al primer elemento del array. Esto significa que los cambios realizados en el array dentro de la función afectan al array original.

##### Ejemplo de Pasar Arrays por Puntero

```cpp
#include <iostream>
using namespace std;

void imprimirArray(int* arr, int tam) {
    for (int i = 0; i < tam; ++i) {
        cout << arr[i] << " ";
    }
    cout << endl;
}

int main() {
    int numeros[] = {1, 2, 3, 4, 5};
    int tam = sizeof(numeros) / sizeof(numeros[0]);

    imprimirArray(numeros, tam); // Pasar array a la función

    return 0;
}
```

En este ejemplo, el array `numeros` se pasa a la función `imprimirArray` como un puntero al primer elemento del array.

#### Pasar Arrays por Referencia

C++ permite pasar arrays por referencia, lo que asegura que la función recibe una referencia al array original. Esto evita la ambigüedad que puede surgir al pasar arrays por puntero y facilita la lectura del código.

##### Ejemplo de Pasar Arrays por Referencia

```cpp
#include <iostream>
using namespace std;

template<size_t N>
void imprimirArrayPorReferencia(int (&arr)[N]) {
    for (int i = 0; i < N; ++i) {
        cout << arr[i] << " ";
    }
    cout << endl;
}

int main() {
    int numeros[] = {1, 2, 3, 4, 5};

    imprimirArrayPorReferencia(numeros); // Pasar array a la función por referencia

    return 0;
}
```

En este ejemplo, la función `imprimirArrayPorReferencia` recibe una referencia al array, asegurando que se trata del array completo y no solo de un puntero al primer elemento.

#### Pasar Arrays de Cadenas

Los arrays de cadenas (C-strings) se pueden pasar de la misma manera que los arrays de enteros. Dado que los C-strings son arrays de caracteres terminados en nulo, se puede usar la misma técnica para pasarlos como argumentos.

##### Ejemplo de Pasar Arrays de Cadenas

```cpp
#include <iostream>
using namespace std;

void imprimirCadenas(const char* cadenas[], int tam) {
    for (int i = 0; i < tam; ++i) {
        cout << cadenas[i] << endl;
    }
}

int main() {
    const char* frutas[] = {"Manzana", "Banana", "Cereza", "Dátil"};

    int tam = sizeof(frutas) / sizeof(frutas[0]);
    imprimirCadenas(frutas, tam); // Pasar array de cadenas a la función

    return 0;
}
```

En este ejemplo, el array de C-strings `frutas` se pasa a la función `imprimirCadenas` como un puntero a un array de punteros a caracteres.

### Pasar Arrays Multidimensionales

Los arrays multidimensionales también pueden pasarse a las funciones. Es importante especificar todas las dimensiones excepto la primera al pasar el array a la función.

##### Ejemplo de Pasar Arrays Bidimensionales

```cpp
#include <iostream>
using namespace std;

void imprimirMatriz(int matriz[][3], int filas) {
    for (int i = 0; i < filas; ++i) {
        for (int j = 0; j < 3; ++j) {
            cout << matriz[i][j] << " ";
        }
        cout << endl;
    }
}

int main() {
    int matriz[2][3] = {
        {1, 2, 3},
        {4, 5, 6}
    };

    imprimirMatriz(matriz, 2); // Pasar array bidimensional a la función

    return 0;
}
```

En este ejemplo, el array bidimensional `matriz` se pasa a la función `imprimirMatriz`, donde se especifica la segunda dimensión en la declaración de la función.

### Consideraciones y Buenas Prácticas

1. **Uso de `const`**: Siempre que sea posible, usa `const` para proteger los arrays de modificaciones no deseadas dentro de la función.

   ```cpp
   void imprimirArray(const int* arr, int tam) {
       // Código para imprimir el array
   }
   ```

2. **Tamaño del Array**: Asegúrate de pasar también el tamaño del array a la función para evitar accesos fuera de los límites.

   ```cpp
   void imprimirArray(const int* arr, int tam) {
       for (int i = 0; i < tam; ++i) {
           cout << arr[i] << " ";
       }
       cout << endl;
   }
   ```

3. **Referencias y Plantillas**: Para arrays de tamaño fijo, las referencias y las plantillas pueden hacer el código más seguro y claro.

   ```cpp
   template<size_t N>
   void imprimirArrayPorReferencia(int (&arr)[N]) {
       for (int i = 0; i < N; ++i) {
           cout << arr[i] << " ";
       }
       cout << endl;
   }
   ```

4. **Arrays Multidimensionales**: Especifica todas las dimensiones excepto la primera al pasar arrays multidimensionales.

   ```cpp
   void imprimirMatriz(int matriz[][3], int filas) {
       // Código para imprimir la matriz
   }
   ```

### Ejemplo Completo

A continuación, un ejemplo completo que ilustra diversas formas de pasar arrays a las funciones:

```cpp
#include <iostream>
using namespace std;

// Pasar array por puntero
void imprimirArray(const int* arr, int tam) {
    for (int i = 0; i < tam; ++i) {
        cout << arr[i] << " ";
    }
    cout << endl;
}

// Pasar array por referencia
template<size_t N>
void imprimirArrayPorReferencia(const int (&arr)[N]) {
    for (int i = 0; i < N; ++i) {
        cout << arr[i] << " ";
    }
    cout << endl;
}

// Pasar array de cadenas
void imprimirCadenas(const char* cadenas[], int tam) {
    for (int i = 0; i < tam; ++i) {
        cout << cadenas[i] << endl;
    }
}

// Pasar array bidimensional
void imprimirMatriz(int matriz[][3], int filas) {
    for (int i = 0; i < filas; ++i) {
        for (int j = 0; j < 3; ++j) {
            cout << matriz[i][j] << " ";
        }
        cout << endl;
    }
}

int main() {
    // Array unidimensional
    int numeros[] = {1, 2, 3, 4, 5};
    int tam = sizeof(numeros) / sizeof(numeros[0]);

    imprimirArray(numeros, tam);
    imprimirArrayPorReferencia(numeros);

    // Array de cadenas
    const char* frutas[] = {"Manzana", "Banana", "Cereza", "Dátil"};
    int tamFrutas = sizeof(frutas) / sizeof(frutas[0]);

    imprimirCadenas(frutas, tamFrutas);

    // Array bidimensional
    int matriz[2][3] = {
        {1, 2, 3},
        {4, 5, 6}
    };

    imprimirMatriz(matriz, 2);

    return 0;
}
```

### Conclusión

Pasar arrays como argumentos a funciones en C++ es una técnica fundamental que permite manejar colecciones de datos de manera eficiente. Entender las diferentes formas de pasar arrays, ya sea por puntero, referencia, o utilizando plantillas, es esencial para escribir funciones versátiles y seguras. Con estas habilidades, los desarrolladores pueden crear programas más robustos y modulares.
### Conversiones Implícitas en Funciones y Paso de Argumentos en C++

Las conversiones implícitas son una característica del lenguaje C++ que permite que los tipos de datos se conviertan automáticamente de un tipo a otro en ciertas circunstancias. Cuando se pasan argumentos a las funciones, estas conversiones implícitas pueden ocurrir para hacer coincidir los tipos de los argumentos con los tipos de los parámetros de la función. Esta característica facilita la escritura de funciones más flexibles y reutilizables.

#### Concepto de Conversiones Implícitas

Las conversiones implícitas se producen automáticamente cuando un tipo de dato puede ser convertido a otro sin necesidad de una conversión explícita por parte del programador. Estas conversiones son útiles para asegurar que los tipos de datos sean compatibles cuando se pasan como argumentos a las funciones.

##### Ejemplo de Conversión Implícita

```cpp
#include <iostream>
using namespace std;

void imprimirNumero(double num) {
    cout << "Número: " << num << endl;
}

int main() {
    int entero = 42;
    float flotante = 3.14f;

    imprimirNumero(entero);    // Conversión implícita de int a double
    imprimirNumero(flotante);  // Conversión implícita de float a double

    return 0;
}
```

En este ejemplo, las variables `entero` y `flotante` se convierten implícitamente a `double` cuando se pasan a la función `imprimirNumero`.

#### Conversiones Implícitas Comunes

1. **De tipos enteros a tipos de punto flotante**
2. **De tipos más pequeños a tipos más grandes (promoción de tipos)**
3. **De tipos derivados a tipos base en herencia**

##### Promoción de Tipos

Cuando se pasan argumentos a una función, los tipos de datos más pequeños pueden promocionarse a tipos más grandes automáticamente.

```cpp
#include <iostream>
using namespace std;

void mostrarLong(long num) {
    cout << "Long: " << num << endl;
}

int main() {
    char c = 'A';
    short s = 10;
    int i = 100;

    mostrarLong(c); // Conversión implícita de char a long
    mostrarLong(s); // Conversión implícita de short a long
    mostrarLong(i); // Conversión implícita de int a long

    return 0;
}
```

En este ejemplo, los tipos `char`, `short` e `int` se convierten implícitamente a `long` cuando se pasan a la función `mostrarLong`.

#### Conversiones con Tipos Derivados y Base

En el contexto de la herencia, un puntero o referencia a un tipo derivado puede convertirse implícitamente en un puntero o referencia a un tipo base.

##### Ejemplo con Herencia

```cpp
#include <iostream>
using namespace std;

class Base {
public:
    virtual void mostrar() const {
        cout << "Base" << endl;
    }
};

class Derivado : public Base {
public:
    void mostrar() const override {
        cout << "Derivado" << endl;
    }
};

void llamarMostrar(const Base& obj) {
    obj.mostrar();
}

int main() {
    Base b;
    Derivado d;

    llamarMostrar(b); // No hay conversión
    llamarMostrar(d); // Conversión implícita de Derivado a Base

    return 0;
}
```

En este ejemplo, un objeto de tipo `Derivado` se convierte implícitamente a `Base` cuando se pasa a la función `llamarMostrar`.

#### Consideraciones y Buenas Prácticas

1. **Cuidado con la Pérdida de Datos**: Las conversiones implícitas pueden provocar la pérdida de precisión o información. Por ejemplo, convertir un `double` a un `int` puede truncar el valor decimal.
2. **Uso de `const` y Referencias**: Para evitar copias innecesarias y posibles errores de conversión, usa referencias constantes (`const &`) en los parámetros de las funciones.
3. **Constructores de Conversión**: Define constructores de conversión para permitir conversiones implícitas seguras entre clases.

##### Ejemplo con Constructor de Conversión

```cpp
#include <iostream>
using namespace std;

class Entero {
private:
    int valor;
public:
    Entero(int v) : valor(v) {}

    void mostrar() const {
        cout << "Entero: " << valor << endl;
    }
};

void mostrarEntero(const Entero& e) {
    e.mostrar();
}

int main() {
    mostrarEntero(42); // Conversión implícita de int a Entero

    return 0;
}
```

En este ejemplo, el constructor de `Entero` permite la conversión implícita de `int` a `Entero` cuando se llama a la función `mostrarEntero`.

### Ejemplo Completo

A continuación, un ejemplo completo que ilustra diversas conversiones implícitas cuando se pasan argumentos a las funciones:

```cpp
#include <iostream>
using namespace std;

class Base {
public:
    virtual void mostrar() const {
        cout << "Base" << endl;
    }
};

class Derivado : public Base {
public:
    void mostrar() const override {
        cout << "Derivado" << endl;
    }
};

void imprimirNumero(double num) {
    cout << "Número: " << num << endl;
}

void mostrarLong(long num) {
    cout << "Long: " << num << endl;
}

void llamarMostrar(const Base& obj) {
    obj.mostrar();
}

class Entero {
private:
    int valor;
public:
    Entero(int v) : valor(v) {}

    void mostrar() const {
        cout << "Entero: " << valor << endl;
    }
};

void mostrarEntero(const Entero& e) {
    e.mostrar();
}

int main() {
    // Conversión implícita de tipos primitivos
    int entero = 42;
    float flotante = 3.14f;

    imprimirNumero(entero);    // Conversión implícita de int a double
    imprimirNumero(flotante);  // Conversión implícita de float a double

    char c = 'A';
    short s = 10;
    int i = 100;

    mostrarLong(c); // Conversión implícita de char a long
    mostrarLong(s); // Conversión implícita de short a long
    mostrarLong(i); // Conversión implícita de int a long

    // Conversión implícita en herencia
    Base b;
    Derivado d;

    llamarMostrar(b); // No hay conversión
    llamarMostrar(d); // Conversión implícita de Derivado a Base

    // Conversión implícita usando constructor
    mostrarEntero(42); // Conversión implícita de int a Entero

    return 0;
}
```

### Conclusión

Las conversiones implícitas en C++ facilitan la interoperabilidad entre diferentes tipos de datos, especialmente al pasar argumentos a funciones. Sin embargo, es crucial manejarlas con cuidado para evitar la pérdida de datos y garantizar la seguridad del tipo. Comprender cómo y cuándo ocurren estas conversiones permite a los desarrolladores escribir funciones más flexibles y robustas, mejorando la eficiencia y la legibilidad del código.
### Funciones con Valor de Retorno y Sin Valor de Retorno en C++

Las funciones en C++ pueden estar diseñadas para devolver un valor o no devolver ningún valor. La diferencia entre ambas reside en el tipo de retorno especificado en la declaración de la función.

#### Funciones con Valor de Retorno

Una función con valor de retorno es una función que devuelve un valor al llamador cuando la función termina. El tipo de valor de retorno puede ser cualquier tipo de dato, como `int`, `double`, `string`, objetos de clases definidas por el usuario, entre otros.

##### Sintaxis

```cpp
tipo_de_retorno nombre_funcion(lista_de_parametros) {
    // Cuerpo de la función
    return valor; // Devolver un valor del tipo especificado
}
```

##### Ejemplo de Función con Valor de Retorno

```cpp
#include <iostream>
using namespace std;

// Función que devuelve la suma de dos enteros
int sumar(int a, int b) {
    return a + b;
}

int main() {
    int resultado = sumar(5, 3);
    cout << "La suma es: " << resultado << endl;
    return 0;
}
```

En este ejemplo, la función `sumar` devuelve un valor entero que es el resultado de sumar dos enteros. El valor devuelto se captura en la variable `resultado` en la función `main`.

##### Ejemplo con un Tipo de Dato Diferente

```cpp
#include <iostream>
using namespace std;

// Función que devuelve un saludo como string
string obtenerSaludo(string nombre) {
    return "Hola, " + nombre + "!";
}

int main() {
    string saludo = obtenerSaludo("Juan");
    cout << saludo << endl;
    return 0;
}
```

En este ejemplo, la función `obtenerSaludo` devuelve una cadena de texto que es un saludo personalizado.

#### Funciones Sin Valor de Retorno

Una función sin valor de retorno (también conocida como función void) no devuelve ningún valor. Estas funciones se utilizan cuando se desea realizar una acción pero no se necesita devolver información al llamador.

##### Sintaxis

```cpp
void nombre_funcion(lista_de_parametros) {
    // Cuerpo de la función
    // No hay sentencia return
}
```

##### Ejemplo de Función Sin Valor de Retorno

```cpp
#include <iostream>
using namespace std;

// Función que imprime un mensaje
void imprimirMensaje(string mensaje) {
    cout << mensaje << endl;
}

int main() {
    imprimirMensaje("Hola, Mundo!");
    return 0;
}
```

En este ejemplo, la función `imprimirMensaje` no devuelve ningún valor. Simplemente realiza la acción de imprimir un mensaje en la consola.

##### Ejemplo con Parámetros por Referencia

A veces, se usan funciones `void` para modificar los valores de los parámetros pasados por referencia.

```cpp
#include <iostream>
using namespace std;

// Función que incrementa el valor de una variable
void incrementar(int& num) {
    num++;
}

int main() {
    int valor = 10;
    incrementar(valor);
    cout << "Valor después de incrementar: " << valor << endl;
    return 0;
}
```

En este ejemplo, la función `incrementar` modifica el valor del parámetro `num` directamente, y esta modificación se refleja en la variable `valor` en la función `main`.

### Comparación entre Funciones con y Sin Valor de Retorno

| Característica                      | Función con Valor de Retorno                    | Función sin Valor de Retorno (void)              |
|-------------------------------------|-------------------------------------------------|-------------------------------------------------|
| Tipo de Retorno                     | Cualquier tipo de dato                          | `void`                                          |
| Uso                                 | Devuelve un valor al llamador                   | Realiza una acción sin devolver un valor         |
| Sintaxis de Retorno                 | `return valor;`                                 | No necesita `return`, pero puede usar `return;`  |
| Captura de Valor Devuelto           | El valor devuelto puede capturarse en una variable | No devuelve valor para capturar                  |
| Modificación de Parámetros          | No modifica parámetros a menos que se pasen por referencia o puntero | Puede modificar parámetros pasados por referencia o puntero |

### Ejemplo Completo

A continuación, un ejemplo que ilustra tanto funciones con valor de retorno como funciones sin valor de retorno:

```cpp
#include <iostream>
using namespace std;

// Función con valor de retorno
double calcularAreaCirculo(double radio) {
    return 3.14159 * radio * radio;
}

// Función sin valor de retorno
void imprimirArea(double area) {
    cout << "El área del círculo es: " << area << endl;
}

int main() {
    double radio = 5.0;
    double area = calcularAreaCirculo(radio); // Llamada a función con valor de retorno
    imprimirArea(area);                       // Llamada a función sin valor de retorno
    return 0;
}
```

En este ejemplo, `calcularAreaCirculo` es una función que devuelve el área de un círculo dado su radio, y `imprimirArea` es una función que imprime el área en la consola.

### Conclusión

Las funciones con valor de retorno y sin valor de retorno son componentes esenciales en C++ que permiten realizar tareas y devolver información útil al llamador. Las funciones con valor de retorno son adecuadas cuando se necesita calcular y devolver un resultado, mientras que las funciones `void` son útiles para realizar acciones que no requieren devolver un valor. Comprender cuándo y cómo usar cada tipo de función es crucial para escribir código claro, eficiente y modular en C++.
### Sobrecarga de Funciones en C++

La sobrecarga de funciones es una característica de C++ que permite definir múltiples funciones con el mismo nombre pero con diferentes listas de parámetros. La función específica que se llama se determina en tiempo de compilación según los argumentos pasados a la función. Esto permite crear funciones que pueden manejar diferentes tipos de datos o diferentes cantidades de datos de una manera limpia y coherente.

#### Conceptos Clave en Sobrecarga de Funciones

1. **Nombre de Función Común:** Todas las funciones sobrecargadas deben compartir el mismo nombre.
2. **Listas de Parámetros Diferentes:** Las funciones deben diferir en el tipo y/o el número de parámetros.
3. **Resolución en Tiempo de Compilación:** El compilador selecciona la función adecuada basándose en los argumentos proporcionados durante la llamada a la función.

##### Reglas para la Sobrecarga de Funciones

- Las funciones sobrecargadas deben tener diferentes listas de parámetros. Esto significa que deben diferir en el número de parámetros, en el tipo de parámetros, o en el orden de los tipos de parámetros.
- No se puede sobrecargar una función solo cambiando el tipo de retorno.
- Los nombres de las funciones deben ser idénticos.

#### Ejemplo de Sobrecarga de Funciones

```cpp
#include <iostream>
using namespace std;

// Sobrecarga de la función sumar
int sumar(int a, int b) {
    return a + b;
}

double sumar(double a, double b) {
    return a + b;
}

string sumar(string a, string b) {
    return a + b;
}

int main() {
    // Llamadas a funciones sobrecargadas
    cout << "Suma de enteros: " << sumar(3, 4) << endl;       // Llama a sumar(int, int)
    cout << "Suma de dobles: " << sumar(3.5, 2.5) << endl;    // Llama a sumar(double, double)
    cout << "Suma de strings: " << sumar("Hola, ", "Mundo!") << endl;  // Llama a sumar(string, string)
    return 0;
}
```

En este ejemplo, la función `sumar` está sobrecargada para manejar enteros, dobles y cadenas de texto.

#### Sobrecarga con Diferente Número de Parámetros

Las funciones también pueden ser sobrecargadas cambiando el número de parámetros.

##### Ejemplo de Sobrecarga con Diferente Número de Parámetros

```cpp
#include <iostream>
using namespace std;

// Sobrecarga de la función imprimir
void imprimir(int a) {
    cout << "Valor entero: " << a << endl;
}

void imprimir(int a, int b) {
    cout << "Valores enteros: " << a << " y " << b << endl;
}

void imprimir(int a, int b, int c) {
    cout << "Valores enteros: " << a << ", " << b << " y " << c << endl;
}

int main() {
    // Llamadas a funciones sobrecargadas
    imprimir(5);          // Llama a imprimir(int)
    imprimir(5, 10);      // Llama a imprimir(int, int)
    imprimir(5, 10, 15);  // Llama a imprimir(int, int, int)
    return 0;
}
```

En este ejemplo, la función `imprimir` está sobrecargada para manejar diferentes cantidades de parámetros.

#### Sobrecarga y Constantes

Las constantes pueden afectar la sobrecarga de funciones, permitiendo definir diferentes versiones de la función para argumentos constantes y no constantes.

##### Ejemplo de Sobrecarga con Constantes

```cpp
#include <iostream>
using namespace std;

// Sobrecarga de la función mostrar
void mostrar(int& a) {
    cout << "Llamada no constante: " << a << endl;
}

void mostrar(const int& a) {
    cout << "Llamada constante: " << a << endl;
}

int main() {
    int x = 10;
    const int y = 20;

    mostrar(x);  // Llama a mostrar(int&)
    mostrar(y);  // Llama a mostrar(const int&)
    return 0;
}
```

En este ejemplo, la función `mostrar` está sobrecargada para manejar tanto referencias constantes como no constantes.

### Beneficios de la Sobrecarga de Funciones

- **Claridad y Simplicidad:** Permite usar el mismo nombre de función para operaciones similares en diferentes tipos de datos.
- **Flexibilidad:** Facilita la implementación de funciones que pueden manejar múltiples tipos de datos y diferentes cantidades de parámetros.
- **Mantenimiento:** Facilita el mantenimiento del código, ya que se puede agregar o modificar una sobrecarga sin afectar a otras.

### Ejemplo Completo

A continuación, un ejemplo más completo que muestra diversas formas de sobrecargar funciones:

```cpp
#include <iostream>
#include <string>
using namespace std;

// Sobrecarga de la función procesar
void procesar(int a) {
    cout << "Procesando entero: " << a << endl;
}

void procesar(double a) {
    cout << "Procesando doble: " << a << endl;
}

void procesar(string a) {
    cout << "Procesando string: " << a << endl;
}

void procesar(int a, double b) {
    cout << "Procesando entero y doble: " << a << " y " << b << endl;
}

void procesar(double a, int b) {
    cout << "Procesando doble y entero: " << a << " y " << b << endl;
}

int main() {
    // Llamadas a funciones sobrecargadas
    procesar(5);           // Llama a procesar(int)
    procesar(3.14);        // Llama a procesar(double)
    procesar("Hola");      // Llama a procesar(string)
    procesar(5, 3.14);     // Llama a procesar(int, double)
    procesar(3.14, 5);     // Llama a procesar(double, int)
    return 0;
}
```

En este ejemplo, la función `procesar` está sobrecargada para manejar diferentes tipos y combinaciones de parámetros.

### Conclusión

La sobrecarga de funciones es una característica poderosa de C++ que permite definir múltiples funciones con el mismo nombre pero con diferentes listas de parámetros. Esto mejora la claridad, flexibilidad y mantenibilidad del código. Comprender cómo y cuándo usar la sobrecarga de funciones es esencial para escribir código C++ limpio y eficiente, permitiendo a los desarrolladores crear interfaces más intuitivas y versátiles para sus programas.
### Recursividad en C++

La recursividad es una técnica de programación en la que una función se llama a sí misma para resolver subproblemas más pequeños de un problema más grande. Esta técnica puede simplificar la resolución de problemas que tienen una estructura repetitiva o fractal, como problemas matemáticos, algoritmos de búsqueda y problemas relacionados con estructuras de datos.

#### Conceptos Básicos de Recursividad

1. **Caso Base:** Es la condición que termina la recursión. Sin un caso base, la función recursiva se llamaría a sí misma indefinidamente, lo que llevaría a un desbordamiento de pila.
2. **Caso Recursivo:** Es la parte de la función donde se hace la llamada recursiva. Esta llamada divide el problema en subproblemas más pequeños.

#### Ejemplo Clásico: Factorial de un Número

El factorial de un número `n` (denotado como `n!`) se define como el producto de todos los números enteros positivos hasta `n`. Matemáticamente, se define como:
- `0! = 1`
- `n! = n * (n - 1)!` para `n > 0`

##### Implementación Recursiva del Factorial

```cpp
#include <iostream>
using namespace std;

int factorial(int n) {
    if (n == 0) { // Caso base
        return 1;
    } else { // Caso recursivo
        return n * factorial(n - 1);
    }
}

int main() {
    int numero = 5;
    cout << "El factorial de " << numero << " es " << factorial(numero) << endl;
    return 0;
}
```

En este ejemplo:
- **Caso Base:** `if (n == 0) return 1;` detiene la recursión cuando `n` es 0.
- **Caso Recursivo:** `return n * factorial(n - 1);` llama a la función con `n - 1`.

#### Ejemplo: Serie de Fibonacci

La serie de Fibonacci es una secuencia donde cada número es la suma de los dos anteriores. Matemáticamente, se define como:
- `F(0) = 0`
- `F(1) = 1`
- `F(n) = F(n - 1) + F(n - 2)` para `n > 1`

##### Implementación Recursiva de Fibonacci

```cpp
#include <iostream>
using namespace std;

int fibonacci(int n) {
    if (n <= 1) { // Casos base
        return n;
    } else { // Caso recursivo
        return fibonacci(n - 1) + fibonacci(n - 2);
    }
}

int main() {
    int numero = 10;
    cout << "El término " << numero << " de la serie de Fibonacci es " << fibonacci(numero) << endl;
    return 0;
}
```

En este ejemplo:
- **Casos Base:** `if (n <= 1) return n;` detiene la recursión cuando `n` es 0 o 1.
- **Caso Recursivo:** `return fibonacci(n - 1) + fibonacci(n - 2);` llama a la función con `n - 1` y `n - 2`.

#### Recursividad de Cola

La recursividad de cola es una forma especial de recursión donde la llamada recursiva es la última operación que se realiza. Los compiladores pueden optimizar la recursividad de cola para evitar el desbordamiento de pila.

##### Ejemplo de Recursividad de Cola

```cpp
#include <iostream>
using namespace std;

int factorialCola(int n, int acumulador = 1) {
    if (n == 0) { // Caso base
        return acumulador;
    } else { // Caso recursivo de cola
        return factorialCola(n - 1, n * acumulador);
    }
}

int main() {
    int numero = 5;
    cout << "El factorial de " << numero << " (usando recursividad de cola) es " << factorialCola(numero) << endl;
    return 0;
}
```

En este ejemplo:
- **Caso Base:** `if (n == 0) return acumulador;` detiene la recursión cuando `n` es 0.
- **Caso Recursivo de Cola:** `return factorialCola(n - 1, n * acumulador);` pasa el cálculo parcial al siguiente llamado.

#### Consideraciones y Buenas Prácticas

1. **Evitar Desbordamientos de Pila:** La recursividad profunda puede llevar a un desbordamiento de pila. Utiliza recursividad de cola cuando sea posible y considera algoritmos iterativos para problemas grandes.
2. **Optimización:** Algunos problemas recursivos pueden beneficiarse de la memoización, donde se almacenan los resultados de subproblemas ya resueltos para evitar cálculos redundantes.
3. **Claridad del Código:** Asegúrate de que los casos base y recursivos estén claramente definidos y documentados para facilitar el mantenimiento y la comprensión del código.

#### Ejemplo Completo con Memoización

Memoización es una técnica de optimización que almacena los resultados de subproblemas para evitar cálculos redundantes.

##### Implementación de Fibonacci con Memoización

```cpp
#include <iostream>
#include <vector>
using namespace std;

vector<int> memo(100, -1); // Inicializar con -1

int fibonacciMemo(int n) {
    if (n <= 1) { // Casos base
        return n;
    }
    if (memo[n] != -1) { // Verificar si el resultado ya está calculado
        return memo[n];
    }
    // Calcular y almacenar el resultado
    memo[n] = fibonacciMemo(n - 1) + fibonacciMemo(n - 2);
    return memo[n];
}

int main() {
    int numero = 10;
    cout << "El término " << numero << " de la serie de Fibonacci (con memoización) es " << fibonacciMemo(numero) << endl;
    return 0;
}
```

### Conclusión

La recursividad es una herramienta poderosa en C++ que permite resolver problemas complejos dividiéndolos en subproblemas más simples. Entender y aplicar correctamente los casos base y recursivos es crucial para evitar errores y optimizar el rendimiento. La recursividad de cola y la memoización son técnicas avanzadas que pueden mejorar la eficiencia y evitar problemas comunes como el desbordamiento de pila. Con una comprensión sólida de la recursividad, los desarrolladores pueden abordar una amplia gama de problemas algorítmicos de manera efectiva.
### `constexpr` en Funciones en C++

La palabra clave `constexpr` en C++ se utiliza para declarar que una función o una variable puede ser evaluada en tiempo de compilación. Esto permite a los compiladores realizar optimizaciones adicionales y detectar errores en tiempo de compilación. `constexpr` es particularmente útil para definir constantes y realizar cálculos en tiempo de compilación, asegurando que el código sea más eficiente y seguro.

#### Concepto de `constexpr` en Funciones

Una función `constexpr` es una función que puede ser evaluada en tiempo de compilación si se le proporcionan argumentos constantes. Para que una función sea `constexpr`, debe cumplir ciertas restricciones que garantizan que su evaluación sea posible en tiempo de compilación.

##### Restricciones de las Funciones `constexpr`

1. Deben tener un valor de retorno.
2. El cuerpo de la función debe consistir en una sola expresión `return` en C++11; desde C++14, se permiten más complejidades como bucles y condiciones.
3. Todos los parámetros deben ser `constexpr` si se pretende que la función sea evaluada en tiempo de compilación.
4. No pueden tener efectos secundarios, como modificar variables globales o estáticas.

#### Definición y Uso de Funciones `constexpr`

##### Ejemplo Básico

```cpp
#include <iostream>
using namespace std;

// Función constexpr para calcular el cuadrado de un número
constexpr int cuadrado(int x) {
    return x * x;
}

int main() {
    constexpr int resultado = cuadrado(5); // Evaluado en tiempo de compilación
    cout << "El cuadrado de 5 es: " << resultado << endl;
    return 0;
}
```

En este ejemplo, la función `cuadrado` se puede evaluar en tiempo de compilación porque cumple con las restricciones de `constexpr`. La variable `resultado` se evalúa en tiempo de compilación, lo que permite optimizaciones adicionales.

#### Funciones `constexpr` en C++14 y Posterior

A partir de C++14, las funciones `constexpr` pueden contener más complejidades, como bucles y condiciones.

##### Ejemplo con Condicionales y Bucles

```cpp
#include <iostream>
using namespace std;

// Función constexpr para calcular el factorial de un número
constexpr int factorial(int n) {
    int resultado = 1;
    for (int i = 1; i <= n; ++i) {
        resultado *= i;
    }
    return resultado;
}

int main() {
    constexpr int resultado = factorial(5); // Evaluado en tiempo de compilación
    cout << "El factorial de 5 es: " << resultado << endl;
    return 0;
}
```

En este ejemplo, la función `factorial` utiliza un bucle para calcular el factorial de un número. Esta función se puede evaluar en tiempo de compilación gracias a las mejoras introducidas en C++14.

#### Ventajas de Usar Funciones `constexpr`

1. **Eficiencia:** Permiten al compilador realizar cálculos en tiempo de compilación, lo que puede reducir el tiempo de ejecución del programa.
2. **Seguridad:** Ayudan a detectar errores en tiempo de compilación en lugar de en tiempo de ejecución.
3. **Optimización:** Facilitan la optimización del código al permitir al compilador realizar evaluaciones constantes y eliminar código innecesario.

#### Limitaciones de las Funciones `constexpr`

1. **Complejidad Restringida:** En C++11, las funciones `constexpr` deben ser simples y constar de una sola expresión `return`. Sin embargo, en C++14 y posteriores, estas restricciones se han relajado.
2. **Evaluación Condicional:** No todas las llamadas a funciones `constexpr` se evaluarán en tiempo de compilación; solo aquellas con argumentos constantes.

#### Ejemplo Completo

A continuación, se muestra un ejemplo más complejo que utiliza funciones `constexpr` para realizar varias operaciones matemáticas en tiempo de compilación:

```cpp
#include <iostream>
using namespace std;

constexpr int maximo(int a, int b) {
    return (a > b) ? a : b;
}

constexpr int minimo(int a, int b) {
    return (a < b) ? a : b;
}

constexpr int sumaDeCuadrados(int a, int b) {
    return cuadrado(a) + cuadrado(b);
}

constexpr int cuadrado(int x) {
    return x * x;
}

int main() {
    constexpr int a = 3;
    constexpr int b = 4;

    constexpr int maxVal = maximo(a, b);        // Evaluado en tiempo de compilación
    constexpr int minVal = minimo(a, b);        // Evaluado en tiempo de compilación
    constexpr int sumaCuadrados = sumaDeCuadrados(a, b); // Evaluado en tiempo de compilación

    cout << "El máximo de " << a << " y " << b << " es: " << maxVal << endl;
    cout << "El mínimo de " << a << " y " << b << " es: " << minVal << endl;
    cout << "La suma de los cuadrados de " << a << " y " << b << " es: " << sumaCuadrados << endl;

    return 0;
}
```

En este ejemplo:
- `maximo` y `minimo` son funciones `constexpr` que determinan el valor máximo y mínimo de dos enteros, respectivamente.
- `sumaDeCuadrados` utiliza la función `cuadrado` para calcular la suma de los cuadrados de dos enteros.
- Todas estas funciones se evalúan en tiempo de compilación.

### Conclusión

Las funciones `constexpr` en C++ son una poderosa herramienta para realizar cálculos en tiempo de compilación, mejorando la eficiencia y seguridad del código. Aunque tienen algunas limitaciones, especialmente en versiones anteriores a C++14, su uso adecuado puede llevar a programas más rápidos y menos propensos a errores. Con una comprensión sólida de `constexpr`, los desarrolladores pueden escribir código más optimizado y robusto.
<---FILES--->
Sintaxis de la Declaración de Funciones
Sintaxis de la Declaración de Funciones Result
Ejemplo de Declaración de Función
Ejemplo de Declaración de Función Result
Sintaxis de la Definición de Funciones
Sintaxis de la Definición de Funciones Result
Ejemplo de Definición de Función
Ejemplo de Definición de Función Result
Parámetros por Valor
Parámetros por Valor Result
Parámetros por Referencia
Parámetros por Referencia Result
Ejemplo de Sobrecarga de Funciones
Ejemplo de Sobrecarga de Funciones Result
Sintaxis de la Declaración de Funciones
Sintaxis de la Declaración de Funciones Result
Ejemplo de Declaración de Función
Ejemplo de Declaración de Función Result
Sintaxis de la Definición de Funciones
Sintaxis de la Definición de Funciones Result
Ejemplo de Definición de Función
Ejemplo de Definición de Función Result
Parámetros por Valor
Parámetros por Valor Result
Parámetros por Referencia
Parámetros por Referencia Result
Ejemplo de Sobrecarga de Funciones
Ejemplo de Sobrecarga de Funciones Result
Tipos de Parámetros
Tipos de Parámetros Result
Parámetros por Puntero
Parámetros por Puntero Result
Parámetros Predeterminados
Parámetros Predeterminados Result
Ejemplo de Argumentos
Ejemplo de Argumentos Result
Ejemplo con Múltiples Parámetros
Ejemplo con Múltiples Parámetros Result
Ejemplo con Referencia Constante
Ejemplo con Referencia Constante Result
Sintaxis de la Declaración de Funciones
Sintaxis de la Declaración de Funciones Result
Ejemplo de Declaración de Función
Ejemplo de Declaración de Función Result
Sintaxis de la Definición de Funciones
Sintaxis de la Definición de Funciones Result
Ejemplo de Definición de Función
Ejemplo de Definición de Función Result
Parámetros por Valor
Parámetros por Valor Result
Parámetros por Referencia
Parámetros por Referencia Result
Ejemplo de Sobrecarga de Funciones
Ejemplo de Sobrecarga de Funciones Result
Tipos de Parámetros
Tipos de Parámetros Result
Parámetros por Puntero
Parámetros por Puntero Result
Parámetros Predeterminados
Parámetros Predeterminados Result
Ejemplo de Argumentos
Ejemplo de Argumentos Result
Ejemplo con Múltiples Parámetros
Ejemplo con Múltiples Parámetros Result
Ejemplo con Referencia Constante
Ejemplo con Referencia Constante Result
Ejemplo de Pasar Arrays por Puntero
Ejemplo de Pasar Arrays por Puntero Result
Ejemplo de Pasar Arrays por Referencia
Ejemplo de Pasar Arrays por Referencia Result
Ejemplo de Pasar Arrays de Cadenas
Ejemplo de Pasar Arrays de Cadenas Result
Ejemplo de Pasar Arrays Bidimensionales
Ejemplo de Pasar Arrays Bidimensionales Result
Sintaxis de la Declaración de Funciones
Sintaxis de la Declaración de Funciones Result
Ejemplo de Declaración de Función
Ejemplo de Declaración de Función Result
Sintaxis de la Definición de Funciones
Sintaxis de la Definición de Funciones Result
Ejemplo de Definición de Función
Ejemplo de Definición de Función Result
Parámetros por Valor
Parámetros por Valor Result
Parámetros por Referencia
Parámetros por Referencia Result
Ejemplo de Sobrecarga de Funciones
Ejemplo de Sobrecarga de Funciones Result
Tipos de Parámetros
Tipos de Parámetros Result
Parámetros por Puntero
Parámetros por Puntero Result
Parámetros Predeterminados
Parámetros Predeterminados Result
Ejemplo de Argumentos
Ejemplo de Argumentos Result
Ejemplo con Múltiples Parámetros
Ejemplo con Múltiples Parámetros Result
Ejemplo con Referencia Constante
Ejemplo con Referencia Constante Result
Ejemplo de Pasar Arrays por Puntero
Ejemplo de Pasar Arrays por Puntero Result
Ejemplo de Pasar Arrays por Referencia
Ejemplo de Pasar Arrays por Referencia Result
Ejemplo de Pasar Arrays de Cadenas
Ejemplo de Pasar Arrays de Cadenas Result
Ejemplo de Pasar Arrays Bidimensionales
Ejemplo de Pasar Arrays Bidimensionales Result
Ejemplo de Conversión Implícita
Ejemplo de Conversión Implícita Result
Promoción de Tipos
Promoción de Tipos Result
Ejemplo con Herencia
Ejemplo con Herencia Result
Ejemplo con Constructor de Conversión
Ejemplo con Constructor de Conversión Result
Sintaxis de la Declaración de Funciones
Sintaxis de la Declaración de Funciones Result
Ejemplo de Declaración de Función
Ejemplo de Declaración de Función Result
Sintaxis de la Definición de Funciones
Sintaxis de la Definición de Funciones Result
Ejemplo de Definición de Función
Ejemplo de Definición de Función Result
Parámetros por Valor
Parámetros por Valor Result
Parámetros por Referencia
Parámetros por Referencia Result
Ejemplo de Sobrecarga de Funciones
Ejemplo de Sobrecarga de Funciones Result
Tipos de Parámetros
Tipos de Parámetros Result
Parámetros por Puntero
Parámetros por Puntero Result
Parámetros Predeterminados
Parámetros Predeterminados Result
Ejemplo de Argumentos
Ejemplo de Argumentos Result
Ejemplo con Múltiples Parámetros
Ejemplo con Múltiples Parámetros Result
Ejemplo con Referencia Constante
Ejemplo con Referencia Constante Result
Ejemplo de Pasar Arrays por Puntero
Ejemplo de Pasar Arrays por Puntero Result
Ejemplo de Pasar Arrays por Referencia
Ejemplo de Pasar Arrays por Referencia Result
Ejemplo de Pasar Arrays de Cadenas
Ejemplo de Pasar Arrays de Cadenas Result
Ejemplo de Pasar Arrays Bidimensionales
Ejemplo de Pasar Arrays Bidimensionales Result
Ejemplo de Conversión Implícita
Ejemplo de Conversión Implícita Result
Promoción de Tipos
Promoción de Tipos Result
Ejemplo con Herencia
Ejemplo con Herencia Result
Ejemplo con Constructor de Conversión
Ejemplo con Constructor de Conversión Result
Sintaxis
Sintaxis Result
Ejemplo de Función con Valor de Retorno
Ejemplo de Función con Valor de Retorno Result
Ejemplo con un Tipo de Dato Diferente
Ejemplo con un Tipo de Dato Diferente Result
Ejemplo de Función Sin Valor de Retorno
Ejemplo de Función Sin Valor de Retorno Result
Ejemplo con Parámetros por Referencia
Ejemplo con Parámetros por Referencia Result
Sintaxis de la Declaración de Funciones
Sintaxis de la Declaración de Funciones Result
Ejemplo de Declaración de Función
Ejemplo de Declaración de Función Result
Sintaxis de la Definición de Funciones
Sintaxis de la Definición de Funciones Result
Ejemplo de Definición de Función
Ejemplo de Definición de Función Result
Parámetros por Valor
Parámetros por Valor Result
Parámetros por Referencia
Parámetros por Referencia Result
Ejemplo de Sobrecarga de Funciones
Ejemplo de Sobrecarga de Funciones Result
Tipos de Parámetros
Tipos de Parámetros Result
Parámetros por Puntero
Parámetros por Puntero Result
Parámetros Predeterminados
Parámetros Predeterminados Result
Ejemplo de Argumentos
Ejemplo de Argumentos Result
Ejemplo con Múltiples Parámetros
Ejemplo con Múltiples Parámetros Result
Ejemplo con Referencia Constante
Ejemplo con Referencia Constante Result
Ejemplo de Pasar Arrays por Puntero
Ejemplo de Pasar Arrays por Puntero Result
Ejemplo de Pasar Arrays por Referencia
Ejemplo de Pasar Arrays por Referencia Result
Ejemplo de Pasar Arrays de Cadenas
Ejemplo de Pasar Arrays de Cadenas Result
Ejemplo de Pasar Arrays Bidimensionales
Ejemplo de Pasar Arrays Bidimensionales Result
Ejemplo de Conversión Implícita
Ejemplo de Conversión Implícita Result
Promoción de Tipos
Promoción de Tipos Result
Ejemplo con Herencia
Ejemplo con Herencia Result
Ejemplo con Constructor de Conversión
Ejemplo con Constructor de Conversión Result
Sintaxis
Sintaxis Result
Ejemplo de Función con Valor de Retorno
Ejemplo de Función con Valor de Retorno Result
Ejemplo con un Tipo de Dato Diferente
Ejemplo con un Tipo de Dato Diferente Result
Ejemplo de Función Sin Valor de Retorno
Ejemplo de Función Sin Valor de Retorno Result
Ejemplo con Parámetros por Referencia
Ejemplo con Parámetros por Referencia Result
Reglas para la Sobrecarga de Funciones
Reglas para la Sobrecarga de Funciones Result
Ejemplo de Sobrecarga con Diferente Número de Parámetros
Ejemplo de Sobrecarga con Diferente Número de Parámetros Result
Ejemplo de Sobrecarga con Constantes
Ejemplo de Sobrecarga con Constantes Result
Sintaxis de la Declaración de Funciones
Sintaxis de la Declaración de Funciones Result
Ejemplo de Declaración de Función
Ejemplo de Declaración de Función Result
Sintaxis de la Definición de Funciones
Sintaxis de la Definición de Funciones Result
Ejemplo de Definición de Función
Ejemplo de Definición de Función Result
Parámetros por Valor
Parámetros por Valor Result
Parámetros por Referencia
Parámetros por Referencia Result
Ejemplo de Sobrecarga de Funciones
Ejemplo de Sobrecarga de Funciones Result
Tipos de Parámetros
Tipos de Parámetros Result
Parámetros por Puntero
Parámetros por Puntero Result
Parámetros Predeterminados
Parámetros Predeterminados Result
Ejemplo de Argumentos
Ejemplo de Argumentos Result
Ejemplo con Múltiples Parámetros
Ejemplo con Múltiples Parámetros Result
Ejemplo con Referencia Constante
Ejemplo con Referencia Constante Result
Ejemplo de Pasar Arrays por Puntero
Ejemplo de Pasar Arrays por Puntero Result
Ejemplo de Pasar Arrays por Referencia
Ejemplo de Pasar Arrays por Referencia Result
Ejemplo de Pasar Arrays de Cadenas
Ejemplo de Pasar Arrays de Cadenas Result
Ejemplo de Pasar Arrays Bidimensionales
Ejemplo de Pasar Arrays Bidimensionales Result
Ejemplo de Conversión Implícita
Ejemplo de Conversión Implícita Result
Promoción de Tipos
Promoción de Tipos Result
Ejemplo con Herencia
Ejemplo con Herencia Result
Ejemplo con Constructor de Conversión
Ejemplo con Constructor de Conversión Result
Sintaxis
Sintaxis Result
Ejemplo de Función con Valor de Retorno
Ejemplo de Función con Valor de Retorno Result
Ejemplo con un Tipo de Dato Diferente
Ejemplo con un Tipo de Dato Diferente Result
Ejemplo de Función Sin Valor de Retorno
Ejemplo de Función Sin Valor de Retorno Result
Ejemplo con Parámetros por Referencia
Ejemplo con Parámetros por Referencia Result
Reglas para la Sobrecarga de Funciones
Reglas para la Sobrecarga de Funciones Result
Ejemplo de Sobrecarga con Diferente Número de Parámetros
Ejemplo de Sobrecarga con Diferente Número de Parámetros Result
Ejemplo de Sobrecarga con Constantes
Ejemplo de Sobrecarga con Constantes Result
Implementación Recursiva del Factorial
Implementación Recursiva del Factorial Result
Implementación Recursiva de Fibonacci
Implementación Recursiva de Fibonacci Result
Ejemplo de Recursividad de Cola
Ejemplo de Recursividad de Cola Result
Implementación de Fibonacci con Memoización
Implementación de Fibonacci con Memoización Result
Sintaxis de la Declaración de Funciones
Sintaxis de la Declaración de Funciones Result
Ejemplo de Declaración de Función
Ejemplo de Declaración de Función Result
Sintaxis de la Definición de Funciones
Sintaxis de la Definición de Funciones Result
Ejemplo de Definición de Función
Ejemplo de Definición de Función Result
Parámetros por Valor
Parámetros por Valor Result
Parámetros por Referencia
Parámetros por Referencia Result
Ejemplo de Sobrecarga de Funciones
Ejemplo de Sobrecarga de Funciones Result
Tipos de Parámetros
Tipos de Parámetros Result
Parámetros por Puntero
Parámetros por Puntero Result
Parámetros Predeterminados
Parámetros Predeterminados Result
Ejemplo de Argumentos
Ejemplo de Argumentos Result
Ejemplo con Múltiples Parámetros
Ejemplo con Múltiples Parámetros Result
Ejemplo con Referencia Constante
Ejemplo con Referencia Constante Result
Ejemplo de Pasar Arrays por Puntero
Ejemplo de Pasar Arrays por Puntero Result
Ejemplo de Pasar Arrays por Referencia
Ejemplo de Pasar Arrays por Referencia Result
Ejemplo de Pasar Arrays de Cadenas
Ejemplo de Pasar Arrays de Cadenas Result
Ejemplo de Pasar Arrays Bidimensionales
Ejemplo de Pasar Arrays Bidimensionales Result
Ejemplo de Conversión Implícita
Ejemplo de Conversión Implícita Result
Promoción de Tipos
Promoción de Tipos Result
Ejemplo con Herencia
Ejemplo con Herencia Result
Ejemplo con Constructor de Conversión
Ejemplo con Constructor de Conversión Result
Sintaxis
Sintaxis Result
Ejemplo de Función con Valor de Retorno
Ejemplo de Función con Valor de Retorno Result
Ejemplo con un Tipo de Dato Diferente
Ejemplo con un Tipo de Dato Diferente Result
Ejemplo de Función Sin Valor de Retorno
Ejemplo de Función Sin Valor de Retorno Result
Ejemplo con Parámetros por Referencia
Ejemplo con Parámetros por Referencia Result
Reglas para la Sobrecarga de Funciones
Reglas para la Sobrecarga de Funciones Result
Ejemplo de Sobrecarga con Diferente Número de Parámetros
Ejemplo de Sobrecarga con Diferente Número de Parámetros Result
Ejemplo de Sobrecarga con Constantes
Ejemplo de Sobrecarga con Constantes Result
Implementación Recursiva del Factorial
Implementación Recursiva del Factorial Result
Implementación Recursiva de Fibonacci
Implementación Recursiva de Fibonacci Result
Ejemplo de Recursividad de Cola
Ejemplo de Recursividad de Cola Result
Implementación de Fibonacci con Memoización
Implementación de Fibonacci con Memoización Result
Restricciones de las Funciones `constexpr`
Restricciones de las Funciones `constexpr` Result
Ejemplo Básico
Ejemplo Básico Result
Ejemplo con Condicionales y Bucles
Ejemplo con Condicionales y Bucles Result
<---Sintaxis de la Declaración de Funciones--->
```cpp
tipo_retorno nombre_funcion(lista_de_parametros);
<---Sintaxis de la Declaración de Funciones Result--->
<---Ejemplo de Declaración de Función--->
```cpp
int sumar(int a, int b);
void mostrarMensaje(string mensaje);
<---Ejemplo de Declaración de Función Result--->
<---Sintaxis de la Definición de Funciones--->
```cpp
tipo_retorno nombre_funcion(lista_de_parametros) {
    // Cuerpo de la función
}
<---Sintaxis de la Definición de Funciones Result--->
<---Ejemplo de Definición de Función--->
```cpp
int sumar(int a, int b) {
    return a + b;
}

void mostrarMensaje(string mensaje) {
    cout << mensaje << endl;
}
```cpp
#include <iostream>
using namespace std;

// Declaraciones de funciones
int sumar(int a, int b);
void mostrarMensaje(string mensaje);

int main() {
    int resultado = sumar(5, 3);
    cout << "La suma es: " << resultado << endl;

    mostrarMensaje("Hola, mundo!");

    return 0;
}

// Definiciones de funciones
int sumar(int a, int b) {
    return a + b;
}

void mostrarMensaje(string mensaje) {
    cout << mensaje << endl;
}
<---Ejemplo de Definición de Función Result--->
<---Parámetros por Valor--->
```cpp
void incrementarPorValor(int x) {
    x++;
}

int main() {
    int numero = 5;
    incrementarPorValor(numero);
    cout << "Número después de incrementar por valor: " << numero << endl; // Salida: 5
    return 0;
}
<---Parámetros por Valor Result--->
<---Parámetros por Referencia--->
```cpp
void incrementarPorReferencia(int& x) {
    x++;
}

int main() {
    int numero = 5;
    incrementarPorReferencia(numero);
    cout << "Número después de incrementar por referencia: " << numero << endl; // Salida: 6
    return 0;
}
<---Parámetros por Referencia Result--->
<---Ejemplo de Sobrecarga de Funciones--->
```cpp
#include <iostream>
using namespace std;

int sumar(int a, int b) {
    return a + b;
}

double sumar(double a, double b) {
    return a + b;
}

int main() {
    cout << "Suma de enteros: " << sumar(3, 4) << endl;       // Llama a sumar(int, int)
    cout << "Suma de dobles: " << sumar(3.5, 2.5) << endl;    // Llama a sumar(double, double)
    return 0;
}
<---Ejemplo de Sobrecarga de Funciones Result--->
<---Sintaxis de la Declaración de Funciones--->
```cpp
tipo_retorno nombre_funcion(lista_de_parametros);
<---Sintaxis de la Declaración de Funciones Result--->
<---Ejemplo de Declaración de Función--->
```cpp
int sumar(int a, int b);
void mostrarMensaje(string mensaje);
<---Ejemplo de Declaración de Función Result--->
<---Sintaxis de la Definición de Funciones--->
```cpp
tipo_retorno nombre_funcion(lista_de_parametros) {
    // Cuerpo de la función
}
<---Sintaxis de la Definición de Funciones Result--->
<---Ejemplo de Definición de Función--->
```cpp
int sumar(int a, int b) {
    return a + b;
}

void mostrarMensaje(string mensaje) {
    cout << mensaje << endl;
}
```cpp
#include <iostream>
using namespace std;

// Declaraciones de funciones
int sumar(int a, int b);
void mostrarMensaje(string mensaje);

int main() {
    int resultado = sumar(5, 3);
    cout << "La suma es: " << resultado << endl;

    mostrarMensaje("Hola, mundo!");

    return 0;
}

// Definiciones de funciones
int sumar(int a, int b) {
    return a + b;
}

void mostrarMensaje(string mensaje) {
    cout << mensaje << endl;
}
<---Ejemplo de Definición de Función Result--->
<---Parámetros por Valor--->
```cpp
void incrementarPorValor(int x) {
    x++;
    cout << "Dentro de la función: " << x << endl;
}

int main() {
    int numero = 5;
    incrementarPorValor(numero);
    cout << "Fuera de la función: " << numero << endl; // Salida: 5
    return 0;
}
<---Parámetros por Valor Result--->
<---Parámetros por Referencia--->
```cpp
void incrementarPorReferencia(int& x) {
    x++;
    cout << "Dentro de la función: " << x << endl;
}

int main() {
    int numero = 5;
    incrementarPorReferencia(numero);
    cout << "Fuera de la función: " << numero << endl; // Salida: 6
    return 0;
}
<---Parámetros por Referencia Result--->
<---Ejemplo de Sobrecarga de Funciones--->
```cpp
#include <iostream>
using namespace std;

int sumar(int a, int b) {
    return a + b;
}

double sumar(double a, double b) {
    return a + b;
}

int main() {
    cout << "Suma de enteros: " << sumar(3, 4) << endl;       // Llama a sumar(int, int)
    cout << "Suma de dobles: " << sumar(3.5, 2.5) << endl;    // Llama a sumar(double, double)
    return 0;
}
<---Ejemplo de Sobrecarga de Funciones Result--->
<---Tipos de Parámetros--->
<---Tipos de Parámetros Result--->
<---Parámetros por Puntero--->
```cpp
void incrementarPorPuntero(int* x) {
    (*x)++;
    cout << "Dentro de la función: " << *x << endl;
}

int main() {
    int numero = 5;
    incrementarPorPuntero(&numero);
    cout << "Fuera de la función: " << numero << endl; // Salida: 6
    return 0;
}
<---Parámetros por Puntero Result--->
<---Parámetros Predeterminados--->
```cpp
void saludar(string nombre = "Mundo") {
    cout << "Hola, " << nombre << "!" << endl;
}

int main() {
    saludar(); // Usa el valor predeterminado: Mundo
    saludar("Juan"); // Usa el argumento proporcionado: Juan
    return 0;
}
<---Parámetros Predeterminados Result--->
<---Ejemplo de Argumentos--->
```cpp
int sumar(int a, int b) {
    return a + b;
}

int main() {
    int x = 5;
    int y = 3;
    int resultado = sumar(x, y); // x y y son los argumentos
    cout << "Resultado: " << resultado << endl;
    return 0;
}
<---Ejemplo de Argumentos Result--->
<---Ejemplo con Múltiples Parámetros--->
```cpp
#include <iostream>
using namespace std;

void imprimirDatos(string nombre, int edad, double altura) {
    cout << "Nombre: " << nombre << endl;
    cout << "Edad: " << edad << endl;
    cout << "Altura: " << altura << " metros" << endl;
}

int main() {
    imprimirDatos("Juan", 30, 1.75);
    return 0;
}
<---Ejemplo con Múltiples Parámetros Result--->
<---Ejemplo con Referencia Constante--->
```cpp
void mostrarMensaje(const string& mensaje) {
    cout << mensaje << endl;
}

int main() {
    string saludo = "Hola, Mundo!";
    mostrarMensaje(saludo);
    return 0;
}
<---Ejemplo con Referencia Constante Result--->
<---Sintaxis de la Declaración de Funciones--->
```cpp
tipo_retorno nombre_funcion(lista_de_parametros);
<---Sintaxis de la Declaración de Funciones Result--->
<---Ejemplo de Declaración de Función--->
```cpp
int sumar(int a, int b);
void mostrarMensaje(string mensaje);
<---Ejemplo de Declaración de Función Result--->
<---Sintaxis de la Definición de Funciones--->
```cpp
tipo_retorno nombre_funcion(lista_de_parametros) {
    // Cuerpo de la función
}
<---Sintaxis de la Definición de Funciones Result--->
<---Ejemplo de Definición de Función--->
```cpp
int sumar(int a, int b) {
    return a + b;
}

void mostrarMensaje(string mensaje) {
    cout << mensaje << endl;
}
```cpp
#include <iostream>
using namespace std;

// Declaraciones de funciones
int sumar(int a, int b);
void mostrarMensaje(string mensaje);

int main() {
    int resultado = sumar(5, 3);
    cout << "La suma es: " << resultado << endl;

    mostrarMensaje("Hola, mundo!");

    return 0;
}

// Definiciones de funciones
int sumar(int a, int b) {
    return a + b;
}

void mostrarMensaje(string mensaje) {
    cout << mensaje << endl;
}
<---Ejemplo de Definición de Función Result--->
<---Parámetros por Valor--->
```cpp
void incrementarPorValor(int x) {
    x++;
    cout << "Dentro de la función: " << x << endl;
}

int main() {
    int numero = 5;
    incrementarPorValor(numero);
    cout << "Fuera de la función: " << numero << endl; // Salida: 5
    return 0;
}
<---Parámetros por Valor Result--->
<---Parámetros por Referencia--->
```cpp
void incrementarPorReferencia(int& x) {
    x++;
    cout << "Dentro de la función: " << x << endl;
}

int main() {
    int numero = 5;
    incrementarPorReferencia(numero);
    cout << "Fuera de la función: " << numero << endl; // Salida: 6
    return 0;
}
<---Parámetros por Referencia Result--->
<---Ejemplo de Sobrecarga de Funciones--->
```cpp
#include <iostream>
using namespace std;

int sumar(int a, int b) {
    return a + b;
}

double sumar(double a, double b) {
    return a + b;
}

int main() {
    cout << "Suma de enteros: " << sumar(3, 4) << endl;       // Llama a sumar(int, int)
    cout << "Suma de dobles: " << sumar(3.5, 2.5) << endl;    // Llama a sumar(double, double)
    return 0;
}
<---Ejemplo de Sobrecarga de Funciones Result--->
<---Tipos de Parámetros--->
<---Tipos de Parámetros Result--->
<---Parámetros por Puntero--->
```cpp
void incrementarPorPuntero(int* x) {
    (*x)++;
    cout << "Dentro de la función: " << *x << endl;
}

int main() {
    int numero = 5;
    incrementarPorPuntero(&numero);
    cout << "Fuera de la función: " << numero << endl; // Salida: 6
    return 0;
}
<---Parámetros por Puntero Result--->
<---Parámetros Predeterminados--->
```cpp
void saludar(string nombre = "Mundo") {
    cout << "Hola, " << nombre << "!" << endl;
}

int main() {
    saludar(); // Usa el valor predeterminado: Mundo
    saludar("Juan"); // Usa el argumento proporcionado: Juan
    return 0;
}
<---Parámetros Predeterminados Result--->
<---Ejemplo de Argumentos--->
```cpp
int sumar(int a, int b) {
    return a + b;
}

int main() {
    int x = 5;
    int y = 3;
    int resultado = sumar(x, y); // x y y son los argumentos
    cout << "Resultado: " << resultado << endl;
    return 0;
}
<---Ejemplo de Argumentos Result--->
<---Ejemplo con Múltiples Parámetros--->
```cpp
#include <iostream>
using namespace std;

void imprimirDatos(string nombre, int edad, double altura) {
    cout << "Nombre: " << nombre << endl;
    cout << "Edad: " << edad << endl;
    cout << "Altura: " << altura << " metros" << endl;
}

int main() {
    imprimirDatos("Juan", 30, 1.75);
    return 0;
}
<---Ejemplo con Múltiples Parámetros Result--->
<---Ejemplo con Referencia Constante--->
```cpp
void mostrarMensaje(const string& mensaje) {
    cout << mensaje << endl;
}

int main() {
    string saludo = "Hola, Mundo!";
    mostrarMensaje(saludo);
    return 0;
}
<---Ejemplo con Referencia Constante Result--->
<---Ejemplo de Pasar Arrays por Puntero--->
```cpp
#include <iostream>
using namespace std;

void imprimirArray(int* arr, int tam) {
    for (int i = 0; i < tam; ++i) {
        cout << arr[i] << " ";
    }
    cout << endl;
}

int main() {
    int numeros[] = {1, 2, 3, 4, 5};
    int tam = sizeof(numeros) / sizeof(numeros[0]);

    imprimirArray(numeros, tam); // Pasar array a la función

    return 0;
}
<---Ejemplo de Pasar Arrays por Puntero Result--->
<---Ejemplo de Pasar Arrays por Referencia--->
```cpp
#include <iostream>
using namespace std;

template<size_t N>
void imprimirArrayPorReferencia(int (&arr)[N]) {
    for (int i = 0; i < N; ++i) {
        cout << arr[i] << " ";
    }
    cout << endl;
}

int main() {
    int numeros[] = {1, 2, 3, 4, 5};

    imprimirArrayPorReferencia(numeros); // Pasar array a la función por referencia

    return 0;
}
<---Ejemplo de Pasar Arrays por Referencia Result--->
<---Ejemplo de Pasar Arrays de Cadenas--->
```cpp
#include <iostream>
using namespace std;

void imprimirCadenas(const char* cadenas[], int tam) {
    for (int i = 0; i < tam; ++i) {
        cout << cadenas[i] << endl;
    }
}

int main() {
    const char* frutas[] = {"Manzana", "Banana", "Cereza", "Dátil"};

    int tam = sizeof(frutas) / sizeof(frutas[0]);
    imprimirCadenas(frutas, tam); // Pasar array de cadenas a la función

    return 0;
}
<---Ejemplo de Pasar Arrays de Cadenas Result--->
<---Ejemplo de Pasar Arrays Bidimensionales--->
```cpp
#include <iostream>
using namespace std;

void imprimirMatriz(int matriz[][3], int filas) {
    for (int i = 0; i < filas; ++i) {
        for (int j = 0; j < 3; ++j) {
            cout << matriz[i][j] << " ";
        }
        cout << endl;
    }
}

int main() {
    int matriz[2][3] = {
        {1, 2, 3},
        {4, 5, 6}
    };

    imprimirMatriz(matriz, 2); // Pasar array bidimensional a la función

    return 0;
}
```cpp
#include <iostream>
using namespace std;

// Pasar array por puntero
void imprimirArray(const int* arr, int tam) {
    for (int i = 0; i < tam; ++i) {
        cout << arr[i] << " ";
    }
    cout << endl;
}

// Pasar array por referencia
template<size_t N>
void imprimirArrayPorReferencia(const int (&arr)[N]) {
    for (int i = 0; i < N; ++i) {
        cout << arr[i] << " ";
    }
    cout << endl;
}

// Pasar array de cadenas
void imprimirCadenas(const char* cadenas[], int tam) {
    for (int i = 0; i < tam; ++i) {
        cout << cadenas[i] << endl;
    }
}

// Pasar array bidimensional
void imprimirMatriz(int matriz[][3], int filas) {
    for (int i = 0; i < filas; ++i) {
        for (int j = 0; j < 3; ++j) {
            cout << matriz[i][j] << " ";
        }
        cout << endl;
    }
}

int main() {
    // Array unidimensional
    int numeros[] = {1, 2, 3, 4, 5};
    int tam = sizeof(numeros) / sizeof(numeros[0]);

    imprimirArray(numeros, tam);
    imprimirArrayPorReferencia(numeros);

    // Array de cadenas
    const char* frutas[] = {"Manzana", "Banana", "Cereza", "Dátil"};
    int tamFrutas = sizeof(frutas) / sizeof(frutas[0]);

    imprimirCadenas(frutas, tamFrutas);

    // Array bidimensional
    int matriz[2][3] = {
        {1, 2, 3},
        {4, 5, 6}
    };

    imprimirMatriz(matriz, 2);

    return 0;
}
<---Ejemplo de Pasar Arrays Bidimensionales Result--->
<---Sintaxis de la Declaración de Funciones--->
```cpp
tipo_retorno nombre_funcion(lista_de_parametros);
<---Sintaxis de la Declaración de Funciones Result--->
<---Ejemplo de Declaración de Función--->
```cpp
int sumar(int a, int b);
void mostrarMensaje(string mensaje);
<---Ejemplo de Declaración de Función Result--->
<---Sintaxis de la Definición de Funciones--->
```cpp
tipo_retorno nombre_funcion(lista_de_parametros) {
    // Cuerpo de la función
}
<---Sintaxis de la Definición de Funciones Result--->
<---Ejemplo de Definición de Función--->
```cpp
int sumar(int a, int b) {
    return a + b;
}

void mostrarMensaje(string mensaje) {
    cout << mensaje << endl;
}
```cpp
#include <iostream>
using namespace std;

// Declaraciones de funciones
int sumar(int a, int b);
void mostrarMensaje(string mensaje);

int main() {
    int resultado = sumar(5, 3);
    cout << "La suma es: " << resultado << endl;

    mostrarMensaje("Hola, mundo!");

    return 0;
}

// Definiciones de funciones
int sumar(int a, int b) {
    return a + b;
}

void mostrarMensaje(string mensaje) {
    cout << mensaje << endl;
}
<---Ejemplo de Definición de Función Result--->
<---Parámetros por Valor--->
```cpp
void incrementarPorValor(int x) {
    x++;
    cout << "Dentro de la función: " << x << endl;
}

int main() {
    int numero = 5;
    incrementarPorValor(numero);
    cout << "Fuera de la función: " << numero << endl; // Salida: 5
    return 0;
}
<---Parámetros por Valor Result--->
<---Parámetros por Referencia--->
```cpp
void incrementarPorReferencia(int& x) {
    x++;
    cout << "Dentro de la función: " << x << endl;
}

int main() {
    int numero = 5;
    incrementarPorReferencia(numero);
    cout << "Fuera de la función: " << numero << endl; // Salida: 6
    return 0;
}
<---Parámetros por Referencia Result--->
<---Ejemplo de Sobrecarga de Funciones--->
```cpp
#include <iostream>
using namespace std;

int sumar(int a, int b) {
    return a + b;
}

double sumar(double a, double b) {
    return a + b;
}

int main() {
    cout << "Suma de enteros: " << sumar(3, 4) << endl;       // Llama a sumar(int, int)
    cout << "Suma de dobles: " << sumar(3.5, 2.5) << endl;    // Llama a sumar(double, double)
    return 0;
}
<---Ejemplo de Sobrecarga de Funciones Result--->
<---Tipos de Parámetros--->
<---Tipos de Parámetros Result--->
<---Parámetros por Puntero--->
```cpp
void incrementarPorPuntero(int* x) {
    (*x)++;
    cout << "Dentro de la función: " << *x << endl;
}

int main() {
    int numero = 5;
    incrementarPorPuntero(&numero);
    cout << "Fuera de la función: " << numero << endl; // Salida: 6
    return 0;
}
<---Parámetros por Puntero Result--->
<---Parámetros Predeterminados--->
```cpp
void saludar(string nombre = "Mundo") {
    cout << "Hola, " << nombre << "!" << endl;
}

int main() {
    saludar(); // Usa el valor predeterminado: Mundo
    saludar("Juan"); // Usa el argumento proporcionado: Juan
    return 0;
}
<---Parámetros Predeterminados Result--->
<---Ejemplo de Argumentos--->
```cpp
int sumar(int a, int b) {
    return a + b;
}

int main() {
    int x = 5;
    int y = 3;
    int resultado = sumar(x, y); // x y y son los argumentos
    cout << "Resultado: " << resultado << endl;
    return 0;
}
<---Ejemplo de Argumentos Result--->
<---Ejemplo con Múltiples Parámetros--->
```cpp
#include <iostream>
using namespace std;

void imprimirDatos(string nombre, int edad, double altura) {
    cout << "Nombre: " << nombre << endl;
    cout << "Edad: " << edad << endl;
    cout << "Altura: " << altura << " metros" << endl;
}

int main() {
    imprimirDatos("Juan", 30, 1.75);
    return 0;
}
<---Ejemplo con Múltiples Parámetros Result--->
<---Ejemplo con Referencia Constante--->
```cpp
void mostrarMensaje(const string& mensaje) {
    cout << mensaje << endl;
}

int main() {
    string saludo = "Hola, Mundo!";
    mostrarMensaje(saludo);
    return 0;
}
<---Ejemplo con Referencia Constante Result--->
<---Ejemplo de Pasar Arrays por Puntero--->
```cpp
#include <iostream>
using namespace std;

void imprimirArray(int* arr, int tam) {
    for (int i = 0; i < tam; ++i) {
        cout << arr[i] << " ";
    }
    cout << endl;
}

int main() {
    int numeros[] = {1, 2, 3, 4, 5};
    int tam = sizeof(numeros) / sizeof(numeros[0]);

    imprimirArray(numeros, tam); // Pasar array a la función

    return 0;
}
<---Ejemplo de Pasar Arrays por Puntero Result--->
<---Ejemplo de Pasar Arrays por Referencia--->
```cpp
#include <iostream>
using namespace std;

template<size_t N>
void imprimirArrayPorReferencia(int (&arr)[N]) {
    for (int i = 0; i < N; ++i) {
        cout << arr[i] << " ";
    }
    cout << endl;
}

int main() {
    int numeros[] = {1, 2, 3, 4, 5};

    imprimirArrayPorReferencia(numeros); // Pasar array a la función por referencia

    return 0;
}
<---Ejemplo de Pasar Arrays por Referencia Result--->
<---Ejemplo de Pasar Arrays de Cadenas--->
```cpp
#include <iostream>
using namespace std;

void imprimirCadenas(const char* cadenas[], int tam) {
    for (int i = 0; i < tam; ++i) {
        cout << cadenas[i] << endl;
    }
}

int main() {
    const char* frutas[] = {"Manzana", "Banana", "Cereza", "Dátil"};

    int tam = sizeof(frutas) / sizeof(frutas[0]);
    imprimirCadenas(frutas, tam); // Pasar array de cadenas a la función

    return 0;
}
<---Ejemplo de Pasar Arrays de Cadenas Result--->
<---Ejemplo de Pasar Arrays Bidimensionales--->
```cpp
#include <iostream>
using namespace std;

void imprimirMatriz(int matriz[][3], int filas) {
    for (int i = 0; i < filas; ++i) {
        for (int j = 0; j < 3; ++j) {
            cout << matriz[i][j] << " ";
        }
        cout << endl;
    }
}

int main() {
    int matriz[2][3] = {
        {1, 2, 3},
        {4, 5, 6}
    };

    imprimirMatriz(matriz, 2); // Pasar array bidimensional a la función

    return 0;
}
```cpp
#include <iostream>
using namespace std;

// Pasar array por puntero
void imprimirArray(const int* arr, int tam) {
    for (int i = 0; i < tam; ++i) {
        cout << arr[i] << " ";
    }
    cout << endl;
}

// Pasar array por referencia
template<size_t N>
void imprimirArrayPorReferencia(const int (&arr)[N]) {
    for (int i = 0; i < N; ++i) {
        cout << arr[i] << " ";
    }
    cout << endl;
}

// Pasar array de cadenas
void imprimirCadenas(const char* cadenas[], int tam) {
    for (int i = 0; i < tam; ++i) {
        cout << cadenas[i] << endl;
    }
}

// Pasar array bidimensional
void imprimirMatriz(int matriz[][3], int filas) {
    for (int i = 0; i < filas; ++i) {
        for (int j = 0; j < 3; ++j) {
            cout << matriz[i][j] << " ";
        }
        cout << endl;
    }
}

int main() {
    // Array unidimensional
    int numeros[] = {1, 2, 3, 4, 5};
    int tam = sizeof(numeros) / sizeof(numeros[0]);

    imprimirArray(numeros, tam);
    imprimirArrayPorReferencia(numeros);

    // Array de cadenas
    const char* frutas[] = {"Manzana", "Banana", "Cereza", "Dátil"};
    int tamFrutas = sizeof(frutas) / sizeof(frutas[0]);

    imprimirCadenas(frutas, tamFrutas);

    // Array bidimensional
    int matriz[2][3] = {
        {1, 2, 3},
        {4, 5, 6}
    };

    imprimirMatriz(matriz, 2);

    return 0;
}
<---Ejemplo de Pasar Arrays Bidimensionales Result--->
<---Ejemplo de Conversión Implícita--->
```cpp
#include <iostream>
using namespace std;

void imprimirNumero(double num) {
    cout << "Número: " << num << endl;
}

int main() {
    int entero = 42;
    float flotante = 3.14f;

    imprimirNumero(entero);    // Conversión implícita de int a double
    imprimirNumero(flotante);  // Conversión implícita de float a double

    return 0;
}
<---Ejemplo de Conversión Implícita Result--->
<---Promoción de Tipos--->
```cpp
#include <iostream>
using namespace std;

void mostrarLong(long num) {
    cout << "Long: " << num << endl;
}

int main() {
    char c = 'A';
    short s = 10;
    int i = 100;

    mostrarLong(c); // Conversión implícita de char a long
    mostrarLong(s); // Conversión implícita de short a long
    mostrarLong(i); // Conversión implícita de int a long

    return 0;
}
<---Promoción de Tipos Result--->
<---Ejemplo con Herencia--->
```cpp
#include <iostream>
using namespace std;

class Base {
public:
    virtual void mostrar() const {
        cout << "Base" << endl;
    }
};

class Derivado : public Base {
public:
    void mostrar() const override {
        cout << "Derivado" << endl;
    }
};

void llamarMostrar(const Base& obj) {
    obj.mostrar();
}

int main() {
    Base b;
    Derivado d;

    llamarMostrar(b); // No hay conversión
    llamarMostrar(d); // Conversión implícita de Derivado a Base

    return 0;
}
<---Ejemplo con Herencia Result--->
<---Ejemplo con Constructor de Conversión--->
```cpp
#include <iostream>
using namespace std;

class Entero {
private:
    int valor;
public:
    Entero(int v) : valor(v) {}

    void mostrar() const {
        cout << "Entero: " << valor << endl;
    }
};

void mostrarEntero(const Entero& e) {
    e.mostrar();
}

int main() {
    mostrarEntero(42); // Conversión implícita de int a Entero

    return 0;
}
```cpp
#include <iostream>
using namespace std;

class Base {
public:
    virtual void mostrar() const {
        cout << "Base" << endl;
    }
};

class Derivado : public Base {
public:
    void mostrar() const override {
        cout << "Derivado" << endl;
    }
};

void imprimirNumero(double num) {
    cout << "Número: " << num << endl;
}

void mostrarLong(long num) {
    cout << "Long: " << num << endl;
}

void llamarMostrar(const Base& obj) {
    obj.mostrar();
}

class Entero {
private:
    int valor;
public:
    Entero(int v) : valor(v) {}

    void mostrar() const {
        cout << "Entero: " << valor << endl;
    }
};

void mostrarEntero(const Entero& e) {
    e.mostrar();
}

int main() {
    // Conversión implícita de tipos primitivos
    int entero = 42;
    float flotante = 3.14f;

    imprimirNumero(entero);    // Conversión implícita de int a double
    imprimirNumero(flotante);  // Conversión implícita de float a double

    char c = 'A';
    short s = 10;
    int i = 100;

    mostrarLong(c); // Conversión implícita de char a long
    mostrarLong(s); // Conversión implícita de short a long
    mostrarLong(i); // Conversión implícita de int a long

    // Conversión implícita en herencia
    Base b;
    Derivado d;

    llamarMostrar(b); // No hay conversión
    llamarMostrar(d); // Conversión implícita de Derivado a Base

    // Conversión implícita usando constructor
    mostrarEntero(42); // Conversión implícita de int a Entero

    return 0;
}
<---Ejemplo con Constructor de Conversión Result--->
<---Sintaxis de la Declaración de Funciones--->
```cpp
tipo_retorno nombre_funcion(lista_de_parametros);
<---Sintaxis de la Declaración de Funciones Result--->
<---Ejemplo de Declaración de Función--->
```cpp
int sumar(int a, int b);
void mostrarMensaje(string mensaje);
<---Ejemplo de Declaración de Función Result--->
<---Sintaxis de la Definición de Funciones--->
```cpp
tipo_retorno nombre_funcion(lista_de_parametros) {
    // Cuerpo de la función
}
<---Sintaxis de la Definición de Funciones Result--->
<---Ejemplo de Definición de Función--->
```cpp
int sumar(int a, int b) {
    return a + b;
}

void mostrarMensaje(string mensaje) {
    cout << mensaje << endl;
}
```cpp
#include <iostream>
using namespace std;

// Declaraciones de funciones
int sumar(int a, int b);
void mostrarMensaje(string mensaje);

int main() {
    int resultado = sumar(5, 3);
    cout << "La suma es: " << resultado << endl;

    mostrarMensaje("Hola, mundo!");

    return 0;
}

// Definiciones de funciones
int sumar(int a, int b) {
    return a + b;
}

void mostrarMensaje(string mensaje) {
    cout << mensaje << endl;
}
<---Ejemplo de Definición de Función Result--->
<---Parámetros por Valor--->
```cpp
void incrementarPorValor(int x) {
    x++;
    cout << "Dentro de la función: " << x << endl;
}

int main() {
    int numero = 5;
    incrementarPorValor(numero);
    cout << "Fuera de la función: " << numero << endl; // Salida: 5
    return 0;
}
<---Parámetros por Valor Result--->
<---Parámetros por Referencia--->
```cpp
void incrementarPorReferencia(int& x) {
    x++;
    cout << "Dentro de la función: " << x << endl;
}

int main() {
    int numero = 5;
    incrementarPorReferencia(numero);
    cout << "Fuera de la función: " << numero << endl; // Salida: 6
    return 0;
}
<---Parámetros por Referencia Result--->
<---Ejemplo de Sobrecarga de Funciones--->
```cpp
#include <iostream>
using namespace std;

int sumar(int a, int b) {
    return a + b;
}

double sumar(double a, double b) {
    return a + b;
}

int main() {
    cout << "Suma de enteros: " << sumar(3, 4) << endl;       // Llama a sumar(int, int)
    cout << "Suma de dobles: " << sumar(3.5, 2.5) << endl;    // Llama a sumar(double, double)
    return 0;
}
<---Ejemplo de Sobrecarga de Funciones Result--->
<---Tipos de Parámetros--->
<---Tipos de Parámetros Result--->
<---Parámetros por Puntero--->
```cpp
void incrementarPorPuntero(int* x) {
    (*x)++;
    cout << "Dentro de la función: " << *x << endl;
}

int main() {
    int numero = 5;
    incrementarPorPuntero(&numero);
    cout << "Fuera de la función: " << numero << endl; // Salida: 6
    return 0;
}
<---Parámetros por Puntero Result--->
<---Parámetros Predeterminados--->
```cpp
void saludar(string nombre = "Mundo") {
    cout << "Hola, " << nombre << "!" << endl;
}

int main() {
    saludar(); // Usa el valor predeterminado: Mundo
    saludar("Juan"); // Usa el argumento proporcionado: Juan
    return 0;
}
<---Parámetros Predeterminados Result--->
<---Ejemplo de Argumentos--->
```cpp
int sumar(int a, int b) {
    return a + b;
}

int main() {
    int x = 5;
    int y = 3;
    int resultado = sumar(x, y); // x y y son los argumentos
    cout << "Resultado: " << resultado << endl;
    return 0;
}
<---Ejemplo de Argumentos Result--->
<---Ejemplo con Múltiples Parámetros--->
```cpp
#include <iostream>
using namespace std;

void imprimirDatos(string nombre, int edad, double altura) {
    cout << "Nombre: " << nombre << endl;
    cout << "Edad: " << edad << endl;
    cout << "Altura: " << altura << " metros" << endl;
}

int main() {
    imprimirDatos("Juan", 30, 1.75);
    return 0;
}
<---Ejemplo con Múltiples Parámetros Result--->
<---Ejemplo con Referencia Constante--->
```cpp
void mostrarMensaje(const string& mensaje) {
    cout << mensaje << endl;
}

int main() {
    string saludo = "Hola, Mundo!";
    mostrarMensaje(saludo);
    return 0;
}
<---Ejemplo con Referencia Constante Result--->
<---Ejemplo de Pasar Arrays por Puntero--->
```cpp
#include <iostream>
using namespace std;

void imprimirArray(int* arr, int tam) {
    for (int i = 0; i < tam; ++i) {
        cout << arr[i] << " ";
    }
    cout << endl;
}

int main() {
    int numeros[] = {1, 2, 3, 4, 5};
    int tam = sizeof(numeros) / sizeof(numeros[0]);

    imprimirArray(numeros, tam); // Pasar array a la función

    return 0;
}
<---Ejemplo de Pasar Arrays por Puntero Result--->
<---Ejemplo de Pasar Arrays por Referencia--->
```cpp
#include <iostream>
using namespace std;

template<size_t N>
void imprimirArrayPorReferencia(int (&arr)[N]) {
    for (int i = 0; i < N; ++i) {
        cout << arr[i] << " ";
    }
    cout << endl;
}

int main() {
    int numeros[] = {1, 2, 3, 4, 5};

    imprimirArrayPorReferencia(numeros); // Pasar array a la función por referencia

    return 0;
}
<---Ejemplo de Pasar Arrays por Referencia Result--->
<---Ejemplo de Pasar Arrays de Cadenas--->
```cpp
#include <iostream>
using namespace std;

void imprimirCadenas(const char* cadenas[], int tam) {
    for (int i = 0; i < tam; ++i) {
        cout << cadenas[i] << endl;
    }
}

int main() {
    const char* frutas[] = {"Manzana", "Banana", "Cereza", "Dátil"};

    int tam = sizeof(frutas) / sizeof(frutas[0]);
    imprimirCadenas(frutas, tam); // Pasar array de cadenas a la función

    return 0;
}
<---Ejemplo de Pasar Arrays de Cadenas Result--->
<---Ejemplo de Pasar Arrays Bidimensionales--->
```cpp
#include <iostream>
using namespace std;

void imprimirMatriz(int matriz[][3], int filas) {
    for (int i = 0; i < filas; ++i) {
        for (int j = 0; j < 3; ++j) {
            cout << matriz[i][j] << " ";
        }
        cout << endl;
    }
}

int main() {
    int matriz[2][3] = {
        {1, 2, 3},
        {4, 5, 6}
    };

    imprimirMatriz(matriz, 2); // Pasar array bidimensional a la función

    return 0;
}
```cpp
#include <iostream>
using namespace std;

// Pasar array por puntero
void imprimirArray(const int* arr, int tam) {
    for (int i = 0; i < tam; ++i) {
        cout << arr[i] << " ";
    }
    cout << endl;
}

// Pasar array por referencia
template<size_t N>
void imprimirArrayPorReferencia(const int (&arr)[N]) {
    for (int i = 0; i < N; ++i) {
        cout << arr[i] << " ";
    }
    cout << endl;
}

// Pasar array de cadenas
void imprimirCadenas(const char* cadenas[], int tam) {
    for (int i = 0; i < tam; ++i) {
        cout << cadenas[i] << endl;
    }
}

// Pasar array bidimensional
void imprimirMatriz(int matriz[][3], int filas) {
    for (int i = 0; i < filas; ++i) {
        for (int j = 0; j < 3; ++j) {
            cout << matriz[i][j] << " ";
        }
        cout << endl;
    }
}

int main() {
    // Array unidimensional
    int numeros[] = {1, 2, 3, 4, 5};
    int tam = sizeof(numeros) / sizeof(numeros[0]);

    imprimirArray(numeros, tam);
    imprimirArrayPorReferencia(numeros);

    // Array de cadenas
    const char* frutas[] = {"Manzana", "Banana", "Cereza", "Dátil"};
    int tamFrutas = sizeof(frutas) / sizeof(frutas[0]);

    imprimirCadenas(frutas, tamFrutas);

    // Array bidimensional
    int matriz[2][3] = {
        {1, 2, 3},
        {4, 5, 6}
    };

    imprimirMatriz(matriz, 2);

    return 0;
}
<---Ejemplo de Pasar Arrays Bidimensionales Result--->
<---Ejemplo de Conversión Implícita--->
```cpp
#include <iostream>
using namespace std;

void imprimirNumero(double num) {
    cout << "Número: " << num << endl;
}

int main() {
    int entero = 42;
    float flotante = 3.14f;

    imprimirNumero(entero);    // Conversión implícita de int a double
    imprimirNumero(flotante);  // Conversión implícita de float a double

    return 0;
}
<---Ejemplo de Conversión Implícita Result--->
<---Promoción de Tipos--->
```cpp
#include <iostream>
using namespace std;

void mostrarLong(long num) {
    cout << "Long: " << num << endl;
}

int main() {
    char c = 'A';
    short s = 10;
    int i = 100;

    mostrarLong(c); // Conversión implícita de char a long
    mostrarLong(s); // Conversión implícita de short a long
    mostrarLong(i); // Conversión implícita de int a long

    return 0;
}
<---Promoción de Tipos Result--->
<---Ejemplo con Herencia--->
```cpp
#include <iostream>
using namespace std;

class Base {
public:
    virtual void mostrar() const {
        cout << "Base" << endl;
    }
};

class Derivado : public Base {
public:
    void mostrar() const override {
        cout << "Derivado" << endl;
    }
};

void llamarMostrar(const Base& obj) {
    obj.mostrar();
}

int main() {
    Base b;
    Derivado d;

    llamarMostrar(b); // No hay conversión
    llamarMostrar(d); // Conversión implícita de Derivado a Base

    return 0;
}
<---Ejemplo con Herencia Result--->
<---Ejemplo con Constructor de Conversión--->
```cpp
#include <iostream>
using namespace std;

class Entero {
private:
    int valor;
public:
    Entero(int v) : valor(v) {}

    void mostrar() const {
        cout << "Entero: " << valor << endl;
    }
};

void mostrarEntero(const Entero& e) {
    e.mostrar();
}

int main() {
    mostrarEntero(42); // Conversión implícita de int a Entero

    return 0;
}
```cpp
#include <iostream>
using namespace std;

class Base {
public:
    virtual void mostrar() const {
        cout << "Base" << endl;
    }
};

class Derivado : public Base {
public:
    void mostrar() const override {
        cout << "Derivado" << endl;
    }
};

void imprimirNumero(double num) {
    cout << "Número: " << num << endl;
}

void mostrarLong(long num) {
    cout << "Long: " << num << endl;
}

void llamarMostrar(const Base& obj) {
    obj.mostrar();
}

class Entero {
private:
    int valor;
public:
    Entero(int v) : valor(v) {}

    void mostrar() const {
        cout << "Entero: " << valor << endl;
    }
};

void mostrarEntero(const Entero& e) {
    e.mostrar();
}

int main() {
    // Conversión implícita de tipos primitivos
    int entero = 42;
    float flotante = 3.14f;

    imprimirNumero(entero);    // Conversión implícita de int a double
    imprimirNumero(flotante);  // Conversión implícita de float a double

    char c = 'A';
    short s = 10;
    int i = 100;

    mostrarLong(c); // Conversión implícita de char a long
    mostrarLong(s); // Conversión implícita de short a long
    mostrarLong(i); // Conversión implícita de int a long

    // Conversión implícita en herencia
    Base b;
    Derivado d;

    llamarMostrar(b); // No hay conversión
    llamarMostrar(d); // Conversión implícita de Derivado a Base

    // Conversión implícita usando constructor
    mostrarEntero(42); // Conversión implícita de int a Entero

    return 0;
}
<---Ejemplo con Constructor de Conversión Result--->
<---Sintaxis--->
```cpp
void nombre_funcion(lista_de_parametros) {
    // Cuerpo de la función
    // No hay sentencia return
}
<---Sintaxis Result--->
<---Ejemplo de Función con Valor de Retorno--->
```cpp
#include <iostream>
using namespace std;

// Función que devuelve la suma de dos enteros
int sumar(int a, int b) {
    return a + b;
}

int main() {
    int resultado = sumar(5, 3);
    cout << "La suma es: " << resultado << endl;
    return 0;
}
<---Ejemplo de Función con Valor de Retorno Result--->
<---Ejemplo con un Tipo de Dato Diferente--->
```cpp
#include <iostream>
using namespace std;

// Función que devuelve un saludo como string
string obtenerSaludo(string nombre) {
    return "Hola, " + nombre + "!";
}

int main() {
    string saludo = obtenerSaludo("Juan");
    cout << saludo << endl;
    return 0;
}
<---Ejemplo con un Tipo de Dato Diferente Result--->
<---Ejemplo de Función Sin Valor de Retorno--->
```cpp
#include <iostream>
using namespace std;

// Función que imprime un mensaje
void imprimirMensaje(string mensaje) {
    cout << mensaje << endl;
}

int main() {
    imprimirMensaje("Hola, Mundo!");
    return 0;
}
<---Ejemplo de Función Sin Valor de Retorno Result--->
<---Ejemplo con Parámetros por Referencia--->
```cpp
#include <iostream>
using namespace std;

// Función que incrementa el valor de una variable
void incrementar(int& num) {
    num++;
}

int main() {
    int valor = 10;
    incrementar(valor);
    cout << "Valor después de incrementar: " << valor << endl;
    return 0;
}
```cpp
#include <iostream>
using namespace std;

// Función con valor de retorno
double calcularAreaCirculo(double radio) {
    return 3.14159 * radio * radio;
}

// Función sin valor de retorno
void imprimirArea(double area) {
    cout << "El área del círculo es: " << area << endl;
}

int main() {
    double radio = 5.0;
    double area = calcularAreaCirculo(radio); // Llamada a función con valor de retorno
    imprimirArea(area);                       // Llamada a función sin valor de retorno
    return 0;
}
<---Ejemplo con Parámetros por Referencia Result--->
<---Sintaxis de la Declaración de Funciones--->
```cpp
tipo_retorno nombre_funcion(lista_de_parametros);
<---Sintaxis de la Declaración de Funciones Result--->
<---Ejemplo de Declaración de Función--->
```cpp
int sumar(int a, int b);
void mostrarMensaje(string mensaje);
<---Ejemplo de Declaración de Función Result--->
<---Sintaxis de la Definición de Funciones--->
```cpp
tipo_retorno nombre_funcion(lista_de_parametros) {
    // Cuerpo de la función
}
<---Sintaxis de la Definición de Funciones Result--->
<---Ejemplo de Definición de Función--->
```cpp
int sumar(int a, int b) {
    return a + b;
}

void mostrarMensaje(string mensaje) {
    cout << mensaje << endl;
}
```cpp
#include <iostream>
using namespace std;

// Declaraciones de funciones
int sumar(int a, int b);
void mostrarMensaje(string mensaje);

int main() {
    int resultado = sumar(5, 3);
    cout << "La suma es: " << resultado << endl;

    mostrarMensaje("Hola, mundo!");

    return 0;
}

// Definiciones de funciones
int sumar(int a, int b) {
    return a + b;
}

void mostrarMensaje(string mensaje) {
    cout << mensaje << endl;
}
<---Ejemplo de Definición de Función Result--->
<---Parámetros por Valor--->
```cpp
void incrementarPorValor(int x) {
    x++;
    cout << "Dentro de la función: " << x << endl;
}

int main() {
    int numero = 5;
    incrementarPorValor(numero);
    cout << "Fuera de la función: " << numero << endl; // Salida: 5
    return 0;
}
<---Parámetros por Valor Result--->
<---Parámetros por Referencia--->
```cpp
void incrementarPorReferencia(int& x) {
    x++;
    cout << "Dentro de la función: " << x << endl;
}

int main() {
    int numero = 5;
    incrementarPorReferencia(numero);
    cout << "Fuera de la función: " << numero << endl; // Salida: 6
    return 0;
}
<---Parámetros por Referencia Result--->
<---Ejemplo de Sobrecarga de Funciones--->
```cpp
#include <iostream>
using namespace std;

int sumar(int a, int b) {
    return a + b;
}

double sumar(double a, double b) {
    return a + b;
}

int main() {
    cout << "Suma de enteros: " << sumar(3, 4) << endl;       // Llama a sumar(int, int)
    cout << "Suma de dobles: " << sumar(3.5, 2.5) << endl;    // Llama a sumar(double, double)
    return 0;
}
<---Ejemplo de Sobrecarga de Funciones Result--->
<---Tipos de Parámetros--->
<---Tipos de Parámetros Result--->
<---Parámetros por Puntero--->
```cpp
void incrementarPorPuntero(int* x) {
    (*x)++;
    cout << "Dentro de la función: " << *x << endl;
}

int main() {
    int numero = 5;
    incrementarPorPuntero(&numero);
    cout << "Fuera de la función: " << numero << endl; // Salida: 6
    return 0;
}
<---Parámetros por Puntero Result--->
<---Parámetros Predeterminados--->
```cpp
void saludar(string nombre = "Mundo") {
    cout << "Hola, " << nombre << "!" << endl;
}

int main() {
    saludar(); // Usa el valor predeterminado: Mundo
    saludar("Juan"); // Usa el argumento proporcionado: Juan
    return 0;
}
<---Parámetros Predeterminados Result--->
<---Ejemplo de Argumentos--->
```cpp
int sumar(int a, int b) {
    return a + b;
}

int main() {
    int x = 5;
    int y = 3;
    int resultado = sumar(x, y); // x y y son los argumentos
    cout << "Resultado: " << resultado << endl;
    return 0;
}
<---Ejemplo de Argumentos Result--->
<---Ejemplo con Múltiples Parámetros--->
```cpp
#include <iostream>
using namespace std;

void imprimirDatos(string nombre, int edad, double altura) {
    cout << "Nombre: " << nombre << endl;
    cout << "Edad: " << edad << endl;
    cout << "Altura: " << altura << " metros" << endl;
}

int main() {
    imprimirDatos("Juan", 30, 1.75);
    return 0;
}
<---Ejemplo con Múltiples Parámetros Result--->
<---Ejemplo con Referencia Constante--->
```cpp
void mostrarMensaje(const string& mensaje) {
    cout << mensaje << endl;
}

int main() {
    string saludo = "Hola, Mundo!";
    mostrarMensaje(saludo);
    return 0;
}
<---Ejemplo con Referencia Constante Result--->
<---Ejemplo de Pasar Arrays por Puntero--->
```cpp
#include <iostream>
using namespace std;

void imprimirArray(int* arr, int tam) {
    for (int i = 0; i < tam; ++i) {
        cout << arr[i] << " ";
    }
    cout << endl;
}

int main() {
    int numeros[] = {1, 2, 3, 4, 5};
    int tam = sizeof(numeros) / sizeof(numeros[0]);

    imprimirArray(numeros, tam); // Pasar array a la función

    return 0;
}
<---Ejemplo de Pasar Arrays por Puntero Result--->
<---Ejemplo de Pasar Arrays por Referencia--->
```cpp
#include <iostream>
using namespace std;

template<size_t N>
void imprimirArrayPorReferencia(int (&arr)[N]) {
    for (int i = 0; i < N; ++i) {
        cout << arr[i] << " ";
    }
    cout << endl;
}

int main() {
    int numeros[] = {1, 2, 3, 4, 5};

    imprimirArrayPorReferencia(numeros); // Pasar array a la función por referencia

    return 0;
}
<---Ejemplo de Pasar Arrays por Referencia Result--->
<---Ejemplo de Pasar Arrays de Cadenas--->
```cpp
#include <iostream>
using namespace std;

void imprimirCadenas(const char* cadenas[], int tam) {
    for (int i = 0; i < tam; ++i) {
        cout << cadenas[i] << endl;
    }
}

int main() {
    const char* frutas[] = {"Manzana", "Banana", "Cereza", "Dátil"};

    int tam = sizeof(frutas) / sizeof(frutas[0]);
    imprimirCadenas(frutas, tam); // Pasar array de cadenas a la función

    return 0;
}
<---Ejemplo de Pasar Arrays de Cadenas Result--->
<---Ejemplo de Pasar Arrays Bidimensionales--->
```cpp
#include <iostream>
using namespace std;

void imprimirMatriz(int matriz[][3], int filas) {
    for (int i = 0; i < filas; ++i) {
        for (int j = 0; j < 3; ++j) {
            cout << matriz[i][j] << " ";
        }
        cout << endl;
    }
}

int main() {
    int matriz[2][3] = {
        {1, 2, 3},
        {4, 5, 6}
    };

    imprimirMatriz(matriz, 2); // Pasar array bidimensional a la función

    return 0;
}
```cpp
#include <iostream>
using namespace std;

// Pasar array por puntero
void imprimirArray(const int* arr, int tam) {
    for (int i = 0; i < tam; ++i) {
        cout << arr[i] << " ";
    }
    cout << endl;
}

// Pasar array por referencia
template<size_t N>
void imprimirArrayPorReferencia(const int (&arr)[N]) {
    for (int i = 0; i < N; ++i) {
        cout << arr[i] << " ";
    }
    cout << endl;
}

// Pasar array de cadenas
void imprimirCadenas(const char* cadenas[], int tam) {
    for (int i = 0; i < tam; ++i) {
        cout << cadenas[i] << endl;
    }
}

// Pasar array bidimensional
void imprimirMatriz(int matriz[][3], int filas) {
    for (int i = 0; i < filas; ++i) {
        for (int j = 0; j < 3; ++j) {
            cout << matriz[i][j] << " ";
        }
        cout << endl;
    }
}

int main() {
    // Array unidimensional
    int numeros[] = {1, 2, 3, 4, 5};
    int tam = sizeof(numeros) / sizeof(numeros[0]);

    imprimirArray(numeros, tam);
    imprimirArrayPorReferencia(numeros);

    // Array de cadenas
    const char* frutas[] = {"Manzana", "Banana", "Cereza", "Dátil"};
    int tamFrutas = sizeof(frutas) / sizeof(frutas[0]);

    imprimirCadenas(frutas, tamFrutas);

    // Array bidimensional
    int matriz[2][3] = {
        {1, 2, 3},
        {4, 5, 6}
    };

    imprimirMatriz(matriz, 2);

    return 0;
}
<---Ejemplo de Pasar Arrays Bidimensionales Result--->
<---Ejemplo de Conversión Implícita--->
```cpp
#include <iostream>
using namespace std;

void imprimirNumero(double num) {
    cout << "Número: " << num << endl;
}

int main() {
    int entero = 42;
    float flotante = 3.14f;

    imprimirNumero(entero);    // Conversión implícita de int a double
    imprimirNumero(flotante);  // Conversión implícita de float a double

    return 0;
}
<---Ejemplo de Conversión Implícita Result--->
<---Promoción de Tipos--->
```cpp
#include <iostream>
using namespace std;

void mostrarLong(long num) {
    cout << "Long: " << num << endl;
}

int main() {
    char c = 'A';
    short s = 10;
    int i = 100;

    mostrarLong(c); // Conversión implícita de char a long
    mostrarLong(s); // Conversión implícita de short a long
    mostrarLong(i); // Conversión implícita de int a long

    return 0;
}
<---Promoción de Tipos Result--->
<---Ejemplo con Herencia--->
```cpp
#include <iostream>
using namespace std;

class Base {
public:
    virtual void mostrar() const {
        cout << "Base" << endl;
    }
};

class Derivado : public Base {
public:
    void mostrar() const override {
        cout << "Derivado" << endl;
    }
};

void llamarMostrar(const Base& obj) {
    obj.mostrar();
}

int main() {
    Base b;
    Derivado d;

    llamarMostrar(b); // No hay conversión
    llamarMostrar(d); // Conversión implícita de Derivado a Base

    return 0;
}
<---Ejemplo con Herencia Result--->
<---Ejemplo con Constructor de Conversión--->
```cpp
#include <iostream>
using namespace std;

class Entero {
private:
    int valor;
public:
    Entero(int v) : valor(v) {}

    void mostrar() const {
        cout << "Entero: " << valor << endl;
    }
};

void mostrarEntero(const Entero& e) {
    e.mostrar();
}

int main() {
    mostrarEntero(42); // Conversión implícita de int a Entero

    return 0;
}
```cpp
#include <iostream>
using namespace std;

class Base {
public:
    virtual void mostrar() const {
        cout << "Base" << endl;
    }
};

class Derivado : public Base {
public:
    void mostrar() const override {
        cout << "Derivado" << endl;
    }
};

void imprimirNumero(double num) {
    cout << "Número: " << num << endl;
}

void mostrarLong(long num) {
    cout << "Long: " << num << endl;
}

void llamarMostrar(const Base& obj) {
    obj.mostrar();
}

class Entero {
private:
    int valor;
public:
    Entero(int v) : valor(v) {}

    void mostrar() const {
        cout << "Entero: " << valor << endl;
    }
};

void mostrarEntero(const Entero& e) {
    e.mostrar();
}

int main() {
    // Conversión implícita de tipos primitivos
    int entero = 42;
    float flotante = 3.14f;

    imprimirNumero(entero);    // Conversión implícita de int a double
    imprimirNumero(flotante);  // Conversión implícita de float a double

    char c = 'A';
    short s = 10;
    int i = 100;

    mostrarLong(c); // Conversión implícita de char a long
    mostrarLong(s); // Conversión implícita de short a long
    mostrarLong(i); // Conversión implícita de int a long

    // Conversión implícita en herencia
    Base b;
    Derivado d;

    llamarMostrar(b); // No hay conversión
    llamarMostrar(d); // Conversión implícita de Derivado a Base

    // Conversión implícita usando constructor
    mostrarEntero(42); // Conversión implícita de int a Entero

    return 0;
}
<---Ejemplo con Constructor de Conversión Result--->
<---Sintaxis--->
```cpp
void nombre_funcion(lista_de_parametros) {
    // Cuerpo de la función
    // No hay sentencia return
}
<---Sintaxis Result--->
<---Ejemplo de Función con Valor de Retorno--->
```cpp
#include <iostream>
using namespace std;

// Función que devuelve la suma de dos enteros
int sumar(int a, int b) {
    return a + b;
}

int main() {
    int resultado = sumar(5, 3);
    cout << "La suma es: " << resultado << endl;
    return 0;
}
<---Ejemplo de Función con Valor de Retorno Result--->
<---Ejemplo con un Tipo de Dato Diferente--->
```cpp
#include <iostream>
using namespace std;

// Función que devuelve un saludo como string
string obtenerSaludo(string nombre) {
    return "Hola, " + nombre + "!";
}

int main() {
    string saludo = obtenerSaludo("Juan");
    cout << saludo << endl;
    return 0;
}
<---Ejemplo con un Tipo de Dato Diferente Result--->
<---Ejemplo de Función Sin Valor de Retorno--->
```cpp
#include <iostream>
using namespace std;

// Función que imprime un mensaje
void imprimirMensaje(string mensaje) {
    cout << mensaje << endl;
}

int main() {
    imprimirMensaje("Hola, Mundo!");
    return 0;
}
<---Ejemplo de Función Sin Valor de Retorno Result--->
<---Ejemplo con Parámetros por Referencia--->
```cpp
#include <iostream>
using namespace std;

// Función que incrementa el valor de una variable
void incrementar(int& num) {
    num++;
}

int main() {
    int valor = 10;
    incrementar(valor);
    cout << "Valor después de incrementar: " << valor << endl;
    return 0;
}
```cpp
#include <iostream>
using namespace std;

// Función con valor de retorno
double calcularAreaCirculo(double radio) {
    return 3.14159 * radio * radio;
}

// Función sin valor de retorno
void imprimirArea(double area) {
    cout << "El área del círculo es: " << area << endl;
}

int main() {
    double radio = 5.0;
    double area = calcularAreaCirculo(radio); // Llamada a función con valor de retorno
    imprimirArea(area);                       // Llamada a función sin valor de retorno
    return 0;
}
<---Ejemplo con Parámetros por Referencia Result--->
<---Reglas para la Sobrecarga de Funciones--->
```cpp
#include <iostream>
using namespace std;

// Sobrecarga de la función sumar
int sumar(int a, int b) {
    return a + b;
}

double sumar(double a, double b) {
    return a + b;
}

string sumar(string a, string b) {
    return a + b;
}

int main() {
    // Llamadas a funciones sobrecargadas
    cout << "Suma de enteros: " << sumar(3, 4) << endl;       // Llama a sumar(int, int)
    cout << "Suma de dobles: " << sumar(3.5, 2.5) << endl;    // Llama a sumar(double, double)
    cout << "Suma de strings: " << sumar("Hola, ", "Mundo!") << endl;  // Llama a sumar(string, string)
    return 0;
}
<---Reglas para la Sobrecarga de Funciones Result--->
<---Ejemplo de Sobrecarga con Diferente Número de Parámetros--->
```cpp
#include <iostream>
using namespace std;

// Sobrecarga de la función imprimir
void imprimir(int a) {
    cout << "Valor entero: " << a << endl;
}

void imprimir(int a, int b) {
    cout << "Valores enteros: " << a << " y " << b << endl;
}

void imprimir(int a, int b, int c) {
    cout << "Valores enteros: " << a << ", " << b << " y " << c << endl;
}

int main() {
    // Llamadas a funciones sobrecargadas
    imprimir(5);          // Llama a imprimir(int)
    imprimir(5, 10);      // Llama a imprimir(int, int)
    imprimir(5, 10, 15);  // Llama a imprimir(int, int, int)
    return 0;
}
<---Ejemplo de Sobrecarga con Diferente Número de Parámetros Result--->
<---Ejemplo de Sobrecarga con Constantes--->
```cpp
#include <iostream>
using namespace std;

// Sobrecarga de la función mostrar
void mostrar(int& a) {
    cout << "Llamada no constante: " << a << endl;
}

void mostrar(const int& a) {
    cout << "Llamada constante: " << a << endl;
}

int main() {
    int x = 10;
    const int y = 20;

    mostrar(x);  // Llama a mostrar(int&)
    mostrar(y);  // Llama a mostrar(const int&)
    return 0;
}
```cpp
#include <iostream>
#include <string>
using namespace std;

// Sobrecarga de la función procesar
void procesar(int a) {
    cout << "Procesando entero: " << a << endl;
}

void procesar(double a) {
    cout << "Procesando doble: " << a << endl;
}

void procesar(string a) {
    cout << "Procesando string: " << a << endl;
}

void procesar(int a, double b) {
    cout << "Procesando entero y doble: " << a << " y " << b << endl;
}

void procesar(double a, int b) {
    cout << "Procesando doble y entero: " << a << " y " << b << endl;
}

int main() {
    // Llamadas a funciones sobrecargadas
    procesar(5);           // Llama a procesar(int)
    procesar(3.14);        // Llama a procesar(double)
    procesar("Hola");      // Llama a procesar(string)
    procesar(5, 3.14);     // Llama a procesar(int, double)
    procesar(3.14, 5);     // Llama a procesar(double, int)
    return 0;
}
<---Ejemplo de Sobrecarga con Constantes Result--->
<---Sintaxis de la Declaración de Funciones--->
```cpp
tipo_retorno nombre_funcion(lista_de_parametros);
<---Sintaxis de la Declaración de Funciones Result--->
<---Ejemplo de Declaración de Función--->
```cpp
int sumar(int a, int b);
void mostrarMensaje(string mensaje);
<---Ejemplo de Declaración de Función Result--->
<---Sintaxis de la Definición de Funciones--->
```cpp
tipo_retorno nombre_funcion(lista_de_parametros) {
    // Cuerpo de la función
}
<---Sintaxis de la Definición de Funciones Result--->
<---Ejemplo de Definición de Función--->
```cpp
int sumar(int a, int b) {
    return a + b;
}

void mostrarMensaje(string mensaje) {
    cout << mensaje << endl;
}
```cpp
#include <iostream>
using namespace std;

// Declaraciones de funciones
int sumar(int a, int b);
void mostrarMensaje(string mensaje);

int main() {
    int resultado = sumar(5, 3);
    cout << "La suma es: " << resultado << endl;

    mostrarMensaje("Hola, mundo!");

    return 0;
}

// Definiciones de funciones
int sumar(int a, int b) {
    return a + b;
}

void mostrarMensaje(string mensaje) {
    cout << mensaje << endl;
}
<---Ejemplo de Definición de Función Result--->
<---Parámetros por Valor--->
```cpp
void incrementarPorValor(int x) {
    x++;
    cout << "Dentro de la función: " << x << endl;
}

int main() {
    int numero = 5;
    incrementarPorValor(numero);
    cout << "Fuera de la función: " << numero << endl; // Salida: 5
    return 0;
}
<---Parámetros por Valor Result--->
<---Parámetros por Referencia--->
```cpp
void incrementarPorReferencia(int& x) {
    x++;
    cout << "Dentro de la función: " << x << endl;
}

int main() {
    int numero = 5;
    incrementarPorReferencia(numero);
    cout << "Fuera de la función: " << numero << endl; // Salida: 6
    return 0;
}
<---Parámetros por Referencia Result--->
<---Ejemplo de Sobrecarga de Funciones--->
```cpp
#include <iostream>
using namespace std;

int sumar(int a, int b) {
    return a + b;
}

double sumar(double a, double b) {
    return a + b;
}

int main() {
    cout << "Suma de enteros: " << sumar(3, 4) << endl;       // Llama a sumar(int, int)
    cout << "Suma de dobles: " << sumar(3.5, 2.5) << endl;    // Llama a sumar(double, double)
    return 0;
}
<---Ejemplo de Sobrecarga de Funciones Result--->
<---Tipos de Parámetros--->
<---Tipos de Parámetros Result--->
<---Parámetros por Puntero--->
```cpp
void incrementarPorPuntero(int* x) {
    (*x)++;
    cout << "Dentro de la función: " << *x << endl;
}

int main() {
    int numero = 5;
    incrementarPorPuntero(&numero);
    cout << "Fuera de la función: " << numero << endl; // Salida: 6
    return 0;
}
<---Parámetros por Puntero Result--->
<---Parámetros Predeterminados--->
```cpp
void saludar(string nombre = "Mundo") {
    cout << "Hola, " << nombre << "!" << endl;
}

int main() {
    saludar(); // Usa el valor predeterminado: Mundo
    saludar("Juan"); // Usa el argumento proporcionado: Juan
    return 0;
}
<---Parámetros Predeterminados Result--->
<---Ejemplo de Argumentos--->
```cpp
int sumar(int a, int b) {
    return a + b;
}

int main() {
    int x = 5;
    int y = 3;
    int resultado = sumar(x, y); // x y y son los argumentos
    cout << "Resultado: " << resultado << endl;
    return 0;
}
<---Ejemplo de Argumentos Result--->
<---Ejemplo con Múltiples Parámetros--->
```cpp
#include <iostream>
using namespace std;

void imprimirDatos(string nombre, int edad, double altura) {
    cout << "Nombre: " << nombre << endl;
    cout << "Edad: " << edad << endl;
    cout << "Altura: " << altura << " metros" << endl;
}

int main() {
    imprimirDatos("Juan", 30, 1.75);
    return 0;
}
<---Ejemplo con Múltiples Parámetros Result--->
<---Ejemplo con Referencia Constante--->
```cpp
void mostrarMensaje(const string& mensaje) {
    cout << mensaje << endl;
}

int main() {
    string saludo = "Hola, Mundo!";
    mostrarMensaje(saludo);
    return 0;
}
<---Ejemplo con Referencia Constante Result--->
<---Ejemplo de Pasar Arrays por Puntero--->
```cpp
#include <iostream>
using namespace std;

void imprimirArray(int* arr, int tam) {
    for (int i = 0; i < tam; ++i) {
        cout << arr[i] << " ";
    }
    cout << endl;
}

int main() {
    int numeros[] = {1, 2, 3, 4, 5};
    int tam = sizeof(numeros) / sizeof(numeros[0]);

    imprimirArray(numeros, tam); // Pasar array a la función

    return 0;
}
<---Ejemplo de Pasar Arrays por Puntero Result--->
<---Ejemplo de Pasar Arrays por Referencia--->
```cpp
#include <iostream>
using namespace std;

template<size_t N>
void imprimirArrayPorReferencia(int (&arr)[N]) {
    for (int i = 0; i < N; ++i) {
        cout << arr[i] << " ";
    }
    cout << endl;
}

int main() {
    int numeros[] = {1, 2, 3, 4, 5};

    imprimirArrayPorReferencia(numeros); // Pasar array a la función por referencia

    return 0;
}
<---Ejemplo de Pasar Arrays por Referencia Result--->
<---Ejemplo de Pasar Arrays de Cadenas--->
```cpp
#include <iostream>
using namespace std;

void imprimirCadenas(const char* cadenas[], int tam) {
    for (int i = 0; i < tam; ++i) {
        cout << cadenas[i] << endl;
    }
}

int main() {
    const char* frutas[] = {"Manzana", "Banana", "Cereza", "Dátil"};

    int tam = sizeof(frutas) / sizeof(frutas[0]);
    imprimirCadenas(frutas, tam); // Pasar array de cadenas a la función

    return 0;
}
<---Ejemplo de Pasar Arrays de Cadenas Result--->
<---Ejemplo de Pasar Arrays Bidimensionales--->
```cpp
#include <iostream>
using namespace std;

void imprimirMatriz(int matriz[][3], int filas) {
    for (int i = 0; i < filas; ++i) {
        for (int j = 0; j < 3; ++j) {
            cout << matriz[i][j] << " ";
        }
        cout << endl;
    }
}

int main() {
    int matriz[2][3] = {
        {1, 2, 3},
        {4, 5, 6}
    };

    imprimirMatriz(matriz, 2); // Pasar array bidimensional a la función

    return 0;
}
```cpp
#include <iostream>
using namespace std;

// Pasar array por puntero
void imprimirArray(const int* arr, int tam) {
    for (int i = 0; i < tam; ++i) {
        cout << arr[i] << " ";
    }
    cout << endl;
}

// Pasar array por referencia
template<size_t N>
void imprimirArrayPorReferencia(const int (&arr)[N]) {
    for (int i = 0; i < N; ++i) {
        cout << arr[i] << " ";
    }
    cout << endl;
}

// Pasar array de cadenas
void imprimirCadenas(const char* cadenas[], int tam) {
    for (int i = 0; i < tam; ++i) {
        cout << cadenas[i] << endl;
    }
}

// Pasar array bidimensional
void imprimirMatriz(int matriz[][3], int filas) {
    for (int i = 0; i < filas; ++i) {
        for (int j = 0; j < 3; ++j) {
            cout << matriz[i][j] << " ";
        }
        cout << endl;
    }
}

int main() {
    // Array unidimensional
    int numeros[] = {1, 2, 3, 4, 5};
    int tam = sizeof(numeros) / sizeof(numeros[0]);

    imprimirArray(numeros, tam);
    imprimirArrayPorReferencia(numeros);

    // Array de cadenas
    const char* frutas[] = {"Manzana", "Banana", "Cereza", "Dátil"};
    int tamFrutas = sizeof(frutas) / sizeof(frutas[0]);

    imprimirCadenas(frutas, tamFrutas);

    // Array bidimensional
    int matriz[2][3] = {
        {1, 2, 3},
        {4, 5, 6}
    };

    imprimirMatriz(matriz, 2);

    return 0;
}
<---Ejemplo de Pasar Arrays Bidimensionales Result--->
<---Ejemplo de Conversión Implícita--->
```cpp
#include <iostream>
using namespace std;

void imprimirNumero(double num) {
    cout << "Número: " << num << endl;
}

int main() {
    int entero = 42;
    float flotante = 3.14f;

    imprimirNumero(entero);    // Conversión implícita de int a double
    imprimirNumero(flotante);  // Conversión implícita de float a double

    return 0;
}
<---Ejemplo de Conversión Implícita Result--->
<---Promoción de Tipos--->
```cpp
#include <iostream>
using namespace std;

void mostrarLong(long num) {
    cout << "Long: " << num << endl;
}

int main() {
    char c = 'A';
    short s = 10;
    int i = 100;

    mostrarLong(c); // Conversión implícita de char a long
    mostrarLong(s); // Conversión implícita de short a long
    mostrarLong(i); // Conversión implícita de int a long

    return 0;
}
<---Promoción de Tipos Result--->
<---Ejemplo con Herencia--->
```cpp
#include <iostream>
using namespace std;

class Base {
public:
    virtual void mostrar() const {
        cout << "Base" << endl;
    }
};

class Derivado : public Base {
public:
    void mostrar() const override {
        cout << "Derivado" << endl;
    }
};

void llamarMostrar(const Base& obj) {
    obj.mostrar();
}

int main() {
    Base b;
    Derivado d;

    llamarMostrar(b); // No hay conversión
    llamarMostrar(d); // Conversión implícita de Derivado a Base

    return 0;
}
<---Ejemplo con Herencia Result--->
<---Ejemplo con Constructor de Conversión--->
```cpp
#include <iostream>
using namespace std;

class Entero {
private:
    int valor;
public:
    Entero(int v) : valor(v) {}

    void mostrar() const {
        cout << "Entero: " << valor << endl;
    }
};

void mostrarEntero(const Entero& e) {
    e.mostrar();
}

int main() {
    mostrarEntero(42); // Conversión implícita de int a Entero

    return 0;
}
```cpp
#include <iostream>
using namespace std;

class Base {
public:
    virtual void mostrar() const {
        cout << "Base" << endl;
    }
};

class Derivado : public Base {
public:
    void mostrar() const override {
        cout << "Derivado" << endl;
    }
};

void imprimirNumero(double num) {
    cout << "Número: " << num << endl;
}

void mostrarLong(long num) {
    cout << "Long: " << num << endl;
}

void llamarMostrar(const Base& obj) {
    obj.mostrar();
}

class Entero {
private:
    int valor;
public:
    Entero(int v) : valor(v) {}

    void mostrar() const {
        cout << "Entero: " << valor << endl;
    }
};

void mostrarEntero(const Entero& e) {
    e.mostrar();
}

int main() {
    // Conversión implícita de tipos primitivos
    int entero = 42;
    float flotante = 3.14f;

    imprimirNumero(entero);    // Conversión implícita de int a double
    imprimirNumero(flotante);  // Conversión implícita de float a double

    char c = 'A';
    short s = 10;
    int i = 100;

    mostrarLong(c); // Conversión implícita de char a long
    mostrarLong(s); // Conversión implícita de short a long
    mostrarLong(i); // Conversión implícita de int a long

    // Conversión implícita en herencia
    Base b;
    Derivado d;

    llamarMostrar(b); // No hay conversión
    llamarMostrar(d); // Conversión implícita de Derivado a Base

    // Conversión implícita usando constructor
    mostrarEntero(42); // Conversión implícita de int a Entero

    return 0;
}
<---Ejemplo con Constructor de Conversión Result--->
<---Sintaxis--->
```cpp
void nombre_funcion(lista_de_parametros) {
    // Cuerpo de la función
    // No hay sentencia return
}
<---Sintaxis Result--->
<---Ejemplo de Función con Valor de Retorno--->
```cpp
#include <iostream>
using namespace std;

// Función que devuelve la suma de dos enteros
int sumar(int a, int b) {
    return a + b;
}

int main() {
    int resultado = sumar(5, 3);
    cout << "La suma es: " << resultado << endl;
    return 0;
}
<---Ejemplo de Función con Valor de Retorno Result--->
<---Ejemplo con un Tipo de Dato Diferente--->
```cpp
#include <iostream>
using namespace std;

// Función que devuelve un saludo como string
string obtenerSaludo(string nombre) {
    return "Hola, " + nombre + "!";
}

int main() {
    string saludo = obtenerSaludo("Juan");
    cout << saludo << endl;
    return 0;
}
<---Ejemplo con un Tipo de Dato Diferente Result--->
<---Ejemplo de Función Sin Valor de Retorno--->
```cpp
#include <iostream>
using namespace std;

// Función que imprime un mensaje
void imprimirMensaje(string mensaje) {
    cout << mensaje << endl;
}

int main() {
    imprimirMensaje("Hola, Mundo!");
    return 0;
}
<---Ejemplo de Función Sin Valor de Retorno Result--->
<---Ejemplo con Parámetros por Referencia--->
```cpp
#include <iostream>
using namespace std;

// Función que incrementa el valor de una variable
void incrementar(int& num) {
    num++;
}

int main() {
    int valor = 10;
    incrementar(valor);
    cout << "Valor después de incrementar: " << valor << endl;
    return 0;
}
```cpp
#include <iostream>
using namespace std;

// Función con valor de retorno
double calcularAreaCirculo(double radio) {
    return 3.14159 * radio * radio;
}

// Función sin valor de retorno
void imprimirArea(double area) {
    cout << "El área del círculo es: " << area << endl;
}

int main() {
    double radio = 5.0;
    double area = calcularAreaCirculo(radio); // Llamada a función con valor de retorno
    imprimirArea(area);                       // Llamada a función sin valor de retorno
    return 0;
}
<---Ejemplo con Parámetros por Referencia Result--->
<---Reglas para la Sobrecarga de Funciones--->
```cpp
#include <iostream>
using namespace std;

// Sobrecarga de la función sumar
int sumar(int a, int b) {
    return a + b;
}

double sumar(double a, double b) {
    return a + b;
}

string sumar(string a, string b) {
    return a + b;
}

int main() {
    // Llamadas a funciones sobrecargadas
    cout << "Suma de enteros: " << sumar(3, 4) << endl;       // Llama a sumar(int, int)
    cout << "Suma de dobles: " << sumar(3.5, 2.5) << endl;    // Llama a sumar(double, double)
    cout << "Suma de strings: " << sumar("Hola, ", "Mundo!") << endl;  // Llama a sumar(string, string)
    return 0;
}
<---Reglas para la Sobrecarga de Funciones Result--->
<---Ejemplo de Sobrecarga con Diferente Número de Parámetros--->
```cpp
#include <iostream>
using namespace std;

// Sobrecarga de la función imprimir
void imprimir(int a) {
    cout << "Valor entero: " << a << endl;
}

void imprimir(int a, int b) {
    cout << "Valores enteros: " << a << " y " << b << endl;
}

void imprimir(int a, int b, int c) {
    cout << "Valores enteros: " << a << ", " << b << " y " << c << endl;
}

int main() {
    // Llamadas a funciones sobrecargadas
    imprimir(5);          // Llama a imprimir(int)
    imprimir(5, 10);      // Llama a imprimir(int, int)
    imprimir(5, 10, 15);  // Llama a imprimir(int, int, int)
    return 0;
}
<---Ejemplo de Sobrecarga con Diferente Número de Parámetros Result--->
<---Ejemplo de Sobrecarga con Constantes--->
```cpp
#include <iostream>
using namespace std;

// Sobrecarga de la función mostrar
void mostrar(int& a) {
    cout << "Llamada no constante: " << a << endl;
}

void mostrar(const int& a) {
    cout << "Llamada constante: " << a << endl;
}

int main() {
    int x = 10;
    const int y = 20;

    mostrar(x);  // Llama a mostrar(int&)
    mostrar(y);  // Llama a mostrar(const int&)
    return 0;
}
```cpp
#include <iostream>
#include <string>
using namespace std;

// Sobrecarga de la función procesar
void procesar(int a) {
    cout << "Procesando entero: " << a << endl;
}

void procesar(double a) {
    cout << "Procesando doble: " << a << endl;
}

void procesar(string a) {
    cout << "Procesando string: " << a << endl;
}

void procesar(int a, double b) {
    cout << "Procesando entero y doble: " << a << " y " << b << endl;
}

void procesar(double a, int b) {
    cout << "Procesando doble y entero: " << a << " y " << b << endl;
}

int main() {
    // Llamadas a funciones sobrecargadas
    procesar(5);           // Llama a procesar(int)
    procesar(3.14);        // Llama a procesar(double)
    procesar("Hola");      // Llama a procesar(string)
    procesar(5, 3.14);     // Llama a procesar(int, double)
    procesar(3.14, 5);     // Llama a procesar(double, int)
    return 0;
}
<---Ejemplo de Sobrecarga con Constantes Result--->
<---Implementación Recursiva del Factorial--->
```cpp
#include <iostream>
using namespace std;

int factorial(int n) {
    if (n == 0) { // Caso base
        return 1;
    } else { // Caso recursivo
        return n * factorial(n - 1);
    }
}

int main() {
    int numero = 5;
    cout << "El factorial de " << numero << " es " << factorial(numero) << endl;
    return 0;
}
<---Implementación Recursiva del Factorial Result--->
<---Implementación Recursiva de Fibonacci--->
```cpp
#include <iostream>
using namespace std;

int fibonacci(int n) {
    if (n <= 1) { // Casos base
        return n;
    } else { // Caso recursivo
        return fibonacci(n - 1) + fibonacci(n - 2);
    }
}

int main() {
    int numero = 10;
    cout << "El término " << numero << " de la serie de Fibonacci es " << fibonacci(numero) << endl;
    return 0;
}
<---Implementación Recursiva de Fibonacci Result--->
<---Ejemplo de Recursividad de Cola--->
```cpp
#include <iostream>
using namespace std;

int factorialCola(int n, int acumulador = 1) {
    if (n == 0) { // Caso base
        return acumulador;
    } else { // Caso recursivo de cola
        return factorialCola(n - 1, n * acumulador);
    }
}

int main() {
    int numero = 5;
    cout << "El factorial de " << numero << " (usando recursividad de cola) es " << factorialCola(numero) << endl;
    return 0;
}
<---Ejemplo de Recursividad de Cola Result--->
<---Implementación de Fibonacci con Memoización--->
```cpp
#include <iostream>
#include <vector>
using namespace std;

vector<int> memo(100, -1); // Inicializar con -1

int fibonacciMemo(int n) {
    if (n <= 1) { // Casos base
        return n;
    }
    if (memo[n] != -1) { // Verificar si el resultado ya está calculado
        return memo[n];
    }
    // Calcular y almacenar el resultado
    memo[n] = fibonacciMemo(n - 1) + fibonacciMemo(n - 2);
    return memo[n];
}

int main() {
    int numero = 10;
    cout << "El término " << numero << " de la serie de Fibonacci (con memoización) es " << fibonacciMemo(numero) << endl;
    return 0;
}
<---Implementación de Fibonacci con Memoización Result--->
<---Sintaxis de la Declaración de Funciones--->
```cpp
tipo_retorno nombre_funcion(lista_de_parametros);
<---Sintaxis de la Declaración de Funciones Result--->
<---Ejemplo de Declaración de Función--->
```cpp
int sumar(int a, int b);
void mostrarMensaje(string mensaje);
<---Ejemplo de Declaración de Función Result--->
<---Sintaxis de la Definición de Funciones--->
```cpp
tipo_retorno nombre_funcion(lista_de_parametros) {
    // Cuerpo de la función
}
<---Sintaxis de la Definición de Funciones Result--->
<---Ejemplo de Definición de Función--->
```cpp
int sumar(int a, int b) {
    return a + b;
}

void mostrarMensaje(string mensaje) {
    cout << mensaje << endl;
}
```cpp
#include <iostream>
using namespace std;

// Declaraciones de funciones
int sumar(int a, int b);
void mostrarMensaje(string mensaje);

int main() {
    int resultado = sumar(5, 3);
    cout << "La suma es: " << resultado << endl;

    mostrarMensaje("Hola, mundo!");

    return 0;
}

// Definiciones de funciones
int sumar(int a, int b) {
    return a + b;
}

void mostrarMensaje(string mensaje) {
    cout << mensaje << endl;
}
<---Ejemplo de Definición de Función Result--->
<---Parámetros por Valor--->
```cpp
void incrementarPorValor(int x) {
    x++;
    cout << "Dentro de la función: " << x << endl;
}

int main() {
    int numero = 5;
    incrementarPorValor(numero);
    cout << "Fuera de la función: " << numero << endl; // Salida: 5
    return 0;
}
<---Parámetros por Valor Result--->
<---Parámetros por Referencia--->
```cpp
void incrementarPorReferencia(int& x) {
    x++;
    cout << "Dentro de la función: " << x << endl;
}

int main() {
    int numero = 5;
    incrementarPorReferencia(numero);
    cout << "Fuera de la función: " << numero << endl; // Salida: 6
    return 0;
}
<---Parámetros por Referencia Result--->
<---Ejemplo de Sobrecarga de Funciones--->
```cpp
#include <iostream>
using namespace std;

int sumar(int a, int b) {
    return a + b;
}

double sumar(double a, double b) {
    return a + b;
}

int main() {
    cout << "Suma de enteros: " << sumar(3, 4) << endl;       // Llama a sumar(int, int)
    cout << "Suma de dobles: " << sumar(3.5, 2.5) << endl;    // Llama a sumar(double, double)
    return 0;
}
<---Ejemplo de Sobrecarga de Funciones Result--->
<---Tipos de Parámetros--->
<---Tipos de Parámetros Result--->
<---Parámetros por Puntero--->
```cpp
void incrementarPorPuntero(int* x) {
    (*x)++;
    cout << "Dentro de la función: " << *x << endl;
}

int main() {
    int numero = 5;
    incrementarPorPuntero(&numero);
    cout << "Fuera de la función: " << numero << endl; // Salida: 6
    return 0;
}
<---Parámetros por Puntero Result--->
<---Parámetros Predeterminados--->
```cpp
void saludar(string nombre = "Mundo") {
    cout << "Hola, " << nombre << "!" << endl;
}

int main() {
    saludar(); // Usa el valor predeterminado: Mundo
    saludar("Juan"); // Usa el argumento proporcionado: Juan
    return 0;
}
<---Parámetros Predeterminados Result--->
<---Ejemplo de Argumentos--->
```cpp
int sumar(int a, int b) {
    return a + b;
}

int main() {
    int x = 5;
    int y = 3;
    int resultado = sumar(x, y); // x y y son los argumentos
    cout << "Resultado: " << resultado << endl;
    return 0;
}
<---Ejemplo de Argumentos Result--->
<---Ejemplo con Múltiples Parámetros--->
```cpp
#include <iostream>
using namespace std;

void imprimirDatos(string nombre, int edad, double altura) {
    cout << "Nombre: " << nombre << endl;
    cout << "Edad: " << edad << endl;
    cout << "Altura: " << altura << " metros" << endl;
}

int main() {
    imprimirDatos("Juan", 30, 1.75);
    return 0;
}
<---Ejemplo con Múltiples Parámetros Result--->
<---Ejemplo con Referencia Constante--->
```cpp
void mostrarMensaje(const string& mensaje) {
    cout << mensaje << endl;
}

int main() {
    string saludo = "Hola, Mundo!";
    mostrarMensaje(saludo);
    return 0;
}
<---Ejemplo con Referencia Constante Result--->
<---Ejemplo de Pasar Arrays por Puntero--->
```cpp
#include <iostream>
using namespace std;

void imprimirArray(int* arr, int tam) {
    for (int i = 0; i < tam; ++i) {
        cout << arr[i] << " ";
    }
    cout << endl;
}

int main() {
    int numeros[] = {1, 2, 3, 4, 5};
    int tam = sizeof(numeros) / sizeof(numeros[0]);

    imprimirArray(numeros, tam); // Pasar array a la función

    return 0;
}
<---Ejemplo de Pasar Arrays por Puntero Result--->
<---Ejemplo de Pasar Arrays por Referencia--->
```cpp
#include <iostream>
using namespace std;

template<size_t N>
void imprimirArrayPorReferencia(int (&arr)[N]) {
    for (int i = 0; i < N; ++i) {
        cout << arr[i] << " ";
    }
    cout << endl;
}

int main() {
    int numeros[] = {1, 2, 3, 4, 5};

    imprimirArrayPorReferencia(numeros); // Pasar array a la función por referencia

    return 0;
}
<---Ejemplo de Pasar Arrays por Referencia Result--->
<---Ejemplo de Pasar Arrays de Cadenas--->
```cpp
#include <iostream>
using namespace std;

void imprimirCadenas(const char* cadenas[], int tam) {
    for (int i = 0; i < tam; ++i) {
        cout << cadenas[i] << endl;
    }
}

int main() {
    const char* frutas[] = {"Manzana", "Banana", "Cereza", "Dátil"};

    int tam = sizeof(frutas) / sizeof(frutas[0]);
    imprimirCadenas(frutas, tam); // Pasar array de cadenas a la función

    return 0;
}
<---Ejemplo de Pasar Arrays de Cadenas Result--->
<---Ejemplo de Pasar Arrays Bidimensionales--->
```cpp
#include <iostream>
using namespace std;

void imprimirMatriz(int matriz[][3], int filas) {
    for (int i = 0; i < filas; ++i) {
        for (int j = 0; j < 3; ++j) {
            cout << matriz[i][j] << " ";
        }
        cout << endl;
    }
}

int main() {
    int matriz[2][3] = {
        {1, 2, 3},
        {4, 5, 6}
    };

    imprimirMatriz(matriz, 2); // Pasar array bidimensional a la función

    return 0;
}
```cpp
#include <iostream>
using namespace std;

// Pasar array por puntero
void imprimirArray(const int* arr, int tam) {
    for (int i = 0; i < tam; ++i) {
        cout << arr[i] << " ";
    }
    cout << endl;
}

// Pasar array por referencia
template<size_t N>
void imprimirArrayPorReferencia(const int (&arr)[N]) {
    for (int i = 0; i < N; ++i) {
        cout << arr[i] << " ";
    }
    cout << endl;
}

// Pasar array de cadenas
void imprimirCadenas(const char* cadenas[], int tam) {
    for (int i = 0; i < tam; ++i) {
        cout << cadenas[i] << endl;
    }
}

// Pasar array bidimensional
void imprimirMatriz(int matriz[][3], int filas) {
    for (int i = 0; i < filas; ++i) {
        for (int j = 0; j < 3; ++j) {
            cout << matriz[i][j] << " ";
        }
        cout << endl;
    }
}

int main() {
    // Array unidimensional
    int numeros[] = {1, 2, 3, 4, 5};
    int tam = sizeof(numeros) / sizeof(numeros[0]);

    imprimirArray(numeros, tam);
    imprimirArrayPorReferencia(numeros);

    // Array de cadenas
    const char* frutas[] = {"Manzana", "Banana", "Cereza", "Dátil"};
    int tamFrutas = sizeof(frutas) / sizeof(frutas[0]);

    imprimirCadenas(frutas, tamFrutas);

    // Array bidimensional
    int matriz[2][3] = {
        {1, 2, 3},
        {4, 5, 6}
    };

    imprimirMatriz(matriz, 2);

    return 0;
}
<---Ejemplo de Pasar Arrays Bidimensionales Result--->
<---Ejemplo de Conversión Implícita--->
```cpp
#include <iostream>
using namespace std;

void imprimirNumero(double num) {
    cout << "Número: " << num << endl;
}

int main() {
    int entero = 42;
    float flotante = 3.14f;

    imprimirNumero(entero);    // Conversión implícita de int a double
    imprimirNumero(flotante);  // Conversión implícita de float a double

    return 0;
}
<---Ejemplo de Conversión Implícita Result--->
<---Promoción de Tipos--->
```cpp
#include <iostream>
using namespace std;

void mostrarLong(long num) {
    cout << "Long: " << num << endl;
}

int main() {
    char c = 'A';
    short s = 10;
    int i = 100;

    mostrarLong(c); // Conversión implícita de char a long
    mostrarLong(s); // Conversión implícita de short a long
    mostrarLong(i); // Conversión implícita de int a long

    return 0;
}
<---Promoción de Tipos Result--->
<---Ejemplo con Herencia--->
```cpp
#include <iostream>
using namespace std;

class Base {
public:
    virtual void mostrar() const {
        cout << "Base" << endl;
    }
};

class Derivado : public Base {
public:
    void mostrar() const override {
        cout << "Derivado" << endl;
    }
};

void llamarMostrar(const Base& obj) {
    obj.mostrar();
}

int main() {
    Base b;
    Derivado d;

    llamarMostrar(b); // No hay conversión
    llamarMostrar(d); // Conversión implícita de Derivado a Base

    return 0;
}
<---Ejemplo con Herencia Result--->
<---Ejemplo con Constructor de Conversión--->
```cpp
#include <iostream>
using namespace std;

class Entero {
private:
    int valor;
public:
    Entero(int v) : valor(v) {}

    void mostrar() const {
        cout << "Entero: " << valor << endl;
    }
};

void mostrarEntero(const Entero& e) {
    e.mostrar();
}

int main() {
    mostrarEntero(42); // Conversión implícita de int a Entero

    return 0;
}
```cpp
#include <iostream>
using namespace std;

class Base {
public:
    virtual void mostrar() const {
        cout << "Base" << endl;
    }
};

class Derivado : public Base {
public:
    void mostrar() const override {
        cout << "Derivado" << endl;
    }
};

void imprimirNumero(double num) {
    cout << "Número: " << num << endl;
}

void mostrarLong(long num) {
    cout << "Long: " << num << endl;
}

void llamarMostrar(const Base& obj) {
    obj.mostrar();
}

class Entero {
private:
    int valor;
public:
    Entero(int v) : valor(v) {}

    void mostrar() const {
        cout << "Entero: " << valor << endl;
    }
};

void mostrarEntero(const Entero& e) {
    e.mostrar();
}

int main() {
    // Conversión implícita de tipos primitivos
    int entero = 42;
    float flotante = 3.14f;

    imprimirNumero(entero);    // Conversión implícita de int a double
    imprimirNumero(flotante);  // Conversión implícita de float a double

    char c = 'A';
    short s = 10;
    int i = 100;

    mostrarLong(c); // Conversión implícita de char a long
    mostrarLong(s); // Conversión implícita de short a long
    mostrarLong(i); // Conversión implícita de int a long

    // Conversión implícita en herencia
    Base b;
    Derivado d;

    llamarMostrar(b); // No hay conversión
    llamarMostrar(d); // Conversión implícita de Derivado a Base

    // Conversión implícita usando constructor
    mostrarEntero(42); // Conversión implícita de int a Entero

    return 0;
}
<---Ejemplo con Constructor de Conversión Result--->
<---Sintaxis--->
```cpp
void nombre_funcion(lista_de_parametros) {
    // Cuerpo de la función
    // No hay sentencia return
}
<---Sintaxis Result--->
<---Ejemplo de Función con Valor de Retorno--->
```cpp
#include <iostream>
using namespace std;

// Función que devuelve la suma de dos enteros
int sumar(int a, int b) {
    return a + b;
}

int main() {
    int resultado = sumar(5, 3);
    cout << "La suma es: " << resultado << endl;
    return 0;
}
<---Ejemplo de Función con Valor de Retorno Result--->
<---Ejemplo con un Tipo de Dato Diferente--->
```cpp
#include <iostream>
using namespace std;

// Función que devuelve un saludo como string
string obtenerSaludo(string nombre) {
    return "Hola, " + nombre + "!";
}

int main() {
    string saludo = obtenerSaludo("Juan");
    cout << saludo << endl;
    return 0;
}
<---Ejemplo con un Tipo de Dato Diferente Result--->
<---Ejemplo de Función Sin Valor de Retorno--->
```cpp
#include <iostream>
using namespace std;

// Función que imprime un mensaje
void imprimirMensaje(string mensaje) {
    cout << mensaje << endl;
}

int main() {
    imprimirMensaje("Hola, Mundo!");
    return 0;
}
<---Ejemplo de Función Sin Valor de Retorno Result--->
<---Ejemplo con Parámetros por Referencia--->
```cpp
#include <iostream>
using namespace std;

// Función que incrementa el valor de una variable
void incrementar(int& num) {
    num++;
}

int main() {
    int valor = 10;
    incrementar(valor);
    cout << "Valor después de incrementar: " << valor << endl;
    return 0;
}
```cpp
#include <iostream>
using namespace std;

// Función con valor de retorno
double calcularAreaCirculo(double radio) {
    return 3.14159 * radio * radio;
}

// Función sin valor de retorno
void imprimirArea(double area) {
    cout << "El área del círculo es: " << area << endl;
}

int main() {
    double radio = 5.0;
    double area = calcularAreaCirculo(radio); // Llamada a función con valor de retorno
    imprimirArea(area);                       // Llamada a función sin valor de retorno
    return 0;
}
<---Ejemplo con Parámetros por Referencia Result--->
<---Reglas para la Sobrecarga de Funciones--->
```cpp
#include <iostream>
using namespace std;

// Sobrecarga de la función sumar
int sumar(int a, int b) {
    return a + b;
}

double sumar(double a, double b) {
    return a + b;
}

string sumar(string a, string b) {
    return a + b;
}

int main() {
    // Llamadas a funciones sobrecargadas
    cout << "Suma de enteros: " << sumar(3, 4) << endl;       // Llama a sumar(int, int)
    cout << "Suma de dobles: " << sumar(3.5, 2.5) << endl;    // Llama a sumar(double, double)
    cout << "Suma de strings: " << sumar("Hola, ", "Mundo!") << endl;  // Llama a sumar(string, string)
    return 0;
}
<---Reglas para la Sobrecarga de Funciones Result--->
<---Ejemplo de Sobrecarga con Diferente Número de Parámetros--->
```cpp
#include <iostream>
using namespace std;

// Sobrecarga de la función imprimir
void imprimir(int a) {
    cout << "Valor entero: " << a << endl;
}

void imprimir(int a, int b) {
    cout << "Valores enteros: " << a << " y " << b << endl;
}

void imprimir(int a, int b, int c) {
    cout << "Valores enteros: " << a << ", " << b << " y " << c << endl;
}

int main() {
    // Llamadas a funciones sobrecargadas
    imprimir(5);          // Llama a imprimir(int)
    imprimir(5, 10);      // Llama a imprimir(int, int)
    imprimir(5, 10, 15);  // Llama a imprimir(int, int, int)
    return 0;
}
<---Ejemplo de Sobrecarga con Diferente Número de Parámetros Result--->
<---Ejemplo de Sobrecarga con Constantes--->
```cpp
#include <iostream>
using namespace std;

// Sobrecarga de la función mostrar
void mostrar(int& a) {
    cout << "Llamada no constante: " << a << endl;
}

void mostrar(const int& a) {
    cout << "Llamada constante: " << a << endl;
}

int main() {
    int x = 10;
    const int y = 20;

    mostrar(x);  // Llama a mostrar(int&)
    mostrar(y);  // Llama a mostrar(const int&)
    return 0;
}
```cpp
#include <iostream>
#include <string>
using namespace std;

// Sobrecarga de la función procesar
void procesar(int a) {
    cout << "Procesando entero: " << a << endl;
}

void procesar(double a) {
    cout << "Procesando doble: " << a << endl;
}

void procesar(string a) {
    cout << "Procesando string: " << a << endl;
}

void procesar(int a, double b) {
    cout << "Procesando entero y doble: " << a << " y " << b << endl;
}

void procesar(double a, int b) {
    cout << "Procesando doble y entero: " << a << " y " << b << endl;
}

int main() {
    // Llamadas a funciones sobrecargadas
    procesar(5);           // Llama a procesar(int)
    procesar(3.14);        // Llama a procesar(double)
    procesar("Hola");      // Llama a procesar(string)
    procesar(5, 3.14);     // Llama a procesar(int, double)
    procesar(3.14, 5);     // Llama a procesar(double, int)
    return 0;
}
<---Ejemplo de Sobrecarga con Constantes Result--->
<---Implementación Recursiva del Factorial--->
```cpp
#include <iostream>
using namespace std;

int factorial(int n) {
    if (n == 0) { // Caso base
        return 1;
    } else { // Caso recursivo
        return n * factorial(n - 1);
    }
}

int main() {
    int numero = 5;
    cout << "El factorial de " << numero << " es " << factorial(numero) << endl;
    return 0;
}
<---Implementación Recursiva del Factorial Result--->
<---Implementación Recursiva de Fibonacci--->
```cpp
#include <iostream>
using namespace std;

int fibonacci(int n) {
    if (n <= 1) { // Casos base
        return n;
    } else { // Caso recursivo
        return fibonacci(n - 1) + fibonacci(n - 2);
    }
}

int main() {
    int numero = 10;
    cout << "El término " << numero << " de la serie de Fibonacci es " << fibonacci(numero) << endl;
    return 0;
}
<---Implementación Recursiva de Fibonacci Result--->
<---Ejemplo de Recursividad de Cola--->
```cpp
#include <iostream>
using namespace std;

int factorialCola(int n, int acumulador = 1) {
    if (n == 0) { // Caso base
        return acumulador;
    } else { // Caso recursivo de cola
        return factorialCola(n - 1, n * acumulador);
    }
}

int main() {
    int numero = 5;
    cout << "El factorial de " << numero << " (usando recursividad de cola) es " << factorialCola(numero) << endl;
    return 0;
}
<---Ejemplo de Recursividad de Cola Result--->
<---Implementación de Fibonacci con Memoización--->
```cpp
#include <iostream>
#include <vector>
using namespace std;

vector<int> memo(100, -1); // Inicializar con -1

int fibonacciMemo(int n) {
    if (n <= 1) { // Casos base
        return n;
    }
    if (memo[n] != -1) { // Verificar si el resultado ya está calculado
        return memo[n];
    }
    // Calcular y almacenar el resultado
    memo[n] = fibonacciMemo(n - 1) + fibonacciMemo(n - 2);
    return memo[n];
}

int main() {
    int numero = 10;
    cout << "El término " << numero << " de la serie de Fibonacci (con memoización) es " << fibonacciMemo(numero) << endl;
    return 0;
}
<---Implementación de Fibonacci con Memoización Result--->
<---Restricciones de las Funciones `constexpr`--->
<---Restricciones de las Funciones `constexpr` Result--->
<---Ejemplo Básico--->
```cpp
#include <iostream>
using namespace std;

// Función constexpr para calcular el cuadrado de un número
constexpr int cuadrado(int x) {
    return x * x;
}

int main() {
    constexpr int resultado = cuadrado(5); // Evaluado en tiempo de compilación
    cout << "El cuadrado de 5 es: " << resultado << endl;
    return 0;
}
<---Ejemplo Básico Result--->
<---Ejemplo con Condicionales y Bucles--->
```cpp
#include <iostream>
using namespace std;

// Función constexpr para calcular el factorial de un número
constexpr int factorial(int n) {
    int resultado = 1;
    for (int i = 1; i <= n; ++i) {
        resultado *= i;
    }
    return resultado;
}

int main() {
    constexpr int resultado = factorial(5); // Evaluado en tiempo de compilación
    cout << "El factorial de 5 es: " << resultado << endl;
    return 0;
}
```cpp
#include <iostream>
using namespace std;

constexpr int maximo(int a, int b) {
    return (a > b) ? a : b;
}

constexpr int minimo(int a, int b) {
    return (a < b) ? a : b;
}

constexpr int sumaDeCuadrados(int a, int b) {
    return cuadrado(a) + cuadrado(b);
}

constexpr int cuadrado(int x) {
    return x * x;
}

int main() {
    constexpr int a = 3;
    constexpr int b = 4;

    constexpr int maxVal = maximo(a, b);        // Evaluado en tiempo de compilación
    constexpr int minVal = minimo(a, b);        // Evaluado en tiempo de compilación
    constexpr int sumaCuadrados = sumaDeCuadrados(a, b); // Evaluado en tiempo de compilación

    cout << "El máximo de " << a << " y " << b << " es: " << maxVal << endl;
    cout << "El mínimo de " << a << " y " << b << " es: " << minVal << endl;
    cout << "La suma de los cuadrados de " << a << " y " << b << " es: " << sumaCuadrados << endl;

    return 0;
}
<---Ejemplo con Condicionales y Bucles Result--->
