<---EXPLANATION--->
### Introducción a las Plantillas en C++

Las plantillas en C++ son una característica poderosa que permite escribir código genérico, capaz de trabajar con cualquier tipo de dato. Esto facilita la reutilización de código y la creación de funciones y clases que operan de manera eficiente con diferentes tipos de datos.

#### Definición de Plantillas de Función

Las plantillas de función permiten crear funciones que pueden trabajar con cualquier tipo de dato.

##### Ejemplo Básico

```cpp
// plantilla_funcion.cpp
#include <iostream>

template <typename T>
T obtenerMayor(T a, T b) {
    return (a > b) ? a : b;
}

int main() {
    std::cout << "Mayor entre 3 y 7: " << obtenerMayor(3, 7) << std::endl;
    std::cout << "Mayor entre 5.5 y 2.2: " << obtenerMayor(5.5, 2.2) << std::endl;
    return 0;
}
```

En este ejemplo:
- La función `obtenerMayor` utiliza una plantilla para trabajar con cualquier tipo de dato (`int`, `double`, etc.).
- La palabra clave `template` seguida de `<typename T>` define una plantilla de función donde `T` es un parámetro de tipo.

#### Definición de Plantillas de Clase

Las plantillas de clase permiten crear clases genéricas que pueden manejar diferentes tipos de datos.

##### Ejemplo Básico

```cpp
// plantilla_clase.h
#ifndef PLANTILLA_CLASE_H
#define PLANTILLA_CLASE_H

template <typename T>
class MiClase {
public:
    MiClase(T valor);
    void mostrarValor();
private:
    T valor;
};

#include "plantilla_clase.cpp"
#endif // PLANTILLA_CLASE_H
```

```cpp
// plantilla_clase.cpp
#include <iostream>
#include "plantilla_clase.h"

template <typename T>
MiClase<T>::MiClase(T v) : valor(v) {}

template <typename T>
void MiClase<T>::mostrarValor() {
    std::cout << "El valor es: " << valor << std::endl;
}
```

```cpp
// main.cpp
#include "plantilla_clase.h"

int main() {
    MiClase<int> obj1(5);
    obj1.mostrarValor();
    
    MiClase<double> obj2(3.14);
    obj2.mostrarValor();

    return 0;
}
```

En este ejemplo:
- La clase `MiClase` es una plantilla que puede manejar diferentes tipos de datos (`int`, `double`, etc.).
- La palabra clave `template` seguida de `<typename T>` define una plantilla de clase.
- La implementación de los métodos de la plantilla de clase se encuentra en un archivo separado (`plantilla_clase.cpp`), y se incluye al final del archivo de cabecera.

### Buenas Prácticas para el Uso de Plantillas

#### 1. Mantener la Implementación de Plantillas en el Archivo de Cabecera

Aunque se puede separar la declaración y la implementación de plantillas en archivos `.h` y `.cpp` respectivamente, a menudo se recomienda mantener ambas en el archivo de cabecera para evitar problemas de enlace.

##### Ejemplo

```cpp
// MiClase.h
#ifndef MICLASE_H
#define MICLASE_H

#include <iostream>

template <typename T>
class MiClase {
public:
    MiClase(T valor) : valor(valor) {}
    void mostrarValor();
private:
    T valor;
};

template <typename T>
void MiClase<T>::mostrarValor() {
    std::cout << "El valor es: " << valor << std::endl;
}

#endif // MICLASE_H
```

#### 2. Utilizar Nombres Significativos para Parámetros de Tipo

Utilice nombres de parámetros de tipo que sean significativos para mejorar la legibilidad del código.

##### Ejemplo

```cpp
template <typename Tipo>
class Contenedor {
    Tipo elemento;
public:
    Contenedor(Tipo e) : elemento(e) {}
    Tipo obtenerElemento() { return elemento; }
};
```

#### 3. Documentar las Plantillas Adecuadamente

Asegúrese de documentar las plantillas para explicar el propósito de los parámetros de tipo y cómo se deben utilizar.

##### Ejemplo

```cpp
// MiClase.h
#ifndef MICLASE_H
#define MICLASE_H

#include <iostream>

// Clase plantilla que almacena y muestra un valor de cualquier tipo
template <typename T>
class MiClase {
public:
    // Constructor que inicializa el valor
    MiClase(T valor) : valor(valor) {}
    // Muestra el valor almacenado en la salida estándar
    void mostrarValor();
private:
    T valor; // El valor almacenado, de tipo T
};

template <typename T>
void MiClase<T>::mostrarValor() {
    std::cout << "El valor es: " << valor << std::endl;
}

#endif // MICLASE_H
```

### Conclusión

Las plantillas en C++ son una herramienta poderosa para escribir código genérico y reutilizable. Al seguir buenas prácticas como mantener la implementación en el archivo de cabecera, utilizar nombres significativos para los parámetros de tipo y documentar adecuadamente, se puede crear código claro y mantenible. Las plantillas permiten a los desarrolladores escribir funciones y clases que trabajan de manera eficiente con cualquier tipo de dato, mejorando la flexibilidad y reutilización del código.
### Uso de Plantillas en Funciones

Las plantillas de función en C++ permiten crear funciones genéricas que pueden trabajar con diferentes tipos de datos. Esto hace que el código sea más flexible y reutilizable.

#### Definición de Plantillas de Función

Las plantillas de función se definen utilizando la palabra clave `template` seguida de una lista de parámetros de tipo entre corchetes angulares (`< >`). Estos parámetros de tipo actúan como marcadores de posición que se reemplazan con tipos específicos cuando se llama a la función.

##### Ejemplo Básico

```cpp
#include <iostream>

// Definición de la plantilla de función
template <typename T>
T obtenerMayor(T a, T b) {
    return (a > b) ? a : b;
}

int main() {
    std::cout << "Mayor entre 3 y 7: " << obtenerMayor(3, 7) << std::endl; // Uso con int
    std::cout << "Mayor entre 5.5 y 2.2: " << obtenerMayor(5.5, 2.2) << std::endl; // Uso con double
    std::cout << "Mayor entre 'a' y 'z': " << obtenerMayor('a', 'z') << std::endl; // Uso con char
    return 0;
}
```

En este ejemplo:
- La función `obtenerMayor` se define como una plantilla que puede trabajar con cualquier tipo de dato (`int`, `double`, `char`, etc.).
- La palabra clave `template` seguida de `<typename T>` define una plantilla de función donde `T` es un parámetro de tipo.
- La función `obtenerMayor` devuelve el mayor de los dos valores pasados como argumentos.

#### Especialización de Plantillas de Función

En algunos casos, puede ser necesario definir una implementación específica de una plantilla de función para un tipo de dato particular. Esto se conoce como especialización de plantilla.

##### Ejemplo de Especialización

```cpp
#include <iostream>

// Definición de la plantilla de función genérica
template <typename T>
T obtenerMayor(T a, T b) {
    return (a > b) ? a : b;
}

// Especialización para const char*
template <>
const char* obtenerMayor<const char*>(const char* a, const char* b) {
    return (std::strcmp(a, b) > 0) ? a : b;
}

int main() {
    std::cout << "Mayor entre 3 y 7: " << obtenerMayor(3, 7) << std::endl; // Uso con int
    std::cout << "Mayor entre 5.5 y 2.2: " << obtenerMayor(5.5, 2.2) << std::endl; // Uso con double
    std::cout << "Mayor entre \"abc\" y \"xyz\": " << obtenerMayor("abc", "xyz") << std::endl; // Uso con const char*
    return 0;
}
```

En este ejemplo:
- La función `obtenerMayor` se especializa para el tipo `const char*`.
- La especialización utiliza `std::strcmp` para comparar cadenas de caracteres.

#### Plantillas de Función con Múltiples Parámetros de Tipo

Las plantillas de función también pueden tener múltiples parámetros de tipo, lo que permite crear funciones más versátiles.

##### Ejemplo con Múltiples Parámetros de Tipo

```cpp
#include <iostream>

// Definición de la plantilla de función con múltiples parámetros de tipo
template <typename T1, typename T2>
void imprimirAmbos(T1 a, T2 b) {
    std::cout << "Valor 1: " << a << ", Valor 2: " << b << std::endl;
}

int main() {
    imprimirAmbos(3, 4.5); // Uso con int y double
    imprimirAmbos('a', "Hola"); // Uso con char y const char*
    imprimirAmbos(5, std::string("Mundo")); // Uso con int y std::string
    return 0;
}
```

En este ejemplo:
- La función `imprimirAmbos` se define como una plantilla con dos parámetros de tipo (`T1` y `T2`).
- La función puede imprimir valores de diferentes tipos en una sola llamada.

### Buenas Prácticas para el Uso de Plantillas en Funciones

#### 1. Utilizar Nombres Claros y Significativos para los Parámetros de Tipo

Usar nombres de parámetros de tipo que sean claros y significativos ayuda a mejorar la legibilidad del código.

##### Ejemplo

```cpp
template <typename TipoElemento>
TipoElemento obtenerMayor(TipoElemento a, TipoElemento b) {
    return (a > b) ? a : b;
}
```

#### 2. Documentar las Plantillas de Función

Documentar adecuadamente las plantillas de función para explicar el propósito de cada parámetro de tipo y cómo se deben utilizar.

##### Ejemplo

```cpp
// Función plantilla que devuelve el mayor de dos valores de cualquier tipo
// T: tipo de los valores (puede ser int, double, etc.)
template <typename T>
T obtenerMayor(T a, T b) {
    return (a > b) ? a : b;
}
```

#### 3. Probar las Plantillas con Diferentes Tipos

Asegurarse de probar las plantillas de función con diferentes tipos de datos para verificar su funcionamiento y detectar posibles problemas.

##### Ejemplo

```cpp
int main() {
    std::cout << "Mayor entre 3 y 7: " << obtenerMayor(3, 7) << std::endl; // int
    std::cout << "Mayor entre 5.5 y 2.2: " << obtenerMayor(5.5, 2.2) << std::endl; // double
    std::cout << "Mayor entre 'a' y 'z': " << obtenerMayor('a', 'z') << std::endl; // char
    return 0;
}
```

### Conclusión

Las plantillas de función en C++ permiten escribir funciones genéricas que pueden trabajar con diferentes tipos de datos, mejorando la reutilización y flexibilidad del código. Seguir buenas prácticas como utilizar nombres claros para los parámetros de tipo, documentar adecuadamente y probar con diferentes tipos, ayuda a crear código más robusto y mantenible. Las plantillas son una herramienta esencial para cualquier desarrollador de C++ que busca escribir código eficiente y reutilizable.
### Plantillas en Funciones con Múltiples Tipos de Datos

Las plantillas en funciones que aceptan múltiples tipos de datos permiten crear funciones más versátiles y flexibles. Esto se logra definiendo plantillas con varios parámetros de tipo, lo que permite que las funciones trabajen con diferentes combinaciones de tipos de datos.

#### Definición de Plantillas de Función con Múltiples Parámetros de Tipo

Para definir una plantilla de función con múltiples parámetros de tipo, se utiliza la palabra clave `template` seguida de una lista de parámetros de tipo separados por comas.

##### Ejemplo Básico

```cpp
#include <iostream>

// Definición de la plantilla de función con dos parámetros de tipo
template <typename T1, typename T2>
void imprimirAmbos(T1 a, T2 b) {
    std::cout << "Valor 1: " << a << ", Valor 2: " << b << std::endl;
}

int main() {
    imprimirAmbos(3, 4.5); // Uso con int y double
    imprimirAmbos('a', "Hola"); // Uso con char y const char*
    imprimirAmbos(5, std::string("Mundo")); // Uso con int y std::string
    return 0;
}
```

En este ejemplo:
- La función `imprimirAmbos` se define como una plantilla con dos parámetros de tipo (`T1` y `T2`).
- La función imprime dos valores de tipos diferentes en una sola llamada.

#### Plantillas de Función con Parámetros de Tipo y No Tipo

Las plantillas de función también pueden incluir parámetros que no son tipos (por ejemplo, enteros constantes). Esto permite una mayor flexibilidad en la definición de funciones genéricas.

##### Ejemplo

```cpp
#include <iostream>

// Definición de la plantilla de función con un parámetro de tipo y un parámetro no tipo
template <typename T, int N>
void imprimirArray(const T (&arr)[N]) {
    for (int i = 0; i < N; ++i) {
        std::cout << arr[i] << " ";
    }
    std::cout << std::endl;
}

int main() {
    int arr1[] = {1, 2, 3, 4, 5};
    imprimirArray(arr1); // Uso con array de int

    double arr2[] = {1.1, 2.2, 3.3};
    imprimirArray(arr2); // Uso con array de double

    char arr3[] = {'a', 'b', 'c'};
    imprimirArray(arr3); // Uso con array de char

    return 0;
}
```

En este ejemplo:
- La función `imprimirArray` se define como una plantilla con un parámetro de tipo (`T`) y un parámetro no tipo (`int N`).
- El parámetro `N` representa el tamaño del array, lo que permite que la función trabaje con arrays de cualquier tamaño y tipo.

#### Especialización de Plantillas de Función con Múltiples Parámetros de Tipo

Al igual que con plantillas de función simples, es posible especializar plantillas de función con múltiples parámetros de tipo para tipos de datos específicos.

##### Ejemplo de Especialización

```cpp
#include <iostream>
#include <cstring>

// Definición de la plantilla de función genérica
template <typename T1, typename T2>
void comparar(T1 a, T2 b) {
    std::cout << "Comparación genérica: " << (a == b) << std::endl;
}

// Especialización para const char* y const char*
template <>
void comparar<const char*, const char*>(const char* a, const char* b) {
    std::cout << "Comparación de cadenas: " << (std::strcmp(a, b) == 0) << std::endl;
}

int main() {
    comparar(5, 5); // Uso con int
    comparar(3.14, 2.71); // Uso con double
    comparar("Hola", "Hola"); // Uso con const char*

    return 0;
}
```

En este ejemplo:
- La función `comparar` se especializa para comparar cadenas de caracteres (`const char*`).
- La especialización utiliza `std::strcmp` para comparar las cadenas.

### Buenas Prácticas para el Uso de Plantillas con Múltiples Parámetros de Tipo

#### 1. Utilizar Nombres Claros y Significativos para los Parámetros de Tipo

Usar nombres de parámetros de tipo claros y significativos mejora la legibilidad del código.

##### Ejemplo

```cpp
template <typename Tipo1, typename Tipo2>
void imprimirValores(Tipo1 a, Tipo2 b) {
    std::cout << "Valor 1: " << a << ", Valor 2: " << b << std::endl;
}
```

#### 2. Documentar las Plantillas de Función

Documentar adecuadamente las plantillas de función para explicar el propósito de cada parámetro de tipo y cómo se deben utilizar.

##### Ejemplo

```cpp
// Función plantilla que imprime dos valores de cualquier tipo
// Tipo1: tipo del primer valor
// Tipo2: tipo del segundo valor
template <typename Tipo1, typename Tipo2>
void imprimirValores(Tipo1 a, Tipo2 b) {
    std::cout << "Valor 1: " << a << ", Valor 2: " << b << std::endl;
}
```

#### 3. Probar las Plantillas con Diferentes Combinaciones de Tipos

Asegurarse de probar las plantillas de función con diferentes combinaciones de tipos de datos para verificar su funcionamiento y detectar posibles problemas.

##### Ejemplo

```cpp
int main() {
    imprimirValores(3, 4.5); // Uso con int y double
    imprimirValores('a', "Hola"); // Uso con char y const char*
    imprimirValores(5, std::string("Mundo")); // Uso con int y std::string
    return 0;
}
```

### Conclusión

Las plantillas en funciones con múltiples tipos de datos en C++ permiten crear funciones más versátiles y flexibles, capaces de trabajar con diferentes combinaciones de tipos. Seguir buenas prácticas como utilizar nombres claros para los parámetros de tipo, documentar adecuadamente y probar con diferentes combinaciones de tipos, ayuda a crear código más robusto y mantenible. Las plantillas son una herramienta esencial para cualquier desarrollador de C++ que busca escribir código eficiente y reutilizable.
<---FILES--->
Ejemplo Básico
Ejemplo Básico Result
Ejemplo
Ejemplo Result
Ejemplo Básico
Ejemplo Básico Result
Ejemplo
Ejemplo Result
Ejemplo de Especialización
Ejemplo de Especialización Result
Ejemplo con Múltiples Parámetros de Tipo
Ejemplo con Múltiples Parámetros de Tipo Result
Ejemplo Básico
Ejemplo Básico Result
Ejemplo
Ejemplo Result
Ejemplo de Especialización
Ejemplo de Especialización Result
Ejemplo con Múltiples Parámetros de Tipo
Ejemplo con Múltiples Parámetros de Tipo Result
<---Ejemplo Básico--->
```cpp
// plantilla_clase.h
#ifndef PLANTILLA_CLASE_H
#define PLANTILLA_CLASE_H

template <typename T>
class MiClase {
public:
    MiClase(T valor);
    void mostrarValor();
private:
    T valor;
};

#include "plantilla_clase.cpp"
#endif // PLANTILLA_CLASE_H
```cpp
// plantilla_clase.cpp
#include <iostream>
#include "plantilla_clase.h"

template <typename T>
MiClase<T>::MiClase(T v) : valor(v) {}

template <typename T>
void MiClase<T>::mostrarValor() {
    std::cout << "El valor es: " << valor << std::endl;
}
```cpp
// main.cpp
#include "plantilla_clase.h"

int main() {
    MiClase<int> obj1(5);
    obj1.mostrarValor();
    
    MiClase<double> obj2(3.14);
    obj2.mostrarValor();

    return 0;
}
<---Ejemplo Básico Result--->
<---Ejemplo--->
```cpp
// MiClase.h
#ifndef MICLASE_H
#define MICLASE_H

#include <iostream>

// Clase plantilla que almacena y muestra un valor de cualquier tipo
template <typename T>
class MiClase {
public:
    // Constructor que inicializa el valor
    MiClase(T valor) : valor(valor) {}
    // Muestra el valor almacenado en la salida estándar
    void mostrarValor();
private:
    T valor; // El valor almacenado, de tipo T
};

template <typename T>
void MiClase<T>::mostrarValor() {
    std::cout << "El valor es: " << valor << std::endl;
}

#endif // MICLASE_H
<---Ejemplo Result--->
<---Ejemplo Básico--->
```cpp
#include <iostream>

// Definición de la plantilla de función
template <typename T>
T obtenerMayor(T a, T b) {
    return (a > b) ? a : b;
}

int main() {
    std::cout << "Mayor entre 3 y 7: " << obtenerMayor(3, 7) << std::endl; // Uso con int
    std::cout << "Mayor entre 5.5 y 2.2: " << obtenerMayor(5.5, 2.2) << std::endl; // Uso con double
    std::cout << "Mayor entre 'a' y 'z': " << obtenerMayor('a', 'z') << std::endl; // Uso con char
    return 0;
}
<---Ejemplo Básico Result--->
<---Ejemplo--->
```cpp
int main() {
    std::cout << "Mayor entre 3 y 7: " << obtenerMayor(3, 7) << std::endl; // int
    std::cout << "Mayor entre 5.5 y 2.2: " << obtenerMayor(5.5, 2.2) << std::endl; // double
    std::cout << "Mayor entre 'a' y 'z': " << obtenerMayor('a', 'z') << std::endl; // char
    return 0;
}
<---Ejemplo Result--->
<---Ejemplo de Especialización--->
```cpp
#include <iostream>

// Definición de la plantilla de función genérica
template <typename T>
T obtenerMayor(T a, T b) {
    return (a > b) ? a : b;
}

// Especialización para const char*
template <>
const char* obtenerMayor<const char*>(const char* a, const char* b) {
    return (std::strcmp(a, b) > 0) ? a : b;
}

int main() {
    std::cout << "Mayor entre 3 y 7: " << obtenerMayor(3, 7) << std::endl; // Uso con int
    std::cout << "Mayor entre 5.5 y 2.2: " << obtenerMayor(5.5, 2.2) << std::endl; // Uso con double
    std::cout << "Mayor entre \"abc\" y \"xyz\": " << obtenerMayor("abc", "xyz") << std::endl; // Uso con const char*
    return 0;
}
<---Ejemplo de Especialización Result--->
<---Ejemplo con Múltiples Parámetros de Tipo--->
```cpp
#include <iostream>

// Definición de la plantilla de función con múltiples parámetros de tipo
template <typename T1, typename T2>
void imprimirAmbos(T1 a, T2 b) {
    std::cout << "Valor 1: " << a << ", Valor 2: " << b << std::endl;
}

int main() {
    imprimirAmbos(3, 4.5); // Uso con int y double
    imprimirAmbos('a', "Hola"); // Uso con char y const char*
    imprimirAmbos(5, std::string("Mundo")); // Uso con int y std::string
    return 0;
}
<---Ejemplo con Múltiples Parámetros de Tipo Result--->
<---Ejemplo Básico--->
```cpp
#include <iostream>

// Definición de la plantilla de función con dos parámetros de tipo
template <typename T1, typename T2>
void imprimirAmbos(T1 a, T2 b) {
    std::cout << "Valor 1: " << a << ", Valor 2: " << b << std::endl;
}

int main() {
    imprimirAmbos(3, 4.5); // Uso con int y double
    imprimirAmbos('a', "Hola"); // Uso con char y const char*
    imprimirAmbos(5, std::string("Mundo")); // Uso con int y std::string
    return 0;
}
<---Ejemplo Básico Result--->
<---Ejemplo--->
```cpp
int main() {
    imprimirValores(3, 4.5); // Uso con int y double
    imprimirValores('a', "Hola"); // Uso con char y const char*
    imprimirValores(5, std::string("Mundo")); // Uso con int y std::string
    return 0;
}
<---Ejemplo Result--->
<---Ejemplo de Especialización--->
```cpp
#include <iostream>
#include <cstring>

// Definición de la plantilla de función genérica
template <typename T1, typename T2>
void comparar(T1 a, T2 b) {
    std::cout << "Comparación genérica: " << (a == b) << std::endl;
}

// Especialización para const char* y const char*
template <>
void comparar<const char*, const char*>(const char* a, const char* b) {
    std::cout << "Comparación de cadenas: " << (std::strcmp(a, b) == 0) << std::endl;
}

int main() {
    comparar(5, 5); // Uso con int
    comparar(3.14, 2.71); // Uso con double
    comparar("Hola", "Hola"); // Uso con const char*

    return 0;
}
<---Ejemplo de Especialización Result--->
<---Ejemplo con Múltiples Parámetros de Tipo--->
```cpp
#include <iostream>

// Definición de la plantilla de función con múltiples parámetros de tipo
template <typename T1, typename T2>
void imprimirAmbos(T1 a, T2 b) {
    std::cout << "Valor 1: " << a << ", Valor 2: " << b << std::endl;
}

int main() {
    imprimirAmbos(3, 4.5); // Uso con int y double
    imprimirAmbos('a', "Hola"); // Uso con char y const char*
    imprimirAmbos(5, std::string("Mundo")); // Uso con int y std::string
    return 0;
}
<---Ejemplo con Múltiples Parámetros de Tipo Result--->
