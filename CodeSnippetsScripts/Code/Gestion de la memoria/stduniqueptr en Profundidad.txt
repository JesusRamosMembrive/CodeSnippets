<---EXPLANATION--->
### Gestión de Memoria en C++

La gestión de memoria en C++ es un aspecto fundamental que todo desarrollador debe entender profundamente para evitar errores comunes como fugas de memoria y accesos inválidos. A diferencia de lenguajes de programación que manejan la memoria automáticamente, C++ permite y requiere que el programador gestione la asignación y liberación de memoria.

#### Tipos de Memoria en C++

En C++, la memoria se puede clasificar en dos tipos principales: memoria estática y memoria dinámica.

1. **Memoria Estática**: Se asigna en el tiempo de compilación. Incluye variables globales, variables estáticas y constantes.
2. **Memoria Dinámica**: Se asigna en el tiempo de ejecución usando operadores como `new` y `delete`.

#### Asignación y Liberación de Memoria

##### Memoria Estática

La memoria estática se gestiona automáticamente. Por ejemplo:

```cpp
#include <iostream>

int globalVariable = 10; // Variable global (memoria estática)

int main() {
    static int staticVariable = 20; // Variable estática local (memoria estática)
    return 0;
}
```

##### Memoria Dinámica

La memoria dinámica se asigna y libera manualmente usando `new` y `delete` para variables simples, y `new[]` y `delete[]` para arreglos.

##### Ejemplo Básico de Asignación Dinámica

```cpp
#include <iostream>

int main() {
    int* ptr = new int; // Asignar memoria para un entero
    *ptr = 100; // Usar la memoria asignada
    std::cout << *ptr << std::endl; // Salida: 100
    delete ptr; // Liberar la memoria

    return 0;
}
```

##### Ejemplo de Arreglo Dinámico

```cpp
#include <iostream>

int main() {
    int size = 5;
    int* array = new int[size]; // Asignar memoria para un arreglo de enteros

    for(int i = 0; i < size; ++i) {
        array[i] = i * 10; // Inicializar el arreglo
    }

    for(int i = 0; i < size; ++i) {
        std::cout << array[i] << " "; // Salida: 0 10 20 30 40
    }
    std::cout << std::endl;

    delete[] array; // Liberar la memoria

    return 0;
}
```

### Buenas Prácticas para la Gestión de Memoria

#### 1. Siempre Liberar la Memoria Asignada

No liberar la memoria asignada dinámicamente resulta en fugas de memoria, lo que puede llevar a que una aplicación consuma más memoria de la necesaria y eventualmente falle.

##### Ejemplo Incorrecto

```cpp
int* ptr = new int; // Asignar memoria
// ... uso de ptr
// Olvidar liberar la memoria: fuga de memoria
```

##### Ejemplo Correcto

```cpp
int* ptr = new int; // Asignar memoria
// ... uso de ptr
delete ptr; // Liberar memoria
```

#### 2. Usar Smart Pointers

Los punteros inteligentes (`smart pointers`) en la biblioteca estándar de C++ (`std::unique_ptr`, `std::shared_ptr`, etc.) ayudan a manejar la memoria de manera automática y evitar fugas de memoria.

##### Ejemplo con `std::unique_ptr`

```cpp
#include <iostream>
#include <memory>

int main() {
    std::unique_ptr<int> ptr = std::make_unique<int>(100); // Asignar memoria
    std::cout << *ptr << std::endl; // Salida: 100
    // Memoria se libera automáticamente cuando ptr sale del alcance

    return 0;
}
```

#### 3. Evitar Accesos Inválidos a Memoria

Acceder a memoria después de haberla liberado resulta en comportamiento indefinido. Siempre asegúrese de no usar punteros después de haber llamado a `delete`.

##### Ejemplo Incorrecto

```cpp
int* ptr = new int(10);
delete ptr; // Liberar memoria
std::cout << *ptr << std::endl; // Acceso inválido: comportamiento indefinido
```

##### Ejemplo Correcto

```cpp
int* ptr = new int(10);
delete ptr; // Liberar memoria
ptr = nullptr; // Evitar acceso inválido
```

### Gestión de Memoria en Clases

Cuando se diseñan clases que manejan recursos dinámicos, es esencial implementar correctamente el constructor de copia, el operador de asignación y el destructor.

#### Ejemplo: Clase con Gestión de Memoria

```cpp
#include <iostream>
#include <cstring>

class String {
private:
    char* data;
    size_t size;

public:
    String(const char* str) {
        size = strlen(str);
        data = new char[size + 1];
        strcpy(data, str);
    }

    ~String() {
        delete[] data;
    }

    // Constructor de copia
    String(const String& other) {
        size = other.size;
        data = new char[size + 1];
        strcpy(data, other.data);
    }

    // Operador de asignación
    String& operator=(const String& other) {
        if (this == &other) return *this;

        delete[] data;

        size = other.size;
        data = new char[size + 1];
        strcpy(data, other.data);
        return *this;
    }

    void print() const {
        std::cout << data << std::endl;
    }
};

int main() {
    String str1("Hello");
    String str2 = str1; // Constructor de copia
    String str3("World");
    str3 = str1; // Operador de asignación
    str1.print(); // Salida: Hello
    str2.print(); // Salida: Hello
    str3.print(); // Salida: Hello

    return 0;
}
```

### Conclusión

La gestión de memoria en C++ es un tema crítico que requiere atención cuidadosa para evitar errores como fugas de memoria y accesos inválidos. El uso de buenas prácticas como liberar memoria correctamente, usar punteros inteligentes y manejar adecuadamente la memoria en clases asegura que las aplicaciones sean eficientes y robustas. Al entender y aplicar estos conceptos, los desarrolladores pueden escribir código más seguro y mantenible.
### Punteros en C++

Los punteros son una característica fundamental en C++ que permite a los desarrolladores manipular la memoria directamente. Un puntero es una variable que almacena la dirección de memoria de otra variable. Comprender cómo funcionan los punteros es crucial para gestionar la memoria dinámica, realizar operaciones avanzadas y optimizar el rendimiento del código.

#### Declaración y Uso de Punteros

##### Declaración de Punteros

La sintaxis básica para declarar un puntero es:

```cpp
int* ptr; // Declara un puntero a un entero
```

##### Asignación y Acceso a Datos

Para asignar una dirección a un puntero y acceder a los datos apuntados, se utilizan los operadores `&` (referencia) y `*` (desreferencia).

```cpp
int var = 10;
int* ptr = &var; // ptr apunta a la dirección de var

std::cout << "Valor de var: " << var << std::endl; // Salida: 10
std::cout << "Dirección de var: " << &var << std::endl; // Dirección de var
std::cout << "Valor apuntado por ptr: " << *ptr << std::endl; // Salida: 10
```

### Operaciones con Punteros

#### Punteros y Arreglos

Los punteros y arreglos están estrechamente relacionados en C++. El nombre de un arreglo es un puntero constante al primer elemento del arreglo.

```cpp
int arr[5] = {1, 2, 3, 4, 5};
int* ptr = arr; // ptr apunta al primer elemento del arreglo

for(int i = 0; i < 5; ++i) {
    std::cout << *(ptr + i) << " "; // Acceder a los elementos del arreglo usando punteros
}
// Salida: 1 2 3 4 5
```

#### Aritmética de Punteros

La aritmética de punteros permite realizar operaciones como suma y resta sobre punteros para navegar por arreglos y estructuras de datos.

```cpp
int arr[5] = {1, 2, 3, 4, 5};
int* ptr = arr;

std::cout << "Primer elemento: " << *ptr << std::endl; // Salida: 1
ptr++;
std::cout << "Segundo elemento: " << *ptr << std::endl; // Salida: 2
```

#### Punteros a Punteros

Un puntero a puntero es una variable que almacena la dirección de otro puntero.

```cpp
int var = 10;
int* ptr = &var;
int** ptr2 = &ptr;

std::cout << "Valor de var: " << var << std::endl; // Salida: 10
std::cout << "Valor apuntado por ptr: " << *ptr << std::endl; // Salida: 10
std::cout << "Valor apuntado por ptr2: " << **ptr2 << std::endl; // Salida: 10
```

### Buenas Prácticas con Punteros

#### Inicializar Punteros

Siempre inicialice los punteros, ya sea asignándoles una dirección válida o estableciéndolos a `nullptr`.

```cpp
int* ptr = nullptr; // Puntero inicializado a nullptr
```

#### Liberar Memoria

Cuando se utiliza memoria dinámica, es crucial liberar la memoria usando `delete` o `delete[]` para evitar fugas de memoria.

```cpp
int* ptr = new int(10);
delete ptr; // Liberar memoria asignada
ptr = nullptr; // Evitar acceso a memoria liberada
```

#### Evitar Punteros Colgantes

Un puntero colgante apunta a una memoria que ha sido liberada. Asignar `nullptr` a los punteros después de liberar la memoria ayuda a evitar este problema.

```cpp
int* ptr = new int(10);
delete ptr;
ptr = nullptr; // Ahora ptr no es un puntero colgante
```

### Ejemplos Avanzados

#### Punteros y Funciones

Los punteros pueden pasarse a funciones para modificar variables fuera del ámbito de la función.

##### Paso por Referencia usando Punteros

```cpp
#include <iostream>

void incrementar(int* ptr) {
    (*ptr)++;
}

int main() {
    int var = 10;
    incrementar(&var);
    std::cout << "Valor de var después de incrementar: " << var << std::endl; // Salida: 11

    return 0;
}
```

#### Punteros a Funciones

Los punteros a funciones permiten almacenar y llamar funciones dinámicamente.

##### Ejemplo de Puntero a Función

```cpp
#include <iostream>

void saludo() {
    std::cout << "Hola, Mundo!" << std::endl;
}

void llamarFuncion(void (*func)()) {
    func();
}

int main() {
    void (*ptrFunc)() = &saludo;
    llamarFuncion(ptrFunc); // Salida: Hola, Mundo!

    return 0;
}
```

### Conclusión

Los punteros en C++ son una herramienta poderosa que permite un control fino sobre la memoria y la gestión de recursos. Sin embargo, también requieren una comprensión cuidadosa y atención a los detalles para evitar errores comunes como fugas de memoria, punteros colgantes y accesos inválidos. Con una buena práctica y el uso de punteros inteligentes, se puede escribir código eficiente y seguro que aproveche al máximo las capacidades del lenguaje C++.
### Referencias en C++

Las referencias son una característica poderosa y segura de C++ que permite crear alias para las variables. A diferencia de los punteros, las referencias no pueden ser nulas y deben ser inicializadas cuando se declaran. Las referencias simplifican la sintaxis y hacen el código más legible, especialmente cuando se pasan parámetros a funciones.

#### Declaración y Uso de Referencias

##### Declaración Básica

Para declarar una referencia, se utiliza el operador `&` seguido del nombre de la referencia.

```cpp
int var = 10;
int& ref = var; // ref es una referencia a var

std::cout << "var: " << var << std::endl; // Salida: 10
std::cout << "ref: " << ref << std::endl; // Salida: 10
```

##### Modificación a través de Referencias

Las referencias pueden ser utilizadas para modificar la variable original a la que hacen referencia.

```cpp
int var = 10;
int& ref = var;

ref = 20; // Modifica var a través de ref

std::cout << "var: " << var << std::endl; // Salida: 20
std::cout << "ref: " << ref << std::endl; // Salida: 20
```

### Referencias y Funciones

Las referencias son especialmente útiles para pasar parámetros a funciones sin hacer copias de los mismos, lo que mejora el rendimiento.

#### Paso por Referencia

Pasar parámetros por referencia permite modificar los argumentos originales dentro de la función.

##### Ejemplo de Paso por Referencia

```cpp
#include <iostream>

void incrementar(int& ref) {
    ref++;
}

int main() {
    int var = 10;
    incrementar(var);
    std::cout << "Valor de var después de incrementar: " << var << std::endl; // Salida: 11

    return 0;
}
```

#### Referencias Constantes

Las referencias constantes permiten pasar parámetros a funciones sin permitir la modificación de los mismos dentro de la función. Esto es útil para optimizar el rendimiento y garantizar la inmutabilidad de los datos.

##### Ejemplo de Referencia Constante

```cpp
#include <iostream>

void mostrar(const int& ref) {
    std::cout << "Valor: " << ref << std::endl;
}

int main() {
    int var = 10;
    mostrar(var); // Salida: 10

    return 0;
}
```

### Referencias en Clases

Las referencias también se utilizan ampliamente en clases para implementar constructores de copia, operadores de asignación y otros métodos.

#### Constructor de Copia

Un constructor de copia utiliza referencias para evitar la creación de copias innecesarias de objetos.

##### Ejemplo de Constructor de Copia

```cpp
#include <iostream>

class MiClase {
private:
    int valor;

public:
    MiClase(int v) : valor(v) {}
    
    // Constructor de copia
    MiClase(const MiClase& otra) : valor(otra.valor) {
        std::cout << "Constructor de copia llamado" << std::endl;
    }

    int obtenerValor() const { return valor; }
};

int main() {
    MiClase obj1(10);
    MiClase obj2 = obj1; // Llama al constructor de copia

    std::cout << "Valor de obj1: " << obj1.obtenerValor() << std::endl; // Salida: 10
    std::cout << "Valor de obj2: " << obj2.obtenerValor() << std::endl; // Salida: 10

    return 0;
}
```

#### Operador de Asignación

El operador de asignación también se implementa usando referencias para evitar copias innecesarias y gestionar la asignación de recursos correctamente.

##### Ejemplo de Operador de Asignación

```cpp
#include <iostream>

class MiClase {
private:
    int valor;

public:
    MiClase(int v) : valor(v) {}
    
    // Operador de asignación
    MiClase& operator=(const MiClase& otra) {
        if (this != &otra) {
            valor = otra.valor;
        }
        return *this;
    }

    int obtenerValor() const { return valor; }
};

int main() {
    MiClase obj1(10);
    MiClase obj2(20);
    obj2 = obj1; // Llama al operador de asignación

    std::cout << "Valor de obj1: " << obj1.obtenerValor() << std::endl; // Salida: 10
    std::cout << "Valor de obj2: " << obj2.obtenerValor() << std::endl; // Salida: 10

    return 0;
}
```

### Buenas Prácticas con Referencias

#### Evitar Referencias Dangling

Las referencias dangling (colgantes) ocurren cuando una referencia apunta a una variable que ha sido destruida o liberada. Siempre asegúrese de que la vida útil del objeto referenciado sea mayor que la de la referencia.

##### Ejemplo de Referencia Dangling (a Evitar)

```cpp
int& funcion() {
    int var = 10;
    return var; // var se destruye al salir de la función
}

int main() {
    int& ref = funcion(); // ref ahora es una referencia dangling
    std::cout << ref << std::endl; // Comportamiento indefinido

    return 0;
}
```

#### Uso de Const en Referencias

Utilice `const` siempre que sea posible para evitar modificaciones accidentales y mejorar la seguridad del código.

```cpp
void mostrar(const int& ref) {
    std::cout << "Valor: " << ref << std::endl;
}
```

### Conclusión

Las referencias en C++ son una herramienta esencial para la manipulación eficiente y segura de variables. Permiten pasar argumentos a funciones sin hacer copias, lo que mejora el rendimiento, y garantizan la inmutabilidad cuando se usan con `const`. Al seguir buenas prácticas y evitar referencias colgantes, se puede escribir código más limpio, seguro y eficiente.
### Gestión Dinámica de la Memoria en C++

La gestión dinámica de la memoria en C++ permite a los desarrolladores asignar y liberar memoria en tiempo de ejecución. Esto es esencial para manejar estructuras de datos cuyo tamaño no puede determinarse en tiempo de compilación y para optimizar el uso de la memoria. Sin embargo, también implica la responsabilidad de liberar la memoria asignada para evitar fugas de memoria y otros errores.

#### Operadores `new` y `delete`

##### Asignación de Memoria

El operador `new` se utiliza para asignar memoria dinámica para un solo objeto o un arreglo de objetos. Devuelve un puntero al tipo especificado.

```cpp
int* ptr = new int; // Asignar memoria para un entero
*ptr = 10;
std::cout << *ptr << std::endl; // Salida: 10

delete ptr; // Liberar la memoria asignada
```

##### Asignación de Memoria para Arreglos

Para asignar memoria para un arreglo, se utiliza `new[]` y para liberarla, `delete[]`.

```cpp
int size = 5;
int* arr = new int[size]; // Asignar memoria para un arreglo de enteros

for(int i = 0; i < size; ++i) {
    arr[i] = i * 10;
}

for(int i = 0; i < size; ++i) {
    std::cout << arr[i] << " "; // Salida: 0 10 20 30 40
}
std::cout << std::endl;

delete[] arr; // Liberar la memoria asignada para el arreglo
```

#### Gestión de Memoria en Clases

Cuando se manejan recursos dinámicos en clases, es crucial implementar correctamente el constructor, destructor, constructor de copia y operador de asignación para gestionar la memoria de manera adecuada.

##### Ejemplo: Clase con Gestión de Memoria Dinámica

```cpp
#include <iostream>

class MiClase {
private:
    int* data;
    size_t size;

public:
    // Constructor
    MiClase(size_t s) : size(s) {
        data = new int[size];
        for(size_t i = 0; i < size; ++i) {
            data[i] = i * 10;
        }
    }

    // Destructor
    ~MiClase() {
        delete[] data;
    }

    // Constructor de copia
    MiClase(const MiClase& other) : size(other.size) {
        data = new int[size];
        std::copy(other.data, other.data + size, data);
    }

    // Operador de asignación
    MiClase& operator=(const MiClase& other) {
        if (this == &other) return *this;

        delete[] data;

        size = other.size;
        data = new int[size];
        std::copy(other.data, other.data + size, data);

        return *this;
    }

    void print() const {
        for(size_t i = 0; i < size; ++i) {
            std::cout << data[i] << " ";
        }
        std::cout << std::endl;
    }
};

int main() {
    MiClase obj1(5);
    obj1.print(); // Salida: 0 10 20 30 40

    MiClase obj2 = obj1; // Constructor de copia
    obj2.print(); // Salida: 0 10 20 30 40

    MiClase obj3(3);
    obj3 = obj1; // Operador de asignación
    obj3.print(); // Salida: 0 10 20 30 40

    return 0;
}
```

### Smart Pointers

C++11 introdujo los punteros inteligentes (`smart pointers`) en la biblioteca estándar (`<memory>`) para ayudar a gestionar la memoria de manera automática y segura. Los tres tipos principales son `std::unique_ptr`, `std::shared_ptr` y `std::weak_ptr`.

#### `std::unique_ptr`

Un `std::unique_ptr` es un puntero exclusivo que posee la memoria a la que apunta y no puede compartirla con otro puntero. Cuando el `unique_ptr` sale de alcance, la memoria se libera automáticamente.

##### Ejemplo con `std::unique_ptr`

```cpp
#include <iostream>
#include <memory>

int main() {
    std::unique_ptr<int> ptr = std::make_unique<int>(10);
    std::cout << *ptr << std::endl; // Salida: 10

    return 0;
}
```

#### `std::shared_ptr`

Un `std::shared_ptr` permite compartir la propiedad de la memoria con múltiples punteros. La memoria se libera cuando el último `shared_ptr` que la posee es destruido.

##### Ejemplo con `std::shared_ptr`

```cpp
#include <iostream>
#include <memory>

int main() {
    std::shared_ptr<int> ptr1 = std::make_shared<int>(20);
    std::shared_ptr<int> ptr2 = ptr1;

    std::cout << *ptr1 << std::endl; // Salida: 20
    std::cout << *ptr2 << std::endl; // Salida: 20

    return 0;
}
```

#### `std::weak_ptr`

Un `std::weak_ptr` es un puntero no propietario que se utiliza junto con `std::shared_ptr` para evitar ciclos de referencia. No afecta la vida útil de la memoria a la que apunta.

##### Ejemplo con `std::weak_ptr`

```cpp
#include <iostream>
#include <memory>

int main() {
    std::shared_ptr<int> sptr = std::make_shared<int>(30);
    std::weak_ptr<int> wptr = sptr;

    std::cout << "Use count: " << sptr.use_count() << std::endl; // Salida: 1

    if (auto spt = wptr.lock()) {
        std::cout << *spt << std::endl; // Salida: 30
    } else {
        std::cout << "wptr is expired" << std::endl;
    }

    return 0;
}
```

### Buenas Prácticas para la Gestión Dinámica de la Memoria

#### 1. Siempre Liberar la Memoria Asignada

Evitar fugas de memoria asegurando que toda la memoria asignada dinámicamente se libera adecuadamente.

```cpp
int* ptr = new int(10);
// ...
delete ptr; // Liberar la memoria
```

#### 2. Usar Smart Pointers

Preferir el uso de punteros inteligentes sobre los punteros crudos para evitar problemas de gestión de memoria.

```cpp
std::unique_ptr<int> ptr = std::make_unique<int>(10);
```

#### 3. Evitar Accesos Inválidos

Asegurarse de no acceder a memoria después de haberla liberado. Asignar `nullptr` a los punteros después de `delete` puede ayudar.

```cpp
int* ptr = new int(10);
delete ptr;
ptr = nullptr; // Evitar acceso a memoria liberada
```

#### 4. Usar RAII (Resource Acquisition Is Initialization)

Utilizar el principio RAII para gestionar recursos, asegurando que la adquisición de un recurso se produce en el constructor y su liberación en el destructor.

```cpp
class Recurso {
public:
    Recurso() { /* adquirir recurso */ }
    ~Recurso() { /* liberar recurso */ }
};
```

### Conclusión

La gestión dinámica de la memoria en C++ proporciona flexibilidad y control, pero también implica la responsabilidad de manejar adecuadamente la asignación y liberación de memoria. El uso de punteros inteligentes y buenas prácticas de programación ayudan a prevenir errores comunes y aseguran que los recursos se gestionen de manera eficiente y segura. Al dominar estas técnicas, los desarrolladores pueden escribir código más robusto y mantenible.
### Punteros Inteligentes en C++

Los punteros inteligentes en C++ son una característica introducida en C++11 que ayuda a gestionar la memoria automáticamente y prevenir fugas de memoria y errores comunes como los punteros colgantes. Los punteros inteligentes son clases de la biblioteca estándar que administran la vida útil de los objetos a los que apuntan. Los tres tipos principales de punteros inteligentes son `std::unique_ptr`, `std::shared_ptr` y `std::weak_ptr`.

#### `std::unique_ptr`

Un `std::unique_ptr` es un puntero inteligente que posee de manera exclusiva la memoria a la que apunta. No puede haber dos `std::unique_ptr` que posean el mismo recurso simultáneamente.

##### Características:
- Exclusividad: No puede haber copias de un `std::unique_ptr`.
- Liberación automática: La memoria se libera automáticamente cuando el `std::unique_ptr` sale de su ámbito.

##### Ejemplo de Uso de `std::unique_ptr`

```cpp
#include <iostream>
#include <memory>

int main() {
    std::unique_ptr<int> ptr = std::make_unique<int>(10); // Asignación de memoria
    std::cout << *ptr << std::endl; // Salida: 10

    // ptr2 = ptr; // Error: no se permite la copia de std::unique_ptr

    std::unique_ptr<int> ptr2 = std::move(ptr); // Transferencia de propiedad
    std::cout << *ptr2 << std::endl; // Salida: 10

    // La memoria se libera automáticamente al salir de ámbito
    return 0;
}
```

#### `std::shared_ptr`

Un `std::shared_ptr` permite compartir la propiedad de la memoria con múltiples punteros. La memoria se libera cuando el último `std::shared_ptr` que posee la memoria se destruye.

##### Características:
- Compartición: Múltiples `std::shared_ptr` pueden apuntar al mismo recurso.
- Contador de referencias: Lleva un conteo de cuántos `std::shared_ptr` están apuntando al recurso.

##### Ejemplo de Uso de `std::shared_ptr`

```cpp
#include <iostream>
#include <memory>

int main() {
    std::shared_ptr<int> ptr1 = std::make_shared<int>(20); // Asignación de memoria
    std::shared_ptr<int> ptr2 = ptr1; // Compartir la propiedad

    std::cout << *ptr1 << std::endl; // Salida: 20
    std::cout << *ptr2 << std::endl; // Salida: 20
    std::cout << "Use count: " << ptr1.use_count() << std::endl; // Salida: 2

    // La memoria se libera automáticamente cuando el último shared_ptr se destruye
    return 0;
}
```

#### `std::weak_ptr`

Un `std::weak_ptr` es un puntero inteligente no propietario que se utiliza junto con `std::shared_ptr` para evitar ciclos de referencia. No afecta el conteo de referencias del `std::shared_ptr`.

##### Características:
- No propietario: No incrementa el contador de referencias.
- Utilizado para evitar ciclos de referencia: Permite la comprobación segura de si el recurso aún existe.

##### Ejemplo de Uso de `std::weak_ptr`

```cpp
#include <iostream>
#include <memory>

int main() {
    std::shared_ptr<int> sptr = std::make_shared<int>(30);
    std::weak_ptr<int> wptr = sptr; // No incrementa el contador de referencias

    std::cout << "Use count: " << sptr.use_count() << std::endl; // Salida: 1

    if (auto spt = wptr.lock()) { // Comprobar si el recurso aún existe
        std::cout << *spt << std::endl; // Salida: 30
    } else {
        std::cout << "wptr is expired" << std::endl;
    }

    return 0;
}
```

### Buenas Prácticas con Punteros Inteligentes

#### 1. Preferir `std::unique_ptr` por Defecto

Utilice `std::unique_ptr` cuando no necesite compartir la propiedad del recurso. Esto asegura que la propiedad sea clara y evita problemas de gestión de memoria.

```cpp
std::unique_ptr<int> ptr = std::make_unique<int>(10);
```

#### 2. Usar `std::shared_ptr` para Propiedad Compartida

Utilice `std::shared_ptr` cuando necesite compartir la propiedad del recurso entre múltiples partes del código.

```cpp
std::shared_ptr<int> ptr1 = std::make_shared<int>(20);
std::shared_ptr<int> ptr2 = ptr1;
```

#### 3. Evitar Ciclos de Referencia con `std::weak_ptr`

Utilice `std::weak_ptr` junto con `std::shared_ptr` para evitar ciclos de referencia que pueden causar fugas de memoria.

```cpp
class Nodo {
public:
    std::shared_ptr<Nodo> siguiente;
    std::weak_ptr<Nodo> anterior; // Evitar ciclo de referencia
};
```

#### 4. Evitar el Uso de Punteros Crudos

Prefiera los punteros inteligentes sobre los punteros crudos para gestionar automáticamente la vida útil de los recursos y evitar errores comunes.

### Conclusión

Los punteros inteligentes en C++ proporcionan una forma segura y eficiente de gestionar la memoria dinámica. Al utilizar `std::unique_ptr`, `std::shared_ptr` y `std::weak_ptr`, los desarrolladores pueden prevenir fugas de memoria y errores de acceso a memoria, mejorando la robustez y mantenibilidad del código. Siguiendo buenas prácticas y eligiendo el tipo de puntero inteligente adecuado para cada situación, se puede aprovechar al máximo esta poderosa característica del lenguaje.
### `std::unique_ptr` en Profundidad

`std::unique_ptr` es un puntero inteligente que proporciona propiedad exclusiva sobre un recurso. Es una herramienta poderosa para gestionar la memoria dinámica y asegurar que los recursos sean liberados correctamente cuando ya no se necesiten. Aquí profundizaremos en su uso, las mejores prácticas y cómo integrarlo en proyectos más grandes.

#### Declaraciones y Uso Básico

##### Declaración y Asignación

Para declarar un `std::unique_ptr`, se incluye la cabecera `<memory>` y se puede utilizar `std::make_unique` para asignar memoria.

```cpp
#include <iostream>
#include <memory>

int main() {
    std::unique_ptr<int> ptr = std::make_unique<int>(10);
    std::cout << *ptr << std::endl; // Salida: 10
    // Memoria liberada automáticamente al salir del alcance
    return 0;
}
```

#### En Clases y Archivos de Cabecera

El uso de `std::unique_ptr` en clases permite una gestión de recursos clara y segura. Aquí se muestra cómo declarar y definir una clase que utiliza `std::unique_ptr`.

##### Declaración en el Archivo de Cabecera (.h)

```cpp
// MiClase.h
#ifndef MICLASE_H
#define MICLASE_H

#include <memory>
#include <string>

class MiClase {
public:
    MiClase(const std::string& nombre);
    ~MiClase();

    void mostrar() const;

private:
    std::unique_ptr<std::string> nombre_;
};

#endif // MICLASE_H
```

##### Definición en el Archivo de Implementación (.cpp)

```cpp
// MiClase.cpp
#include "MiClase.h"
#include <iostream>

// Constructor
MiClase::MiClase(const std::string& nombre)
    : nombre_(std::make_unique<std::string>(nombre)) {}

// Destructor
MiClase::~MiClase() {
    // `std::unique_ptr` libera la memoria automáticamente
}

// Método mostrar
void MiClase::mostrar() const {
    std::cout << "Nombre: " << *nombre_ << std::endl;
}
```

#### Transferencia de Propiedad

La propiedad de un `std::unique_ptr` puede transferirse utilizando `std::move`. Esto es útil cuando se necesita transferir la propiedad de un recurso a otra función o objeto.

##### Ejemplo de Transferencia de Propiedad

```cpp
#include <iostream>
#include <memory>

void mostrar(std::unique_ptr<int> ptr) {
    std::cout << *ptr << std::endl;
}

int main() {
    std::unique_ptr<int> ptr = std::make_unique<int>(42);
    mostrar(std::move(ptr)); // Transferir la propiedad
    // ptr ya no es válido aquí
    return 0;
}
```

#### Mejor Uso de `std::unique_ptr`

##### 1. Encapsulación de Recursos

Utilice `std::unique_ptr` para encapsular recursos en clases. Esto asegura que los recursos sean liberados correctamente cuando la instancia de la clase es destruida.

```cpp
class Archivo {
public:
    Archivo(const std::string& nombre) : archivo_(std::fopen(nombre.c_str(), "r")) {
        if (!archivo_) {
            throw std::runtime_error("No se pudo abrir el archivo");
        }
    }

    ~Archivo() {
        if (archivo_) {
            std::fclose(archivo_);
        }
    }

private:
    std::unique_ptr<FILE, decltype(&std::fclose)> archivo_;
};
```

##### 2. Uso en Contenedores

Los contenedores de la STL pueden almacenar `std::unique_ptr`, lo que permite una gestión eficiente de colecciones de recursos dinámicos.

```cpp
#include <vector>
#include <memory>

int main() {
    std::vector<std::unique_ptr<int>> vec;
    vec.push_back(std::make_unique<int>(1));
    vec.push_back(std::make_unique<int>(2));
    vec.push_back(std::make_unique<int>(3));

    for (const auto& ptr : vec) {
        std::cout << *ptr << std::endl;
    }
    return 0;
}
```

##### 3. Evitar el Uso de Punteros Crudos

Prefiera `std::unique_ptr` sobre los punteros crudos para garantizar la gestión automática de la memoria y reducir el riesgo de fugas de memoria y accesos inválidos.

#### Ejemplo Completo

A continuación, se muestra un ejemplo más completo que incluye la declaración y el uso de `std::unique_ptr` en una clase, mostrando la gestión de recursos y la transferencia de propiedad.

##### Archivo de Cabecera (.h)

```cpp
// GestorRecurso.h
#ifndef GESTORRECURSO_H
#define GESTORRECURSO_H

#include <memory>
#include <string>

class GestorRecurso {
public:
    GestorRecurso(const std::string& nombre);
    void mostrarRecurso() const;

    // Transferir la propiedad del recurso
    std::unique_ptr<std::string> transferirRecurso();

private:
    std::unique_ptr<std::string> recurso_;
};

#endif // GESTORRECURSO_H
```

##### Archivo de Implementación (.cpp)

```cpp
// GestorRecurso.cpp
#include "GestorRecurso.h"
#include <iostream>

GestorRecurso::GestorRecurso(const std::string& nombre)
    : recurso_(std::make_unique<std::string>(nombre)) {}

void GestorRecurso::mostrarRecurso() const {
    std::cout << "Recurso: " << *recurso_ << std::endl;
}

std::unique_ptr<std::string> GestorRecurso::transferirRecurso() {
    return std::move(recurso_);
}
```

##### Función Principal

```cpp
#include <iostream>
#include "GestorRecurso.h"

int main() {
    GestorRecurso gestor("MiRecurso");
    gestor.mostrarRecurso();

    std::unique_ptr<std::string> recurso = gestor.transferirRecurso();
    if (recurso) {
        std::cout << "Recurso transferido: " << *recurso << std::endl;
    }

    // Intentar mostrar el recurso después de la transferencia
    gestor.mostrarRecurso(); // Esto no imprimirá nada ya que el recurso fue transferido

    return 0;
}
```

### Conclusión

`std::unique_ptr` es una herramienta esencial en C++ para la gestión segura y eficiente de recursos. Su uso adecuado en clases, funciones y contenedores permite evitar muchos errores comunes relacionados con la gestión de memoria, como fugas de memoria y accesos a memoria inválida. Al seguir las mejores prácticas y entender cómo transferir la propiedad de recursos, se puede escribir código más robusto y mantenible.
<---FILES--->
Memoria Estática
Memoria Estática Result
Memoria Dinámica
Memoria Dinámica Result
Ejemplo Básico de Asignación Dinámica
Ejemplo Básico de Asignación Dinámica Result
Ejemplo de Arreglo Dinámico
Ejemplo de Arreglo Dinámico Result
Ejemplo Incorrecto
Ejemplo Incorrecto Result
Ejemplo Correcto
Ejemplo Correcto Result
Ejemplo con `std::unique_ptr`
Ejemplo con `std::unique_ptr` Result
Memoria Estática
Memoria Estática Result
Memoria Dinámica
Memoria Dinámica Result
Ejemplo Básico de Asignación Dinámica
Ejemplo Básico de Asignación Dinámica Result
Ejemplo de Arreglo Dinámico
Ejemplo de Arreglo Dinámico Result
Ejemplo Incorrecto
Ejemplo Incorrecto Result
Ejemplo Correcto
Ejemplo Correcto Result
Ejemplo con `std::unique_ptr`
Ejemplo con `std::unique_ptr` Result
Declaración de Punteros
Declaración de Punteros Result
Asignación y Acceso a Datos
Asignación y Acceso a Datos Result
Paso por Referencia usando Punteros
Paso por Referencia usando Punteros Result
Ejemplo de Puntero a Función
Ejemplo de Puntero a Función Result
Memoria Estática
Memoria Estática Result
Memoria Dinámica
Memoria Dinámica Result
Ejemplo Básico de Asignación Dinámica
Ejemplo Básico de Asignación Dinámica Result
Ejemplo de Arreglo Dinámico
Ejemplo de Arreglo Dinámico Result
Ejemplo Incorrecto
Ejemplo Incorrecto Result
Ejemplo Correcto
Ejemplo Correcto Result
Ejemplo con `std::unique_ptr`
Ejemplo con `std::unique_ptr` Result
Declaración de Punteros
Declaración de Punteros Result
Asignación y Acceso a Datos
Asignación y Acceso a Datos Result
Paso por Referencia usando Punteros
Paso por Referencia usando Punteros Result
Ejemplo de Puntero a Función
Ejemplo de Puntero a Función Result
Declaración Básica
Declaración Básica Result
Modificación a través de Referencias
Modificación a través de Referencias Result
Ejemplo de Paso por Referencia
Ejemplo de Paso por Referencia Result
Ejemplo de Referencia Constante
Ejemplo de Referencia Constante Result
Ejemplo de Constructor de Copia
Ejemplo de Constructor de Copia Result
Ejemplo de Operador de Asignación
Ejemplo de Operador de Asignación Result
Ejemplo de Referencia Dangling (a Evitar)
Ejemplo de Referencia Dangling (a Evitar) Result
Memoria Estática
Memoria Estática Result
Memoria Dinámica
Memoria Dinámica Result
Ejemplo Básico de Asignación Dinámica
Ejemplo Básico de Asignación Dinámica Result
Ejemplo de Arreglo Dinámico
Ejemplo de Arreglo Dinámico Result
Ejemplo Incorrecto
Ejemplo Incorrecto Result
Ejemplo Correcto
Ejemplo Correcto Result
Ejemplo con `std::unique_ptr`
Ejemplo con `std::unique_ptr` Result
Declaración de Punteros
Declaración de Punteros Result
Asignación y Acceso a Datos
Asignación y Acceso a Datos Result
Paso por Referencia usando Punteros
Paso por Referencia usando Punteros Result
Ejemplo de Puntero a Función
Ejemplo de Puntero a Función Result
Declaración Básica
Declaración Básica Result
Modificación a través de Referencias
Modificación a través de Referencias Result
Ejemplo de Paso por Referencia
Ejemplo de Paso por Referencia Result
Ejemplo de Referencia Constante
Ejemplo de Referencia Constante Result
Ejemplo de Constructor de Copia
Ejemplo de Constructor de Copia Result
Ejemplo de Operador de Asignación
Ejemplo de Operador de Asignación Result
Ejemplo de Referencia Dangling (a Evitar)
Ejemplo de Referencia Dangling (a Evitar) Result
Asignación de Memoria
Asignación de Memoria Result
Asignación de Memoria para Arreglos
Asignación de Memoria para Arreglos Result
Ejemplo: Clase con Gestión de Memoria Dinámica
Ejemplo: Clase con Gestión de Memoria Dinámica Result
Ejemplo con `std::shared_ptr`
Ejemplo con `std::shared_ptr` Result
Ejemplo con `std::weak_ptr`
Ejemplo con `std::weak_ptr` Result
Memoria Estática
Memoria Estática Result
Memoria Dinámica
Memoria Dinámica Result
Ejemplo Básico de Asignación Dinámica
Ejemplo Básico de Asignación Dinámica Result
Ejemplo de Arreglo Dinámico
Ejemplo de Arreglo Dinámico Result
Ejemplo Incorrecto
Ejemplo Incorrecto Result
Ejemplo Correcto
Ejemplo Correcto Result
Ejemplo con `std::unique_ptr`
Ejemplo con `std::unique_ptr` Result
Declaración de Punteros
Declaración de Punteros Result
Asignación y Acceso a Datos
Asignación y Acceso a Datos Result
Paso por Referencia usando Punteros
Paso por Referencia usando Punteros Result
Ejemplo de Puntero a Función
Ejemplo de Puntero a Función Result
Declaración Básica
Declaración Básica Result
Modificación a través de Referencias
Modificación a través de Referencias Result
Ejemplo de Paso por Referencia
Ejemplo de Paso por Referencia Result
Ejemplo de Referencia Constante
Ejemplo de Referencia Constante Result
Ejemplo de Constructor de Copia
Ejemplo de Constructor de Copia Result
Ejemplo de Operador de Asignación
Ejemplo de Operador de Asignación Result
Ejemplo de Referencia Dangling (a Evitar)
Ejemplo de Referencia Dangling (a Evitar) Result
Asignación de Memoria
Asignación de Memoria Result
Asignación de Memoria para Arreglos
Asignación de Memoria para Arreglos Result
Ejemplo: Clase con Gestión de Memoria Dinámica
Ejemplo: Clase con Gestión de Memoria Dinámica Result
Ejemplo con `std::shared_ptr`
Ejemplo con `std::shared_ptr` Result
Ejemplo con `std::weak_ptr`
Ejemplo con `std::weak_ptr` Result
Características:
Características: Result
Ejemplo de Uso de `std::unique_ptr`
Ejemplo de Uso de `std::unique_ptr` Result
Ejemplo de Uso de `std::shared_ptr`
Ejemplo de Uso de `std::shared_ptr` Result
Ejemplo de Uso de `std::weak_ptr`
Ejemplo de Uso de `std::weak_ptr` Result
Memoria Estática
Memoria Estática Result
Memoria Dinámica
Memoria Dinámica Result
Ejemplo Básico de Asignación Dinámica
Ejemplo Básico de Asignación Dinámica Result
Ejemplo de Arreglo Dinámico
Ejemplo de Arreglo Dinámico Result
Ejemplo Incorrecto
Ejemplo Incorrecto Result
Ejemplo Correcto
Ejemplo Correcto Result
Ejemplo con `std::unique_ptr`
Ejemplo con `std::unique_ptr` Result
Declaración de Punteros
Declaración de Punteros Result
Asignación y Acceso a Datos
Asignación y Acceso a Datos Result
Paso por Referencia usando Punteros
Paso por Referencia usando Punteros Result
Ejemplo de Puntero a Función
Ejemplo de Puntero a Función Result
Declaración Básica
Declaración Básica Result
Modificación a través de Referencias
Modificación a través de Referencias Result
Ejemplo de Paso por Referencia
Ejemplo de Paso por Referencia Result
Ejemplo de Referencia Constante
Ejemplo de Referencia Constante Result
Ejemplo de Constructor de Copia
Ejemplo de Constructor de Copia Result
Ejemplo de Operador de Asignación
Ejemplo de Operador de Asignación Result
Ejemplo de Referencia Dangling (a Evitar)
Ejemplo de Referencia Dangling (a Evitar) Result
Asignación de Memoria
Asignación de Memoria Result
Asignación de Memoria para Arreglos
Asignación de Memoria para Arreglos Result
Ejemplo: Clase con Gestión de Memoria Dinámica
Ejemplo: Clase con Gestión de Memoria Dinámica Result
Ejemplo con `std::shared_ptr`
Ejemplo con `std::shared_ptr` Result
Ejemplo con `std::weak_ptr`
Ejemplo con `std::weak_ptr` Result
Características:
Características: Result
Ejemplo de Uso de `std::unique_ptr`
Ejemplo de Uso de `std::unique_ptr` Result
Ejemplo de Uso de `std::shared_ptr`
Ejemplo de Uso de `std::shared_ptr` Result
Ejemplo de Uso de `std::weak_ptr`
Ejemplo de Uso de `std::weak_ptr` Result
Declaración y Asignación
Declaración y Asignación Result
Declaración en el Archivo de Cabecera (.h)
Declaración en el Archivo de Cabecera (.h) Result
Definición en el Archivo de Implementación (.cpp)
Definición en el Archivo de Implementación (.cpp) Result
Ejemplo de Transferencia de Propiedad
Ejemplo de Transferencia de Propiedad Result
1. Encapsulación de Recursos
1. Encapsulación de Recursos Result
2. Uso en Contenedores
2. Uso en Contenedores Result
3. Evitar el Uso de Punteros Crudos
3. Evitar el Uso de Punteros Crudos Result
Archivo de Cabecera (.h)
Archivo de Cabecera (.h) Result
Archivo de Implementación (.cpp)
Archivo de Implementación (.cpp) Result
Función Principal
Función Principal Result
<---Memoria Estática--->
```cpp
#include <iostream>

int globalVariable = 10; // Variable global (memoria estática)

int main() {
    static int staticVariable = 20; // Variable estática local (memoria estática)
    return 0;
}
<---Memoria Estática Result--->
<---Memoria Dinámica--->
<---Memoria Dinámica Result--->
<---Ejemplo Básico de Asignación Dinámica--->
```cpp
#include <iostream>

int main() {
    int* ptr = new int; // Asignar memoria para un entero
    *ptr = 100; // Usar la memoria asignada
    std::cout << *ptr << std::endl; // Salida: 100
    delete ptr; // Liberar la memoria

    return 0;
}
<---Ejemplo Básico de Asignación Dinámica Result--->
<---Ejemplo de Arreglo Dinámico--->
```cpp
#include <iostream>

int main() {
    int size = 5;
    int* array = new int[size]; // Asignar memoria para un arreglo de enteros

    for(int i = 0; i < size; ++i) {
        array[i] = i * 10; // Inicializar el arreglo
    }

    for(int i = 0; i < size; ++i) {
        std::cout << array[i] << " "; // Salida: 0 10 20 30 40
    }
    std::cout << std::endl;

    delete[] array; // Liberar la memoria

    return 0;
}
<---Ejemplo de Arreglo Dinámico Result--->
<---Ejemplo Incorrecto--->
```cpp
int* ptr = new int(10);
delete ptr; // Liberar memoria
std::cout << *ptr << std::endl; // Acceso inválido: comportamiento indefinido
<---Ejemplo Incorrecto Result--->
<---Ejemplo Correcto--->
```cpp
int* ptr = new int(10);
delete ptr; // Liberar memoria
ptr = nullptr; // Evitar acceso inválido
```cpp
#include <iostream>
#include <cstring>

class String {
private:
    char* data;
    size_t size;

public:
    String(const char* str) {
        size = strlen(str);
        data = new char[size + 1];
        strcpy(data, str);
    }

    ~String() {
        delete[] data;
    }

    // Constructor de copia
    String(const String& other) {
        size = other.size;
        data = new char[size + 1];
        strcpy(data, other.data);
    }

    // Operador de asignación
    String& operator=(const String& other) {
        if (this == &other) return *this;

        delete[] data;

        size = other.size;
        data = new char[size + 1];
        strcpy(data, other.data);
        return *this;
    }

    void print() const {
        std::cout << data << std::endl;
    }
};

int main() {
    String str1("Hello");
    String str2 = str1; // Constructor de copia
    String str3("World");
    str3 = str1; // Operador de asignación
    str1.print(); // Salida: Hello
    str2.print(); // Salida: Hello
    str3.print(); // Salida: Hello

    return 0;
}
<---Ejemplo Correcto Result--->
<---Ejemplo con `std::unique_ptr`--->
```cpp
#include <iostream>
#include <memory>

int main() {
    std::unique_ptr<int> ptr = std::make_unique<int>(100); // Asignar memoria
    std::cout << *ptr << std::endl; // Salida: 100
    // Memoria se libera automáticamente cuando ptr sale del alcance

    return 0;
}
<---Ejemplo con `std::unique_ptr` Result--->
<---Memoria Estática--->
```cpp
#include <iostream>

int globalVariable = 10; // Variable global (memoria estática)

int main() {
    static int staticVariable = 20; // Variable estática local (memoria estática)
    return 0;
}
<---Memoria Estática Result--->
<---Memoria Dinámica--->
<---Memoria Dinámica Result--->
<---Ejemplo Básico de Asignación Dinámica--->
```cpp
#include <iostream>

int main() {
    int* ptr = new int; // Asignar memoria para un entero
    *ptr = 100; // Usar la memoria asignada
    std::cout << *ptr << std::endl; // Salida: 100
    delete ptr; // Liberar la memoria

    return 0;
}
<---Ejemplo Básico de Asignación Dinámica Result--->
<---Ejemplo de Arreglo Dinámico--->
```cpp
#include <iostream>

int main() {
    int size = 5;
    int* array = new int[size]; // Asignar memoria para un arreglo de enteros

    for(int i = 0; i < size; ++i) {
        array[i] = i * 10; // Inicializar el arreglo
    }

    for(int i = 0; i < size; ++i) {
        std::cout << array[i] << " "; // Salida: 0 10 20 30 40
    }
    std::cout << std::endl;

    delete[] array; // Liberar la memoria

    return 0;
}
<---Ejemplo de Arreglo Dinámico Result--->
<---Ejemplo Incorrecto--->
```cpp
int* ptr = new int(10);
delete ptr; // Liberar memoria
std::cout << *ptr << std::endl; // Acceso inválido: comportamiento indefinido
<---Ejemplo Incorrecto Result--->
<---Ejemplo Correcto--->
```cpp
int* ptr = new int(10);
delete ptr; // Liberar memoria
ptr = nullptr; // Evitar acceso inválido
```cpp
#include <iostream>
#include <cstring>

class String {
private:
    char* data;
    size_t size;

public:
    String(const char* str) {
        size = strlen(str);
        data = new char[size + 1];
        strcpy(data, str);
    }

    ~String() {
        delete[] data;
    }

    // Constructor de copia
    String(const String& other) {
        size = other.size;
        data = new char[size + 1];
        strcpy(data, other.data);
    }

    // Operador de asignación
    String& operator=(const String& other) {
        if (this == &other) return *this;

        delete[] data;

        size = other.size;
        data = new char[size + 1];
        strcpy(data, other.data);
        return *this;
    }

    void print() const {
        std::cout << data << std::endl;
    }
};

int main() {
    String str1("Hello");
    String str2 = str1; // Constructor de copia
    String str3("World");
    str3 = str1; // Operador de asignación
    str1.print(); // Salida: Hello
    str2.print(); // Salida: Hello
    str3.print(); // Salida: Hello

    return 0;
}
<---Ejemplo Correcto Result--->
<---Ejemplo con `std::unique_ptr`--->
```cpp
#include <iostream>
#include <memory>

int main() {
    std::unique_ptr<int> ptr = std::make_unique<int>(100); // Asignar memoria
    std::cout << *ptr << std::endl; // Salida: 100
    // Memoria se libera automáticamente cuando ptr sale del alcance

    return 0;
}
<---Ejemplo con `std::unique_ptr` Result--->
<---Declaración de Punteros--->
```cpp
int* ptr; // Declara un puntero a un entero
<---Declaración de Punteros Result--->
<---Asignación y Acceso a Datos--->
```cpp
int var = 10;
int* ptr = &var; // ptr apunta a la dirección de var

std::cout << "Valor de var: " << var << std::endl; // Salida: 10
std::cout << "Dirección de var: " << &var << std::endl; // Dirección de var
std::cout << "Valor apuntado por ptr: " << *ptr << std::endl; // Salida: 10
```cpp
int arr[5] = {1, 2, 3, 4, 5};
int* ptr = arr; // ptr apunta al primer elemento del arreglo

for(int i = 0; i < 5; ++i) {
    std::cout << *(ptr + i) << " "; // Acceder a los elementos del arreglo usando punteros
}
// Salida: 1 2 3 4 5
```cpp
int arr[5] = {1, 2, 3, 4, 5};
int* ptr = arr;

std::cout << "Primer elemento: " << *ptr << std::endl; // Salida: 1
ptr++;
std::cout << "Segundo elemento: " << *ptr << std::endl; // Salida: 2
```cpp
int var = 10;
int* ptr = &var;
int** ptr2 = &ptr;

std::cout << "Valor de var: " << var << std::endl; // Salida: 10
std::cout << "Valor apuntado por ptr: " << *ptr << std::endl; // Salida: 10
std::cout << "Valor apuntado por ptr2: " << **ptr2 << std::endl; // Salida: 10
```cpp
int* ptr = nullptr; // Puntero inicializado a nullptr
```cpp
int* ptr = new int(10);
delete ptr; // Liberar memoria asignada
ptr = nullptr; // Evitar acceso a memoria liberada
```cpp
int* ptr = new int(10);
delete ptr;
ptr = nullptr; // Ahora ptr no es un puntero colgante
<---Asignación y Acceso a Datos Result--->
<---Paso por Referencia usando Punteros--->
```cpp
#include <iostream>

void incrementar(int* ptr) {
    (*ptr)++;
}

int main() {
    int var = 10;
    incrementar(&var);
    std::cout << "Valor de var después de incrementar: " << var << std::endl; // Salida: 11

    return 0;
}
<---Paso por Referencia usando Punteros Result--->
<---Ejemplo de Puntero a Función--->
```cpp
#include <iostream>

void saludo() {
    std::cout << "Hola, Mundo!" << std::endl;
}

void llamarFuncion(void (*func)()) {
    func();
}

int main() {
    void (*ptrFunc)() = &saludo;
    llamarFuncion(ptrFunc); // Salida: Hola, Mundo!

    return 0;
}
<---Ejemplo de Puntero a Función Result--->
<---Memoria Estática--->
```cpp
#include <iostream>

int globalVariable = 10; // Variable global (memoria estática)

int main() {
    static int staticVariable = 20; // Variable estática local (memoria estática)
    return 0;
}
<---Memoria Estática Result--->
<---Memoria Dinámica--->
<---Memoria Dinámica Result--->
<---Ejemplo Básico de Asignación Dinámica--->
```cpp
#include <iostream>

int main() {
    int* ptr = new int; // Asignar memoria para un entero
    *ptr = 100; // Usar la memoria asignada
    std::cout << *ptr << std::endl; // Salida: 100
    delete ptr; // Liberar la memoria

    return 0;
}
<---Ejemplo Básico de Asignación Dinámica Result--->
<---Ejemplo de Arreglo Dinámico--->
```cpp
#include <iostream>

int main() {
    int size = 5;
    int* array = new int[size]; // Asignar memoria para un arreglo de enteros

    for(int i = 0; i < size; ++i) {
        array[i] = i * 10; // Inicializar el arreglo
    }

    for(int i = 0; i < size; ++i) {
        std::cout << array[i] << " "; // Salida: 0 10 20 30 40
    }
    std::cout << std::endl;

    delete[] array; // Liberar la memoria

    return 0;
}
<---Ejemplo de Arreglo Dinámico Result--->
<---Ejemplo Incorrecto--->
```cpp
int* ptr = new int(10);
delete ptr; // Liberar memoria
std::cout << *ptr << std::endl; // Acceso inválido: comportamiento indefinido
<---Ejemplo Incorrecto Result--->
<---Ejemplo Correcto--->
```cpp
int* ptr = new int(10);
delete ptr; // Liberar memoria
ptr = nullptr; // Evitar acceso inválido
```cpp
#include <iostream>
#include <cstring>

class String {
private:
    char* data;
    size_t size;

public:
    String(const char* str) {
        size = strlen(str);
        data = new char[size + 1];
        strcpy(data, str);
    }

    ~String() {
        delete[] data;
    }

    // Constructor de copia
    String(const String& other) {
        size = other.size;
        data = new char[size + 1];
        strcpy(data, other.data);
    }

    // Operador de asignación
    String& operator=(const String& other) {
        if (this == &other) return *this;

        delete[] data;

        size = other.size;
        data = new char[size + 1];
        strcpy(data, other.data);
        return *this;
    }

    void print() const {
        std::cout << data << std::endl;
    }
};

int main() {
    String str1("Hello");
    String str2 = str1; // Constructor de copia
    String str3("World");
    str3 = str1; // Operador de asignación
    str1.print(); // Salida: Hello
    str2.print(); // Salida: Hello
    str3.print(); // Salida: Hello

    return 0;
}
<---Ejemplo Correcto Result--->
<---Ejemplo con `std::unique_ptr`--->
```cpp
#include <iostream>
#include <memory>

int main() {
    std::unique_ptr<int> ptr = std::make_unique<int>(100); // Asignar memoria
    std::cout << *ptr << std::endl; // Salida: 100
    // Memoria se libera automáticamente cuando ptr sale del alcance

    return 0;
}
<---Ejemplo con `std::unique_ptr` Result--->
<---Declaración de Punteros--->
```cpp
int* ptr; // Declara un puntero a un entero
<---Declaración de Punteros Result--->
<---Asignación y Acceso a Datos--->
```cpp
int var = 10;
int* ptr = &var; // ptr apunta a la dirección de var

std::cout << "Valor de var: " << var << std::endl; // Salida: 10
std::cout << "Dirección de var: " << &var << std::endl; // Dirección de var
std::cout << "Valor apuntado por ptr: " << *ptr << std::endl; // Salida: 10
```cpp
int arr[5] = {1, 2, 3, 4, 5};
int* ptr = arr; // ptr apunta al primer elemento del arreglo

for(int i = 0; i < 5; ++i) {
    std::cout << *(ptr + i) << " "; // Acceder a los elementos del arreglo usando punteros
}
// Salida: 1 2 3 4 5
```cpp
int arr[5] = {1, 2, 3, 4, 5};
int* ptr = arr;

std::cout << "Primer elemento: " << *ptr << std::endl; // Salida: 1
ptr++;
std::cout << "Segundo elemento: " << *ptr << std::endl; // Salida: 2
```cpp
int var = 10;
int* ptr = &var;
int** ptr2 = &ptr;

std::cout << "Valor de var: " << var << std::endl; // Salida: 10
std::cout << "Valor apuntado por ptr: " << *ptr << std::endl; // Salida: 10
std::cout << "Valor apuntado por ptr2: " << **ptr2 << std::endl; // Salida: 10
```cpp
int* ptr = nullptr; // Puntero inicializado a nullptr
```cpp
int* ptr = new int(10);
delete ptr; // Liberar memoria asignada
ptr = nullptr; // Evitar acceso a memoria liberada
```cpp
int* ptr = new int(10);
delete ptr;
ptr = nullptr; // Ahora ptr no es un puntero colgante
<---Asignación y Acceso a Datos Result--->
<---Paso por Referencia usando Punteros--->
```cpp
#include <iostream>

void incrementar(int* ptr) {
    (*ptr)++;
}

int main() {
    int var = 10;
    incrementar(&var);
    std::cout << "Valor de var después de incrementar: " << var << std::endl; // Salida: 11

    return 0;
}
<---Paso por Referencia usando Punteros Result--->
<---Ejemplo de Puntero a Función--->
```cpp
#include <iostream>

void saludo() {
    std::cout << "Hola, Mundo!" << std::endl;
}

void llamarFuncion(void (*func)()) {
    func();
}

int main() {
    void (*ptrFunc)() = &saludo;
    llamarFuncion(ptrFunc); // Salida: Hola, Mundo!

    return 0;
}
<---Ejemplo de Puntero a Función Result--->
<---Declaración Básica--->
```cpp
int var = 10;
int& ref = var; // ref es una referencia a var

std::cout << "var: " << var << std::endl; // Salida: 10
std::cout << "ref: " << ref << std::endl; // Salida: 10
<---Declaración Básica Result--->
<---Modificación a través de Referencias--->
```cpp
int var = 10;
int& ref = var;

ref = 20; // Modifica var a través de ref

std::cout << "var: " << var << std::endl; // Salida: 20
std::cout << "ref: " << ref << std::endl; // Salida: 20
<---Modificación a través de Referencias Result--->
<---Ejemplo de Paso por Referencia--->
```cpp
#include <iostream>

void incrementar(int& ref) {
    ref++;
}

int main() {
    int var = 10;
    incrementar(var);
    std::cout << "Valor de var después de incrementar: " << var << std::endl; // Salida: 11

    return 0;
}
<---Ejemplo de Paso por Referencia Result--->
<---Ejemplo de Referencia Constante--->
```cpp
#include <iostream>

void mostrar(const int& ref) {
    std::cout << "Valor: " << ref << std::endl;
}

int main() {
    int var = 10;
    mostrar(var); // Salida: 10

    return 0;
}
<---Ejemplo de Referencia Constante Result--->
<---Ejemplo de Constructor de Copia--->
```cpp
#include <iostream>

class MiClase {
private:
    int valor;

public:
    MiClase(int v) : valor(v) {}
    
    // Constructor de copia
    MiClase(const MiClase& otra) : valor(otra.valor) {
        std::cout << "Constructor de copia llamado" << std::endl;
    }

    int obtenerValor() const { return valor; }
};

int main() {
    MiClase obj1(10);
    MiClase obj2 = obj1; // Llama al constructor de copia

    std::cout << "Valor de obj1: " << obj1.obtenerValor() << std::endl; // Salida: 10
    std::cout << "Valor de obj2: " << obj2.obtenerValor() << std::endl; // Salida: 10

    return 0;
}
<---Ejemplo de Constructor de Copia Result--->
<---Ejemplo de Operador de Asignación--->
```cpp
#include <iostream>

class MiClase {
private:
    int valor;

public:
    MiClase(int v) : valor(v) {}
    
    // Operador de asignación
    MiClase& operator=(const MiClase& otra) {
        if (this != &otra) {
            valor = otra.valor;
        }
        return *this;
    }

    int obtenerValor() const { return valor; }
};

int main() {
    MiClase obj1(10);
    MiClase obj2(20);
    obj2 = obj1; // Llama al operador de asignación

    std::cout << "Valor de obj1: " << obj1.obtenerValor() << std::endl; // Salida: 10
    std::cout << "Valor de obj2: " << obj2.obtenerValor() << std::endl; // Salida: 10

    return 0;
}
<---Ejemplo de Operador de Asignación Result--->
<---Ejemplo de Referencia Dangling (a Evitar)--->
```cpp
int& funcion() {
    int var = 10;
    return var; // var se destruye al salir de la función
}

int main() {
    int& ref = funcion(); // ref ahora es una referencia dangling
    std::cout << ref << std::endl; // Comportamiento indefinido

    return 0;
}
```cpp
void mostrar(const int& ref) {
    std::cout << "Valor: " << ref << std::endl;
}
<---Ejemplo de Referencia Dangling (a Evitar) Result--->
<---Memoria Estática--->
```cpp
#include <iostream>

int globalVariable = 10; // Variable global (memoria estática)

int main() {
    static int staticVariable = 20; // Variable estática local (memoria estática)
    return 0;
}
<---Memoria Estática Result--->
<---Memoria Dinámica--->
<---Memoria Dinámica Result--->
<---Ejemplo Básico de Asignación Dinámica--->
```cpp
#include <iostream>

int main() {
    int* ptr = new int; // Asignar memoria para un entero
    *ptr = 100; // Usar la memoria asignada
    std::cout << *ptr << std::endl; // Salida: 100
    delete ptr; // Liberar la memoria

    return 0;
}
<---Ejemplo Básico de Asignación Dinámica Result--->
<---Ejemplo de Arreglo Dinámico--->
```cpp
#include <iostream>

int main() {
    int size = 5;
    int* array = new int[size]; // Asignar memoria para un arreglo de enteros

    for(int i = 0; i < size; ++i) {
        array[i] = i * 10; // Inicializar el arreglo
    }

    for(int i = 0; i < size; ++i) {
        std::cout << array[i] << " "; // Salida: 0 10 20 30 40
    }
    std::cout << std::endl;

    delete[] array; // Liberar la memoria

    return 0;
}
<---Ejemplo de Arreglo Dinámico Result--->
<---Ejemplo Incorrecto--->
```cpp
int* ptr = new int(10);
delete ptr; // Liberar memoria
std::cout << *ptr << std::endl; // Acceso inválido: comportamiento indefinido
<---Ejemplo Incorrecto Result--->
<---Ejemplo Correcto--->
```cpp
int* ptr = new int(10);
delete ptr; // Liberar memoria
ptr = nullptr; // Evitar acceso inválido
```cpp
#include <iostream>
#include <cstring>

class String {
private:
    char* data;
    size_t size;

public:
    String(const char* str) {
        size = strlen(str);
        data = new char[size + 1];
        strcpy(data, str);
    }

    ~String() {
        delete[] data;
    }

    // Constructor de copia
    String(const String& other) {
        size = other.size;
        data = new char[size + 1];
        strcpy(data, other.data);
    }

    // Operador de asignación
    String& operator=(const String& other) {
        if (this == &other) return *this;

        delete[] data;

        size = other.size;
        data = new char[size + 1];
        strcpy(data, other.data);
        return *this;
    }

    void print() const {
        std::cout << data << std::endl;
    }
};

int main() {
    String str1("Hello");
    String str2 = str1; // Constructor de copia
    String str3("World");
    str3 = str1; // Operador de asignación
    str1.print(); // Salida: Hello
    str2.print(); // Salida: Hello
    str3.print(); // Salida: Hello

    return 0;
}
<---Ejemplo Correcto Result--->
<---Ejemplo con `std::unique_ptr`--->
```cpp
#include <iostream>
#include <memory>

int main() {
    std::unique_ptr<int> ptr = std::make_unique<int>(10);
    std::cout << *ptr << std::endl; // Salida: 10

    return 0;
}
<---Ejemplo con `std::unique_ptr` Result--->
<---Declaración de Punteros--->
```cpp
int* ptr; // Declara un puntero a un entero
<---Declaración de Punteros Result--->
<---Asignación y Acceso a Datos--->
```cpp
int var = 10;
int* ptr = &var; // ptr apunta a la dirección de var

std::cout << "Valor de var: " << var << std::endl; // Salida: 10
std::cout << "Dirección de var: " << &var << std::endl; // Dirección de var
std::cout << "Valor apuntado por ptr: " << *ptr << std::endl; // Salida: 10
```cpp
int arr[5] = {1, 2, 3, 4, 5};
int* ptr = arr; // ptr apunta al primer elemento del arreglo

for(int i = 0; i < 5; ++i) {
    std::cout << *(ptr + i) << " "; // Acceder a los elementos del arreglo usando punteros
}
// Salida: 1 2 3 4 5
```cpp
int arr[5] = {1, 2, 3, 4, 5};
int* ptr = arr;

std::cout << "Primer elemento: " << *ptr << std::endl; // Salida: 1
ptr++;
std::cout << "Segundo elemento: " << *ptr << std::endl; // Salida: 2
```cpp
int var = 10;
int* ptr = &var;
int** ptr2 = &ptr;

std::cout << "Valor de var: " << var << std::endl; // Salida: 10
std::cout << "Valor apuntado por ptr: " << *ptr << std::endl; // Salida: 10
std::cout << "Valor apuntado por ptr2: " << **ptr2 << std::endl; // Salida: 10
```cpp
int* ptr = nullptr; // Puntero inicializado a nullptr
```cpp
int* ptr = new int(10);
delete ptr; // Liberar memoria asignada
ptr = nullptr; // Evitar acceso a memoria liberada
```cpp
int* ptr = new int(10);
delete ptr;
ptr = nullptr; // Ahora ptr no es un puntero colgante
<---Asignación y Acceso a Datos Result--->
<---Paso por Referencia usando Punteros--->
```cpp
#include <iostream>

void incrementar(int* ptr) {
    (*ptr)++;
}

int main() {
    int var = 10;
    incrementar(&var);
    std::cout << "Valor de var después de incrementar: " << var << std::endl; // Salida: 11

    return 0;
}
<---Paso por Referencia usando Punteros Result--->
<---Ejemplo de Puntero a Función--->
```cpp
#include <iostream>

void saludo() {
    std::cout << "Hola, Mundo!" << std::endl;
}

void llamarFuncion(void (*func)()) {
    func();
}

int main() {
    void (*ptrFunc)() = &saludo;
    llamarFuncion(ptrFunc); // Salida: Hola, Mundo!

    return 0;
}
<---Ejemplo de Puntero a Función Result--->
<---Declaración Básica--->
```cpp
int var = 10;
int& ref = var; // ref es una referencia a var

std::cout << "var: " << var << std::endl; // Salida: 10
std::cout << "ref: " << ref << std::endl; // Salida: 10
<---Declaración Básica Result--->
<---Modificación a través de Referencias--->
```cpp
int var = 10;
int& ref = var;

ref = 20; // Modifica var a través de ref

std::cout << "var: " << var << std::endl; // Salida: 20
std::cout << "ref: " << ref << std::endl; // Salida: 20
<---Modificación a través de Referencias Result--->
<---Ejemplo de Paso por Referencia--->
```cpp
#include <iostream>

void incrementar(int& ref) {
    ref++;
}

int main() {
    int var = 10;
    incrementar(var);
    std::cout << "Valor de var después de incrementar: " << var << std::endl; // Salida: 11

    return 0;
}
<---Ejemplo de Paso por Referencia Result--->
<---Ejemplo de Referencia Constante--->
```cpp
#include <iostream>

void mostrar(const int& ref) {
    std::cout << "Valor: " << ref << std::endl;
}

int main() {
    int var = 10;
    mostrar(var); // Salida: 10

    return 0;
}
<---Ejemplo de Referencia Constante Result--->
<---Ejemplo de Constructor de Copia--->
```cpp
#include <iostream>

class MiClase {
private:
    int valor;

public:
    MiClase(int v) : valor(v) {}
    
    // Constructor de copia
    MiClase(const MiClase& otra) : valor(otra.valor) {
        std::cout << "Constructor de copia llamado" << std::endl;
    }

    int obtenerValor() const { return valor; }
};

int main() {
    MiClase obj1(10);
    MiClase obj2 = obj1; // Llama al constructor de copia

    std::cout << "Valor de obj1: " << obj1.obtenerValor() << std::endl; // Salida: 10
    std::cout << "Valor de obj2: " << obj2.obtenerValor() << std::endl; // Salida: 10

    return 0;
}
<---Ejemplo de Constructor de Copia Result--->
<---Ejemplo de Operador de Asignación--->
```cpp
#include <iostream>

class MiClase {
private:
    int valor;

public:
    MiClase(int v) : valor(v) {}
    
    // Operador de asignación
    MiClase& operator=(const MiClase& otra) {
        if (this != &otra) {
            valor = otra.valor;
        }
        return *this;
    }

    int obtenerValor() const { return valor; }
};

int main() {
    MiClase obj1(10);
    MiClase obj2(20);
    obj2 = obj1; // Llama al operador de asignación

    std::cout << "Valor de obj1: " << obj1.obtenerValor() << std::endl; // Salida: 10
    std::cout << "Valor de obj2: " << obj2.obtenerValor() << std::endl; // Salida: 10

    return 0;
}
<---Ejemplo de Operador de Asignación Result--->
<---Ejemplo de Referencia Dangling (a Evitar)--->
```cpp
int& funcion() {
    int var = 10;
    return var; // var se destruye al salir de la función
}

int main() {
    int& ref = funcion(); // ref ahora es una referencia dangling
    std::cout << ref << std::endl; // Comportamiento indefinido

    return 0;
}
```cpp
void mostrar(const int& ref) {
    std::cout << "Valor: " << ref << std::endl;
}
<---Ejemplo de Referencia Dangling (a Evitar) Result--->
<---Asignación de Memoria--->
```cpp
int* ptr = new int; // Asignar memoria para un entero
*ptr = 10;
std::cout << *ptr << std::endl; // Salida: 10

delete ptr; // Liberar la memoria asignada
<---Asignación de Memoria Result--->
<---Asignación de Memoria para Arreglos--->
```cpp
int size = 5;
int* arr = new int[size]; // Asignar memoria para un arreglo de enteros

for(int i = 0; i < size; ++i) {
    arr[i] = i * 10;
}

for(int i = 0; i < size; ++i) {
    std::cout << arr[i] << " "; // Salida: 0 10 20 30 40
}
std::cout << std::endl;

delete[] arr; // Liberar la memoria asignada para el arreglo
<---Asignación de Memoria para Arreglos Result--->
<---Ejemplo: Clase con Gestión de Memoria Dinámica--->
```cpp
#include <iostream>

class MiClase {
private:
    int* data;
    size_t size;

public:
    // Constructor
    MiClase(size_t s) : size(s) {
        data = new int[size];
        for(size_t i = 0; i < size; ++i) {
            data[i] = i * 10;
        }
    }

    // Destructor
    ~MiClase() {
        delete[] data;
    }

    // Constructor de copia
    MiClase(const MiClase& other) : size(other.size) {
        data = new int[size];
        std::copy(other.data, other.data + size, data);
    }

    // Operador de asignación
    MiClase& operator=(const MiClase& other) {
        if (this == &other) return *this;

        delete[] data;

        size = other.size;
        data = new int[size];
        std::copy(other.data, other.data + size, data);

        return *this;
    }

    void print() const {
        for(size_t i = 0; i < size; ++i) {
            std::cout << data[i] << " ";
        }
        std::cout << std::endl;
    }
};

int main() {
    MiClase obj1(5);
    obj1.print(); // Salida: 0 10 20 30 40

    MiClase obj2 = obj1; // Constructor de copia
    obj2.print(); // Salida: 0 10 20 30 40

    MiClase obj3(3);
    obj3 = obj1; // Operador de asignación
    obj3.print(); // Salida: 0 10 20 30 40

    return 0;
}
<---Ejemplo: Clase con Gestión de Memoria Dinámica Result--->
<---Ejemplo con `std::shared_ptr`--->
```cpp
#include <iostream>
#include <memory>

int main() {
    std::shared_ptr<int> ptr1 = std::make_shared<int>(20);
    std::shared_ptr<int> ptr2 = ptr1;

    std::cout << *ptr1 << std::endl; // Salida: 20
    std::cout << *ptr2 << std::endl; // Salida: 20

    return 0;
}
<---Ejemplo con `std::shared_ptr` Result--->
<---Ejemplo con `std::weak_ptr`--->
```cpp
#include <iostream>
#include <memory>

int main() {
    std::shared_ptr<int> sptr = std::make_shared<int>(30);
    std::weak_ptr<int> wptr = sptr;

    std::cout << "Use count: " << sptr.use_count() << std::endl; // Salida: 1

    if (auto spt = wptr.lock()) {
        std::cout << *spt << std::endl; // Salida: 30
    } else {
        std::cout << "wptr is expired" << std::endl;
    }

    return 0;
}
```cpp
int* ptr = new int(10);
// ...
delete ptr; // Liberar la memoria
```cpp
std::unique_ptr<int> ptr = std::make_unique<int>(10);
```cpp
int* ptr = new int(10);
delete ptr;
ptr = nullptr; // Evitar acceso a memoria liberada
```cpp
class Recurso {
public:
    Recurso() { /* adquirir recurso */ }
    ~Recurso() { /* liberar recurso */ }
};
<---Ejemplo con `std::weak_ptr` Result--->
<---Memoria Estática--->
```cpp
#include <iostream>

int globalVariable = 10; // Variable global (memoria estática)

int main() {
    static int staticVariable = 20; // Variable estática local (memoria estática)
    return 0;
}
<---Memoria Estática Result--->
<---Memoria Dinámica--->
<---Memoria Dinámica Result--->
<---Ejemplo Básico de Asignación Dinámica--->
```cpp
#include <iostream>

int main() {
    int* ptr = new int; // Asignar memoria para un entero
    *ptr = 100; // Usar la memoria asignada
    std::cout << *ptr << std::endl; // Salida: 100
    delete ptr; // Liberar la memoria

    return 0;
}
<---Ejemplo Básico de Asignación Dinámica Result--->
<---Ejemplo de Arreglo Dinámico--->
```cpp
#include <iostream>

int main() {
    int size = 5;
    int* array = new int[size]; // Asignar memoria para un arreglo de enteros

    for(int i = 0; i < size; ++i) {
        array[i] = i * 10; // Inicializar el arreglo
    }

    for(int i = 0; i < size; ++i) {
        std::cout << array[i] << " "; // Salida: 0 10 20 30 40
    }
    std::cout << std::endl;

    delete[] array; // Liberar la memoria

    return 0;
}
<---Ejemplo de Arreglo Dinámico Result--->
<---Ejemplo Incorrecto--->
```cpp
int* ptr = new int(10);
delete ptr; // Liberar memoria
std::cout << *ptr << std::endl; // Acceso inválido: comportamiento indefinido
<---Ejemplo Incorrecto Result--->
<---Ejemplo Correcto--->
```cpp
int* ptr = new int(10);
delete ptr; // Liberar memoria
ptr = nullptr; // Evitar acceso inválido
```cpp
#include <iostream>
#include <cstring>

class String {
private:
    char* data;
    size_t size;

public:
    String(const char* str) {
        size = strlen(str);
        data = new char[size + 1];
        strcpy(data, str);
    }

    ~String() {
        delete[] data;
    }

    // Constructor de copia
    String(const String& other) {
        size = other.size;
        data = new char[size + 1];
        strcpy(data, other.data);
    }

    // Operador de asignación
    String& operator=(const String& other) {
        if (this == &other) return *this;

        delete[] data;

        size = other.size;
        data = new char[size + 1];
        strcpy(data, other.data);
        return *this;
    }

    void print() const {
        std::cout << data << std::endl;
    }
};

int main() {
    String str1("Hello");
    String str2 = str1; // Constructor de copia
    String str3("World");
    str3 = str1; // Operador de asignación
    str1.print(); // Salida: Hello
    str2.print(); // Salida: Hello
    str3.print(); // Salida: Hello

    return 0;
}
<---Ejemplo Correcto Result--->
<---Ejemplo con `std::unique_ptr`--->
```cpp
#include <iostream>
#include <memory>

int main() {
    std::unique_ptr<int> ptr = std::make_unique<int>(10);
    std::cout << *ptr << std::endl; // Salida: 10

    return 0;
}
<---Ejemplo con `std::unique_ptr` Result--->
<---Declaración de Punteros--->
```cpp
int* ptr; // Declara un puntero a un entero
<---Declaración de Punteros Result--->
<---Asignación y Acceso a Datos--->
```cpp
int var = 10;
int* ptr = &var; // ptr apunta a la dirección de var

std::cout << "Valor de var: " << var << std::endl; // Salida: 10
std::cout << "Dirección de var: " << &var << std::endl; // Dirección de var
std::cout << "Valor apuntado por ptr: " << *ptr << std::endl; // Salida: 10
```cpp
int arr[5] = {1, 2, 3, 4, 5};
int* ptr = arr; // ptr apunta al primer elemento del arreglo

for(int i = 0; i < 5; ++i) {
    std::cout << *(ptr + i) << " "; // Acceder a los elementos del arreglo usando punteros
}
// Salida: 1 2 3 4 5
```cpp
int arr[5] = {1, 2, 3, 4, 5};
int* ptr = arr;

std::cout << "Primer elemento: " << *ptr << std::endl; // Salida: 1
ptr++;
std::cout << "Segundo elemento: " << *ptr << std::endl; // Salida: 2
```cpp
int var = 10;
int* ptr = &var;
int** ptr2 = &ptr;

std::cout << "Valor de var: " << var << std::endl; // Salida: 10
std::cout << "Valor apuntado por ptr: " << *ptr << std::endl; // Salida: 10
std::cout << "Valor apuntado por ptr2: " << **ptr2 << std::endl; // Salida: 10
```cpp
int* ptr = nullptr; // Puntero inicializado a nullptr
```cpp
int* ptr = new int(10);
delete ptr; // Liberar memoria asignada
ptr = nullptr; // Evitar acceso a memoria liberada
```cpp
int* ptr = new int(10);
delete ptr;
ptr = nullptr; // Ahora ptr no es un puntero colgante
<---Asignación y Acceso a Datos Result--->
<---Paso por Referencia usando Punteros--->
```cpp
#include <iostream>

void incrementar(int* ptr) {
    (*ptr)++;
}

int main() {
    int var = 10;
    incrementar(&var);
    std::cout << "Valor de var después de incrementar: " << var << std::endl; // Salida: 11

    return 0;
}
<---Paso por Referencia usando Punteros Result--->
<---Ejemplo de Puntero a Función--->
```cpp
#include <iostream>

void saludo() {
    std::cout << "Hola, Mundo!" << std::endl;
}

void llamarFuncion(void (*func)()) {
    func();
}

int main() {
    void (*ptrFunc)() = &saludo;
    llamarFuncion(ptrFunc); // Salida: Hola, Mundo!

    return 0;
}
<---Ejemplo de Puntero a Función Result--->
<---Declaración Básica--->
```cpp
int var = 10;
int& ref = var; // ref es una referencia a var

std::cout << "var: " << var << std::endl; // Salida: 10
std::cout << "ref: " << ref << std::endl; // Salida: 10
<---Declaración Básica Result--->
<---Modificación a través de Referencias--->
```cpp
int var = 10;
int& ref = var;

ref = 20; // Modifica var a través de ref

std::cout << "var: " << var << std::endl; // Salida: 20
std::cout << "ref: " << ref << std::endl; // Salida: 20
<---Modificación a través de Referencias Result--->
<---Ejemplo de Paso por Referencia--->
```cpp
#include <iostream>

void incrementar(int& ref) {
    ref++;
}

int main() {
    int var = 10;
    incrementar(var);
    std::cout << "Valor de var después de incrementar: " << var << std::endl; // Salida: 11

    return 0;
}
<---Ejemplo de Paso por Referencia Result--->
<---Ejemplo de Referencia Constante--->
```cpp
#include <iostream>

void mostrar(const int& ref) {
    std::cout << "Valor: " << ref << std::endl;
}

int main() {
    int var = 10;
    mostrar(var); // Salida: 10

    return 0;
}
<---Ejemplo de Referencia Constante Result--->
<---Ejemplo de Constructor de Copia--->
```cpp
#include <iostream>

class MiClase {
private:
    int valor;

public:
    MiClase(int v) : valor(v) {}
    
    // Constructor de copia
    MiClase(const MiClase& otra) : valor(otra.valor) {
        std::cout << "Constructor de copia llamado" << std::endl;
    }

    int obtenerValor() const { return valor; }
};

int main() {
    MiClase obj1(10);
    MiClase obj2 = obj1; // Llama al constructor de copia

    std::cout << "Valor de obj1: " << obj1.obtenerValor() << std::endl; // Salida: 10
    std::cout << "Valor de obj2: " << obj2.obtenerValor() << std::endl; // Salida: 10

    return 0;
}
<---Ejemplo de Constructor de Copia Result--->
<---Ejemplo de Operador de Asignación--->
```cpp
#include <iostream>

class MiClase {
private:
    int valor;

public:
    MiClase(int v) : valor(v) {}
    
    // Operador de asignación
    MiClase& operator=(const MiClase& otra) {
        if (this != &otra) {
            valor = otra.valor;
        }
        return *this;
    }

    int obtenerValor() const { return valor; }
};

int main() {
    MiClase obj1(10);
    MiClase obj2(20);
    obj2 = obj1; // Llama al operador de asignación

    std::cout << "Valor de obj1: " << obj1.obtenerValor() << std::endl; // Salida: 10
    std::cout << "Valor de obj2: " << obj2.obtenerValor() << std::endl; // Salida: 10

    return 0;
}
<---Ejemplo de Operador de Asignación Result--->
<---Ejemplo de Referencia Dangling (a Evitar)--->
```cpp
int& funcion() {
    int var = 10;
    return var; // var se destruye al salir de la función
}

int main() {
    int& ref = funcion(); // ref ahora es una referencia dangling
    std::cout << ref << std::endl; // Comportamiento indefinido

    return 0;
}
```cpp
void mostrar(const int& ref) {
    std::cout << "Valor: " << ref << std::endl;
}
<---Ejemplo de Referencia Dangling (a Evitar) Result--->
<---Asignación de Memoria--->
```cpp
int* ptr = new int; // Asignar memoria para un entero
*ptr = 10;
std::cout << *ptr << std::endl; // Salida: 10

delete ptr; // Liberar la memoria asignada
<---Asignación de Memoria Result--->
<---Asignación de Memoria para Arreglos--->
```cpp
int size = 5;
int* arr = new int[size]; // Asignar memoria para un arreglo de enteros

for(int i = 0; i < size; ++i) {
    arr[i] = i * 10;
}

for(int i = 0; i < size; ++i) {
    std::cout << arr[i] << " "; // Salida: 0 10 20 30 40
}
std::cout << std::endl;

delete[] arr; // Liberar la memoria asignada para el arreglo
<---Asignación de Memoria para Arreglos Result--->
<---Ejemplo: Clase con Gestión de Memoria Dinámica--->
```cpp
#include <iostream>

class MiClase {
private:
    int* data;
    size_t size;

public:
    // Constructor
    MiClase(size_t s) : size(s) {
        data = new int[size];
        for(size_t i = 0; i < size; ++i) {
            data[i] = i * 10;
        }
    }

    // Destructor
    ~MiClase() {
        delete[] data;
    }

    // Constructor de copia
    MiClase(const MiClase& other) : size(other.size) {
        data = new int[size];
        std::copy(other.data, other.data + size, data);
    }

    // Operador de asignación
    MiClase& operator=(const MiClase& other) {
        if (this == &other) return *this;

        delete[] data;

        size = other.size;
        data = new int[size];
        std::copy(other.data, other.data + size, data);

        return *this;
    }

    void print() const {
        for(size_t i = 0; i < size; ++i) {
            std::cout << data[i] << " ";
        }
        std::cout << std::endl;
    }
};

int main() {
    MiClase obj1(5);
    obj1.print(); // Salida: 0 10 20 30 40

    MiClase obj2 = obj1; // Constructor de copia
    obj2.print(); // Salida: 0 10 20 30 40

    MiClase obj3(3);
    obj3 = obj1; // Operador de asignación
    obj3.print(); // Salida: 0 10 20 30 40

    return 0;
}
<---Ejemplo: Clase con Gestión de Memoria Dinámica Result--->
<---Ejemplo con `std::shared_ptr`--->
```cpp
#include <iostream>
#include <memory>

int main() {
    std::shared_ptr<int> ptr1 = std::make_shared<int>(20);
    std::shared_ptr<int> ptr2 = ptr1;

    std::cout << *ptr1 << std::endl; // Salida: 20
    std::cout << *ptr2 << std::endl; // Salida: 20

    return 0;
}
<---Ejemplo con `std::shared_ptr` Result--->
<---Ejemplo con `std::weak_ptr`--->
```cpp
#include <iostream>
#include <memory>

int main() {
    std::shared_ptr<int> sptr = std::make_shared<int>(30);
    std::weak_ptr<int> wptr = sptr;

    std::cout << "Use count: " << sptr.use_count() << std::endl; // Salida: 1

    if (auto spt = wptr.lock()) {
        std::cout << *spt << std::endl; // Salida: 30
    } else {
        std::cout << "wptr is expired" << std::endl;
    }

    return 0;
}
```cpp
int* ptr = new int(10);
// ...
delete ptr; // Liberar la memoria
```cpp
std::unique_ptr<int> ptr = std::make_unique<int>(10);
```cpp
int* ptr = new int(10);
delete ptr;
ptr = nullptr; // Evitar acceso a memoria liberada
```cpp
class Recurso {
public:
    Recurso() { /* adquirir recurso */ }
    ~Recurso() { /* liberar recurso */ }
};
<---Ejemplo con `std::weak_ptr` Result--->
<---Características:--->
<---Características: Result--->
<---Ejemplo de Uso de `std::unique_ptr`--->
```cpp
#include <iostream>
#include <memory>

int main() {
    std::unique_ptr<int> ptr = std::make_unique<int>(10); // Asignación de memoria
    std::cout << *ptr << std::endl; // Salida: 10

    // ptr2 = ptr; // Error: no se permite la copia de std::unique_ptr

    std::unique_ptr<int> ptr2 = std::move(ptr); // Transferencia de propiedad
    std::cout << *ptr2 << std::endl; // Salida: 10

    // La memoria se libera automáticamente al salir de ámbito
    return 0;
}
<---Ejemplo de Uso de `std::unique_ptr` Result--->
<---Ejemplo de Uso de `std::shared_ptr`--->
```cpp
#include <iostream>
#include <memory>

int main() {
    std::shared_ptr<int> ptr1 = std::make_shared<int>(20); // Asignación de memoria
    std::shared_ptr<int> ptr2 = ptr1; // Compartir la propiedad

    std::cout << *ptr1 << std::endl; // Salida: 20
    std::cout << *ptr2 << std::endl; // Salida: 20
    std::cout << "Use count: " << ptr1.use_count() << std::endl; // Salida: 2

    // La memoria se libera automáticamente cuando el último shared_ptr se destruye
    return 0;
}
<---Ejemplo de Uso de `std::shared_ptr` Result--->
<---Ejemplo de Uso de `std::weak_ptr`--->
```cpp
#include <iostream>
#include <memory>

int main() {
    std::shared_ptr<int> sptr = std::make_shared<int>(30);
    std::weak_ptr<int> wptr = sptr; // No incrementa el contador de referencias

    std::cout << "Use count: " << sptr.use_count() << std::endl; // Salida: 1

    if (auto spt = wptr.lock()) { // Comprobar si el recurso aún existe
        std::cout << *spt << std::endl; // Salida: 30
    } else {
        std::cout << "wptr is expired" << std::endl;
    }

    return 0;
}
```cpp
std::unique_ptr<int> ptr = std::make_unique<int>(10);
```cpp
std::shared_ptr<int> ptr1 = std::make_shared<int>(20);
std::shared_ptr<int> ptr2 = ptr1;
```cpp
class Nodo {
public:
    std::shared_ptr<Nodo> siguiente;
    std::weak_ptr<Nodo> anterior; // Evitar ciclo de referencia
};
<---Ejemplo de Uso de `std::weak_ptr` Result--->
<---Memoria Estática--->
```cpp
#include <iostream>

int globalVariable = 10; // Variable global (memoria estática)

int main() {
    static int staticVariable = 20; // Variable estática local (memoria estática)
    return 0;
}
<---Memoria Estática Result--->
<---Memoria Dinámica--->
<---Memoria Dinámica Result--->
<---Ejemplo Básico de Asignación Dinámica--->
```cpp
#include <iostream>

int main() {
    int* ptr = new int; // Asignar memoria para un entero
    *ptr = 100; // Usar la memoria asignada
    std::cout << *ptr << std::endl; // Salida: 100
    delete ptr; // Liberar la memoria

    return 0;
}
<---Ejemplo Básico de Asignación Dinámica Result--->
<---Ejemplo de Arreglo Dinámico--->
```cpp
#include <iostream>

int main() {
    int size = 5;
    int* array = new int[size]; // Asignar memoria para un arreglo de enteros

    for(int i = 0; i < size; ++i) {
        array[i] = i * 10; // Inicializar el arreglo
    }

    for(int i = 0; i < size; ++i) {
        std::cout << array[i] << " "; // Salida: 0 10 20 30 40
    }
    std::cout << std::endl;

    delete[] array; // Liberar la memoria

    return 0;
}
<---Ejemplo de Arreglo Dinámico Result--->
<---Ejemplo Incorrecto--->
```cpp
int* ptr = new int(10);
delete ptr; // Liberar memoria
std::cout << *ptr << std::endl; // Acceso inválido: comportamiento indefinido
<---Ejemplo Incorrecto Result--->
<---Ejemplo Correcto--->
```cpp
int* ptr = new int(10);
delete ptr; // Liberar memoria
ptr = nullptr; // Evitar acceso inválido
```cpp
#include <iostream>
#include <cstring>

class String {
private:
    char* data;
    size_t size;

public:
    String(const char* str) {
        size = strlen(str);
        data = new char[size + 1];
        strcpy(data, str);
    }

    ~String() {
        delete[] data;
    }

    // Constructor de copia
    String(const String& other) {
        size = other.size;
        data = new char[size + 1];
        strcpy(data, other.data);
    }

    // Operador de asignación
    String& operator=(const String& other) {
        if (this == &other) return *this;

        delete[] data;

        size = other.size;
        data = new char[size + 1];
        strcpy(data, other.data);
        return *this;
    }

    void print() const {
        std::cout << data << std::endl;
    }
};

int main() {
    String str1("Hello");
    String str2 = str1; // Constructor de copia
    String str3("World");
    str3 = str1; // Operador de asignación
    str1.print(); // Salida: Hello
    str2.print(); // Salida: Hello
    str3.print(); // Salida: Hello

    return 0;
}
<---Ejemplo Correcto Result--->
<---Ejemplo con `std::unique_ptr`--->
```cpp
#include <iostream>
#include <memory>

int main() {
    std::unique_ptr<int> ptr = std::make_unique<int>(10);
    std::cout << *ptr << std::endl; // Salida: 10

    return 0;
}
<---Ejemplo con `std::unique_ptr` Result--->
<---Declaración de Punteros--->
```cpp
int* ptr; // Declara un puntero a un entero
<---Declaración de Punteros Result--->
<---Asignación y Acceso a Datos--->
```cpp
int var = 10;
int* ptr = &var; // ptr apunta a la dirección de var

std::cout << "Valor de var: " << var << std::endl; // Salida: 10
std::cout << "Dirección de var: " << &var << std::endl; // Dirección de var
std::cout << "Valor apuntado por ptr: " << *ptr << std::endl; // Salida: 10
```cpp
int arr[5] = {1, 2, 3, 4, 5};
int* ptr = arr; // ptr apunta al primer elemento del arreglo

for(int i = 0; i < 5; ++i) {
    std::cout << *(ptr + i) << " "; // Acceder a los elementos del arreglo usando punteros
}
// Salida: 1 2 3 4 5
```cpp
int arr[5] = {1, 2, 3, 4, 5};
int* ptr = arr;

std::cout << "Primer elemento: " << *ptr << std::endl; // Salida: 1
ptr++;
std::cout << "Segundo elemento: " << *ptr << std::endl; // Salida: 2
```cpp
int var = 10;
int* ptr = &var;
int** ptr2 = &ptr;

std::cout << "Valor de var: " << var << std::endl; // Salida: 10
std::cout << "Valor apuntado por ptr: " << *ptr << std::endl; // Salida: 10
std::cout << "Valor apuntado por ptr2: " << **ptr2 << std::endl; // Salida: 10
```cpp
int* ptr = nullptr; // Puntero inicializado a nullptr
```cpp
int* ptr = new int(10);
delete ptr; // Liberar memoria asignada
ptr = nullptr; // Evitar acceso a memoria liberada
```cpp
int* ptr = new int(10);
delete ptr;
ptr = nullptr; // Ahora ptr no es un puntero colgante
<---Asignación y Acceso a Datos Result--->
<---Paso por Referencia usando Punteros--->
```cpp
#include <iostream>

void incrementar(int* ptr) {
    (*ptr)++;
}

int main() {
    int var = 10;
    incrementar(&var);
    std::cout << "Valor de var después de incrementar: " << var << std::endl; // Salida: 11

    return 0;
}
<---Paso por Referencia usando Punteros Result--->
<---Ejemplo de Puntero a Función--->
```cpp
#include <iostream>

void saludo() {
    std::cout << "Hola, Mundo!" << std::endl;
}

void llamarFuncion(void (*func)()) {
    func();
}

int main() {
    void (*ptrFunc)() = &saludo;
    llamarFuncion(ptrFunc); // Salida: Hola, Mundo!

    return 0;
}
<---Ejemplo de Puntero a Función Result--->
<---Declaración Básica--->
```cpp
int var = 10;
int& ref = var; // ref es una referencia a var

std::cout << "var: " << var << std::endl; // Salida: 10
std::cout << "ref: " << ref << std::endl; // Salida: 10
<---Declaración Básica Result--->
<---Modificación a través de Referencias--->
```cpp
int var = 10;
int& ref = var;

ref = 20; // Modifica var a través de ref

std::cout << "var: " << var << std::endl; // Salida: 20
std::cout << "ref: " << ref << std::endl; // Salida: 20
<---Modificación a través de Referencias Result--->
<---Ejemplo de Paso por Referencia--->
```cpp
#include <iostream>

void incrementar(int& ref) {
    ref++;
}

int main() {
    int var = 10;
    incrementar(var);
    std::cout << "Valor de var después de incrementar: " << var << std::endl; // Salida: 11

    return 0;
}
<---Ejemplo de Paso por Referencia Result--->
<---Ejemplo de Referencia Constante--->
```cpp
#include <iostream>

void mostrar(const int& ref) {
    std::cout << "Valor: " << ref << std::endl;
}

int main() {
    int var = 10;
    mostrar(var); // Salida: 10

    return 0;
}
<---Ejemplo de Referencia Constante Result--->
<---Ejemplo de Constructor de Copia--->
```cpp
#include <iostream>

class MiClase {
private:
    int valor;

public:
    MiClase(int v) : valor(v) {}
    
    // Constructor de copia
    MiClase(const MiClase& otra) : valor(otra.valor) {
        std::cout << "Constructor de copia llamado" << std::endl;
    }

    int obtenerValor() const { return valor; }
};

int main() {
    MiClase obj1(10);
    MiClase obj2 = obj1; // Llama al constructor de copia

    std::cout << "Valor de obj1: " << obj1.obtenerValor() << std::endl; // Salida: 10
    std::cout << "Valor de obj2: " << obj2.obtenerValor() << std::endl; // Salida: 10

    return 0;
}
<---Ejemplo de Constructor de Copia Result--->
<---Ejemplo de Operador de Asignación--->
```cpp
#include <iostream>

class MiClase {
private:
    int valor;

public:
    MiClase(int v) : valor(v) {}
    
    // Operador de asignación
    MiClase& operator=(const MiClase& otra) {
        if (this != &otra) {
            valor = otra.valor;
        }
        return *this;
    }

    int obtenerValor() const { return valor; }
};

int main() {
    MiClase obj1(10);
    MiClase obj2(20);
    obj2 = obj1; // Llama al operador de asignación

    std::cout << "Valor de obj1: " << obj1.obtenerValor() << std::endl; // Salida: 10
    std::cout << "Valor de obj2: " << obj2.obtenerValor() << std::endl; // Salida: 10

    return 0;
}
<---Ejemplo de Operador de Asignación Result--->
<---Ejemplo de Referencia Dangling (a Evitar)--->
```cpp
int& funcion() {
    int var = 10;
    return var; // var se destruye al salir de la función
}

int main() {
    int& ref = funcion(); // ref ahora es una referencia dangling
    std::cout << ref << std::endl; // Comportamiento indefinido

    return 0;
}
```cpp
void mostrar(const int& ref) {
    std::cout << "Valor: " << ref << std::endl;
}
<---Ejemplo de Referencia Dangling (a Evitar) Result--->
<---Asignación de Memoria--->
```cpp
int* ptr = new int; // Asignar memoria para un entero
*ptr = 10;
std::cout << *ptr << std::endl; // Salida: 10

delete ptr; // Liberar la memoria asignada
<---Asignación de Memoria Result--->
<---Asignación de Memoria para Arreglos--->
```cpp
int size = 5;
int* arr = new int[size]; // Asignar memoria para un arreglo de enteros

for(int i = 0; i < size; ++i) {
    arr[i] = i * 10;
}

for(int i = 0; i < size; ++i) {
    std::cout << arr[i] << " "; // Salida: 0 10 20 30 40
}
std::cout << std::endl;

delete[] arr; // Liberar la memoria asignada para el arreglo
<---Asignación de Memoria para Arreglos Result--->
<---Ejemplo: Clase con Gestión de Memoria Dinámica--->
```cpp
#include <iostream>

class MiClase {
private:
    int* data;
    size_t size;

public:
    // Constructor
    MiClase(size_t s) : size(s) {
        data = new int[size];
        for(size_t i = 0; i < size; ++i) {
            data[i] = i * 10;
        }
    }

    // Destructor
    ~MiClase() {
        delete[] data;
    }

    // Constructor de copia
    MiClase(const MiClase& other) : size(other.size) {
        data = new int[size];
        std::copy(other.data, other.data + size, data);
    }

    // Operador de asignación
    MiClase& operator=(const MiClase& other) {
        if (this == &other) return *this;

        delete[] data;

        size = other.size;
        data = new int[size];
        std::copy(other.data, other.data + size, data);

        return *this;
    }

    void print() const {
        for(size_t i = 0; i < size; ++i) {
            std::cout << data[i] << " ";
        }
        std::cout << std::endl;
    }
};

int main() {
    MiClase obj1(5);
    obj1.print(); // Salida: 0 10 20 30 40

    MiClase obj2 = obj1; // Constructor de copia
    obj2.print(); // Salida: 0 10 20 30 40

    MiClase obj3(3);
    obj3 = obj1; // Operador de asignación
    obj3.print(); // Salida: 0 10 20 30 40

    return 0;
}
<---Ejemplo: Clase con Gestión de Memoria Dinámica Result--->
<---Ejemplo con `std::shared_ptr`--->
```cpp
#include <iostream>
#include <memory>

int main() {
    std::shared_ptr<int> ptr1 = std::make_shared<int>(20);
    std::shared_ptr<int> ptr2 = ptr1;

    std::cout << *ptr1 << std::endl; // Salida: 20
    std::cout << *ptr2 << std::endl; // Salida: 20

    return 0;
}
<---Ejemplo con `std::shared_ptr` Result--->
<---Ejemplo con `std::weak_ptr`--->
```cpp
#include <iostream>
#include <memory>

int main() {
    std::shared_ptr<int> sptr = std::make_shared<int>(30);
    std::weak_ptr<int> wptr = sptr;

    std::cout << "Use count: " << sptr.use_count() << std::endl; // Salida: 1

    if (auto spt = wptr.lock()) {
        std::cout << *spt << std::endl; // Salida: 30
    } else {
        std::cout << "wptr is expired" << std::endl;
    }

    return 0;
}
```cpp
int* ptr = new int(10);
// ...
delete ptr; // Liberar la memoria
```cpp
std::unique_ptr<int> ptr = std::make_unique<int>(10);
```cpp
int* ptr = new int(10);
delete ptr;
ptr = nullptr; // Evitar acceso a memoria liberada
```cpp
class Recurso {
public:
    Recurso() { /* adquirir recurso */ }
    ~Recurso() { /* liberar recurso */ }
};
<---Ejemplo con `std::weak_ptr` Result--->
<---Características:--->
<---Características: Result--->
<---Ejemplo de Uso de `std::unique_ptr`--->
```cpp
#include <iostream>
#include <memory>

int main() {
    std::unique_ptr<int> ptr = std::make_unique<int>(10); // Asignación de memoria
    std::cout << *ptr << std::endl; // Salida: 10

    // ptr2 = ptr; // Error: no se permite la copia de std::unique_ptr

    std::unique_ptr<int> ptr2 = std::move(ptr); // Transferencia de propiedad
    std::cout << *ptr2 << std::endl; // Salida: 10

    // La memoria se libera automáticamente al salir de ámbito
    return 0;
}
<---Ejemplo de Uso de `std::unique_ptr` Result--->
<---Ejemplo de Uso de `std::shared_ptr`--->
```cpp
#include <iostream>
#include <memory>

int main() {
    std::shared_ptr<int> ptr1 = std::make_shared<int>(20); // Asignación de memoria
    std::shared_ptr<int> ptr2 = ptr1; // Compartir la propiedad

    std::cout << *ptr1 << std::endl; // Salida: 20
    std::cout << *ptr2 << std::endl; // Salida: 20
    std::cout << "Use count: " << ptr1.use_count() << std::endl; // Salida: 2

    // La memoria se libera automáticamente cuando el último shared_ptr se destruye
    return 0;
}
<---Ejemplo de Uso de `std::shared_ptr` Result--->
<---Ejemplo de Uso de `std::weak_ptr`--->
```cpp
#include <iostream>
#include <memory>

int main() {
    std::shared_ptr<int> sptr = std::make_shared<int>(30);
    std::weak_ptr<int> wptr = sptr; // No incrementa el contador de referencias

    std::cout << "Use count: " << sptr.use_count() << std::endl; // Salida: 1

    if (auto spt = wptr.lock()) { // Comprobar si el recurso aún existe
        std::cout << *spt << std::endl; // Salida: 30
    } else {
        std::cout << "wptr is expired" << std::endl;
    }

    return 0;
}
```cpp
std::unique_ptr<int> ptr = std::make_unique<int>(10);
```cpp
std::shared_ptr<int> ptr1 = std::make_shared<int>(20);
std::shared_ptr<int> ptr2 = ptr1;
```cpp
class Nodo {
public:
    std::shared_ptr<Nodo> siguiente;
    std::weak_ptr<Nodo> anterior; // Evitar ciclo de referencia
};
<---Ejemplo de Uso de `std::weak_ptr` Result--->
<---Declaración y Asignación--->
```cpp
#include <iostream>
#include <memory>

int main() {
    std::unique_ptr<int> ptr = std::make_unique<int>(10);
    std::cout << *ptr << std::endl; // Salida: 10
    // Memoria liberada automáticamente al salir del alcance
    return 0;
}
<---Declaración y Asignación Result--->
<---Declaración en el Archivo de Cabecera (.h)--->
```cpp
// MiClase.h
#ifndef MICLASE_H
#define MICLASE_H

#include <memory>
#include <string>

class MiClase {
public:
    MiClase(const std::string& nombre);
    ~MiClase();

    void mostrar() const;

private:
    std::unique_ptr<std::string> nombre_;
};

#endif // MICLASE_H
<---Declaración en el Archivo de Cabecera (.h) Result--->
<---Definición en el Archivo de Implementación (.cpp)--->
```cpp
// MiClase.cpp
#include "MiClase.h"
#include <iostream>

// Constructor
MiClase::MiClase(const std::string& nombre)
    : nombre_(std::make_unique<std::string>(nombre)) {}

// Destructor
MiClase::~MiClase() {
    // `std::unique_ptr` libera la memoria automáticamente
}

// Método mostrar
void MiClase::mostrar() const {
    std::cout << "Nombre: " << *nombre_ << std::endl;
}
<---Definición en el Archivo de Implementación (.cpp) Result--->
<---Ejemplo de Transferencia de Propiedad--->
```cpp
#include <iostream>
#include <memory>

void mostrar(std::unique_ptr<int> ptr) {
    std::cout << *ptr << std::endl;
}

int main() {
    std::unique_ptr<int> ptr = std::make_unique<int>(42);
    mostrar(std::move(ptr)); // Transferir la propiedad
    // ptr ya no es válido aquí
    return 0;
}
<---Ejemplo de Transferencia de Propiedad Result--->
<---1. Encapsulación de Recursos--->
```cpp
class Archivo {
public:
    Archivo(const std::string& nombre) : archivo_(std::fopen(nombre.c_str(), "r")) {
        if (!archivo_) {
            throw std::runtime_error("No se pudo abrir el archivo");
        }
    }

    ~Archivo() {
        if (archivo_) {
            std::fclose(archivo_);
        }
    }

private:
    std::unique_ptr<FILE, decltype(&std::fclose)> archivo_;
};
<---1. Encapsulación de Recursos Result--->
<---2. Uso en Contenedores--->
```cpp
#include <vector>
#include <memory>

int main() {
    std::vector<std::unique_ptr<int>> vec;
    vec.push_back(std::make_unique<int>(1));
    vec.push_back(std::make_unique<int>(2));
    vec.push_back(std::make_unique<int>(3));

    for (const auto& ptr : vec) {
        std::cout << *ptr << std::endl;
    }
    return 0;
}
<---2. Uso en Contenedores Result--->
<---3. Evitar el Uso de Punteros Crudos--->
<---3. Evitar el Uso de Punteros Crudos Result--->
<---Archivo de Cabecera (.h)--->
```cpp
// GestorRecurso.h
#ifndef GESTORRECURSO_H
#define GESTORRECURSO_H

#include <memory>
#include <string>

class GestorRecurso {
public:
    GestorRecurso(const std::string& nombre);
    void mostrarRecurso() const;

    // Transferir la propiedad del recurso
    std::unique_ptr<std::string> transferirRecurso();

private:
    std::unique_ptr<std::string> recurso_;
};

#endif // GESTORRECURSO_H
<---Archivo de Cabecera (.h) Result--->
<---Archivo de Implementación (.cpp)--->
```cpp
// GestorRecurso.cpp
#include "GestorRecurso.h"
#include <iostream>

GestorRecurso::GestorRecurso(const std::string& nombre)
    : recurso_(std::make_unique<std::string>(nombre)) {}

void GestorRecurso::mostrarRecurso() const {
    std::cout << "Recurso: " << *recurso_ << std::endl;
}

std::unique_ptr<std::string> GestorRecurso::transferirRecurso() {
    return std::move(recurso_);
}
<---Archivo de Implementación (.cpp) Result--->
<---Función Principal--->
```cpp
#include <iostream>
#include "GestorRecurso.h"

int main() {
    GestorRecurso gestor("MiRecurso");
    gestor.mostrarRecurso();

    std::unique_ptr<std::string> recurso = gestor.transferirRecurso();
    if (recurso) {
        std::cout << "Recurso transferido: " << *recurso << std::endl;
    }

    // Intentar mostrar el recurso después de la transferencia
    gestor.mostrarRecurso(); // Esto no imprimirá nada ya que el recurso fue transferido

    return 0;
}
<---Función Principal Result--->
