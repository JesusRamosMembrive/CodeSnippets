<---EXPLANATION--->
### `std::weak_ptr` en Profundidad

`std::weak_ptr` es un tipo de puntero inteligente en C++ que proporciona una referencia no propietaria a un objeto gestionado por `std::shared_ptr`. Su principal uso es evitar ciclos de referencia que pueden provocar fugas de memoria. `std::weak_ptr` no afecta el conteo de referencias de `std::shared_ptr`, permitiendo una referencia segura y controlada a los objetos sin extender su vida útil.

#### Declaraciones y Uso Básico

##### Declaración y Asignación

Para declarar un `std::weak_ptr`, se incluye la cabecera `<memory>`. Un `std::weak_ptr` debe ser inicializado con un `std::shared_ptr`.

```cpp
#include <iostream>
#include <memory>

int main() {
    std::shared_ptr<int> sptr = std::make_shared<int>(42);
    std::weak_ptr<int> wptr = sptr; // Inicializar con shared_ptr

    std::cout << "Use count: " << sptr.use_count() << std::endl; // Salida: 1
    return 0;
}
```

#### Uso de `lock` para Acceder al Objeto

El método `lock` de `std::weak_ptr` retorna un `std::shared_ptr` que comparte la propiedad del objeto si el objeto aún existe; de lo contrario, retorna un `nullptr`.

```cpp
#include <iostream>
#include <memory>

int main() {
    std::shared_ptr<int> sptr = std::make_shared<int>(42);
    std::weak_ptr<int> wptr = sptr;

    if (auto spt = wptr.lock()) { // Crear shared_ptr temporal
        std::cout << *spt << std::endl; // Salida: 42
    } else {
        std::cout << "El recurso ya no está disponible." << std::endl;
    }

    sptr.reset(); // Liberar el recurso

    if (auto spt = wptr.lock()) {
        std::cout << *spt << std::endl;
    } else {
        std::cout << "El recurso ya no está disponible." << std::endl; // Salida esperada
    }

    return 0;
}
```

#### Evitar Ciclos de Referencia

El uso más común de `std::weak_ptr` es evitar ciclos de referencia en estructuras de datos como grafos o árboles, donde los nodos pueden tener referencias entre sí.

##### Ejemplo de Ciclo de Referencia Evitado con `std::weak_ptr`

###### Declaración en el Archivo de Cabecera (.h)

```cpp
// Nodo.h
#ifndef NODO_H
#define NODO_H

#include <memory>
#include <vector>

class Nodo {
public:
    Nodo(int valor);
    void agregarHijo(std::shared_ptr<Nodo> hijo);
    void establecerPadre(std::weak_ptr<Nodo> padre);
    void mostrar() const;

private:
    int valor_;
    std::vector<std::shared_ptr<Nodo>> hijos_;
    std::weak_ptr<Nodo> padre_; // Referencia no propietaria
};

#endif // NODO_H
```

###### Definición en el Archivo de Implementación (.cpp)

```cpp
// Nodo.cpp
#include "Nodo.h"
#include <iostream>

Nodo::Nodo(int valor) : valor_(valor) {}

void Nodo::agregarHijo(std::shared_ptr<Nodo> hijo) {
    hijos_.push_back(hijo);
}

void Nodo::establecerPadre(std::weak_ptr<Nodo> padre) {
    padre_ = padre;
}

void Nodo::mostrar() const {
    std::cout << "Nodo: " << valor_ << std::endl;
    if (auto p = padre_.lock()) {
        std::cout << " Padre: " << p->valor_ << std::endl;
    } else {
        std::cout << " Sin padre" << std::endl;
    }
    for (const auto& hijo : hijos_) {
        hijo->mostrar();
    }
}
```

###### Función Principal

```cpp
#include <iostream>
#include "Nodo.h"

int main() {
    auto nodo1 = std::make_shared<Nodo>(1);
    auto nodo2 = std::make_shared<Nodo>(2);
    auto nodo3 = std::make_shared<Nodo>(3);

    nodo1->agregarHijo(nodo2);
    nodo2->establecerPadre(nodo1);
    nodo2->agregarHijo(nodo3);
    nodo3->establecerPadre(nodo2);

    nodo1->mostrar();

    return 0;
}
```

#### Buenas Prácticas con `std::weak_ptr`

##### 1. Utilizar `std::weak_ptr` para Referencias a Objetos de Vida Útil Controlada

Use `std::weak_ptr` para referencias que no deberían extender la vida útil del objeto, como en el caso de cachés, observadores o nodos de grafos.

```cpp
#include <iostream>
#include <memory>
#include <vector>

class Observador {
public:
    virtual void actualizar() = 0;
};

class Sujeto {
public:
    void agregarObservador(std::shared_ptr<Observador> obs) {
        observadores_.push_back(obs);
    }

    void notificar() {
        for (auto& obs : observadores_) {
            if (auto sp = obs.lock()) {
                sp->actualizar();
            }
        }
    }

private:
    std::vector<std::weak_ptr<Observador>> observadores_;
};

class ConcretoObservador : public Observador, public std::enable_shared_from_this<ConcretoObservador> {
public:
    void actualizar() override {
        std::cout << "Observador actualizado!" << std::endl;
    }

    void suscribirse(Sujeto& sujeto) {
        sujeto.agregarObservador(shared_from_this());
    }
};

int main() {
    Sujeto sujeto;
    auto obs = std::make_shared<ConcretoObservador>();
    obs->suscribirse(sujeto);

    sujeto.notificar(); // Salida: Observador actualizado!

    return 0;
}
```

##### 2. Usar `std::weak_ptr` en Estructuras de Datos Complejas

En estructuras de datos complejas como grafos o árboles, `std::weak_ptr` es ideal para evitar ciclos de referencia.

```cpp
#include <memory>
#include <iostream>

class Nodo {
public:
    Nodo(int valor) : valor_(valor) {}

    void agregarHijo(std::shared_ptr<Nodo> hijo) {
        hijos_.push_back(hijo);
        hijo->padre_ = weak_from_this();
    }

    void mostrar() const {
        std::cout << "Nodo: " << valor_ << std::endl;
        for (const auto& hijo : hijos_) {
            hijo->mostrar();
        }
    }

private:
    int valor_;
    std::vector<std::shared_ptr<Nodo>> hijos_;
    std::weak_ptr<Nodo> padre_; // Referencia no propietaria
};

int main() {
    auto nodo1 = std::make_shared<Nodo>(1);
    auto nodo2 = std::make_shared<Nodo>(2);
    auto nodo3 = std::make_shared<Nodo>(3);

    nodo1->agregarHijo(nodo2);
    nodo2->agregarHijo(nodo3);

    nodo1->mostrar(); // Muestra la jerarquía completa

    return 0;
}
```

### Conclusión

`std::weak_ptr` es una herramienta crucial en C++ para gestionar referencias no propietarias y evitar ciclos de referencia que pueden provocar fugas de memoria. Su uso adecuado en conjunción con `std::shared_ptr` asegura una gestión de memoria eficiente y segura en aplicaciones complejas. Al comprender y aplicar las mejores prácticas para `std::weak_ptr`, los desarrolladores pueden escribir código más robusto y mantenible.
<---FILES--->
Declaración y Asignación
Declaración y Asignación Result
Ejemplo de Ciclo de Referencia Evitado con `std::weak_ptr`
Ejemplo de Ciclo de Referencia Evitado con `std::weak_ptr` Result
Declaración en el Archivo de Cabecera (.h)
Declaración en el Archivo de Cabecera (.h) Result
Definición en el Archivo de Implementación (.cpp)
Definición en el Archivo de Implementación (.cpp) Result
Función Principal
Función Principal Result
1. Utilizar `std::weak_ptr` para Referencias a Objetos de Vida Útil Controlada
1. Utilizar `std::weak_ptr` para Referencias a Objetos de Vida Útil Controlada Result
2. Usar `std::weak_ptr` en Estructuras de Datos Complejas
2. Usar `std::weak_ptr` en Estructuras de Datos Complejas Result
<---Declaración y Asignación--->
```cpp
#include <iostream>
#include <memory>

int main() {
    std::shared_ptr<int> sptr = std::make_shared<int>(42);
    std::weak_ptr<int> wptr = sptr; // Inicializar con shared_ptr

    std::cout << "Use count: " << sptr.use_count() << std::endl; // Salida: 1
    return 0;
}
```cpp
#include <iostream>
#include <memory>

int main() {
    std::shared_ptr<int> sptr = std::make_shared<int>(42);
    std::weak_ptr<int> wptr = sptr;

    if (auto spt = wptr.lock()) { // Crear shared_ptr temporal
        std::cout << *spt << std::endl; // Salida: 42
    } else {
        std::cout << "El recurso ya no está disponible." << std::endl;
    }

    sptr.reset(); // Liberar el recurso

    if (auto spt = wptr.lock()) {
        std::cout << *spt << std::endl;
    } else {
        std::cout << "El recurso ya no está disponible." << std::endl; // Salida esperada
    }

    return 0;
}
<---Declaración y Asignación Result--->
<---Ejemplo de Ciclo de Referencia Evitado con `std::weak_ptr`--->
<---Ejemplo de Ciclo de Referencia Evitado con `std::weak_ptr` Result--->
<---Declaración en el Archivo de Cabecera (.h)--->
```cpp
// Nodo.h
#ifndef NODO_H
#define NODO_H

#include <memory>
#include <vector>

class Nodo {
public:
    Nodo(int valor);
    void agregarHijo(std::shared_ptr<Nodo> hijo);
    void establecerPadre(std::weak_ptr<Nodo> padre);
    void mostrar() const;

private:
    int valor_;
    std::vector<std::shared_ptr<Nodo>> hijos_;
    std::weak_ptr<Nodo> padre_; // Referencia no propietaria
};

#endif // NODO_H
<---Declaración en el Archivo de Cabecera (.h) Result--->
<---Definición en el Archivo de Implementación (.cpp)--->
```cpp
// Nodo.cpp
#include "Nodo.h"
#include <iostream>

Nodo::Nodo(int valor) : valor_(valor) {}

void Nodo::agregarHijo(std::shared_ptr<Nodo> hijo) {
    hijos_.push_back(hijo);
}

void Nodo::establecerPadre(std::weak_ptr<Nodo> padre) {
    padre_ = padre;
}

void Nodo::mostrar() const {
    std::cout << "Nodo: " << valor_ << std::endl;
    if (auto p = padre_.lock()) {
        std::cout << " Padre: " << p->valor_ << std::endl;
    } else {
        std::cout << " Sin padre" << std::endl;
    }
    for (const auto& hijo : hijos_) {
        hijo->mostrar();
    }
}
<---Definición en el Archivo de Implementación (.cpp) Result--->
<---Función Principal--->
```cpp
#include <iostream>
#include "Nodo.h"

int main() {
    auto nodo1 = std::make_shared<Nodo>(1);
    auto nodo2 = std::make_shared<Nodo>(2);
    auto nodo3 = std::make_shared<Nodo>(3);

    nodo1->agregarHijo(nodo2);
    nodo2->establecerPadre(nodo1);
    nodo2->agregarHijo(nodo3);
    nodo3->establecerPadre(nodo2);

    nodo1->mostrar();

    return 0;
}
<---Función Principal Result--->
<---1. Utilizar `std::weak_ptr` para Referencias a Objetos de Vida Útil Controlada--->
```cpp
#include <iostream>
#include <memory>
#include <vector>

class Observador {
public:
    virtual void actualizar() = 0;
};

class Sujeto {
public:
    void agregarObservador(std::shared_ptr<Observador> obs) {
        observadores_.push_back(obs);
    }

    void notificar() {
        for (auto& obs : observadores_) {
            if (auto sp = obs.lock()) {
                sp->actualizar();
            }
        }
    }

private:
    std::vector<std::weak_ptr<Observador>> observadores_;
};

class ConcretoObservador : public Observador, public std::enable_shared_from_this<ConcretoObservador> {
public:
    void actualizar() override {
        std::cout << "Observador actualizado!" << std::endl;
    }

    void suscribirse(Sujeto& sujeto) {
        sujeto.agregarObservador(shared_from_this());
    }
};

int main() {
    Sujeto sujeto;
    auto obs = std::make_shared<ConcretoObservador>();
    obs->suscribirse(sujeto);

    sujeto.notificar(); // Salida: Observador actualizado!

    return 0;
}
<---1. Utilizar `std::weak_ptr` para Referencias a Objetos de Vida Útil Controlada Result--->
<---2. Usar `std::weak_ptr` en Estructuras de Datos Complejas--->
```cpp
#include <memory>
#include <iostream>

class Nodo {
public:
    Nodo(int valor) : valor_(valor) {}

    void agregarHijo(std::shared_ptr<Nodo> hijo) {
        hijos_.push_back(hijo);
        hijo->padre_ = weak_from_this();
    }

    void mostrar() const {
        std::cout << "Nodo: " << valor_ << std::endl;
        for (const auto& hijo : hijos_) {
            hijo->mostrar();
        }
    }

private:
    int valor_;
    std::vector<std::shared_ptr<Nodo>> hijos_;
    std::weak_ptr<Nodo> padre_; // Referencia no propietaria
};

int main() {
    auto nodo1 = std::make_shared<Nodo>(1);
    auto nodo2 = std::make_shared<Nodo>(2);
    auto nodo3 = std::make_shared<Nodo>(3);

    nodo1->agregarHijo(nodo2);
    nodo2->agregarHijo(nodo3);

    nodo1->mostrar(); // Muestra la jerarquía completa

    return 0;
}
<---2. Usar `std::weak_ptr` en Estructuras de Datos Complejas Result--->
