<---EXPLANATION--->
### Gestión de Memoria en C++

La gestión de memoria en C++ es un aspecto fundamental que todo desarrollador debe entender profundamente para evitar errores comunes como fugas de memoria y accesos inválidos. A diferencia de lenguajes de programación que manejan la memoria automáticamente, C++ permite y requiere que el programador gestione la asignación y liberación de memoria.

#### Tipos de Memoria en C++

En C++, la memoria se puede clasificar en dos tipos principales: memoria estática y memoria dinámica.

1. **Memoria Estática**: Se asigna en el tiempo de compilación. Incluye variables globales, variables estáticas y constantes.
2. **Memoria Dinámica**: Se asigna en el tiempo de ejecución usando operadores como `new` y `delete`.

#### Asignación y Liberación de Memoria

##### Memoria Estática

La memoria estática se gestiona automáticamente. Por ejemplo:

```cpp
#include <iostream>

int globalVariable = 10; // Variable global (memoria estática)

int main() {
    static int staticVariable = 20; // Variable estática local (memoria estática)
    return 0;
}
```

##### Memoria Dinámica

La memoria dinámica se asigna y libera manualmente usando `new` y `delete` para variables simples, y `new[]` y `delete[]` para arreglos.

##### Ejemplo Básico de Asignación Dinámica

```cpp
#include <iostream>

int main() {
    int* ptr = new int; // Asignar memoria para un entero
    *ptr = 100; // Usar la memoria asignada
    std::cout << *ptr << std::endl; // Salida: 100
    delete ptr; // Liberar la memoria

    return 0;
}
```

##### Ejemplo de Arreglo Dinámico

```cpp
#include <iostream>

int main() {
    int size = 5;
    int* array = new int[size]; // Asignar memoria para un arreglo de enteros

    for(int i = 0; i < size; ++i) {
        array[i] = i * 10; // Inicializar el arreglo
    }

    for(int i = 0; i < size; ++i) {
        std::cout << array[i] << " "; // Salida: 0 10 20 30 40
    }
    std::cout << std::endl;

    delete[] array; // Liberar la memoria

    return 0;
}
```

### Buenas Prácticas para la Gestión de Memoria

#### 1. Siempre Liberar la Memoria Asignada

No liberar la memoria asignada dinámicamente resulta en fugas de memoria, lo que puede llevar a que una aplicación consuma más memoria de la necesaria y eventualmente falle.

##### Ejemplo Incorrecto

```cpp
int* ptr = new int; // Asignar memoria
// ... uso de ptr
// Olvidar liberar la memoria: fuga de memoria
```

##### Ejemplo Correcto

```cpp
int* ptr = new int; // Asignar memoria
// ... uso de ptr
delete ptr; // Liberar memoria
```

#### 2. Usar Smart Pointers

Los punteros inteligentes (`smart pointers`) en la biblioteca estándar de C++ (`std::unique_ptr`, `std::shared_ptr`, etc.) ayudan a manejar la memoria de manera automática y evitar fugas de memoria.

##### Ejemplo con `std::unique_ptr`

```cpp
#include <iostream>
#include <memory>

int main() {
    std::unique_ptr<int> ptr = std::make_unique<int>(100); // Asignar memoria
    std::cout << *ptr << std::endl; // Salida: 100
    // Memoria se libera automáticamente cuando ptr sale del alcance

    return 0;
}
```

#### 3. Evitar Accesos Inválidos a Memoria

Acceder a memoria después de haberla liberado resulta en comportamiento indefinido. Siempre asegúrese de no usar punteros después de haber llamado a `delete`.

##### Ejemplo Incorrecto

```cpp
int* ptr = new int(10);
delete ptr; // Liberar memoria
std::cout << *ptr << std::endl; // Acceso inválido: comportamiento indefinido
```

##### Ejemplo Correcto

```cpp
int* ptr = new int(10);
delete ptr; // Liberar memoria
ptr = nullptr; // Evitar acceso inválido
```

### Gestión de Memoria en Clases

Cuando se diseñan clases que manejan recursos dinámicos, es esencial implementar correctamente el constructor de copia, el operador de asignación y el destructor.

#### Ejemplo: Clase con Gestión de Memoria

```cpp
#include <iostream>
#include <cstring>

class String {
private:
    char* data;
    size_t size;

public:
    String(const char* str) {
        size = strlen(str);
        data = new char[size + 1];
        strcpy(data, str);
    }

    ~String() {
        delete[] data;
    }

    // Constructor de copia
    String(const String& other) {
        size = other.size;
        data = new char[size + 1];
        strcpy(data, other.data);
    }

    // Operador de asignación
    String& operator=(const String& other) {
        if (this == &other) return *this;

        delete[] data;

        size = other.size;
        data = new char[size + 1];
        strcpy(data, other.data);
        return *this;
    }

    void print() const {
        std::cout << data << std::endl;
    }
};

int main() {
    String str1("Hello");
    String str2 = str1; // Constructor de copia
    String str3("World");
    str3 = str1; // Operador de asignación
    str1.print(); // Salida: Hello
    str2.print(); // Salida: Hello
    str3.print(); // Salida: Hello

    return 0;
}
```

### Conclusión

La gestión de memoria en C++ es un tema crítico que requiere atención cuidadosa para evitar errores como fugas de memoria y accesos inválidos. El uso de buenas prácticas como liberar memoria correctamente, usar punteros inteligentes y manejar adecuadamente la memoria en clases asegura que las aplicaciones sean eficientes y robustas. Al entender y aplicar estos conceptos, los desarrolladores pueden escribir código más seguro y mantenible.
### Punteros en C++

Los punteros son una característica fundamental en C++ que permite a los desarrolladores manipular la memoria directamente. Un puntero es una variable que almacena la dirección de memoria de otra variable. Comprender cómo funcionan los punteros es crucial para gestionar la memoria dinámica, realizar operaciones avanzadas y optimizar el rendimiento del código.

#### Declaración y Uso de Punteros

##### Declaración de Punteros

La sintaxis básica para declarar un puntero es:

```cpp
int* ptr; // Declara un puntero a un entero
```

##### Asignación y Acceso a Datos

Para asignar una dirección a un puntero y acceder a los datos apuntados, se utilizan los operadores `&` (referencia) y `*` (desreferencia).

```cpp
int var = 10;
int* ptr = &var; // ptr apunta a la dirección de var

std::cout << "Valor de var: " << var << std::endl; // Salida: 10
std::cout << "Dirección de var: " << &var << std::endl; // Dirección de var
std::cout << "Valor apuntado por ptr: " << *ptr << std::endl; // Salida: 10
```

### Operaciones con Punteros

#### Punteros y Arreglos

Los punteros y arreglos están estrechamente relacionados en C++. El nombre de un arreglo es un puntero constante al primer elemento del arreglo.

```cpp
int arr[5] = {1, 2, 3, 4, 5};
int* ptr = arr; // ptr apunta al primer elemento del arreglo

for(int i = 0; i < 5; ++i) {
    std::cout << *(ptr + i) << " "; // Acceder a los elementos del arreglo usando punteros
}
// Salida: 1 2 3 4 5
```

#### Aritmética de Punteros

La aritmética de punteros permite realizar operaciones como suma y resta sobre punteros para navegar por arreglos y estructuras de datos.

```cpp
int arr[5] = {1, 2, 3, 4, 5};
int* ptr = arr;

std::cout << "Primer elemento: " << *ptr << std::endl; // Salida: 1
ptr++;
std::cout << "Segundo elemento: " << *ptr << std::endl; // Salida: 2
```

#### Punteros a Punteros

Un puntero a puntero es una variable que almacena la dirección de otro puntero.

```cpp
int var = 10;
int* ptr = &var;
int** ptr2 = &ptr;

std::cout << "Valor de var: " << var << std::endl; // Salida: 10
std::cout << "Valor apuntado por ptr: " << *ptr << std::endl; // Salida: 10
std::cout << "Valor apuntado por ptr2: " << **ptr2 << std::endl; // Salida: 10
```

### Buenas Prácticas con Punteros

#### Inicializar Punteros

Siempre inicialice los punteros, ya sea asignándoles una dirección válida o estableciéndolos a `nullptr`.

```cpp
int* ptr = nullptr; // Puntero inicializado a nullptr
```

#### Liberar Memoria

Cuando se utiliza memoria dinámica, es crucial liberar la memoria usando `delete` o `delete[]` para evitar fugas de memoria.

```cpp
int* ptr = new int(10);
delete ptr; // Liberar memoria asignada
ptr = nullptr; // Evitar acceso a memoria liberada
```

#### Evitar Punteros Colgantes

Un puntero colgante apunta a una memoria que ha sido liberada. Asignar `nullptr` a los punteros después de liberar la memoria ayuda a evitar este problema.

```cpp
int* ptr = new int(10);
delete ptr;
ptr = nullptr; // Ahora ptr no es un puntero colgante
```

### Ejemplos Avanzados

#### Punteros y Funciones

Los punteros pueden pasarse a funciones para modificar variables fuera del ámbito de la función.

##### Paso por Referencia usando Punteros

```cpp
#include <iostream>

void incrementar(int* ptr) {
    (*ptr)++;
}

int main() {
    int var = 10;
    incrementar(&var);
    std::cout << "Valor de var después de incrementar: " << var << std::endl; // Salida: 11

    return 0;
}
```

#### Punteros a Funciones

Los punteros a funciones permiten almacenar y llamar funciones dinámicamente.

##### Ejemplo de Puntero a Función

```cpp
#include <iostream>

void saludo() {
    std::cout << "Hola, Mundo!" << std::endl;
}

void llamarFuncion(void (*func)()) {
    func();
}

int main() {
    void (*ptrFunc)() = &saludo;
    llamarFuncion(ptrFunc); // Salida: Hola, Mundo!

    return 0;
}
```

### Conclusión

Los punteros en C++ son una herramienta poderosa que permite un control fino sobre la memoria y la gestión de recursos. Sin embargo, también requieren una comprensión cuidadosa y atención a los detalles para evitar errores comunes como fugas de memoria, punteros colgantes y accesos inválidos. Con una buena práctica y el uso de punteros inteligentes, se puede escribir código eficiente y seguro que aproveche al máximo las capacidades del lenguaje C++.
### Referencias en C++

Las referencias son una característica poderosa y segura de C++ que permite crear alias para las variables. A diferencia de los punteros, las referencias no pueden ser nulas y deben ser inicializadas cuando se declaran. Las referencias simplifican la sintaxis y hacen el código más legible, especialmente cuando se pasan parámetros a funciones.

#### Declaración y Uso de Referencias

##### Declaración Básica

Para declarar una referencia, se utiliza el operador `&` seguido del nombre de la referencia.

```cpp
int var = 10;
int& ref = var; // ref es una referencia a var

std::cout << "var: " << var << std::endl; // Salida: 10
std::cout << "ref: " << ref << std::endl; // Salida: 10
```

##### Modificación a través de Referencias

Las referencias pueden ser utilizadas para modificar la variable original a la que hacen referencia.

```cpp
int var = 10;
int& ref = var;

ref = 20; // Modifica var a través de ref

std::cout << "var: " << var << std::endl; // Salida: 20
std::cout << "ref: " << ref << std::endl; // Salida: 20
```

### Referencias y Funciones

Las referencias son especialmente útiles para pasar parámetros a funciones sin hacer copias de los mismos, lo que mejora el rendimiento.

#### Paso por Referencia

Pasar parámetros por referencia permite modificar los argumentos originales dentro de la función.

##### Ejemplo de Paso por Referencia

```cpp
#include <iostream>

void incrementar(int& ref) {
    ref++;
}

int main() {
    int var = 10;
    incrementar(var);
    std::cout << "Valor de var después de incrementar: " << var << std::endl; // Salida: 11

    return 0;
}
```

#### Referencias Constantes

Las referencias constantes permiten pasar parámetros a funciones sin permitir la modificación de los mismos dentro de la función. Esto es útil para optimizar el rendimiento y garantizar la inmutabilidad de los datos.

##### Ejemplo de Referencia Constante

```cpp
#include <iostream>

void mostrar(const int& ref) {
    std::cout << "Valor: " << ref << std::endl;
}

int main() {
    int var = 10;
    mostrar(var); // Salida: 10

    return 0;
}
```

### Referencias en Clases

Las referencias también se utilizan ampliamente en clases para implementar constructores de copia, operadores de asignación y otros métodos.

#### Constructor de Copia

Un constructor de copia utiliza referencias para evitar la creación de copias innecesarias de objetos.

##### Ejemplo de Constructor de Copia

```cpp
#include <iostream>

class MiClase {
private:
    int valor;

public:
    MiClase(int v) : valor(v) {}
    
    // Constructor de copia
    MiClase(const MiClase& otra) : valor(otra.valor) {
        std::cout << "Constructor de copia llamado" << std::endl;
    }

    int obtenerValor() const { return valor; }
};

int main() {
    MiClase obj1(10);
    MiClase obj2 = obj1; // Llama al constructor de copia

    std::cout << "Valor de obj1: " << obj1.obtenerValor() << std::endl; // Salida: 10
    std::cout << "Valor de obj2: " << obj2.obtenerValor() << std::endl; // Salida: 10

    return 0;
}
```

#### Operador de Asignación

El operador de asignación también se implementa usando referencias para evitar copias innecesarias y gestionar la asignación de recursos correctamente.

##### Ejemplo de Operador de Asignación

```cpp
#include <iostream>

class MiClase {
private:
    int valor;

public:
    MiClase(int v) : valor(v) {}
    
    // Operador de asignación
    MiClase& operator=(const MiClase& otra) {
        if (this != &otra) {
            valor = otra.valor;
        }
        return *this;
    }

    int obtenerValor() const { return valor; }
};

int main() {
    MiClase obj1(10);
    MiClase obj2(20);
    obj2 = obj1; // Llama al operador de asignación

    std::cout << "Valor de obj1: " << obj1.obtenerValor() << std::endl; // Salida: 10
    std::cout << "Valor de obj2: " << obj2.obtenerValor() << std::endl; // Salida: 10

    return 0;
}
```

### Buenas Prácticas con Referencias

#### Evitar Referencias Dangling

Las referencias dangling (colgantes) ocurren cuando una referencia apunta a una variable que ha sido destruida o liberada. Siempre asegúrese de que la vida útil del objeto referenciado sea mayor que la de la referencia.

##### Ejemplo de Referencia Dangling (a Evitar)

```cpp
int& funcion() {
    int var = 10;
    return var; // var se destruye al salir de la función
}

int main() {
    int& ref = funcion(); // ref ahora es una referencia dangling
    std::cout << ref << std::endl; // Comportamiento indefinido

    return 0;
}
```

#### Uso de Const en Referencias

Utilice `const` siempre que sea posible para evitar modificaciones accidentales y mejorar la seguridad del código.

```cpp
void mostrar(const int& ref) {
    std::cout << "Valor: " << ref << std::endl;
}
```

### Conclusión

Las referencias en C++ son una herramienta esencial para la manipulación eficiente y segura de variables. Permiten pasar argumentos a funciones sin hacer copias, lo que mejora el rendimiento, y garantizan la inmutabilidad cuando se usan con `const`. Al seguir buenas prácticas y evitar referencias colgantes, se puede escribir código más limpio, seguro y eficiente.
### Gestión Dinámica de la Memoria en C++

La gestión dinámica de la memoria en C++ permite a los desarrolladores asignar y liberar memoria en tiempo de ejecución. Esto es esencial para manejar estructuras de datos cuyo tamaño no puede determinarse en tiempo de compilación y para optimizar el uso de la memoria. Sin embargo, también implica la responsabilidad de liberar la memoria asignada para evitar fugas de memoria y otros errores.

#### Operadores `new` y `delete`

##### Asignación de Memoria

El operador `new` se utiliza para asignar memoria dinámica para un solo objeto o un arreglo de objetos. Devuelve un puntero al tipo especificado.

```cpp
int* ptr = new int; // Asignar memoria para un entero
*ptr = 10;
std::cout << *ptr << std::endl; // Salida: 10

delete ptr; // Liberar la memoria asignada
```

##### Asignación de Memoria para Arreglos

Para asignar memoria para un arreglo, se utiliza `new[]` y para liberarla, `delete[]`.

```cpp
int size = 5;
int* arr = new int[size]; // Asignar memoria para un arreglo de enteros

for(int i = 0; i < size; ++i) {
    arr[i] = i * 10;
}

for(int i = 0; i < size; ++i) {
    std::cout << arr[i] << " "; // Salida: 0 10 20 30 40
}
std::cout << std::endl;

delete[] arr; // Liberar la memoria asignada para el arreglo
```

#### Gestión de Memoria en Clases

Cuando se manejan recursos dinámicos en clases, es crucial implementar correctamente el constructor, destructor, constructor de copia y operador de asignación para gestionar la memoria de manera adecuada.

##### Ejemplo: Clase con Gestión de Memoria Dinámica

```cpp
#include <iostream>

class MiClase {
private:
    int* data;
    size_t size;

public:
    // Constructor
    MiClase(size_t s) : size(s) {
        data = new int[size];
        for(size_t i = 0; i < size; ++i) {
            data[i] = i * 10;
        }
    }

    // Destructor
    ~MiClase() {
        delete[] data;
    }

    // Constructor de copia
    MiClase(const MiClase& other) : size(other.size) {
        data = new int[size];
        std::copy(other.data, other.data + size, data);
    }

    // Operador de asignación
    MiClase& operator=(const MiClase& other) {
        if (this == &other) return *this;

        delete[] data;

        size = other.size;
        data = new int[size];
        std::copy(other.data, other.data + size, data);

        return *this;
    }

    void print() const {
        for(size_t i = 0; i < size; ++i) {
            std::cout << data[i] << " ";
        }
        std::cout << std::endl;
    }
};

int main() {
    MiClase obj1(5);
    obj1.print(); // Salida: 0 10 20 30 40

    MiClase obj2 = obj1; // Constructor de copia
    obj2.print(); // Salida: 0 10 20 30 40

    MiClase obj3(3);
    obj3 = obj1; // Operador de asignación
    obj3.print(); // Salida: 0 10 20 30 40

    return 0;
}
```

### Smart Pointers

C++11 introdujo los punteros inteligentes (`smart pointers`) en la biblioteca estándar (`<memory>`) para ayudar a gestionar la memoria de manera automática y segura. Los tres tipos principales son `std::unique_ptr`, `std::shared_ptr` y `std::weak_ptr`.

#### `std::unique_ptr`

Un `std::unique_ptr` es un puntero exclusivo que posee la memoria a la que apunta y no puede compartirla con otro puntero. Cuando el `unique_ptr` sale de alcance, la memoria se libera automáticamente.

##### Ejemplo con `std::unique_ptr`

```cpp
#include <iostream>
#include <memory>

int main() {
    std::unique_ptr<int> ptr = std::make_unique<int>(10);
    std::cout << *ptr << std::endl; // Salida: 10

    return 0;
}
```

#### `std::shared_ptr`

Un `std::shared_ptr` permite compartir la propiedad de la memoria con múltiples punteros. La memoria se libera cuando el último `shared_ptr` que la posee es destruido.

##### Ejemplo con `std::shared_ptr`

```cpp
#include <iostream>
#include <memory>

int main() {
    std::shared_ptr<int> ptr1 = std::make_shared<int>(20);
    std::shared_ptr<int> ptr2 = ptr1;

    std::cout << *ptr1 << std::endl; // Salida: 20
    std::cout << *ptr2 << std::endl; // Salida: 20

    return 0;
}
```

#### `std::weak_ptr`

Un `std::weak_ptr` es un puntero no propietario que se utiliza junto con `std::shared_ptr` para evitar ciclos de referencia. No afecta la vida útil de la memoria a la que apunta.

##### Ejemplo con `std::weak_ptr`

```cpp
#include <iostream>
#include <memory>

int main() {
    std::shared_ptr<int> sptr = std::make_shared<int>(30);
    std::weak_ptr<int> wptr = sptr;

    std::cout << "Use count: " << sptr.use_count() << std::endl; // Salida: 1

    if (auto spt = wptr.lock()) {
        std::cout << *spt << std::endl; // Salida: 30
    } else {
        std::cout << "wptr is expired" << std::endl;
    }

    return 0;
}
```

### Buenas Prácticas para la Gestión Dinámica de la Memoria

#### 1. Siempre Liberar la Memoria Asignada

Evitar fugas de memoria asegurando que toda la memoria asignada dinámicamente se libera adecuadamente.

```cpp
int* ptr = new int(10);
// ...
delete ptr; // Liberar la memoria
```

#### 2. Usar Smart Pointers

Preferir el uso de punteros inteligentes sobre los punteros crudos para evitar problemas de gestión de memoria.

```cpp
std::unique_ptr<int> ptr = std::make_unique<int>(10);
```

#### 3. Evitar Accesos Inválidos

Asegurarse de no acceder a memoria después de haberla liberado. Asignar `nullptr` a los punteros después de `delete` puede ayudar.

```cpp
int* ptr = new int(10);
delete ptr;
ptr = nullptr; // Evitar acceso a memoria liberada
```

#### 4. Usar RAII (Resource Acquisition Is Initialization)

Utilizar el principio RAII para gestionar recursos, asegurando que la adquisición de un recurso se produce en el constructor y su liberación en el destructor.

```cpp
class Recurso {
public:
    Recurso() { /* adquirir recurso */ }
    ~Recurso() { /* liberar recurso */ }
};
```

### Conclusión

La gestión dinámica de la memoria en C++ proporciona flexibilidad y control, pero también implica la responsabilidad de manejar adecuadamente la asignación y liberación de memoria. El uso de punteros inteligentes y buenas prácticas de programación ayudan a prevenir errores comunes y aseguran que los recursos se gestionen de manera eficiente y segura. Al dominar estas técnicas, los desarrolladores pueden escribir código más robusto y mantenible.
### Punteros Inteligentes en C++

Los punteros inteligentes en C++ son una característica introducida en C++11 que ayuda a gestionar la memoria automáticamente y prevenir fugas de memoria y errores comunes como los punteros colgantes. Los punteros inteligentes son clases de la biblioteca estándar que administran la vida útil de los objetos a los que apuntan. Los tres tipos principales de punteros inteligentes son `std::unique_ptr`, `std::shared_ptr` y `std::weak_ptr`.

#### `std::unique_ptr`

Un `std::unique_ptr` es un puntero inteligente que posee de manera exclusiva la memoria a la que apunta. No puede haber dos `std::unique_ptr` que posean el mismo recurso simultáneamente.

##### Características:
- Exclusividad: No puede haber copias de un `std::unique_ptr`.
- Liberación automática: La memoria se libera automáticamente cuando el `std::unique_ptr` sale de su ámbito.

##### Ejemplo de Uso de `std::unique_ptr`

```cpp
#include <iostream>
#include <memory>

int main() {
    std::unique_ptr<int> ptr = std::make_unique<int>(10); // Asignación de memoria
    std::cout << *ptr << std::endl; // Salida: 10

    // ptr2 = ptr; // Error: no se permite la copia de std::unique_ptr

    std::unique_ptr<int> ptr2 = std::move(ptr); // Transferencia de propiedad
    std::cout << *ptr2 << std::endl; // Salida: 10

    // La memoria se libera automáticamente al salir de ámbito
    return 0;
}
```

#### `std::shared_ptr`

Un `std::shared_ptr` permite compartir la propiedad de la memoria con múltiples punteros. La memoria se libera cuando el último `std::shared_ptr` que posee la memoria se destruye.

##### Características:
- Compartición: Múltiples `std::shared_ptr` pueden apuntar al mismo recurso.
- Contador de referencias: Lleva un conteo de cuántos `std::shared_ptr` están apuntando al recurso.

##### Ejemplo de Uso de `std::shared_ptr`

```cpp
#include <iostream>
#include <memory>

int main() {
    std::shared_ptr<int> ptr1 = std::make_shared<int>(20); // Asignación de memoria
    std::shared_ptr<int> ptr2 = ptr1; // Compartir la propiedad

    std::cout << *ptr1 << std::endl; // Salida: 20
    std::cout << *ptr2 << std::endl; // Salida: 20
    std::cout << "Use count: " << ptr1.use_count() << std::endl; // Salida: 2

    // La memoria se libera automáticamente cuando el último shared_ptr se destruye
    return 0;
}
```

#### `std::weak_ptr`

Un `std::weak_ptr` es un puntero inteligente no propietario que se utiliza junto con `std::shared_ptr` para evitar ciclos de referencia. No afecta el conteo de referencias del `std::shared_ptr`.

##### Características:
- No propietario: No incrementa el contador de referencias.
- Utilizado para evitar ciclos de referencia: Permite la comprobación segura de si el recurso aún existe.

##### Ejemplo de Uso de `std::weak_ptr`

```cpp
#include <iostream>
#include <memory>

int main() {
    std::shared_ptr<int> sptr = std::make_shared<int>(30);
    std::weak_ptr<int> wptr = sptr; // No incrementa el contador de referencias

    std::cout << "Use count: " << sptr.use_count() << std::endl; // Salida: 1

    if (auto spt = wptr.lock()) { // Comprobar si el recurso aún existe
        std::cout << *spt << std::endl; // Salida: 30
    } else {
        std::cout << "wptr is expired" << std::endl;
    }

    return 0;
}
```

### Buenas Prácticas con Punteros Inteligentes

#### 1. Preferir `std::unique_ptr` por Defecto

Utilice `std::unique_ptr` cuando no necesite compartir la propiedad del recurso. Esto asegura que la propiedad sea clara y evita problemas de gestión de memoria.

```cpp
std::unique_ptr<int> ptr = std::make_unique<int>(10);
```

#### 2. Usar `std::shared_ptr` para Propiedad Compartida

Utilice `std::shared_ptr` cuando necesite compartir la propiedad del recurso entre múltiples partes del código.

```cpp
std::shared_ptr<int> ptr1 = std::make_shared<int>(20);
std::shared_ptr<int> ptr2 = ptr1;
```

#### 3. Evitar Ciclos de Referencia con `std::weak_ptr`

Utilice `std::weak_ptr` junto con `std::shared_ptr` para evitar ciclos de referencia que pueden causar fugas de memoria.

```cpp
class Nodo {
public:
    std::shared_ptr<Nodo> siguiente;
    std::weak_ptr<Nodo> anterior; // Evitar ciclo de referencia
};
```

#### 4. Evitar el Uso de Punteros Crudos

Prefiera los punteros inteligentes sobre los punteros crudos para gestionar automáticamente la vida útil de los recursos y evitar errores comunes.

### Conclusión

Los punteros inteligentes en C++ proporcionan una forma segura y eficiente de gestionar la memoria dinámica. Al utilizar `std::unique_ptr`, `std::shared_ptr` y `std::weak_ptr`, los desarrolladores pueden prevenir fugas de memoria y errores de acceso a memoria, mejorando la robustez y mantenibilidad del código. Siguiendo buenas prácticas y eligiendo el tipo de puntero inteligente adecuado para cada situación, se puede aprovechar al máximo esta poderosa característica del lenguaje.
### `std::unique_ptr` en Profundidad

`std::unique_ptr` es un puntero inteligente que proporciona propiedad exclusiva sobre un recurso. Es una herramienta poderosa para gestionar la memoria dinámica y asegurar que los recursos sean liberados correctamente cuando ya no se necesiten. Aquí profundizaremos en su uso, las mejores prácticas y cómo integrarlo en proyectos más grandes.

#### Declaraciones y Uso Básico

##### Declaración y Asignación

Para declarar un `std::unique_ptr`, se incluye la cabecera `<memory>` y se puede utilizar `std::make_unique` para asignar memoria.

```cpp
#include <iostream>
#include <memory>

int main() {
    std::unique_ptr<int> ptr = std::make_unique<int>(10);
    std::cout << *ptr << std::endl; // Salida: 10
    // Memoria liberada automáticamente al salir del alcance
    return 0;
}
```

#### En Clases y Archivos de Cabecera

El uso de `std::unique_ptr` en clases permite una gestión de recursos clara y segura. Aquí se muestra cómo declarar y definir una clase que utiliza `std::unique_ptr`.

##### Declaración en el Archivo de Cabecera (.h)

```cpp
// MiClase.h
#ifndef MICLASE_H
#define MICLASE_H

#include <memory>
#include <string>

class MiClase {
public:
    MiClase(const std::string& nombre);
    ~MiClase();

    void mostrar() const;

private:
    std::unique_ptr<std::string> nombre_;
};

#endif // MICLASE_H
```

##### Definición en el Archivo de Implementación (.cpp)

```cpp
// MiClase.cpp
#include "MiClase.h"
#include <iostream>

// Constructor
MiClase::MiClase(const std::string& nombre)
    : nombre_(std::make_unique<std::string>(nombre)) {}

// Destructor
MiClase::~MiClase() {
    // `std::unique_ptr` libera la memoria automáticamente
}

// Método mostrar
void MiClase::mostrar() const {
    std::cout << "Nombre: " << *nombre_ << std::endl;
}
```

#### Transferencia de Propiedad

La propiedad de un `std::unique_ptr` puede transferirse utilizando `std::move`. Esto es útil cuando se necesita transferir la propiedad de un recurso a otra función o objeto.

##### Ejemplo de Transferencia de Propiedad

```cpp
#include <iostream>
#include <memory>

void mostrar(std::unique_ptr<int> ptr) {
    std::cout << *ptr << std::endl;
}

int main() {
    std::unique_ptr<int> ptr = std::make_unique<int>(42);
    mostrar(std::move(ptr)); // Transferir la propiedad
    // ptr ya no es válido aquí
    return 0;
}
```

#### Mejor Uso de `std::unique_ptr`

##### 1. Encapsulación de Recursos

Utilice `std::unique_ptr` para encapsular recursos en clases. Esto asegura que los recursos sean liberados correctamente cuando la instancia de la clase es destruida.

```cpp
class Archivo {
public:
    Archivo(const std::string& nombre) : archivo_(std::fopen(nombre.c_str(), "r")) {
        if (!archivo_) {
            throw std::runtime_error("No se pudo abrir el archivo");
        }
    }

    ~Archivo() {
        if (archivo_) {
            std::fclose(archivo_);
        }
    }

private:
    std::unique_ptr<FILE, decltype(&std::fclose)> archivo_;
};
```

##### 2. Uso en Contenedores

Los contenedores de la STL pueden almacenar `std::unique_ptr`, lo que permite una gestión eficiente de colecciones de recursos dinámicos.

```cpp
#include <vector>
#include <memory>

int main() {
    std::vector<std::unique_ptr<int>> vec;
    vec.push_back(std::make_unique<int>(1));
    vec.push_back(std::make_unique<int>(2));
    vec.push_back(std::make_unique<int>(3));

    for (const auto& ptr : vec) {
        std::cout << *ptr << std::endl;
    }
    return 0;
}
```

##### 3. Evitar el Uso de Punteros Crudos

Prefiera `std::unique_ptr` sobre los punteros crudos para garantizar la gestión automática de la memoria y reducir el riesgo de fugas de memoria y accesos inválidos.

#### Ejemplo Completo

A continuación, se muestra un ejemplo más completo que incluye la declaración y el uso de `std::unique_ptr` en una clase, mostrando la gestión de recursos y la transferencia de propiedad.

##### Archivo de Cabecera (.h)

```cpp
// GestorRecurso.h
#ifndef GESTORRECURSO_H
#define GESTORRECURSO_H

#include <memory>
#include <string>

class GestorRecurso {
public:
    GestorRecurso(const std::string& nombre);
    void mostrarRecurso() const;

    // Transferir la propiedad del recurso
    std::unique_ptr<std::string> transferirRecurso();

private:
    std::unique_ptr<std::string> recurso_;
};

#endif // GESTORRECURSO_H
```

##### Archivo de Implementación (.cpp)

```cpp
// GestorRecurso.cpp
#include "GestorRecurso.h"
#include <iostream>

GestorRecurso::GestorRecurso(const std::string& nombre)
    : recurso_(std::make_unique<std::string>(nombre)) {}

void GestorRecurso::mostrarRecurso() const {
    std::cout << "Recurso: " << *recurso_ << std::endl;
}

std::unique_ptr<std::string> GestorRecurso::transferirRecurso() {
    return std::move(recurso_);
}
```

##### Función Principal

```cpp
#include <iostream>
#include "GestorRecurso.h"

int main() {
    GestorRecurso gestor("MiRecurso");
    gestor.mostrarRecurso();

    std::unique_ptr<std::string> recurso = gestor.transferirRecurso();
    if (recurso) {
        std::cout << "Recurso transferido: " << *recurso << std::endl;
    }

    // Intentar mostrar el recurso después de la transferencia
    gestor.mostrarRecurso(); // Esto no imprimirá nada ya que el recurso fue transferido

    return 0;
}
```

### Conclusión

`std::unique_ptr` es una herramienta esencial en C++ para la gestión segura y eficiente de recursos. Su uso adecuado en clases, funciones y contenedores permite evitar muchos errores comunes relacionados con la gestión de memoria, como fugas de memoria y accesos a memoria inválida. Al seguir las mejores prácticas y entender cómo transferir la propiedad de recursos, se puede escribir código más robusto y mantenible.
### `std::shared_ptr` en Profundidad

`std::shared_ptr` es un puntero inteligente que permite compartir la propiedad de un recurso entre múltiples punteros. Este puntero inteligente utiliza un mecanismo de conteo de referencias para asegurarse de que el recurso se libera automáticamente cuando el último `std::shared_ptr` que lo posee es destruido. Aquí exploraremos su uso en profundidad, mejores prácticas y ejemplos de cómo integrarlo en proyectos más grandes.

#### Declaraciones y Uso Básico

##### Declaración y Asignación

Para declarar un `std::shared_ptr`, se incluye la cabecera `<memory>` y se puede utilizar `std::make_shared` para asignar memoria.

```cpp
#include <iostream>
#include <memory>

int main() {
    std::shared_ptr<int> ptr1 = std::make_shared<int>(10);
    std::shared_ptr<int> ptr2 = ptr1; // ptr1 y ptr2 comparten la propiedad del mismo recurso

    std::cout << *ptr1 << std::endl; // Salida: 10
    std::cout << "Use count: " << ptr1.use_count() << std::endl; // Salida: 2

    // Memoria liberada automáticamente cuando el último shared_ptr sale del alcance
    return 0;
}
```

#### En Clases y Archivos de Cabecera

El uso de `std::shared_ptr` en clases permite una gestión de recursos compartida y segura. Aquí se muestra cómo declarar y definir una clase que utiliza `std::shared_ptr`.

##### Declaración en el Archivo de Cabecera (.h)

```cpp
// MiClase.h
#ifndef MICLASE_H
#define MICLASE_H

#include <memory>
#include <string>

class MiClase {
public:
    MiClase(const std::string& nombre);
    void mostrar() const;

private:
    std::shared_ptr<std::string> nombre_;
};

#endif // MICLASE_H
```

##### Definición en el Archivo de Implementación (.cpp)

```cpp
// MiClase.cpp
#include "MiClase.h"
#include <iostream>

// Constructor
MiClase::MiClase(const std::string& nombre)
    : nombre_(std::make_shared<std::string>(nombre)) {}

// Método mostrar
void MiClase::mostrar() const {
    std::cout << "Nombre: " << *nombre_ << std::endl;
}
```

#### Mejor Uso de `std::shared_ptr`

##### 1. Compartición de Recursos

`std::shared_ptr` es ideal para situaciones donde múltiples partes del código necesitan compartir la propiedad de un recurso. Por ejemplo, en estructuras de datos complejas como gráficos o árboles donde los nodos pueden ser compartidos por múltiples padres.

```cpp
#include <memory>
#include <vector>
#include <iostream>

class Nodo {
public:
    Nodo(int valor) : valor_(valor) {}

    void agregarHijo(std::shared_ptr<Nodo> hijo) {
        hijos_.push_back(hijo);
    }

    void mostrar() const {
        std::cout << "Nodo: " << valor_ << std::endl;
        for (const auto& hijo : hijos_) {
            hijo->mostrar();
        }
    }

private:
    int valor_;
    std::vector<std::shared_ptr<Nodo>> hijos_;
};

int main() {
    auto raiz = std::make_shared<Nodo>(1);
    auto hijo1 = std::make_shared<Nodo>(2);
    auto hijo2 = std::make_shared<Nodo>(3);

    raiz->agregarHijo(hijo1);
    raiz->agregarHijo(hijo2);

    raiz->mostrar(); // Muestra toda la jerarquía de nodos

    return 0;
}
```

##### 2. Evitar Ciclos de Referencia

Para evitar ciclos de referencia que pueden causar fugas de memoria, `std::shared_ptr` se utiliza junto con `std::weak_ptr`. Un `std::weak_ptr` es un puntero no propietario que permite referenciar un `std::shared_ptr` sin incrementar su contador de referencias.

##### Ejemplo de Ciclo de Referencia

```cpp
#include <memory>
#include <iostream>

class Nodo;

class Nodo {
public:
    Nodo(int valor) : valor_(valor) {}

    void establecerPadre(std::shared_ptr<Nodo> padre) {
        padre_ = padre;
    }

    void establecerHijo(std::shared_ptr<Nodo> hijo) {
        hijo_ = hijo;
    }

    ~Nodo() {
        std::cout << "Destruyendo nodo: " << valor_ << std::endl;
    }

private:
    int valor_;
    std::shared_ptr<Nodo> hijo_;
    std::shared_ptr<Nodo> padre_; // Ciclo de referencia
};

int main() {
    {
        auto nodo1 = std::make_shared<Nodo>(1);
        auto nodo2 = std::make_shared<Nodo>(2);

        nodo1->establecerHijo(nodo2);
        nodo2->establecerPadre(nodo1);
    } // Ciclo de referencia evita que los nodos sean destruidos

    return 0;
}
```

##### Solución usando `std::weak_ptr`

```cpp
#include <memory>
#include <iostream>

class Nodo;

class Nodo {
public:
    Nodo(int valor) : valor_(valor) {}

    void establecerPadre(std::shared_ptr<Nodo> padre) {
        padre_ = padre;
    }

    void establecerHijo(std::shared_ptr<Nodo> hijo) {
        hijo_ = hijo;
    }

    ~Nodo() {
        std::cout << "Destruyendo nodo: " << valor_ << std::endl;
    }

private:
    int valor_;
    std::shared_ptr<Nodo> hijo_;
    std::weak_ptr<Nodo> padre_; // Evitar ciclo de referencia
};

int main() {
    {
        auto nodo1 = std::make_shared<Nodo>(1);
        auto nodo2 = std::make_shared<Nodo>(2);

        nodo1->establecerHijo(nodo2);
        nodo2->establecerPadre(nodo1);
    } // Nodos correctamente destruidos

    return 0;
}
```

#### Ejemplo Completo

A continuación, se muestra un ejemplo más completo que incluye la declaración y el uso de `std::shared_ptr` en una clase, mostrando la gestión de recursos compartidos y evitando ciclos de referencia con `std::weak_ptr`.

##### Archivo de Cabecera (.h)

```cpp
// GestorRecurso.h
#ifndef GESTORRECURSO_H
#define GESTORRECURSO_H

#include <memory>
#include <string>

class GestorRecurso {
public:
    GestorRecurso(const std::string& nombre);
    void mostrarRecurso() const;

private:
    std::shared_ptr<std::string> recurso_;
};

class Contenedor {
public:
    void establecerRecurso(std::shared_ptr<GestorRecurso> recurso);
    void mostrar() const;

private:
    std::shared_ptr<GestorRecurso> recurso_;
};

#endif // GESTORRECURSO_H
```

##### Archivo de Implementación (.cpp)

```cpp
// GestorRecurso.cpp
#include "GestorRecurso.h"
#include <iostream>

GestorRecurso::GestorRecurso(const std::string& nombre)
    : recurso_(std::make_shared<std::string>(nombre)) {}

void GestorRecurso::mostrarRecurso() const {
    std::cout << "Recurso: " << *recurso_ << std::endl;
}

void Contenedor::establecerRecurso(std::shared_ptr<GestorRecurso> recurso) {
    recurso_ = recurso;
}

void Contenedor::mostrar() const {
    if (recurso_) {
        recurso_->mostrarRecurso();
    } else {
        std::cout << "Sin recurso" << std::endl;
    }
}
```

##### Función Principal

```cpp
#include <iostream>
#include "GestorRecurso.h"

int main() {
    auto recurso = std::make_shared<GestorRecurso>("MiRecurso");
    Contenedor contenedor;
    contenedor.establecerRecurso(recurso);

    recurso->mostrarRecurso();
    contenedor.mostrar();

    return 0;
}
```

### Conclusión

`std::shared_ptr` es una herramienta esencial en C++ para la gestión segura y eficiente de recursos compartidos. Su uso adecuado en clases, funciones y estructuras de datos complejas permite evitar muchos errores comunes relacionados con la gestión de memoria, como fugas de memoria y accesos a memoria inválida. Al seguir las mejores prácticas y entender cómo utilizar `std::shared_ptr` junto con `std::weak_ptr` para evitar ciclos de referencia, se puede escribir código más robusto y mantenible.
### `std::weak_ptr` en Profundidad

`std::weak_ptr` es un tipo de puntero inteligente en C++ que proporciona una referencia no propietaria a un objeto gestionado por `std::shared_ptr`. Su principal uso es evitar ciclos de referencia que pueden provocar fugas de memoria. `std::weak_ptr` no afecta el conteo de referencias de `std::shared_ptr`, permitiendo una referencia segura y controlada a los objetos sin extender su vida útil.

#### Declaraciones y Uso Básico

##### Declaración y Asignación

Para declarar un `std::weak_ptr`, se incluye la cabecera `<memory>`. Un `std::weak_ptr` debe ser inicializado con un `std::shared_ptr`.

```cpp
#include <iostream>
#include <memory>

int main() {
    std::shared_ptr<int> sptr = std::make_shared<int>(42);
    std::weak_ptr<int> wptr = sptr; // Inicializar con shared_ptr

    std::cout << "Use count: " << sptr.use_count() << std::endl; // Salida: 1
    return 0;
}
```

#### Uso de `lock` para Acceder al Objeto

El método `lock` de `std::weak_ptr` retorna un `std::shared_ptr` que comparte la propiedad del objeto si el objeto aún existe; de lo contrario, retorna un `nullptr`.

```cpp
#include <iostream>
#include <memory>

int main() {
    std::shared_ptr<int> sptr = std::make_shared<int>(42);
    std::weak_ptr<int> wptr = sptr;

    if (auto spt = wptr.lock()) { // Crear shared_ptr temporal
        std::cout << *spt << std::endl; // Salida: 42
    } else {
        std::cout << "El recurso ya no está disponible." << std::endl;
    }

    sptr.reset(); // Liberar el recurso

    if (auto spt = wptr.lock()) {
        std::cout << *spt << std::endl;
    } else {
        std::cout << "El recurso ya no está disponible." << std::endl; // Salida esperada
    }

    return 0;
}
```

#### Evitar Ciclos de Referencia

El uso más común de `std::weak_ptr` es evitar ciclos de referencia en estructuras de datos como grafos o árboles, donde los nodos pueden tener referencias entre sí.

##### Ejemplo de Ciclo de Referencia Evitado con `std::weak_ptr`

###### Declaración en el Archivo de Cabecera (.h)

```cpp
// Nodo.h
#ifndef NODO_H
#define NODO_H

#include <memory>
#include <vector>

class Nodo {
public:
    Nodo(int valor);
    void agregarHijo(std::shared_ptr<Nodo> hijo);
    void establecerPadre(std::weak_ptr<Nodo> padre);
    void mostrar() const;

private:
    int valor_;
    std::vector<std::shared_ptr<Nodo>> hijos_;
    std::weak_ptr<Nodo> padre_; // Referencia no propietaria
};

#endif // NODO_H
```

###### Definición en el Archivo de Implementación (.cpp)

```cpp
// Nodo.cpp
#include "Nodo.h"
#include <iostream>

Nodo::Nodo(int valor) : valor_(valor) {}

void Nodo::agregarHijo(std::shared_ptr<Nodo> hijo) {
    hijos_.push_back(hijo);
}

void Nodo::establecerPadre(std::weak_ptr<Nodo> padre) {
    padre_ = padre;
}

void Nodo::mostrar() const {
    std::cout << "Nodo: " << valor_ << std::endl;
    if (auto p = padre_.lock()) {
        std::cout << " Padre: " << p->valor_ << std::endl;
    } else {
        std::cout << " Sin padre" << std::endl;
    }
    for (const auto& hijo : hijos_) {
        hijo->mostrar();
    }
}
```

###### Función Principal

```cpp
#include <iostream>
#include "Nodo.h"

int main() {
    auto nodo1 = std::make_shared<Nodo>(1);
    auto nodo2 = std::make_shared<Nodo>(2);
    auto nodo3 = std::make_shared<Nodo>(3);

    nodo1->agregarHijo(nodo2);
    nodo2->establecerPadre(nodo1);
    nodo2->agregarHijo(nodo3);
    nodo3->establecerPadre(nodo2);

    nodo1->mostrar();

    return 0;
}
```

#### Buenas Prácticas con `std::weak_ptr`

##### 1. Utilizar `std::weak_ptr` para Referencias a Objetos de Vida Útil Controlada

Use `std::weak_ptr` para referencias que no deberían extender la vida útil del objeto, como en el caso de cachés, observadores o nodos de grafos.

```cpp
#include <iostream>
#include <memory>
#include <vector>

class Observador {
public:
    virtual void actualizar() = 0;
};

class Sujeto {
public:
    void agregarObservador(std::shared_ptr<Observador> obs) {
        observadores_.push_back(obs);
    }

    void notificar() {
        for (auto& obs : observadores_) {
            if (auto sp = obs.lock()) {
                sp->actualizar();
            }
        }
    }

private:
    std::vector<std::weak_ptr<Observador>> observadores_;
};

class ConcretoObservador : public Observador, public std::enable_shared_from_this<ConcretoObservador> {
public:
    void actualizar() override {
        std::cout << "Observador actualizado!" << std::endl;
    }

    void suscribirse(Sujeto& sujeto) {
        sujeto.agregarObservador(shared_from_this());
    }
};

int main() {
    Sujeto sujeto;
    auto obs = std::make_shared<ConcretoObservador>();
    obs->suscribirse(sujeto);

    sujeto.notificar(); // Salida: Observador actualizado!

    return 0;
}
```

##### 2. Usar `std::weak_ptr` en Estructuras de Datos Complejas

En estructuras de datos complejas como grafos o árboles, `std::weak_ptr` es ideal para evitar ciclos de referencia.

```cpp
#include <memory>
#include <iostream>

class Nodo {
public:
    Nodo(int valor) : valor_(valor) {}

    void agregarHijo(std::shared_ptr<Nodo> hijo) {
        hijos_.push_back(hijo);
        hijo->padre_ = weak_from_this();
    }

    void mostrar() const {
        std::cout << "Nodo: " << valor_ << std::endl;
        for (const auto& hijo : hijos_) {
            hijo->mostrar();
        }
    }

private:
    int valor_;
    std::vector<std::shared_ptr<Nodo>> hijos_;
    std::weak_ptr<Nodo> padre_; // Referencia no propietaria
};

int main() {
    auto nodo1 = std::make_shared<Nodo>(1);
    auto nodo2 = std::make_shared<Nodo>(2);
    auto nodo3 = std::make_shared<Nodo>(3);

    nodo1->agregarHijo(nodo2);
    nodo2->agregarHijo(nodo3);

    nodo1->mostrar(); // Muestra la jerarquía completa

    return 0;
}
```

### Conclusión

`std::weak_ptr` es una herramienta crucial en C++ para gestionar referencias no propietarias y evitar ciclos de referencia que pueden provocar fugas de memoria. Su uso adecuado en conjunción con `std::shared_ptr` asegura una gestión de memoria eficiente y segura en aplicaciones complejas. Al comprender y aplicar las mejores prácticas para `std::weak_ptr`, los desarrolladores pueden escribir código más robusto y mantenible.
### Arreglos Dinámicos en C++

Los arreglos dinámicos en C++ permiten la gestión flexible de la memoria, adaptándose a necesidades de tamaño que no se pueden determinar en tiempo de compilación. A diferencia de los arreglos estáticos, cuyo tamaño es fijo, los arreglos dinámicos pueden redimensionarse en tiempo de ejecución. Esto se logra mediante la asignación y liberación manual de memoria en el heap.

#### Declaración y Uso Básico

##### Asignación y Liberación de Memoria con `new` y `delete[]`

Para manejar arreglos dinámicos en C++, se utilizan los operadores `new[]` y `delete[]`.

```cpp
#include <iostream>

int main() {
    int size = 5;
    int* arr = new int[size]; // Asignar memoria para un arreglo de enteros

    // Inicializar el arreglo
    for (int i = 0; i < size; ++i) {
        arr[i] = i * 10;
    }

    // Acceder y mostrar los elementos del arreglo
    for (int i = 0; i < size; ++i) {
        std::cout << arr[i] << " "; // Salida: 0 10 20 30 40
    }
    std::cout << std::endl;

    delete[] arr; // Liberar la memoria asignada para el arreglo
    return 0;
}
```

#### Redimensionamiento de Arreglos Dinámicos

Dado que los arreglos dinámicos no pueden cambiar de tamaño una vez asignados, para redimensionar un arreglo se debe:
1. Asignar un nuevo bloque de memoria de mayor tamaño.
2. Copiar los elementos existentes al nuevo bloque.
3. Liberar el bloque de memoria original.

##### Ejemplo de Redimensionamiento

```cpp
#include <iostream>
#include <algorithm> // Para std::copy

int main() {
    int size = 5;
    int* arr = new int[size]; // Asignar memoria para un arreglo de enteros

    // Inicializar el arreglo
    for (int i = 0; i < size; ++i) {
        arr[i] = i * 10;
    }

    // Nuevo tamaño del arreglo
    int newSize = 10;
    int* newArr = new int[newSize]; // Asignar memoria para el nuevo arreglo

    // Copiar elementos del arreglo original al nuevo arreglo
    std::copy(arr, arr + size, newArr);

    // Inicializar los nuevos elementos
    for (int i = size; i < newSize; ++i) {
        newArr[i] = i * 10;
    }

    // Liberar la memoria del arreglo original
    delete[] arr;

    // Asignar el puntero del nuevo arreglo al original
    arr = newArr;

    // Mostrar los elementos del nuevo arreglo
    for (int i = 0; i < newSize; ++i) {
        std::cout << arr[i] << " "; // Salida: 0 10 20 30 40 50 60 70 80 90
    }
    std::cout << std::endl;

    delete[] arr; // Liberar la memoria del nuevo arreglo
    return 0;
}
```

### Arreglos Dinámicos con Clases

#### Uso de Clases para Encapsular Arreglos Dinámicos

Encapsular la gestión de arreglos dinámicos dentro de una clase es una buena práctica que mejora la legibilidad y mantenibilidad del código.

##### Declaración en el Archivo de Cabecera (.h)

```cpp
// ArregloDinamico.h
#ifndef ARREGLODINAMICO_H
#define ARREGLODINAMICO_H

class ArregloDinamico {
public:
    ArregloDinamico(int size);
    ~ArregloDinamico();

    void redimensionar(int newSize);
    void mostrar() const;

private:
    int* datos_;
    int size_;
};

#endif // ARREGLODINAMICO_H
```

##### Definición en el Archivo de Implementación (.cpp)

```cpp
// ArregloDinamico.cpp
#include "ArregloDinamico.h"
#include <iostream>
#include <algorithm>

ArregloDinamico::ArregloDinamico(int size) : size_(size) {
    datos_ = new int[size_];
    for (int i = 0; i < size_; ++i) {
        datos_[i] = i * 10;
    }
}

ArregloDinamico::~ArregloDinamico() {
    delete[] datos_;
}

void ArregloDinamico::redimensionar(int newSize) {
    int* nuevosDatos = new int[newSize];
    std::copy(datos_, datos_ + size_, nuevosDatos);
    for (int i = size_; i < newSize; ++i) {
        nuevosDatos[i] = i * 10;
    }
    delete[] datos_;
    datos_ = nuevosDatos;
    size_ = newSize;
}

void ArregloDinamico::mostrar() const {
    for (int i = 0; i < size_; ++i) {
        std::cout << datos_[i] << " ";
    }
    std::cout << std::endl;
}
```

##### Función Principal

```cpp
#include <iostream>
#include "ArregloDinamico.h"

int main() {
    ArregloDinamico arreglo(5);
    arreglo.mostrar(); // Salida: 0 10 20 30 40

    arreglo.redimensionar(10);
    arreglo.mostrar(); // Salida: 0 10 20 30 40 50 60 70 80 90

    return 0;
}
```

### Uso de `std::vector` para Arreglos Dinámicos

Aunque manejar la memoria manualmente es una habilidad importante, la biblioteca estándar de C++ proporciona `std::vector`, que es una implementación optimizada y segura de un arreglo dinámico.

#### Ejemplo Básico de `std::vector`

```cpp
#include <iostream>
#include <vector>

int main() {
    std::vector<int> vec = {1, 2, 3, 4, 5};

    vec.push_back(6); // Agregar un nuevo elemento
    vec.push_back(7);

    for (const auto& val : vec) {
        std::cout << val << " "; // Salida: 1 2 3 4 5 6 7
    }
    std::cout << std::endl;

    return 0;
}
```

#### Ventajas de `std::vector`

- **Redimensionamiento automático**: `std::vector` gestiona la memoria y se redimensiona automáticamente según sea necesario.
- **Seguridad y facilidad de uso**: Proporciona métodos y operadores que facilitan el manejo de datos.
- **Compatibilidad con algoritmos STL**: `std::vector` funciona perfectamente con los algoritmos de la biblioteca estándar.

### Conclusión

El manejo de arreglos dinámicos en C++ permite una mayor flexibilidad en la gestión de la memoria. Aunque es crucial comprender cómo funcionan `new[]` y `delete[]` para la asignación y liberación manual de memoria, el uso de `std::vector` es generalmente preferible por su simplicidad y eficiencia. Encapsular la lógica de manejo de arreglos dinámicos dentro de clases puede mejorar la estructura y mantenibilidad del código.
### Stack vs Heap en C++

En C++, la memoria se puede gestionar de dos maneras principales: en el stack (pila) y en el heap (montón). Cada una tiene sus propias características, ventajas y desventajas. Es fundamental comprender estas diferencias para escribir código eficiente y evitar problemas de gestión de memoria.

#### Memoria en el Stack

El stack es una región de memoria que gestiona automáticamente la vida útil de las variables locales y de las llamadas a funciones. Se comporta como una estructura de datos LIFO (Last In, First Out).

##### Características del Stack

1. **Almacenamiento Automático**: Las variables locales y los parámetros de las funciones se almacenan automáticamente en el stack.
2. **Vida Útil Limitada**: Las variables en el stack existen solo durante la ejecución del bloque de código o la función en la que están definidas.
3. **Rápido Acceso**: El acceso a las variables en el stack es muy rápido debido a su administración basada en registros.
4. **Tamaño Limitado**: El stack tiene un tamaño limitado que puede variar según el sistema operativo y la configuración del compilador.
5. **Gestión Automática**: La memoria del stack se gestiona automáticamente. No es necesario liberar la memoria manualmente.

##### Ejemplo de Uso del Stack

```cpp
#include <iostream>

void funcion() {
    int localVar = 10; // Variable local en el stack
    std::cout << "Valor de localVar: " << localVar << std::endl;
}

int main() {
    funcion(); // Llamada a la función
    return 0;
}
```

En este ejemplo, `localVar` se almacena en el stack y se destruye automáticamente cuando la función `funcion` termina.

#### Memoria en el Heap

El heap es una región de memoria utilizada para la asignación dinámica de memoria. A diferencia del stack, la memoria en el heap debe gestionarse manualmente.

##### Características del Heap

1. **Almacenamiento Dinámico**: La memoria en el heap se asigna dinámicamente en tiempo de ejecución usando operadores como `new` y `delete`.
2. **Vida Útil Controlada**: La memoria en el heap permanece hasta que se libera explícitamente, lo que permite la gestión flexible de la memoria.
3. **Acceso más Lento**: El acceso a la memoria en el heap es más lento comparado con el stack debido a la necesidad de buscar espacio libre y la posibilidad de fragmentación.
4. **Tamaño Grande**: El heap tiene un tamaño significativamente mayor que el stack, lo que permite asignar grandes bloques de memoria.
5. **Gestión Manual**: Es necesario liberar manualmente la memoria asignada en el heap para evitar fugas de memoria.

##### Ejemplo de Uso del Heap

```cpp
#include <iostream>

void funcion() {
    int* heapVar = new int(20); // Variable asignada en el heap
    std::cout << "Valor de heapVar: " << *heapVar << std::endl;
    delete heapVar; // Liberar la memoria asignada en el heap
}

int main() {
    funcion(); // Llamada a la función
    return 0;
}
```

En este ejemplo, `heapVar` se asigna en el heap y debe liberarse manualmente usando `delete`.

### Comparación entre Stack y Heap

| Característica           | Stack                              | Heap                             |
|--------------------------|-------------------------------------|----------------------------------|
| **Gestión de Memoria**   | Automática                          | Manual                           |
| **Vida Útil**            | Limitada al bloque de código        | Controlada por el programador    |
| **Tamaño**               | Limitado                            | Relativamente grande             |
| **Velocidad de Acceso**  | Rápida                              | Lenta                            |
| **Uso Común**            | Variables locales, llamadas a funciones | Asignación dinámica, estructuras de datos grandes |
| **Fragmentación**        | No                                  | Sí                               |

### Buenas Prácticas

#### Uso del Stack

1. **Variables Locales y Parámetros**: Utilice el stack para variables locales y parámetros de funciones, siempre que sea posible, para aprovechar el acceso rápido y la gestión automática.
2. **Tamaño de Variables**: Evite declarar variables de gran tamaño en el stack para no agotar el espacio disponible.

#### Uso del Heap

1. **Memoria Dinámica**: Use el heap para estructuras de datos que necesiten cambiar de tamaño en tiempo de ejecución, como arreglos dinámicos, listas enlazadas y árboles.
2. **Liberación de Memoria**: Siempre libere la memoria asignada en el heap utilizando `delete` o `delete[]` para evitar fugas de memoria.
3. **Smart Pointers**: Utilice punteros inteligentes (`std::unique_ptr`, `std::shared_ptr`) para gestionar automáticamente la vida útil de los objetos en el heap y evitar fugas de memoria.

### Conclusión

Comprender las diferencias entre el stack y el heap es crucial para la gestión eficiente de la memoria en C++. Utilizar el stack para variables locales y el heap para memoria dinámica permite aprovechar las ventajas de cada uno, como la velocidad y la flexibilidad. Siguiendo buenas prácticas y utilizando herramientas modernas como los punteros inteligentes, se puede escribir código más seguro y eficiente.
### Fugas de Memoria en C++

Una fuga de memoria ocurre cuando un programa no libera la memoria que ha asignado dinámicamente, lo que puede llevar a un consumo excesivo de memoria y, eventualmente, al fallo del programa. En aplicaciones de larga duración o sistemas embebidos, las fugas de memoria pueden tener consecuencias graves.

#### ¿Qué es una Fuga de Memoria?

Una fuga de memoria se produce cuando la memoria que se ha asignado en el heap no se libera adecuadamente. Esto ocurre principalmente cuando se pierde la referencia al puntero que apunta a esa memoria, lo que impide que el programa la reutilice o la libere.

#### Ejemplos Comunes de Fugas de Memoria

##### Fuga de Memoria Simple

```cpp
#include <iostream>

void funcion() {
    int* ptr = new int(10); // Asignar memoria en el heap
    // ptr se pierde al salir de la función sin liberar la memoria
}

int main() {
    funcion();
    // La memoria asignada no se libera
    return 0;
}
```

##### Fuga de Memoria en un Bucle

```cpp
#include <iostream>

void funcion() {
    for (int i = 0; i < 10; ++i) {
        int* ptr = new int(i); // Asignar memoria en el heap en cada iteración
        // Sin delete, cada iteración causa una fuga de memoria
    }
}

int main() {
    funcion();
    return 0;
}
```

### Cómo Detectar y Evitar Fugas de Memoria

#### 1. Liberar Memoria Manualmente

Asegúrese de liberar toda la memoria asignada dinámicamente usando `delete` o `delete[]` cuando ya no se necesite.

```cpp
#include <iostream>

void funcion() {
    int* ptr = new int(10);
    // Usar ptr
    delete ptr; // Liberar la memoria
}

int main() {
    funcion();
    return 0;
}
```

#### 2. Uso de Smart Pointers

Los punteros inteligentes, introducidos en C++11, ayudan a gestionar automáticamente la vida útil de los objetos en el heap, evitando fugas de memoria.

##### `std::unique_ptr`

```cpp
#include <iostream>
#include <memory>

void funcion() {
    std::unique_ptr<int> ptr = std::make_unique<int>(10); // Memoria gestionada automáticamente
    // Usar ptr
}

int main() {
    funcion();
    return 0;
}
```

##### `std::shared_ptr`

```cpp
#include <iostream>
#include <memory>

void funcion() {
    std::shared_ptr<int> ptr1 = std::make_shared<int>(10);
    std::shared_ptr<int> ptr2 = ptr1; // Compartir la propiedad del recurso
    // Usar ptr1 y ptr2
}

int main() {
    funcion();
    return 0;
}
```

#### 3. Uso de Herramientas de Análisis de Memoria

Existen varias herramientas que pueden ayudar a detectar fugas de memoria en el código, tales como:

- **Valgrind**: Una herramienta de análisis de memoria que detecta fugas de memoria y errores de acceso a memoria.
- **AddressSanitizer**: Un runtime que detecta errores de memoria como desbordamientos de buffer y fugas de memoria.

##### Uso Básico de Valgrind

```sh
valgrind --leak-check=full ./mi_programa
```

### Ejemplos Avanzados

#### Fugas de Memoria en Clases

Las fugas de memoria pueden ser más complejas en clases, especialmente si las clases manejan recursos dinámicos.

##### Ejemplo de Clase con Fuga de Memoria

```cpp
#include <iostream>

class MiClase {
public:
    MiClase() {
        ptr_ = new int[10]; // Asignar memoria dinámica
    }
    ~MiClase() {
        // Falta delete[] ptr_, causando una fuga de memoria
    }

private:
    int* ptr_;
};

int main() {
    MiClase obj;
    return 0;
}
```

##### Solución con Destructor Correcto

```cpp
#include <iostream>

class MiClase {
public:
    MiClase() {
        ptr_ = new int[10]; // Asignar memoria dinámica
    }
    ~MiClase() {
        delete[] ptr_; // Liberar la memoria asignada
    }

private:
    int* ptr_;
};

int main() {
    MiClase obj;
    return 0;
}
```

#### Uso de Smart Pointers en Clases

Encapsular la gestión de memoria en clases usando punteros inteligentes.

```cpp
#include <iostream>
#include <memory>

class MiClase {
public:
    MiClase() {
        ptr_ = std::make_unique<int[]>(10); // Uso de unique_ptr
    }
    // No se necesita destructor explícito

private:
    std::unique_ptr<int[]> ptr_;
};

int main() {
    MiClase obj;
    return 0;
}
```

### Mejores Prácticas para Evitar Fugas de Memoria

1. **Usar Smart Pointers**: Siempre que sea posible, use `std::unique_ptr` y `std::shared_ptr` en lugar de punteros crudos.
2. **Liberar Memoria Manualmente**: Si usa `new`, asegúrese de emparejarlo siempre con `delete`.
3. **RAII (Resource Acquisition Is Initialization)**: Utilice el principio RAII para asegurar que los recursos se liberen cuando los objetos salen de su ámbito.
4. **Revisiones y Pruebas de Código**: Realice revisiones de código y pruebas exhaustivas para detectar y corregir fugas de memoria.
5. **Herramientas de Análisis**: Use herramientas como Valgrind y AddressSanitizer para detectar fugas de memoria y otros errores de memoria en su código.

### Conclusión

Las fugas de memoria pueden tener efectos severos en el rendimiento y la estabilidad de un programa. Es crucial entender cómo se producen y adoptar buenas prácticas para prevenirlas. El uso de punteros inteligentes, la liberación manual de memoria y el uso de herramientas de análisis son estrategias efectivas para gestionar la memoria de manera eficiente y segura en C++. Al seguir estas prácticas, se puede escribir código más robusto y mantenible.
<---FILES--->
Memoria Estática
Memoria Estática Result
Memoria Dinámica
Memoria Dinámica Result
Ejemplo Básico de Asignación Dinámica
Ejemplo Básico de Asignación Dinámica Result
Ejemplo de Arreglo Dinámico
Ejemplo de Arreglo Dinámico Result
Ejemplo Incorrecto
Ejemplo Incorrecto Result
Ejemplo Correcto
Ejemplo Correcto Result
Ejemplo con `std::unique_ptr`
Ejemplo con `std::unique_ptr` Result
Memoria Estática
Memoria Estática Result
Memoria Dinámica
Memoria Dinámica Result
Ejemplo Básico de Asignación Dinámica
Ejemplo Básico de Asignación Dinámica Result
Ejemplo de Arreglo Dinámico
Ejemplo de Arreglo Dinámico Result
Ejemplo Incorrecto
Ejemplo Incorrecto Result
Ejemplo Correcto
Ejemplo Correcto Result
Ejemplo con `std::unique_ptr`
Ejemplo con `std::unique_ptr` Result
Declaración de Punteros
Declaración de Punteros Result
Asignación y Acceso a Datos
Asignación y Acceso a Datos Result
Paso por Referencia usando Punteros
Paso por Referencia usando Punteros Result
Ejemplo de Puntero a Función
Ejemplo de Puntero a Función Result
Memoria Estática
Memoria Estática Result
Memoria Dinámica
Memoria Dinámica Result
Ejemplo Básico de Asignación Dinámica
Ejemplo Básico de Asignación Dinámica Result
Ejemplo de Arreglo Dinámico
Ejemplo de Arreglo Dinámico Result
Ejemplo Incorrecto
Ejemplo Incorrecto Result
Ejemplo Correcto
Ejemplo Correcto Result
Ejemplo con `std::unique_ptr`
Ejemplo con `std::unique_ptr` Result
Declaración de Punteros
Declaración de Punteros Result
Asignación y Acceso a Datos
Asignación y Acceso a Datos Result
Paso por Referencia usando Punteros
Paso por Referencia usando Punteros Result
Ejemplo de Puntero a Función
Ejemplo de Puntero a Función Result
Declaración Básica
Declaración Básica Result
Modificación a través de Referencias
Modificación a través de Referencias Result
Ejemplo de Paso por Referencia
Ejemplo de Paso por Referencia Result
Ejemplo de Referencia Constante
Ejemplo de Referencia Constante Result
Ejemplo de Constructor de Copia
Ejemplo de Constructor de Copia Result
Ejemplo de Operador de Asignación
Ejemplo de Operador de Asignación Result
Ejemplo de Referencia Dangling (a Evitar)
Ejemplo de Referencia Dangling (a Evitar) Result
Memoria Estática
Memoria Estática Result
Memoria Dinámica
Memoria Dinámica Result
Ejemplo Básico de Asignación Dinámica
Ejemplo Básico de Asignación Dinámica Result
Ejemplo de Arreglo Dinámico
Ejemplo de Arreglo Dinámico Result
Ejemplo Incorrecto
Ejemplo Incorrecto Result
Ejemplo Correcto
Ejemplo Correcto Result
Ejemplo con `std::unique_ptr`
Ejemplo con `std::unique_ptr` Result
Declaración de Punteros
Declaración de Punteros Result
Asignación y Acceso a Datos
Asignación y Acceso a Datos Result
Paso por Referencia usando Punteros
Paso por Referencia usando Punteros Result
Ejemplo de Puntero a Función
Ejemplo de Puntero a Función Result
Declaración Básica
Declaración Básica Result
Modificación a través de Referencias
Modificación a través de Referencias Result
Ejemplo de Paso por Referencia
Ejemplo de Paso por Referencia Result
Ejemplo de Referencia Constante
Ejemplo de Referencia Constante Result
Ejemplo de Constructor de Copia
Ejemplo de Constructor de Copia Result
Ejemplo de Operador de Asignación
Ejemplo de Operador de Asignación Result
Ejemplo de Referencia Dangling (a Evitar)
Ejemplo de Referencia Dangling (a Evitar) Result
Asignación de Memoria
Asignación de Memoria Result
Asignación de Memoria para Arreglos
Asignación de Memoria para Arreglos Result
Ejemplo: Clase con Gestión de Memoria Dinámica
Ejemplo: Clase con Gestión de Memoria Dinámica Result
Ejemplo con `std::shared_ptr`
Ejemplo con `std::shared_ptr` Result
Ejemplo con `std::weak_ptr`
Ejemplo con `std::weak_ptr` Result
Memoria Estática
Memoria Estática Result
Memoria Dinámica
Memoria Dinámica Result
Ejemplo Básico de Asignación Dinámica
Ejemplo Básico de Asignación Dinámica Result
Ejemplo de Arreglo Dinámico
Ejemplo de Arreglo Dinámico Result
Ejemplo Incorrecto
Ejemplo Incorrecto Result
Ejemplo Correcto
Ejemplo Correcto Result
Ejemplo con `std::unique_ptr`
Ejemplo con `std::unique_ptr` Result
Declaración de Punteros
Declaración de Punteros Result
Asignación y Acceso a Datos
Asignación y Acceso a Datos Result
Paso por Referencia usando Punteros
Paso por Referencia usando Punteros Result
Ejemplo de Puntero a Función
Ejemplo de Puntero a Función Result
Declaración Básica
Declaración Básica Result
Modificación a través de Referencias
Modificación a través de Referencias Result
Ejemplo de Paso por Referencia
Ejemplo de Paso por Referencia Result
Ejemplo de Referencia Constante
Ejemplo de Referencia Constante Result
Ejemplo de Constructor de Copia
Ejemplo de Constructor de Copia Result
Ejemplo de Operador de Asignación
Ejemplo de Operador de Asignación Result
Ejemplo de Referencia Dangling (a Evitar)
Ejemplo de Referencia Dangling (a Evitar) Result
Asignación de Memoria
Asignación de Memoria Result
Asignación de Memoria para Arreglos
Asignación de Memoria para Arreglos Result
Ejemplo: Clase con Gestión de Memoria Dinámica
Ejemplo: Clase con Gestión de Memoria Dinámica Result
Ejemplo con `std::shared_ptr`
Ejemplo con `std::shared_ptr` Result
Ejemplo con `std::weak_ptr`
Ejemplo con `std::weak_ptr` Result
Características:
Características: Result
Ejemplo de Uso de `std::unique_ptr`
Ejemplo de Uso de `std::unique_ptr` Result
Ejemplo de Uso de `std::shared_ptr`
Ejemplo de Uso de `std::shared_ptr` Result
Ejemplo de Uso de `std::weak_ptr`
Ejemplo de Uso de `std::weak_ptr` Result
Memoria Estática
Memoria Estática Result
Memoria Dinámica
Memoria Dinámica Result
Ejemplo Básico de Asignación Dinámica
Ejemplo Básico de Asignación Dinámica Result
Ejemplo de Arreglo Dinámico
Ejemplo de Arreglo Dinámico Result
Ejemplo Incorrecto
Ejemplo Incorrecto Result
Ejemplo Correcto
Ejemplo Correcto Result
Ejemplo con `std::unique_ptr`
Ejemplo con `std::unique_ptr` Result
Declaración de Punteros
Declaración de Punteros Result
Asignación y Acceso a Datos
Asignación y Acceso a Datos Result
Paso por Referencia usando Punteros
Paso por Referencia usando Punteros Result
Ejemplo de Puntero a Función
Ejemplo de Puntero a Función Result
Declaración Básica
Declaración Básica Result
Modificación a través de Referencias
Modificación a través de Referencias Result
Ejemplo de Paso por Referencia
Ejemplo de Paso por Referencia Result
Ejemplo de Referencia Constante
Ejemplo de Referencia Constante Result
Ejemplo de Constructor de Copia
Ejemplo de Constructor de Copia Result
Ejemplo de Operador de Asignación
Ejemplo de Operador de Asignación Result
Ejemplo de Referencia Dangling (a Evitar)
Ejemplo de Referencia Dangling (a Evitar) Result
Asignación de Memoria
Asignación de Memoria Result
Asignación de Memoria para Arreglos
Asignación de Memoria para Arreglos Result
Ejemplo: Clase con Gestión de Memoria Dinámica
Ejemplo: Clase con Gestión de Memoria Dinámica Result
Ejemplo con `std::shared_ptr`
Ejemplo con `std::shared_ptr` Result
Ejemplo con `std::weak_ptr`
Ejemplo con `std::weak_ptr` Result
Características:
Características: Result
Ejemplo de Uso de `std::unique_ptr`
Ejemplo de Uso de `std::unique_ptr` Result
Ejemplo de Uso de `std::shared_ptr`
Ejemplo de Uso de `std::shared_ptr` Result
Ejemplo de Uso de `std::weak_ptr`
Ejemplo de Uso de `std::weak_ptr` Result
Declaración y Asignación
Declaración y Asignación Result
Declaración en el Archivo de Cabecera (.h)
Declaración en el Archivo de Cabecera (.h) Result
Definición en el Archivo de Implementación (.cpp)
Definición en el Archivo de Implementación (.cpp) Result
Ejemplo de Transferencia de Propiedad
Ejemplo de Transferencia de Propiedad Result
1. Encapsulación de Recursos
1. Encapsulación de Recursos Result
2. Uso en Contenedores
2. Uso en Contenedores Result
3. Evitar el Uso de Punteros Crudos
3. Evitar el Uso de Punteros Crudos Result
Archivo de Cabecera (.h)
Archivo de Cabecera (.h) Result
Archivo de Implementación (.cpp)
Archivo de Implementación (.cpp) Result
Función Principal
Función Principal Result
Memoria Estática
Memoria Estática Result
Memoria Dinámica
Memoria Dinámica Result
Ejemplo Básico de Asignación Dinámica
Ejemplo Básico de Asignación Dinámica Result
Ejemplo de Arreglo Dinámico
Ejemplo de Arreglo Dinámico Result
Ejemplo Incorrecto
Ejemplo Incorrecto Result
Ejemplo Correcto
Ejemplo Correcto Result
Ejemplo con `std::unique_ptr`
Ejemplo con `std::unique_ptr` Result
Declaración de Punteros
Declaración de Punteros Result
Asignación y Acceso a Datos
Asignación y Acceso a Datos Result
Paso por Referencia usando Punteros
Paso por Referencia usando Punteros Result
Ejemplo de Puntero a Función
Ejemplo de Puntero a Función Result
Declaración Básica
Declaración Básica Result
Modificación a través de Referencias
Modificación a través de Referencias Result
Ejemplo de Paso por Referencia
Ejemplo de Paso por Referencia Result
Ejemplo de Referencia Constante
Ejemplo de Referencia Constante Result
Ejemplo de Constructor de Copia
Ejemplo de Constructor de Copia Result
Ejemplo de Operador de Asignación
Ejemplo de Operador de Asignación Result
Ejemplo de Referencia Dangling (a Evitar)
Ejemplo de Referencia Dangling (a Evitar) Result
Asignación de Memoria
Asignación de Memoria Result
Asignación de Memoria para Arreglos
Asignación de Memoria para Arreglos Result
Ejemplo: Clase con Gestión de Memoria Dinámica
Ejemplo: Clase con Gestión de Memoria Dinámica Result
Ejemplo con `std::shared_ptr`
Ejemplo con `std::shared_ptr` Result
Ejemplo con `std::weak_ptr`
Ejemplo con `std::weak_ptr` Result
Características:
Características: Result
Ejemplo de Uso de `std::unique_ptr`
Ejemplo de Uso de `std::unique_ptr` Result
Ejemplo de Uso de `std::shared_ptr`
Ejemplo de Uso de `std::shared_ptr` Result
Ejemplo de Uso de `std::weak_ptr`
Ejemplo de Uso de `std::weak_ptr` Result
Declaración y Asignación
Declaración y Asignación Result
Declaración en el Archivo de Cabecera (.h)
Declaración en el Archivo de Cabecera (.h) Result
Definición en el Archivo de Implementación (.cpp)
Definición en el Archivo de Implementación (.cpp) Result
Ejemplo de Transferencia de Propiedad
Ejemplo de Transferencia de Propiedad Result
1. Encapsulación de Recursos
1. Encapsulación de Recursos Result
2. Uso en Contenedores
2. Uso en Contenedores Result
3. Evitar el Uso de Punteros Crudos
3. Evitar el Uso de Punteros Crudos Result
Archivo de Cabecera (.h)
Archivo de Cabecera (.h) Result
Archivo de Implementación (.cpp)
Archivo de Implementación (.cpp) Result
Función Principal
Función Principal Result
1. Compartición de Recursos
1. Compartición de Recursos Result
2. Evitar Ciclos de Referencia
2. Evitar Ciclos de Referencia Result
Ejemplo de Ciclo de Referencia
Ejemplo de Ciclo de Referencia Result
Solución usando `std::weak_ptr`
Solución usando `std::weak_ptr` Result
Memoria Estática
Memoria Estática Result
Memoria Dinámica
Memoria Dinámica Result
Ejemplo Básico de Asignación Dinámica
Ejemplo Básico de Asignación Dinámica Result
Ejemplo de Arreglo Dinámico
Ejemplo de Arreglo Dinámico Result
Ejemplo Incorrecto
Ejemplo Incorrecto Result
Ejemplo Correcto
Ejemplo Correcto Result
Ejemplo con `std::unique_ptr`
Ejemplo con `std::unique_ptr` Result
Declaración de Punteros
Declaración de Punteros Result
Asignación y Acceso a Datos
Asignación y Acceso a Datos Result
Paso por Referencia usando Punteros
Paso por Referencia usando Punteros Result
Ejemplo de Puntero a Función
Ejemplo de Puntero a Función Result
Declaración Básica
Declaración Básica Result
Modificación a través de Referencias
Modificación a través de Referencias Result
Ejemplo de Paso por Referencia
Ejemplo de Paso por Referencia Result
Ejemplo de Referencia Constante
Ejemplo de Referencia Constante Result
Ejemplo de Constructor de Copia
Ejemplo de Constructor de Copia Result
Ejemplo de Operador de Asignación
Ejemplo de Operador de Asignación Result
Ejemplo de Referencia Dangling (a Evitar)
Ejemplo de Referencia Dangling (a Evitar) Result
Asignación de Memoria
Asignación de Memoria Result
Asignación de Memoria para Arreglos
Asignación de Memoria para Arreglos Result
Ejemplo: Clase con Gestión de Memoria Dinámica
Ejemplo: Clase con Gestión de Memoria Dinámica Result
Ejemplo con `std::shared_ptr`
Ejemplo con `std::shared_ptr` Result
Ejemplo con `std::weak_ptr`
Ejemplo con `std::weak_ptr` Result
Características:
Características: Result
Ejemplo de Uso de `std::unique_ptr`
Ejemplo de Uso de `std::unique_ptr` Result
Ejemplo de Uso de `std::shared_ptr`
Ejemplo de Uso de `std::shared_ptr` Result
Ejemplo de Uso de `std::weak_ptr`
Ejemplo de Uso de `std::weak_ptr` Result
Declaración y Asignación
Declaración y Asignación Result
Declaración en el Archivo de Cabecera (.h)
Declaración en el Archivo de Cabecera (.h) Result
Definición en el Archivo de Implementación (.cpp)
Definición en el Archivo de Implementación (.cpp) Result
Ejemplo de Transferencia de Propiedad
Ejemplo de Transferencia de Propiedad Result
1. Encapsulación de Recursos
1. Encapsulación de Recursos Result
2. Uso en Contenedores
2. Uso en Contenedores Result
3. Evitar el Uso de Punteros Crudos
3. Evitar el Uso de Punteros Crudos Result
Archivo de Cabecera (.h)
Archivo de Cabecera (.h) Result
Archivo de Implementación (.cpp)
Archivo de Implementación (.cpp) Result
Función Principal
Función Principal Result
1. Compartición de Recursos
1. Compartición de Recursos Result
2. Evitar Ciclos de Referencia
2. Evitar Ciclos de Referencia Result
Ejemplo de Ciclo de Referencia
Ejemplo de Ciclo de Referencia Result
Solución usando `std::weak_ptr`
Solución usando `std::weak_ptr` Result
Ejemplo de Ciclo de Referencia Evitado con `std::weak_ptr`
Ejemplo de Ciclo de Referencia Evitado con `std::weak_ptr` Result
1. Utilizar `std::weak_ptr` para Referencias a Objetos de Vida Útil Controlada
1. Utilizar `std::weak_ptr` para Referencias a Objetos de Vida Útil Controlada Result
2. Usar `std::weak_ptr` en Estructuras de Datos Complejas
2. Usar `std::weak_ptr` en Estructuras de Datos Complejas Result
Memoria Estática
Memoria Estática Result
Memoria Dinámica
Memoria Dinámica Result
Ejemplo Básico de Asignación Dinámica
Ejemplo Básico de Asignación Dinámica Result
Ejemplo de Arreglo Dinámico
Ejemplo de Arreglo Dinámico Result
Ejemplo Incorrecto
Ejemplo Incorrecto Result
Ejemplo Correcto
Ejemplo Correcto Result
Ejemplo con `std::unique_ptr`
Ejemplo con `std::unique_ptr` Result
Declaración de Punteros
Declaración de Punteros Result
Asignación y Acceso a Datos
Asignación y Acceso a Datos Result
Paso por Referencia usando Punteros
Paso por Referencia usando Punteros Result
Ejemplo de Puntero a Función
Ejemplo de Puntero a Función Result
Declaración Básica
Declaración Básica Result
Modificación a través de Referencias
Modificación a través de Referencias Result
Ejemplo de Paso por Referencia
Ejemplo de Paso por Referencia Result
Ejemplo de Referencia Constante
Ejemplo de Referencia Constante Result
Ejemplo de Constructor de Copia
Ejemplo de Constructor de Copia Result
Ejemplo de Operador de Asignación
Ejemplo de Operador de Asignación Result
Ejemplo de Referencia Dangling (a Evitar)
Ejemplo de Referencia Dangling (a Evitar) Result
Asignación de Memoria
Asignación de Memoria Result
Asignación de Memoria para Arreglos
Asignación de Memoria para Arreglos Result
Ejemplo: Clase con Gestión de Memoria Dinámica
Ejemplo: Clase con Gestión de Memoria Dinámica Result
Ejemplo con `std::shared_ptr`
Ejemplo con `std::shared_ptr` Result
Ejemplo con `std::weak_ptr`
Ejemplo con `std::weak_ptr` Result
Características:
Características: Result
Ejemplo de Uso de `std::unique_ptr`
Ejemplo de Uso de `std::unique_ptr` Result
Ejemplo de Uso de `std::shared_ptr`
Ejemplo de Uso de `std::shared_ptr` Result
Ejemplo de Uso de `std::weak_ptr`
Ejemplo de Uso de `std::weak_ptr` Result
Declaración y Asignación
Declaración y Asignación Result
Declaración en el Archivo de Cabecera (.h)
Declaración en el Archivo de Cabecera (.h) Result
Definición en el Archivo de Implementación (.cpp)
Definición en el Archivo de Implementación (.cpp) Result
Ejemplo de Transferencia de Propiedad
Ejemplo de Transferencia de Propiedad Result
1. Encapsulación de Recursos
1. Encapsulación de Recursos Result
2. Uso en Contenedores
2. Uso en Contenedores Result
3. Evitar el Uso de Punteros Crudos
3. Evitar el Uso de Punteros Crudos Result
Archivo de Cabecera (.h)
Archivo de Cabecera (.h) Result
Archivo de Implementación (.cpp)
Archivo de Implementación (.cpp) Result
Función Principal
Función Principal Result
1. Compartición de Recursos
1. Compartición de Recursos Result
2. Evitar Ciclos de Referencia
2. Evitar Ciclos de Referencia Result
Ejemplo de Ciclo de Referencia
Ejemplo de Ciclo de Referencia Result
Solución usando `std::weak_ptr`
Solución usando `std::weak_ptr` Result
Ejemplo de Ciclo de Referencia Evitado con `std::weak_ptr`
Ejemplo de Ciclo de Referencia Evitado con `std::weak_ptr` Result
1. Utilizar `std::weak_ptr` para Referencias a Objetos de Vida Útil Controlada
1. Utilizar `std::weak_ptr` para Referencias a Objetos de Vida Útil Controlada Result
2. Usar `std::weak_ptr` en Estructuras de Datos Complejas
2. Usar `std::weak_ptr` en Estructuras de Datos Complejas Result
Asignación y Liberación de Memoria con `new` y `delete[]`
Asignación y Liberación de Memoria con `new` y `delete[]` Result
Ejemplo de Redimensionamiento
Ejemplo de Redimensionamiento Result
Memoria Estática
Memoria Estática Result
Memoria Dinámica
Memoria Dinámica Result
Ejemplo Básico de Asignación Dinámica
Ejemplo Básico de Asignación Dinámica Result
Ejemplo de Arreglo Dinámico
Ejemplo de Arreglo Dinámico Result
Ejemplo Incorrecto
Ejemplo Incorrecto Result
Ejemplo Correcto
Ejemplo Correcto Result
Ejemplo con `std::unique_ptr`
Ejemplo con `std::unique_ptr` Result
Declaración de Punteros
Declaración de Punteros Result
Asignación y Acceso a Datos
Asignación y Acceso a Datos Result
Paso por Referencia usando Punteros
Paso por Referencia usando Punteros Result
Ejemplo de Puntero a Función
Ejemplo de Puntero a Función Result
Declaración Básica
Declaración Básica Result
Modificación a través de Referencias
Modificación a través de Referencias Result
Ejemplo de Paso por Referencia
Ejemplo de Paso por Referencia Result
Ejemplo de Referencia Constante
Ejemplo de Referencia Constante Result
Ejemplo de Constructor de Copia
Ejemplo de Constructor de Copia Result
Ejemplo de Operador de Asignación
Ejemplo de Operador de Asignación Result
Ejemplo de Referencia Dangling (a Evitar)
Ejemplo de Referencia Dangling (a Evitar) Result
Asignación de Memoria
Asignación de Memoria Result
Asignación de Memoria para Arreglos
Asignación de Memoria para Arreglos Result
Ejemplo: Clase con Gestión de Memoria Dinámica
Ejemplo: Clase con Gestión de Memoria Dinámica Result
Ejemplo con `std::shared_ptr`
Ejemplo con `std::shared_ptr` Result
Ejemplo con `std::weak_ptr`
Ejemplo con `std::weak_ptr` Result
Características:
Características: Result
Ejemplo de Uso de `std::unique_ptr`
Ejemplo de Uso de `std::unique_ptr` Result
Ejemplo de Uso de `std::shared_ptr`
Ejemplo de Uso de `std::shared_ptr` Result
Ejemplo de Uso de `std::weak_ptr`
Ejemplo de Uso de `std::weak_ptr` Result
Declaración y Asignación
Declaración y Asignación Result
Declaración en el Archivo de Cabecera (.h)
Declaración en el Archivo de Cabecera (.h) Result
Definición en el Archivo de Implementación (.cpp)
Definición en el Archivo de Implementación (.cpp) Result
Ejemplo de Transferencia de Propiedad
Ejemplo de Transferencia de Propiedad Result
1. Encapsulación de Recursos
1. Encapsulación de Recursos Result
2. Uso en Contenedores
2. Uso en Contenedores Result
3. Evitar el Uso de Punteros Crudos
3. Evitar el Uso de Punteros Crudos Result
Archivo de Cabecera (.h)
Archivo de Cabecera (.h) Result
Archivo de Implementación (.cpp)
Archivo de Implementación (.cpp) Result
Función Principal
Función Principal Result
1. Compartición de Recursos
1. Compartición de Recursos Result
2. Evitar Ciclos de Referencia
2. Evitar Ciclos de Referencia Result
Ejemplo de Ciclo de Referencia
Ejemplo de Ciclo de Referencia Result
Solución usando `std::weak_ptr`
Solución usando `std::weak_ptr` Result
Ejemplo de Ciclo de Referencia Evitado con `std::weak_ptr`
Ejemplo de Ciclo de Referencia Evitado con `std::weak_ptr` Result
1. Utilizar `std::weak_ptr` para Referencias a Objetos de Vida Útil Controlada
1. Utilizar `std::weak_ptr` para Referencias a Objetos de Vida Útil Controlada Result
2. Usar `std::weak_ptr` en Estructuras de Datos Complejas
2. Usar `std::weak_ptr` en Estructuras de Datos Complejas Result
Asignación y Liberación de Memoria con `new` y `delete[]`
Asignación y Liberación de Memoria con `new` y `delete[]` Result
Ejemplo de Redimensionamiento
Ejemplo de Redimensionamiento Result
Características del Stack
Características del Stack Result
Ejemplo de Uso del Stack
Ejemplo de Uso del Stack Result
Características del Heap
Características del Heap Result
Ejemplo de Uso del Heap
Ejemplo de Uso del Heap Result
Memoria Estática
Memoria Estática Result
Memoria Dinámica
Memoria Dinámica Result
Ejemplo Básico de Asignación Dinámica
Ejemplo Básico de Asignación Dinámica Result
Ejemplo de Arreglo Dinámico
Ejemplo de Arreglo Dinámico Result
Ejemplo Incorrecto
Ejemplo Incorrecto Result
Ejemplo Correcto
Ejemplo Correcto Result
Ejemplo con `std::unique_ptr`
Ejemplo con `std::unique_ptr` Result
Declaración de Punteros
Declaración de Punteros Result
Asignación y Acceso a Datos
Asignación y Acceso a Datos Result
Paso por Referencia usando Punteros
Paso por Referencia usando Punteros Result
Ejemplo de Puntero a Función
Ejemplo de Puntero a Función Result
Declaración Básica
Declaración Básica Result
Modificación a través de Referencias
Modificación a través de Referencias Result
Ejemplo de Paso por Referencia
Ejemplo de Paso por Referencia Result
Ejemplo de Referencia Constante
Ejemplo de Referencia Constante Result
Ejemplo de Constructor de Copia
Ejemplo de Constructor de Copia Result
Ejemplo de Operador de Asignación
Ejemplo de Operador de Asignación Result
Ejemplo de Referencia Dangling (a Evitar)
Ejemplo de Referencia Dangling (a Evitar) Result
Asignación de Memoria
Asignación de Memoria Result
Asignación de Memoria para Arreglos
Asignación de Memoria para Arreglos Result
Ejemplo: Clase con Gestión de Memoria Dinámica
Ejemplo: Clase con Gestión de Memoria Dinámica Result
Ejemplo con `std::shared_ptr`
Ejemplo con `std::shared_ptr` Result
Ejemplo con `std::weak_ptr`
Ejemplo con `std::weak_ptr` Result
Características:
Características: Result
Ejemplo de Uso de `std::unique_ptr`
Ejemplo de Uso de `std::unique_ptr` Result
Ejemplo de Uso de `std::shared_ptr`
Ejemplo de Uso de `std::shared_ptr` Result
Ejemplo de Uso de `std::weak_ptr`
Ejemplo de Uso de `std::weak_ptr` Result
Declaración y Asignación
Declaración y Asignación Result
Declaración en el Archivo de Cabecera (.h)
Declaración en el Archivo de Cabecera (.h) Result
Definición en el Archivo de Implementación (.cpp)
Definición en el Archivo de Implementación (.cpp) Result
Ejemplo de Transferencia de Propiedad
Ejemplo de Transferencia de Propiedad Result
1. Encapsulación de Recursos
1. Encapsulación de Recursos Result
2. Uso en Contenedores
2. Uso en Contenedores Result
3. Evitar el Uso de Punteros Crudos
3. Evitar el Uso de Punteros Crudos Result
Archivo de Cabecera (.h)
Archivo de Cabecera (.h) Result
Archivo de Implementación (.cpp)
Archivo de Implementación (.cpp) Result
Función Principal
Función Principal Result
1. Compartición de Recursos
1. Compartición de Recursos Result
2. Evitar Ciclos de Referencia
2. Evitar Ciclos de Referencia Result
Ejemplo de Ciclo de Referencia
Ejemplo de Ciclo de Referencia Result
Solución usando `std::weak_ptr`
Solución usando `std::weak_ptr` Result
Ejemplo de Ciclo de Referencia Evitado con `std::weak_ptr`
Ejemplo de Ciclo de Referencia Evitado con `std::weak_ptr` Result
1. Utilizar `std::weak_ptr` para Referencias a Objetos de Vida Útil Controlada
1. Utilizar `std::weak_ptr` para Referencias a Objetos de Vida Útil Controlada Result
2. Usar `std::weak_ptr` en Estructuras de Datos Complejas
2. Usar `std::weak_ptr` en Estructuras de Datos Complejas Result
Asignación y Liberación de Memoria con `new` y `delete[]`
Asignación y Liberación de Memoria con `new` y `delete[]` Result
Ejemplo de Redimensionamiento
Ejemplo de Redimensionamiento Result
Características del Stack
Características del Stack Result
Ejemplo de Uso del Stack
Ejemplo de Uso del Stack Result
Características del Heap
Características del Heap Result
Ejemplo de Uso del Heap
Ejemplo de Uso del Heap Result
Fuga de Memoria Simple
Fuga de Memoria Simple Result
Fuga de Memoria en un Bucle
Fuga de Memoria en un Bucle Result
`std::unique_ptr`
`std::unique_ptr` Result
`std::shared_ptr`
`std::shared_ptr` Result
Uso Básico de Valgrind
Uso Básico de Valgrind Result
Ejemplo de Clase con Fuga de Memoria
Ejemplo de Clase con Fuga de Memoria Result
Solución con Destructor Correcto
Solución con Destructor Correcto Result
<---Memoria Estática--->
```cpp
#include <iostream>

int globalVariable = 10; // Variable global (memoria estática)

int main() {
    static int staticVariable = 20; // Variable estática local (memoria estática)
    return 0;
}
<---Memoria Estática Result--->
<---Memoria Dinámica--->
<---Memoria Dinámica Result--->
<---Ejemplo Básico de Asignación Dinámica--->
```cpp
#include <iostream>

int main() {
    int* ptr = new int; // Asignar memoria para un entero
    *ptr = 100; // Usar la memoria asignada
    std::cout << *ptr << std::endl; // Salida: 100
    delete ptr; // Liberar la memoria

    return 0;
}
<---Ejemplo Básico de Asignación Dinámica Result--->
<---Ejemplo de Arreglo Dinámico--->
```cpp
#include <iostream>

int main() {
    int size = 5;
    int* array = new int[size]; // Asignar memoria para un arreglo de enteros

    for(int i = 0; i < size; ++i) {
        array[i] = i * 10; // Inicializar el arreglo
    }

    for(int i = 0; i < size; ++i) {
        std::cout << array[i] << " "; // Salida: 0 10 20 30 40
    }
    std::cout << std::endl;

    delete[] array; // Liberar la memoria

    return 0;
}
<---Ejemplo de Arreglo Dinámico Result--->
<---Ejemplo Incorrecto--->
```cpp
int* ptr = new int(10);
delete ptr; // Liberar memoria
std::cout << *ptr << std::endl; // Acceso inválido: comportamiento indefinido
<---Ejemplo Incorrecto Result--->
<---Ejemplo Correcto--->
```cpp
int* ptr = new int(10);
delete ptr; // Liberar memoria
ptr = nullptr; // Evitar acceso inválido
```cpp
#include <iostream>
#include <cstring>

class String {
private:
    char* data;
    size_t size;

public:
    String(const char* str) {
        size = strlen(str);
        data = new char[size + 1];
        strcpy(data, str);
    }

    ~String() {
        delete[] data;
    }

    // Constructor de copia
    String(const String& other) {
        size = other.size;
        data = new char[size + 1];
        strcpy(data, other.data);
    }

    // Operador de asignación
    String& operator=(const String& other) {
        if (this == &other) return *this;

        delete[] data;

        size = other.size;
        data = new char[size + 1];
        strcpy(data, other.data);
        return *this;
    }

    void print() const {
        std::cout << data << std::endl;
    }
};

int main() {
    String str1("Hello");
    String str2 = str1; // Constructor de copia
    String str3("World");
    str3 = str1; // Operador de asignación
    str1.print(); // Salida: Hello
    str2.print(); // Salida: Hello
    str3.print(); // Salida: Hello

    return 0;
}
<---Ejemplo Correcto Result--->
<---Ejemplo con `std::unique_ptr`--->
```cpp
#include <iostream>
#include <memory>

int main() {
    std::unique_ptr<int> ptr = std::make_unique<int>(100); // Asignar memoria
    std::cout << *ptr << std::endl; // Salida: 100
    // Memoria se libera automáticamente cuando ptr sale del alcance

    return 0;
}
<---Ejemplo con `std::unique_ptr` Result--->
<---Memoria Estática--->
```cpp
#include <iostream>

int globalVariable = 10; // Variable global (memoria estática)

int main() {
    static int staticVariable = 20; // Variable estática local (memoria estática)
    return 0;
}
<---Memoria Estática Result--->
<---Memoria Dinámica--->
<---Memoria Dinámica Result--->
<---Ejemplo Básico de Asignación Dinámica--->
```cpp
#include <iostream>

int main() {
    int* ptr = new int; // Asignar memoria para un entero
    *ptr = 100; // Usar la memoria asignada
    std::cout << *ptr << std::endl; // Salida: 100
    delete ptr; // Liberar la memoria

    return 0;
}
<---Ejemplo Básico de Asignación Dinámica Result--->
<---Ejemplo de Arreglo Dinámico--->
```cpp
#include <iostream>

int main() {
    int size = 5;
    int* array = new int[size]; // Asignar memoria para un arreglo de enteros

    for(int i = 0; i < size; ++i) {
        array[i] = i * 10; // Inicializar el arreglo
    }

    for(int i = 0; i < size; ++i) {
        std::cout << array[i] << " "; // Salida: 0 10 20 30 40
    }
    std::cout << std::endl;

    delete[] array; // Liberar la memoria

    return 0;
}
<---Ejemplo de Arreglo Dinámico Result--->
<---Ejemplo Incorrecto--->
```cpp
int* ptr = new int(10);
delete ptr; // Liberar memoria
std::cout << *ptr << std::endl; // Acceso inválido: comportamiento indefinido
<---Ejemplo Incorrecto Result--->
<---Ejemplo Correcto--->
```cpp
int* ptr = new int(10);
delete ptr; // Liberar memoria
ptr = nullptr; // Evitar acceso inválido
```cpp
#include <iostream>
#include <cstring>

class String {
private:
    char* data;
    size_t size;

public:
    String(const char* str) {
        size = strlen(str);
        data = new char[size + 1];
        strcpy(data, str);
    }

    ~String() {
        delete[] data;
    }

    // Constructor de copia
    String(const String& other) {
        size = other.size;
        data = new char[size + 1];
        strcpy(data, other.data);
    }

    // Operador de asignación
    String& operator=(const String& other) {
        if (this == &other) return *this;

        delete[] data;

        size = other.size;
        data = new char[size + 1];
        strcpy(data, other.data);
        return *this;
    }

    void print() const {
        std::cout << data << std::endl;
    }
};

int main() {
    String str1("Hello");
    String str2 = str1; // Constructor de copia
    String str3("World");
    str3 = str1; // Operador de asignación
    str1.print(); // Salida: Hello
    str2.print(); // Salida: Hello
    str3.print(); // Salida: Hello

    return 0;
}
<---Ejemplo Correcto Result--->
<---Ejemplo con `std::unique_ptr`--->
```cpp
#include <iostream>
#include <memory>

int main() {
    std::unique_ptr<int> ptr = std::make_unique<int>(100); // Asignar memoria
    std::cout << *ptr << std::endl; // Salida: 100
    // Memoria se libera automáticamente cuando ptr sale del alcance

    return 0;
}
<---Ejemplo con `std::unique_ptr` Result--->
<---Declaración de Punteros--->
```cpp
int* ptr; // Declara un puntero a un entero
<---Declaración de Punteros Result--->
<---Asignación y Acceso a Datos--->
```cpp
int var = 10;
int* ptr = &var; // ptr apunta a la dirección de var

std::cout << "Valor de var: " << var << std::endl; // Salida: 10
std::cout << "Dirección de var: " << &var << std::endl; // Dirección de var
std::cout << "Valor apuntado por ptr: " << *ptr << std::endl; // Salida: 10
```cpp
int arr[5] = {1, 2, 3, 4, 5};
int* ptr = arr; // ptr apunta al primer elemento del arreglo

for(int i = 0; i < 5; ++i) {
    std::cout << *(ptr + i) << " "; // Acceder a los elementos del arreglo usando punteros
}
// Salida: 1 2 3 4 5
```cpp
int arr[5] = {1, 2, 3, 4, 5};
int* ptr = arr;

std::cout << "Primer elemento: " << *ptr << std::endl; // Salida: 1
ptr++;
std::cout << "Segundo elemento: " << *ptr << std::endl; // Salida: 2
```cpp
int var = 10;
int* ptr = &var;
int** ptr2 = &ptr;

std::cout << "Valor de var: " << var << std::endl; // Salida: 10
std::cout << "Valor apuntado por ptr: " << *ptr << std::endl; // Salida: 10
std::cout << "Valor apuntado por ptr2: " << **ptr2 << std::endl; // Salida: 10
```cpp
int* ptr = nullptr; // Puntero inicializado a nullptr
```cpp
int* ptr = new int(10);
delete ptr; // Liberar memoria asignada
ptr = nullptr; // Evitar acceso a memoria liberada
```cpp
int* ptr = new int(10);
delete ptr;
ptr = nullptr; // Ahora ptr no es un puntero colgante
<---Asignación y Acceso a Datos Result--->
<---Paso por Referencia usando Punteros--->
```cpp
#include <iostream>

void incrementar(int* ptr) {
    (*ptr)++;
}

int main() {
    int var = 10;
    incrementar(&var);
    std::cout << "Valor de var después de incrementar: " << var << std::endl; // Salida: 11

    return 0;
}
<---Paso por Referencia usando Punteros Result--->
<---Ejemplo de Puntero a Función--->
```cpp
#include <iostream>

void saludo() {
    std::cout << "Hola, Mundo!" << std::endl;
}

void llamarFuncion(void (*func)()) {
    func();
}

int main() {
    void (*ptrFunc)() = &saludo;
    llamarFuncion(ptrFunc); // Salida: Hola, Mundo!

    return 0;
}
<---Ejemplo de Puntero a Función Result--->
<---Memoria Estática--->
```cpp
#include <iostream>

int globalVariable = 10; // Variable global (memoria estática)

int main() {
    static int staticVariable = 20; // Variable estática local (memoria estática)
    return 0;
}
<---Memoria Estática Result--->
<---Memoria Dinámica--->
<---Memoria Dinámica Result--->
<---Ejemplo Básico de Asignación Dinámica--->
```cpp
#include <iostream>

int main() {
    int* ptr = new int; // Asignar memoria para un entero
    *ptr = 100; // Usar la memoria asignada
    std::cout << *ptr << std::endl; // Salida: 100
    delete ptr; // Liberar la memoria

    return 0;
}
<---Ejemplo Básico de Asignación Dinámica Result--->
<---Ejemplo de Arreglo Dinámico--->
```cpp
#include <iostream>

int main() {
    int size = 5;
    int* array = new int[size]; // Asignar memoria para un arreglo de enteros

    for(int i = 0; i < size; ++i) {
        array[i] = i * 10; // Inicializar el arreglo
    }

    for(int i = 0; i < size; ++i) {
        std::cout << array[i] << " "; // Salida: 0 10 20 30 40
    }
    std::cout << std::endl;

    delete[] array; // Liberar la memoria

    return 0;
}
<---Ejemplo de Arreglo Dinámico Result--->
<---Ejemplo Incorrecto--->
```cpp
int* ptr = new int(10);
delete ptr; // Liberar memoria
std::cout << *ptr << std::endl; // Acceso inválido: comportamiento indefinido
<---Ejemplo Incorrecto Result--->
<---Ejemplo Correcto--->
```cpp
int* ptr = new int(10);
delete ptr; // Liberar memoria
ptr = nullptr; // Evitar acceso inválido
```cpp
#include <iostream>
#include <cstring>

class String {
private:
    char* data;
    size_t size;

public:
    String(const char* str) {
        size = strlen(str);
        data = new char[size + 1];
        strcpy(data, str);
    }

    ~String() {
        delete[] data;
    }

    // Constructor de copia
    String(const String& other) {
        size = other.size;
        data = new char[size + 1];
        strcpy(data, other.data);
    }

    // Operador de asignación
    String& operator=(const String& other) {
        if (this == &other) return *this;

        delete[] data;

        size = other.size;
        data = new char[size + 1];
        strcpy(data, other.data);
        return *this;
    }

    void print() const {
        std::cout << data << std::endl;
    }
};

int main() {
    String str1("Hello");
    String str2 = str1; // Constructor de copia
    String str3("World");
    str3 = str1; // Operador de asignación
    str1.print(); // Salida: Hello
    str2.print(); // Salida: Hello
    str3.print(); // Salida: Hello

    return 0;
}
<---Ejemplo Correcto Result--->
<---Ejemplo con `std::unique_ptr`--->
```cpp
#include <iostream>
#include <memory>

int main() {
    std::unique_ptr<int> ptr = std::make_unique<int>(100); // Asignar memoria
    std::cout << *ptr << std::endl; // Salida: 100
    // Memoria se libera automáticamente cuando ptr sale del alcance

    return 0;
}
<---Ejemplo con `std::unique_ptr` Result--->
<---Declaración de Punteros--->
```cpp
int* ptr; // Declara un puntero a un entero
<---Declaración de Punteros Result--->
<---Asignación y Acceso a Datos--->
```cpp
int var = 10;
int* ptr = &var; // ptr apunta a la dirección de var

std::cout << "Valor de var: " << var << std::endl; // Salida: 10
std::cout << "Dirección de var: " << &var << std::endl; // Dirección de var
std::cout << "Valor apuntado por ptr: " << *ptr << std::endl; // Salida: 10
```cpp
int arr[5] = {1, 2, 3, 4, 5};
int* ptr = arr; // ptr apunta al primer elemento del arreglo

for(int i = 0; i < 5; ++i) {
    std::cout << *(ptr + i) << " "; // Acceder a los elementos del arreglo usando punteros
}
// Salida: 1 2 3 4 5
```cpp
int arr[5] = {1, 2, 3, 4, 5};
int* ptr = arr;

std::cout << "Primer elemento: " << *ptr << std::endl; // Salida: 1
ptr++;
std::cout << "Segundo elemento: " << *ptr << std::endl; // Salida: 2
```cpp
int var = 10;
int* ptr = &var;
int** ptr2 = &ptr;

std::cout << "Valor de var: " << var << std::endl; // Salida: 10
std::cout << "Valor apuntado por ptr: " << *ptr << std::endl; // Salida: 10
std::cout << "Valor apuntado por ptr2: " << **ptr2 << std::endl; // Salida: 10
```cpp
int* ptr = nullptr; // Puntero inicializado a nullptr
```cpp
int* ptr = new int(10);
delete ptr; // Liberar memoria asignada
ptr = nullptr; // Evitar acceso a memoria liberada
```cpp
int* ptr = new int(10);
delete ptr;
ptr = nullptr; // Ahora ptr no es un puntero colgante
<---Asignación y Acceso a Datos Result--->
<---Paso por Referencia usando Punteros--->
```cpp
#include <iostream>

void incrementar(int* ptr) {
    (*ptr)++;
}

int main() {
    int var = 10;
    incrementar(&var);
    std::cout << "Valor de var después de incrementar: " << var << std::endl; // Salida: 11

    return 0;
}
<---Paso por Referencia usando Punteros Result--->
<---Ejemplo de Puntero a Función--->
```cpp
#include <iostream>

void saludo() {
    std::cout << "Hola, Mundo!" << std::endl;
}

void llamarFuncion(void (*func)()) {
    func();
}

int main() {
    void (*ptrFunc)() = &saludo;
    llamarFuncion(ptrFunc); // Salida: Hola, Mundo!

    return 0;
}
<---Ejemplo de Puntero a Función Result--->
<---Declaración Básica--->
```cpp
int var = 10;
int& ref = var; // ref es una referencia a var

std::cout << "var: " << var << std::endl; // Salida: 10
std::cout << "ref: " << ref << std::endl; // Salida: 10
<---Declaración Básica Result--->
<---Modificación a través de Referencias--->
```cpp
int var = 10;
int& ref = var;

ref = 20; // Modifica var a través de ref

std::cout << "var: " << var << std::endl; // Salida: 20
std::cout << "ref: " << ref << std::endl; // Salida: 20
<---Modificación a través de Referencias Result--->
<---Ejemplo de Paso por Referencia--->
```cpp
#include <iostream>

void incrementar(int& ref) {
    ref++;
}

int main() {
    int var = 10;
    incrementar(var);
    std::cout << "Valor de var después de incrementar: " << var << std::endl; // Salida: 11

    return 0;
}
<---Ejemplo de Paso por Referencia Result--->
<---Ejemplo de Referencia Constante--->
```cpp
#include <iostream>

void mostrar(const int& ref) {
    std::cout << "Valor: " << ref << std::endl;
}

int main() {
    int var = 10;
    mostrar(var); // Salida: 10

    return 0;
}
<---Ejemplo de Referencia Constante Result--->
<---Ejemplo de Constructor de Copia--->
```cpp
#include <iostream>

class MiClase {
private:
    int valor;

public:
    MiClase(int v) : valor(v) {}
    
    // Constructor de copia
    MiClase(const MiClase& otra) : valor(otra.valor) {
        std::cout << "Constructor de copia llamado" << std::endl;
    }

    int obtenerValor() const { return valor; }
};

int main() {
    MiClase obj1(10);
    MiClase obj2 = obj1; // Llama al constructor de copia

    std::cout << "Valor de obj1: " << obj1.obtenerValor() << std::endl; // Salida: 10
    std::cout << "Valor de obj2: " << obj2.obtenerValor() << std::endl; // Salida: 10

    return 0;
}
<---Ejemplo de Constructor de Copia Result--->
<---Ejemplo de Operador de Asignación--->
```cpp
#include <iostream>

class MiClase {
private:
    int valor;

public:
    MiClase(int v) : valor(v) {}
    
    // Operador de asignación
    MiClase& operator=(const MiClase& otra) {
        if (this != &otra) {
            valor = otra.valor;
        }
        return *this;
    }

    int obtenerValor() const { return valor; }
};

int main() {
    MiClase obj1(10);
    MiClase obj2(20);
    obj2 = obj1; // Llama al operador de asignación

    std::cout << "Valor de obj1: " << obj1.obtenerValor() << std::endl; // Salida: 10
    std::cout << "Valor de obj2: " << obj2.obtenerValor() << std::endl; // Salida: 10

    return 0;
}
<---Ejemplo de Operador de Asignación Result--->
<---Ejemplo de Referencia Dangling (a Evitar)--->
```cpp
int& funcion() {
    int var = 10;
    return var; // var se destruye al salir de la función
}

int main() {
    int& ref = funcion(); // ref ahora es una referencia dangling
    std::cout << ref << std::endl; // Comportamiento indefinido

    return 0;
}
```cpp
void mostrar(const int& ref) {
    std::cout << "Valor: " << ref << std::endl;
}
<---Ejemplo de Referencia Dangling (a Evitar) Result--->
<---Memoria Estática--->
```cpp
#include <iostream>

int globalVariable = 10; // Variable global (memoria estática)

int main() {
    static int staticVariable = 20; // Variable estática local (memoria estática)
    return 0;
}
<---Memoria Estática Result--->
<---Memoria Dinámica--->
<---Memoria Dinámica Result--->
<---Ejemplo Básico de Asignación Dinámica--->
```cpp
#include <iostream>

int main() {
    int* ptr = new int; // Asignar memoria para un entero
    *ptr = 100; // Usar la memoria asignada
    std::cout << *ptr << std::endl; // Salida: 100
    delete ptr; // Liberar la memoria

    return 0;
}
<---Ejemplo Básico de Asignación Dinámica Result--->
<---Ejemplo de Arreglo Dinámico--->
```cpp
#include <iostream>

int main() {
    int size = 5;
    int* array = new int[size]; // Asignar memoria para un arreglo de enteros

    for(int i = 0; i < size; ++i) {
        array[i] = i * 10; // Inicializar el arreglo
    }

    for(int i = 0; i < size; ++i) {
        std::cout << array[i] << " "; // Salida: 0 10 20 30 40
    }
    std::cout << std::endl;

    delete[] array; // Liberar la memoria

    return 0;
}
<---Ejemplo de Arreglo Dinámico Result--->
<---Ejemplo Incorrecto--->
```cpp
int* ptr = new int(10);
delete ptr; // Liberar memoria
std::cout << *ptr << std::endl; // Acceso inválido: comportamiento indefinido
<---Ejemplo Incorrecto Result--->
<---Ejemplo Correcto--->
```cpp
int* ptr = new int(10);
delete ptr; // Liberar memoria
ptr = nullptr; // Evitar acceso inválido
```cpp
#include <iostream>
#include <cstring>

class String {
private:
    char* data;
    size_t size;

public:
    String(const char* str) {
        size = strlen(str);
        data = new char[size + 1];
        strcpy(data, str);
    }

    ~String() {
        delete[] data;
    }

    // Constructor de copia
    String(const String& other) {
        size = other.size;
        data = new char[size + 1];
        strcpy(data, other.data);
    }

    // Operador de asignación
    String& operator=(const String& other) {
        if (this == &other) return *this;

        delete[] data;

        size = other.size;
        data = new char[size + 1];
        strcpy(data, other.data);
        return *this;
    }

    void print() const {
        std::cout << data << std::endl;
    }
};

int main() {
    String str1("Hello");
    String str2 = str1; // Constructor de copia
    String str3("World");
    str3 = str1; // Operador de asignación
    str1.print(); // Salida: Hello
    str2.print(); // Salida: Hello
    str3.print(); // Salida: Hello

    return 0;
}
<---Ejemplo Correcto Result--->
<---Ejemplo con `std::unique_ptr`--->
```cpp
#include <iostream>
#include <memory>

int main() {
    std::unique_ptr<int> ptr = std::make_unique<int>(10);
    std::cout << *ptr << std::endl; // Salida: 10

    return 0;
}
<---Ejemplo con `std::unique_ptr` Result--->
<---Declaración de Punteros--->
```cpp
int* ptr; // Declara un puntero a un entero
<---Declaración de Punteros Result--->
<---Asignación y Acceso a Datos--->
```cpp
int var = 10;
int* ptr = &var; // ptr apunta a la dirección de var

std::cout << "Valor de var: " << var << std::endl; // Salida: 10
std::cout << "Dirección de var: " << &var << std::endl; // Dirección de var
std::cout << "Valor apuntado por ptr: " << *ptr << std::endl; // Salida: 10
```cpp
int arr[5] = {1, 2, 3, 4, 5};
int* ptr = arr; // ptr apunta al primer elemento del arreglo

for(int i = 0; i < 5; ++i) {
    std::cout << *(ptr + i) << " "; // Acceder a los elementos del arreglo usando punteros
}
// Salida: 1 2 3 4 5
```cpp
int arr[5] = {1, 2, 3, 4, 5};
int* ptr = arr;

std::cout << "Primer elemento: " << *ptr << std::endl; // Salida: 1
ptr++;
std::cout << "Segundo elemento: " << *ptr << std::endl; // Salida: 2
```cpp
int var = 10;
int* ptr = &var;
int** ptr2 = &ptr;

std::cout << "Valor de var: " << var << std::endl; // Salida: 10
std::cout << "Valor apuntado por ptr: " << *ptr << std::endl; // Salida: 10
std::cout << "Valor apuntado por ptr2: " << **ptr2 << std::endl; // Salida: 10
```cpp
int* ptr = nullptr; // Puntero inicializado a nullptr
```cpp
int* ptr = new int(10);
delete ptr; // Liberar memoria asignada
ptr = nullptr; // Evitar acceso a memoria liberada
```cpp
int* ptr = new int(10);
delete ptr;
ptr = nullptr; // Ahora ptr no es un puntero colgante
<---Asignación y Acceso a Datos Result--->
<---Paso por Referencia usando Punteros--->
```cpp
#include <iostream>

void incrementar(int* ptr) {
    (*ptr)++;
}

int main() {
    int var = 10;
    incrementar(&var);
    std::cout << "Valor de var después de incrementar: " << var << std::endl; // Salida: 11

    return 0;
}
<---Paso por Referencia usando Punteros Result--->
<---Ejemplo de Puntero a Función--->
```cpp
#include <iostream>

void saludo() {
    std::cout << "Hola, Mundo!" << std::endl;
}

void llamarFuncion(void (*func)()) {
    func();
}

int main() {
    void (*ptrFunc)() = &saludo;
    llamarFuncion(ptrFunc); // Salida: Hola, Mundo!

    return 0;
}
<---Ejemplo de Puntero a Función Result--->
<---Declaración Básica--->
```cpp
int var = 10;
int& ref = var; // ref es una referencia a var

std::cout << "var: " << var << std::endl; // Salida: 10
std::cout << "ref: " << ref << std::endl; // Salida: 10
<---Declaración Básica Result--->
<---Modificación a través de Referencias--->
```cpp
int var = 10;
int& ref = var;

ref = 20; // Modifica var a través de ref

std::cout << "var: " << var << std::endl; // Salida: 20
std::cout << "ref: " << ref << std::endl; // Salida: 20
<---Modificación a través de Referencias Result--->
<---Ejemplo de Paso por Referencia--->
```cpp
#include <iostream>

void incrementar(int& ref) {
    ref++;
}

int main() {
    int var = 10;
    incrementar(var);
    std::cout << "Valor de var después de incrementar: " << var << std::endl; // Salida: 11

    return 0;
}
<---Ejemplo de Paso por Referencia Result--->
<---Ejemplo de Referencia Constante--->
```cpp
#include <iostream>

void mostrar(const int& ref) {
    std::cout << "Valor: " << ref << std::endl;
}

int main() {
    int var = 10;
    mostrar(var); // Salida: 10

    return 0;
}
<---Ejemplo de Referencia Constante Result--->
<---Ejemplo de Constructor de Copia--->
```cpp
#include <iostream>

class MiClase {
private:
    int valor;

public:
    MiClase(int v) : valor(v) {}
    
    // Constructor de copia
    MiClase(const MiClase& otra) : valor(otra.valor) {
        std::cout << "Constructor de copia llamado" << std::endl;
    }

    int obtenerValor() const { return valor; }
};

int main() {
    MiClase obj1(10);
    MiClase obj2 = obj1; // Llama al constructor de copia

    std::cout << "Valor de obj1: " << obj1.obtenerValor() << std::endl; // Salida: 10
    std::cout << "Valor de obj2: " << obj2.obtenerValor() << std::endl; // Salida: 10

    return 0;
}
<---Ejemplo de Constructor de Copia Result--->
<---Ejemplo de Operador de Asignación--->
```cpp
#include <iostream>

class MiClase {
private:
    int valor;

public:
    MiClase(int v) : valor(v) {}
    
    // Operador de asignación
    MiClase& operator=(const MiClase& otra) {
        if (this != &otra) {
            valor = otra.valor;
        }
        return *this;
    }

    int obtenerValor() const { return valor; }
};

int main() {
    MiClase obj1(10);
    MiClase obj2(20);
    obj2 = obj1; // Llama al operador de asignación

    std::cout << "Valor de obj1: " << obj1.obtenerValor() << std::endl; // Salida: 10
    std::cout << "Valor de obj2: " << obj2.obtenerValor() << std::endl; // Salida: 10

    return 0;
}
<---Ejemplo de Operador de Asignación Result--->
<---Ejemplo de Referencia Dangling (a Evitar)--->
```cpp
int& funcion() {
    int var = 10;
    return var; // var se destruye al salir de la función
}

int main() {
    int& ref = funcion(); // ref ahora es una referencia dangling
    std::cout << ref << std::endl; // Comportamiento indefinido

    return 0;
}
```cpp
void mostrar(const int& ref) {
    std::cout << "Valor: " << ref << std::endl;
}
<---Ejemplo de Referencia Dangling (a Evitar) Result--->
<---Asignación de Memoria--->
```cpp
int* ptr = new int; // Asignar memoria para un entero
*ptr = 10;
std::cout << *ptr << std::endl; // Salida: 10

delete ptr; // Liberar la memoria asignada
<---Asignación de Memoria Result--->
<---Asignación de Memoria para Arreglos--->
```cpp
int size = 5;
int* arr = new int[size]; // Asignar memoria para un arreglo de enteros

for(int i = 0; i < size; ++i) {
    arr[i] = i * 10;
}

for(int i = 0; i < size; ++i) {
    std::cout << arr[i] << " "; // Salida: 0 10 20 30 40
}
std::cout << std::endl;

delete[] arr; // Liberar la memoria asignada para el arreglo
<---Asignación de Memoria para Arreglos Result--->
<---Ejemplo: Clase con Gestión de Memoria Dinámica--->
```cpp
#include <iostream>

class MiClase {
private:
    int* data;
    size_t size;

public:
    // Constructor
    MiClase(size_t s) : size(s) {
        data = new int[size];
        for(size_t i = 0; i < size; ++i) {
            data[i] = i * 10;
        }
    }

    // Destructor
    ~MiClase() {
        delete[] data;
    }

    // Constructor de copia
    MiClase(const MiClase& other) : size(other.size) {
        data = new int[size];
        std::copy(other.data, other.data + size, data);
    }

    // Operador de asignación
    MiClase& operator=(const MiClase& other) {
        if (this == &other) return *this;

        delete[] data;

        size = other.size;
        data = new int[size];
        std::copy(other.data, other.data + size, data);

        return *this;
    }

    void print() const {
        for(size_t i = 0; i < size; ++i) {
            std::cout << data[i] << " ";
        }
        std::cout << std::endl;
    }
};

int main() {
    MiClase obj1(5);
    obj1.print(); // Salida: 0 10 20 30 40

    MiClase obj2 = obj1; // Constructor de copia
    obj2.print(); // Salida: 0 10 20 30 40

    MiClase obj3(3);
    obj3 = obj1; // Operador de asignación
    obj3.print(); // Salida: 0 10 20 30 40

    return 0;
}
<---Ejemplo: Clase con Gestión de Memoria Dinámica Result--->
<---Ejemplo con `std::shared_ptr`--->
```cpp
#include <iostream>
#include <memory>

int main() {
    std::shared_ptr<int> ptr1 = std::make_shared<int>(20);
    std::shared_ptr<int> ptr2 = ptr1;

    std::cout << *ptr1 << std::endl; // Salida: 20
    std::cout << *ptr2 << std::endl; // Salida: 20

    return 0;
}
<---Ejemplo con `std::shared_ptr` Result--->
<---Ejemplo con `std::weak_ptr`--->
```cpp
#include <iostream>
#include <memory>

int main() {
    std::shared_ptr<int> sptr = std::make_shared<int>(30);
    std::weak_ptr<int> wptr = sptr;

    std::cout << "Use count: " << sptr.use_count() << std::endl; // Salida: 1

    if (auto spt = wptr.lock()) {
        std::cout << *spt << std::endl; // Salida: 30
    } else {
        std::cout << "wptr is expired" << std::endl;
    }

    return 0;
}
```cpp
int* ptr = new int(10);
// ...
delete ptr; // Liberar la memoria
```cpp
std::unique_ptr<int> ptr = std::make_unique<int>(10);
```cpp
int* ptr = new int(10);
delete ptr;
ptr = nullptr; // Evitar acceso a memoria liberada
```cpp
class Recurso {
public:
    Recurso() { /* adquirir recurso */ }
    ~Recurso() { /* liberar recurso */ }
};
<---Ejemplo con `std::weak_ptr` Result--->
<---Memoria Estática--->
```cpp
#include <iostream>

int globalVariable = 10; // Variable global (memoria estática)

int main() {
    static int staticVariable = 20; // Variable estática local (memoria estática)
    return 0;
}
<---Memoria Estática Result--->
<---Memoria Dinámica--->
<---Memoria Dinámica Result--->
<---Ejemplo Básico de Asignación Dinámica--->
```cpp
#include <iostream>

int main() {
    int* ptr = new int; // Asignar memoria para un entero
    *ptr = 100; // Usar la memoria asignada
    std::cout << *ptr << std::endl; // Salida: 100
    delete ptr; // Liberar la memoria

    return 0;
}
<---Ejemplo Básico de Asignación Dinámica Result--->
<---Ejemplo de Arreglo Dinámico--->
```cpp
#include <iostream>

int main() {
    int size = 5;
    int* array = new int[size]; // Asignar memoria para un arreglo de enteros

    for(int i = 0; i < size; ++i) {
        array[i] = i * 10; // Inicializar el arreglo
    }

    for(int i = 0; i < size; ++i) {
        std::cout << array[i] << " "; // Salida: 0 10 20 30 40
    }
    std::cout << std::endl;

    delete[] array; // Liberar la memoria

    return 0;
}
<---Ejemplo de Arreglo Dinámico Result--->
<---Ejemplo Incorrecto--->
```cpp
int* ptr = new int(10);
delete ptr; // Liberar memoria
std::cout << *ptr << std::endl; // Acceso inválido: comportamiento indefinido
<---Ejemplo Incorrecto Result--->
<---Ejemplo Correcto--->
```cpp
int* ptr = new int(10);
delete ptr; // Liberar memoria
ptr = nullptr; // Evitar acceso inválido
```cpp
#include <iostream>
#include <cstring>

class String {
private:
    char* data;
    size_t size;

public:
    String(const char* str) {
        size = strlen(str);
        data = new char[size + 1];
        strcpy(data, str);
    }

    ~String() {
        delete[] data;
    }

    // Constructor de copia
    String(const String& other) {
        size = other.size;
        data = new char[size + 1];
        strcpy(data, other.data);
    }

    // Operador de asignación
    String& operator=(const String& other) {
        if (this == &other) return *this;

        delete[] data;

        size = other.size;
        data = new char[size + 1];
        strcpy(data, other.data);
        return *this;
    }

    void print() const {
        std::cout << data << std::endl;
    }
};

int main() {
    String str1("Hello");
    String str2 = str1; // Constructor de copia
    String str3("World");
    str3 = str1; // Operador de asignación
    str1.print(); // Salida: Hello
    str2.print(); // Salida: Hello
    str3.print(); // Salida: Hello

    return 0;
}
<---Ejemplo Correcto Result--->
<---Ejemplo con `std::unique_ptr`--->
```cpp
#include <iostream>
#include <memory>

int main() {
    std::unique_ptr<int> ptr = std::make_unique<int>(10);
    std::cout << *ptr << std::endl; // Salida: 10

    return 0;
}
<---Ejemplo con `std::unique_ptr` Result--->
<---Declaración de Punteros--->
```cpp
int* ptr; // Declara un puntero a un entero
<---Declaración de Punteros Result--->
<---Asignación y Acceso a Datos--->
```cpp
int var = 10;
int* ptr = &var; // ptr apunta a la dirección de var

std::cout << "Valor de var: " << var << std::endl; // Salida: 10
std::cout << "Dirección de var: " << &var << std::endl; // Dirección de var
std::cout << "Valor apuntado por ptr: " << *ptr << std::endl; // Salida: 10
```cpp
int arr[5] = {1, 2, 3, 4, 5};
int* ptr = arr; // ptr apunta al primer elemento del arreglo

for(int i = 0; i < 5; ++i) {
    std::cout << *(ptr + i) << " "; // Acceder a los elementos del arreglo usando punteros
}
// Salida: 1 2 3 4 5
```cpp
int arr[5] = {1, 2, 3, 4, 5};
int* ptr = arr;

std::cout << "Primer elemento: " << *ptr << std::endl; // Salida: 1
ptr++;
std::cout << "Segundo elemento: " << *ptr << std::endl; // Salida: 2
```cpp
int var = 10;
int* ptr = &var;
int** ptr2 = &ptr;

std::cout << "Valor de var: " << var << std::endl; // Salida: 10
std::cout << "Valor apuntado por ptr: " << *ptr << std::endl; // Salida: 10
std::cout << "Valor apuntado por ptr2: " << **ptr2 << std::endl; // Salida: 10
```cpp
int* ptr = nullptr; // Puntero inicializado a nullptr
```cpp
int* ptr = new int(10);
delete ptr; // Liberar memoria asignada
ptr = nullptr; // Evitar acceso a memoria liberada
```cpp
int* ptr = new int(10);
delete ptr;
ptr = nullptr; // Ahora ptr no es un puntero colgante
<---Asignación y Acceso a Datos Result--->
<---Paso por Referencia usando Punteros--->
```cpp
#include <iostream>

void incrementar(int* ptr) {
    (*ptr)++;
}

int main() {
    int var = 10;
    incrementar(&var);
    std::cout << "Valor de var después de incrementar: " << var << std::endl; // Salida: 11

    return 0;
}
<---Paso por Referencia usando Punteros Result--->
<---Ejemplo de Puntero a Función--->
```cpp
#include <iostream>

void saludo() {
    std::cout << "Hola, Mundo!" << std::endl;
}

void llamarFuncion(void (*func)()) {
    func();
}

int main() {
    void (*ptrFunc)() = &saludo;
    llamarFuncion(ptrFunc); // Salida: Hola, Mundo!

    return 0;
}
<---Ejemplo de Puntero a Función Result--->
<---Declaración Básica--->
```cpp
int var = 10;
int& ref = var; // ref es una referencia a var

std::cout << "var: " << var << std::endl; // Salida: 10
std::cout << "ref: " << ref << std::endl; // Salida: 10
<---Declaración Básica Result--->
<---Modificación a través de Referencias--->
```cpp
int var = 10;
int& ref = var;

ref = 20; // Modifica var a través de ref

std::cout << "var: " << var << std::endl; // Salida: 20
std::cout << "ref: " << ref << std::endl; // Salida: 20
<---Modificación a través de Referencias Result--->
<---Ejemplo de Paso por Referencia--->
```cpp
#include <iostream>

void incrementar(int& ref) {
    ref++;
}

int main() {
    int var = 10;
    incrementar(var);
    std::cout << "Valor de var después de incrementar: " << var << std::endl; // Salida: 11

    return 0;
}
<---Ejemplo de Paso por Referencia Result--->
<---Ejemplo de Referencia Constante--->
```cpp
#include <iostream>

void mostrar(const int& ref) {
    std::cout << "Valor: " << ref << std::endl;
}

int main() {
    int var = 10;
    mostrar(var); // Salida: 10

    return 0;
}
<---Ejemplo de Referencia Constante Result--->
<---Ejemplo de Constructor de Copia--->
```cpp
#include <iostream>

class MiClase {
private:
    int valor;

public:
    MiClase(int v) : valor(v) {}
    
    // Constructor de copia
    MiClase(const MiClase& otra) : valor(otra.valor) {
        std::cout << "Constructor de copia llamado" << std::endl;
    }

    int obtenerValor() const { return valor; }
};

int main() {
    MiClase obj1(10);
    MiClase obj2 = obj1; // Llama al constructor de copia

    std::cout << "Valor de obj1: " << obj1.obtenerValor() << std::endl; // Salida: 10
    std::cout << "Valor de obj2: " << obj2.obtenerValor() << std::endl; // Salida: 10

    return 0;
}
<---Ejemplo de Constructor de Copia Result--->
<---Ejemplo de Operador de Asignación--->
```cpp
#include <iostream>

class MiClase {
private:
    int valor;

public:
    MiClase(int v) : valor(v) {}
    
    // Operador de asignación
    MiClase& operator=(const MiClase& otra) {
        if (this != &otra) {
            valor = otra.valor;
        }
        return *this;
    }

    int obtenerValor() const { return valor; }
};

int main() {
    MiClase obj1(10);
    MiClase obj2(20);
    obj2 = obj1; // Llama al operador de asignación

    std::cout << "Valor de obj1: " << obj1.obtenerValor() << std::endl; // Salida: 10
    std::cout << "Valor de obj2: " << obj2.obtenerValor() << std::endl; // Salida: 10

    return 0;
}
<---Ejemplo de Operador de Asignación Result--->
<---Ejemplo de Referencia Dangling (a Evitar)--->
```cpp
int& funcion() {
    int var = 10;
    return var; // var se destruye al salir de la función
}

int main() {
    int& ref = funcion(); // ref ahora es una referencia dangling
    std::cout << ref << std::endl; // Comportamiento indefinido

    return 0;
}
```cpp
void mostrar(const int& ref) {
    std::cout << "Valor: " << ref << std::endl;
}
<---Ejemplo de Referencia Dangling (a Evitar) Result--->
<---Asignación de Memoria--->
```cpp
int* ptr = new int; // Asignar memoria para un entero
*ptr = 10;
std::cout << *ptr << std::endl; // Salida: 10

delete ptr; // Liberar la memoria asignada
<---Asignación de Memoria Result--->
<---Asignación de Memoria para Arreglos--->
```cpp
int size = 5;
int* arr = new int[size]; // Asignar memoria para un arreglo de enteros

for(int i = 0; i < size; ++i) {
    arr[i] = i * 10;
}

for(int i = 0; i < size; ++i) {
    std::cout << arr[i] << " "; // Salida: 0 10 20 30 40
}
std::cout << std::endl;

delete[] arr; // Liberar la memoria asignada para el arreglo
<---Asignación de Memoria para Arreglos Result--->
<---Ejemplo: Clase con Gestión de Memoria Dinámica--->
```cpp
#include <iostream>

class MiClase {
private:
    int* data;
    size_t size;

public:
    // Constructor
    MiClase(size_t s) : size(s) {
        data = new int[size];
        for(size_t i = 0; i < size; ++i) {
            data[i] = i * 10;
        }
    }

    // Destructor
    ~MiClase() {
        delete[] data;
    }

    // Constructor de copia
    MiClase(const MiClase& other) : size(other.size) {
        data = new int[size];
        std::copy(other.data, other.data + size, data);
    }

    // Operador de asignación
    MiClase& operator=(const MiClase& other) {
        if (this == &other) return *this;

        delete[] data;

        size = other.size;
        data = new int[size];
        std::copy(other.data, other.data + size, data);

        return *this;
    }

    void print() const {
        for(size_t i = 0; i < size; ++i) {
            std::cout << data[i] << " ";
        }
        std::cout << std::endl;
    }
};

int main() {
    MiClase obj1(5);
    obj1.print(); // Salida: 0 10 20 30 40

    MiClase obj2 = obj1; // Constructor de copia
    obj2.print(); // Salida: 0 10 20 30 40

    MiClase obj3(3);
    obj3 = obj1; // Operador de asignación
    obj3.print(); // Salida: 0 10 20 30 40

    return 0;
}
<---Ejemplo: Clase con Gestión de Memoria Dinámica Result--->
<---Ejemplo con `std::shared_ptr`--->
```cpp
#include <iostream>
#include <memory>

int main() {
    std::shared_ptr<int> ptr1 = std::make_shared<int>(20);
    std::shared_ptr<int> ptr2 = ptr1;

    std::cout << *ptr1 << std::endl; // Salida: 20
    std::cout << *ptr2 << std::endl; // Salida: 20

    return 0;
}
<---Ejemplo con `std::shared_ptr` Result--->
<---Ejemplo con `std::weak_ptr`--->
```cpp
#include <iostream>
#include <memory>

int main() {
    std::shared_ptr<int> sptr = std::make_shared<int>(30);
    std::weak_ptr<int> wptr = sptr;

    std::cout << "Use count: " << sptr.use_count() << std::endl; // Salida: 1

    if (auto spt = wptr.lock()) {
        std::cout << *spt << std::endl; // Salida: 30
    } else {
        std::cout << "wptr is expired" << std::endl;
    }

    return 0;
}
```cpp
int* ptr = new int(10);
// ...
delete ptr; // Liberar la memoria
```cpp
std::unique_ptr<int> ptr = std::make_unique<int>(10);
```cpp
int* ptr = new int(10);
delete ptr;
ptr = nullptr; // Evitar acceso a memoria liberada
```cpp
class Recurso {
public:
    Recurso() { /* adquirir recurso */ }
    ~Recurso() { /* liberar recurso */ }
};
<---Ejemplo con `std::weak_ptr` Result--->
<---Características:--->
<---Características: Result--->
<---Ejemplo de Uso de `std::unique_ptr`--->
```cpp
#include <iostream>
#include <memory>

int main() {
    std::unique_ptr<int> ptr = std::make_unique<int>(10); // Asignación de memoria
    std::cout << *ptr << std::endl; // Salida: 10

    // ptr2 = ptr; // Error: no se permite la copia de std::unique_ptr

    std::unique_ptr<int> ptr2 = std::move(ptr); // Transferencia de propiedad
    std::cout << *ptr2 << std::endl; // Salida: 10

    // La memoria se libera automáticamente al salir de ámbito
    return 0;
}
<---Ejemplo de Uso de `std::unique_ptr` Result--->
<---Ejemplo de Uso de `std::shared_ptr`--->
```cpp
#include <iostream>
#include <memory>

int main() {
    std::shared_ptr<int> ptr1 = std::make_shared<int>(20); // Asignación de memoria
    std::shared_ptr<int> ptr2 = ptr1; // Compartir la propiedad

    std::cout << *ptr1 << std::endl; // Salida: 20
    std::cout << *ptr2 << std::endl; // Salida: 20
    std::cout << "Use count: " << ptr1.use_count() << std::endl; // Salida: 2

    // La memoria se libera automáticamente cuando el último shared_ptr se destruye
    return 0;
}
<---Ejemplo de Uso de `std::shared_ptr` Result--->
<---Ejemplo de Uso de `std::weak_ptr`--->
```cpp
#include <iostream>
#include <memory>

int main() {
    std::shared_ptr<int> sptr = std::make_shared<int>(30);
    std::weak_ptr<int> wptr = sptr; // No incrementa el contador de referencias

    std::cout << "Use count: " << sptr.use_count() << std::endl; // Salida: 1

    if (auto spt = wptr.lock()) { // Comprobar si el recurso aún existe
        std::cout << *spt << std::endl; // Salida: 30
    } else {
        std::cout << "wptr is expired" << std::endl;
    }

    return 0;
}
```cpp
std::unique_ptr<int> ptr = std::make_unique<int>(10);
```cpp
std::shared_ptr<int> ptr1 = std::make_shared<int>(20);
std::shared_ptr<int> ptr2 = ptr1;
```cpp
class Nodo {
public:
    std::shared_ptr<Nodo> siguiente;
    std::weak_ptr<Nodo> anterior; // Evitar ciclo de referencia
};
<---Ejemplo de Uso de `std::weak_ptr` Result--->
<---Memoria Estática--->
```cpp
#include <iostream>

int globalVariable = 10; // Variable global (memoria estática)

int main() {
    static int staticVariable = 20; // Variable estática local (memoria estática)
    return 0;
}
<---Memoria Estática Result--->
<---Memoria Dinámica--->
<---Memoria Dinámica Result--->
<---Ejemplo Básico de Asignación Dinámica--->
```cpp
#include <iostream>

int main() {
    int* ptr = new int; // Asignar memoria para un entero
    *ptr = 100; // Usar la memoria asignada
    std::cout << *ptr << std::endl; // Salida: 100
    delete ptr; // Liberar la memoria

    return 0;
}
<---Ejemplo Básico de Asignación Dinámica Result--->
<---Ejemplo de Arreglo Dinámico--->
```cpp
#include <iostream>

int main() {
    int size = 5;
    int* array = new int[size]; // Asignar memoria para un arreglo de enteros

    for(int i = 0; i < size; ++i) {
        array[i] = i * 10; // Inicializar el arreglo
    }

    for(int i = 0; i < size; ++i) {
        std::cout << array[i] << " "; // Salida: 0 10 20 30 40
    }
    std::cout << std::endl;

    delete[] array; // Liberar la memoria

    return 0;
}
<---Ejemplo de Arreglo Dinámico Result--->
<---Ejemplo Incorrecto--->
```cpp
int* ptr = new int(10);
delete ptr; // Liberar memoria
std::cout << *ptr << std::endl; // Acceso inválido: comportamiento indefinido
<---Ejemplo Incorrecto Result--->
<---Ejemplo Correcto--->
```cpp
int* ptr = new int(10);
delete ptr; // Liberar memoria
ptr = nullptr; // Evitar acceso inválido
```cpp
#include <iostream>
#include <cstring>

class String {
private:
    char* data;
    size_t size;

public:
    String(const char* str) {
        size = strlen(str);
        data = new char[size + 1];
        strcpy(data, str);
    }

    ~String() {
        delete[] data;
    }

    // Constructor de copia
    String(const String& other) {
        size = other.size;
        data = new char[size + 1];
        strcpy(data, other.data);
    }

    // Operador de asignación
    String& operator=(const String& other) {
        if (this == &other) return *this;

        delete[] data;

        size = other.size;
        data = new char[size + 1];
        strcpy(data, other.data);
        return *this;
    }

    void print() const {
        std::cout << data << std::endl;
    }
};

int main() {
    String str1("Hello");
    String str2 = str1; // Constructor de copia
    String str3("World");
    str3 = str1; // Operador de asignación
    str1.print(); // Salida: Hello
    str2.print(); // Salida: Hello
    str3.print(); // Salida: Hello

    return 0;
}
<---Ejemplo Correcto Result--->
<---Ejemplo con `std::unique_ptr`--->
```cpp
#include <iostream>
#include <memory>

int main() {
    std::unique_ptr<int> ptr = std::make_unique<int>(10);
    std::cout << *ptr << std::endl; // Salida: 10

    return 0;
}
<---Ejemplo con `std::unique_ptr` Result--->
<---Declaración de Punteros--->
```cpp
int* ptr; // Declara un puntero a un entero
<---Declaración de Punteros Result--->
<---Asignación y Acceso a Datos--->
```cpp
int var = 10;
int* ptr = &var; // ptr apunta a la dirección de var

std::cout << "Valor de var: " << var << std::endl; // Salida: 10
std::cout << "Dirección de var: " << &var << std::endl; // Dirección de var
std::cout << "Valor apuntado por ptr: " << *ptr << std::endl; // Salida: 10
```cpp
int arr[5] = {1, 2, 3, 4, 5};
int* ptr = arr; // ptr apunta al primer elemento del arreglo

for(int i = 0; i < 5; ++i) {
    std::cout << *(ptr + i) << " "; // Acceder a los elementos del arreglo usando punteros
}
// Salida: 1 2 3 4 5
```cpp
int arr[5] = {1, 2, 3, 4, 5};
int* ptr = arr;

std::cout << "Primer elemento: " << *ptr << std::endl; // Salida: 1
ptr++;
std::cout << "Segundo elemento: " << *ptr << std::endl; // Salida: 2
```cpp
int var = 10;
int* ptr = &var;
int** ptr2 = &ptr;

std::cout << "Valor de var: " << var << std::endl; // Salida: 10
std::cout << "Valor apuntado por ptr: " << *ptr << std::endl; // Salida: 10
std::cout << "Valor apuntado por ptr2: " << **ptr2 << std::endl; // Salida: 10
```cpp
int* ptr = nullptr; // Puntero inicializado a nullptr
```cpp
int* ptr = new int(10);
delete ptr; // Liberar memoria asignada
ptr = nullptr; // Evitar acceso a memoria liberada
```cpp
int* ptr = new int(10);
delete ptr;
ptr = nullptr; // Ahora ptr no es un puntero colgante
<---Asignación y Acceso a Datos Result--->
<---Paso por Referencia usando Punteros--->
```cpp
#include <iostream>

void incrementar(int* ptr) {
    (*ptr)++;
}

int main() {
    int var = 10;
    incrementar(&var);
    std::cout << "Valor de var después de incrementar: " << var << std::endl; // Salida: 11

    return 0;
}
<---Paso por Referencia usando Punteros Result--->
<---Ejemplo de Puntero a Función--->
```cpp
#include <iostream>

void saludo() {
    std::cout << "Hola, Mundo!" << std::endl;
}

void llamarFuncion(void (*func)()) {
    func();
}

int main() {
    void (*ptrFunc)() = &saludo;
    llamarFuncion(ptrFunc); // Salida: Hola, Mundo!

    return 0;
}
<---Ejemplo de Puntero a Función Result--->
<---Declaración Básica--->
```cpp
int var = 10;
int& ref = var; // ref es una referencia a var

std::cout << "var: " << var << std::endl; // Salida: 10
std::cout << "ref: " << ref << std::endl; // Salida: 10
<---Declaración Básica Result--->
<---Modificación a través de Referencias--->
```cpp
int var = 10;
int& ref = var;

ref = 20; // Modifica var a través de ref

std::cout << "var: " << var << std::endl; // Salida: 20
std::cout << "ref: " << ref << std::endl; // Salida: 20
<---Modificación a través de Referencias Result--->
<---Ejemplo de Paso por Referencia--->
```cpp
#include <iostream>

void incrementar(int& ref) {
    ref++;
}

int main() {
    int var = 10;
    incrementar(var);
    std::cout << "Valor de var después de incrementar: " << var << std::endl; // Salida: 11

    return 0;
}
<---Ejemplo de Paso por Referencia Result--->
<---Ejemplo de Referencia Constante--->
```cpp
#include <iostream>

void mostrar(const int& ref) {
    std::cout << "Valor: " << ref << std::endl;
}

int main() {
    int var = 10;
    mostrar(var); // Salida: 10

    return 0;
}
<---Ejemplo de Referencia Constante Result--->
<---Ejemplo de Constructor de Copia--->
```cpp
#include <iostream>

class MiClase {
private:
    int valor;

public:
    MiClase(int v) : valor(v) {}
    
    // Constructor de copia
    MiClase(const MiClase& otra) : valor(otra.valor) {
        std::cout << "Constructor de copia llamado" << std::endl;
    }

    int obtenerValor() const { return valor; }
};

int main() {
    MiClase obj1(10);
    MiClase obj2 = obj1; // Llama al constructor de copia

    std::cout << "Valor de obj1: " << obj1.obtenerValor() << std::endl; // Salida: 10
    std::cout << "Valor de obj2: " << obj2.obtenerValor() << std::endl; // Salida: 10

    return 0;
}
<---Ejemplo de Constructor de Copia Result--->
<---Ejemplo de Operador de Asignación--->
```cpp
#include <iostream>

class MiClase {
private:
    int valor;

public:
    MiClase(int v) : valor(v) {}
    
    // Operador de asignación
    MiClase& operator=(const MiClase& otra) {
        if (this != &otra) {
            valor = otra.valor;
        }
        return *this;
    }

    int obtenerValor() const { return valor; }
};

int main() {
    MiClase obj1(10);
    MiClase obj2(20);
    obj2 = obj1; // Llama al operador de asignación

    std::cout << "Valor de obj1: " << obj1.obtenerValor() << std::endl; // Salida: 10
    std::cout << "Valor de obj2: " << obj2.obtenerValor() << std::endl; // Salida: 10

    return 0;
}
<---Ejemplo de Operador de Asignación Result--->
<---Ejemplo de Referencia Dangling (a Evitar)--->
```cpp
int& funcion() {
    int var = 10;
    return var; // var se destruye al salir de la función
}

int main() {
    int& ref = funcion(); // ref ahora es una referencia dangling
    std::cout << ref << std::endl; // Comportamiento indefinido

    return 0;
}
```cpp
void mostrar(const int& ref) {
    std::cout << "Valor: " << ref << std::endl;
}
<---Ejemplo de Referencia Dangling (a Evitar) Result--->
<---Asignación de Memoria--->
```cpp
int* ptr = new int; // Asignar memoria para un entero
*ptr = 10;
std::cout << *ptr << std::endl; // Salida: 10

delete ptr; // Liberar la memoria asignada
<---Asignación de Memoria Result--->
<---Asignación de Memoria para Arreglos--->
```cpp
int size = 5;
int* arr = new int[size]; // Asignar memoria para un arreglo de enteros

for(int i = 0; i < size; ++i) {
    arr[i] = i * 10;
}

for(int i = 0; i < size; ++i) {
    std::cout << arr[i] << " "; // Salida: 0 10 20 30 40
}
std::cout << std::endl;

delete[] arr; // Liberar la memoria asignada para el arreglo
<---Asignación de Memoria para Arreglos Result--->
<---Ejemplo: Clase con Gestión de Memoria Dinámica--->
```cpp
#include <iostream>

class MiClase {
private:
    int* data;
    size_t size;

public:
    // Constructor
    MiClase(size_t s) : size(s) {
        data = new int[size];
        for(size_t i = 0; i < size; ++i) {
            data[i] = i * 10;
        }
    }

    // Destructor
    ~MiClase() {
        delete[] data;
    }

    // Constructor de copia
    MiClase(const MiClase& other) : size(other.size) {
        data = new int[size];
        std::copy(other.data, other.data + size, data);
    }

    // Operador de asignación
    MiClase& operator=(const MiClase& other) {
        if (this == &other) return *this;

        delete[] data;

        size = other.size;
        data = new int[size];
        std::copy(other.data, other.data + size, data);

        return *this;
    }

    void print() const {
        for(size_t i = 0; i < size; ++i) {
            std::cout << data[i] << " ";
        }
        std::cout << std::endl;
    }
};

int main() {
    MiClase obj1(5);
    obj1.print(); // Salida: 0 10 20 30 40

    MiClase obj2 = obj1; // Constructor de copia
    obj2.print(); // Salida: 0 10 20 30 40

    MiClase obj3(3);
    obj3 = obj1; // Operador de asignación
    obj3.print(); // Salida: 0 10 20 30 40

    return 0;
}
<---Ejemplo: Clase con Gestión de Memoria Dinámica Result--->
<---Ejemplo con `std::shared_ptr`--->
```cpp
#include <iostream>
#include <memory>

int main() {
    std::shared_ptr<int> ptr1 = std::make_shared<int>(20);
    std::shared_ptr<int> ptr2 = ptr1;

    std::cout << *ptr1 << std::endl; // Salida: 20
    std::cout << *ptr2 << std::endl; // Salida: 20

    return 0;
}
<---Ejemplo con `std::shared_ptr` Result--->
<---Ejemplo con `std::weak_ptr`--->
```cpp
#include <iostream>
#include <memory>

int main() {
    std::shared_ptr<int> sptr = std::make_shared<int>(30);
    std::weak_ptr<int> wptr = sptr;

    std::cout << "Use count: " << sptr.use_count() << std::endl; // Salida: 1

    if (auto spt = wptr.lock()) {
        std::cout << *spt << std::endl; // Salida: 30
    } else {
        std::cout << "wptr is expired" << std::endl;
    }

    return 0;
}
```cpp
int* ptr = new int(10);
// ...
delete ptr; // Liberar la memoria
```cpp
std::unique_ptr<int> ptr = std::make_unique<int>(10);
```cpp
int* ptr = new int(10);
delete ptr;
ptr = nullptr; // Evitar acceso a memoria liberada
```cpp
class Recurso {
public:
    Recurso() { /* adquirir recurso */ }
    ~Recurso() { /* liberar recurso */ }
};
<---Ejemplo con `std::weak_ptr` Result--->
<---Características:--->
<---Características: Result--->
<---Ejemplo de Uso de `std::unique_ptr`--->
```cpp
#include <iostream>
#include <memory>

int main() {
    std::unique_ptr<int> ptr = std::make_unique<int>(10); // Asignación de memoria
    std::cout << *ptr << std::endl; // Salida: 10

    // ptr2 = ptr; // Error: no se permite la copia de std::unique_ptr

    std::unique_ptr<int> ptr2 = std::move(ptr); // Transferencia de propiedad
    std::cout << *ptr2 << std::endl; // Salida: 10

    // La memoria se libera automáticamente al salir de ámbito
    return 0;
}
<---Ejemplo de Uso de `std::unique_ptr` Result--->
<---Ejemplo de Uso de `std::shared_ptr`--->
```cpp
#include <iostream>
#include <memory>

int main() {
    std::shared_ptr<int> ptr1 = std::make_shared<int>(20); // Asignación de memoria
    std::shared_ptr<int> ptr2 = ptr1; // Compartir la propiedad

    std::cout << *ptr1 << std::endl; // Salida: 20
    std::cout << *ptr2 << std::endl; // Salida: 20
    std::cout << "Use count: " << ptr1.use_count() << std::endl; // Salida: 2

    // La memoria se libera automáticamente cuando el último shared_ptr se destruye
    return 0;
}
<---Ejemplo de Uso de `std::shared_ptr` Result--->
<---Ejemplo de Uso de `std::weak_ptr`--->
```cpp
#include <iostream>
#include <memory>

int main() {
    std::shared_ptr<int> sptr = std::make_shared<int>(30);
    std::weak_ptr<int> wptr = sptr; // No incrementa el contador de referencias

    std::cout << "Use count: " << sptr.use_count() << std::endl; // Salida: 1

    if (auto spt = wptr.lock()) { // Comprobar si el recurso aún existe
        std::cout << *spt << std::endl; // Salida: 30
    } else {
        std::cout << "wptr is expired" << std::endl;
    }

    return 0;
}
```cpp
std::unique_ptr<int> ptr = std::make_unique<int>(10);
```cpp
std::shared_ptr<int> ptr1 = std::make_shared<int>(20);
std::shared_ptr<int> ptr2 = ptr1;
```cpp
class Nodo {
public:
    std::shared_ptr<Nodo> siguiente;
    std::weak_ptr<Nodo> anterior; // Evitar ciclo de referencia
};
<---Ejemplo de Uso de `std::weak_ptr` Result--->
<---Declaración y Asignación--->
```cpp
#include <iostream>
#include <memory>

int main() {
    std::unique_ptr<int> ptr = std::make_unique<int>(10);
    std::cout << *ptr << std::endl; // Salida: 10
    // Memoria liberada automáticamente al salir del alcance
    return 0;
}
<---Declaración y Asignación Result--->
<---Declaración en el Archivo de Cabecera (.h)--->
```cpp
// MiClase.h
#ifndef MICLASE_H
#define MICLASE_H

#include <memory>
#include <string>

class MiClase {
public:
    MiClase(const std::string& nombre);
    ~MiClase();

    void mostrar() const;

private:
    std::unique_ptr<std::string> nombre_;
};

#endif // MICLASE_H
<---Declaración en el Archivo de Cabecera (.h) Result--->
<---Definición en el Archivo de Implementación (.cpp)--->
```cpp
// MiClase.cpp
#include "MiClase.h"
#include <iostream>

// Constructor
MiClase::MiClase(const std::string& nombre)
    : nombre_(std::make_unique<std::string>(nombre)) {}

// Destructor
MiClase::~MiClase() {
    // `std::unique_ptr` libera la memoria automáticamente
}

// Método mostrar
void MiClase::mostrar() const {
    std::cout << "Nombre: " << *nombre_ << std::endl;
}
<---Definición en el Archivo de Implementación (.cpp) Result--->
<---Ejemplo de Transferencia de Propiedad--->
```cpp
#include <iostream>
#include <memory>

void mostrar(std::unique_ptr<int> ptr) {
    std::cout << *ptr << std::endl;
}

int main() {
    std::unique_ptr<int> ptr = std::make_unique<int>(42);
    mostrar(std::move(ptr)); // Transferir la propiedad
    // ptr ya no es válido aquí
    return 0;
}
<---Ejemplo de Transferencia de Propiedad Result--->
<---1. Encapsulación de Recursos--->
```cpp
class Archivo {
public:
    Archivo(const std::string& nombre) : archivo_(std::fopen(nombre.c_str(), "r")) {
        if (!archivo_) {
            throw std::runtime_error("No se pudo abrir el archivo");
        }
    }

    ~Archivo() {
        if (archivo_) {
            std::fclose(archivo_);
        }
    }

private:
    std::unique_ptr<FILE, decltype(&std::fclose)> archivo_;
};
<---1. Encapsulación de Recursos Result--->
<---2. Uso en Contenedores--->
```cpp
#include <vector>
#include <memory>

int main() {
    std::vector<std::unique_ptr<int>> vec;
    vec.push_back(std::make_unique<int>(1));
    vec.push_back(std::make_unique<int>(2));
    vec.push_back(std::make_unique<int>(3));

    for (const auto& ptr : vec) {
        std::cout << *ptr << std::endl;
    }
    return 0;
}
<---2. Uso en Contenedores Result--->
<---3. Evitar el Uso de Punteros Crudos--->
<---3. Evitar el Uso de Punteros Crudos Result--->
<---Archivo de Cabecera (.h)--->
```cpp
// GestorRecurso.h
#ifndef GESTORRECURSO_H
#define GESTORRECURSO_H

#include <memory>
#include <string>

class GestorRecurso {
public:
    GestorRecurso(const std::string& nombre);
    void mostrarRecurso() const;

    // Transferir la propiedad del recurso
    std::unique_ptr<std::string> transferirRecurso();

private:
    std::unique_ptr<std::string> recurso_;
};

#endif // GESTORRECURSO_H
<---Archivo de Cabecera (.h) Result--->
<---Archivo de Implementación (.cpp)--->
```cpp
// GestorRecurso.cpp
#include "GestorRecurso.h"
#include <iostream>

GestorRecurso::GestorRecurso(const std::string& nombre)
    : recurso_(std::make_unique<std::string>(nombre)) {}

void GestorRecurso::mostrarRecurso() const {
    std::cout << "Recurso: " << *recurso_ << std::endl;
}

std::unique_ptr<std::string> GestorRecurso::transferirRecurso() {
    return std::move(recurso_);
}
<---Archivo de Implementación (.cpp) Result--->
<---Función Principal--->
```cpp
#include <iostream>
#include "GestorRecurso.h"

int main() {
    GestorRecurso gestor("MiRecurso");
    gestor.mostrarRecurso();

    std::unique_ptr<std::string> recurso = gestor.transferirRecurso();
    if (recurso) {
        std::cout << "Recurso transferido: " << *recurso << std::endl;
    }

    // Intentar mostrar el recurso después de la transferencia
    gestor.mostrarRecurso(); // Esto no imprimirá nada ya que el recurso fue transferido

    return 0;
}
<---Función Principal Result--->
<---Memoria Estática--->
```cpp
#include <iostream>

int globalVariable = 10; // Variable global (memoria estática)

int main() {
    static int staticVariable = 20; // Variable estática local (memoria estática)
    return 0;
}
<---Memoria Estática Result--->
<---Memoria Dinámica--->
<---Memoria Dinámica Result--->
<---Ejemplo Básico de Asignación Dinámica--->
```cpp
#include <iostream>

int main() {
    int* ptr = new int; // Asignar memoria para un entero
    *ptr = 100; // Usar la memoria asignada
    std::cout << *ptr << std::endl; // Salida: 100
    delete ptr; // Liberar la memoria

    return 0;
}
<---Ejemplo Básico de Asignación Dinámica Result--->
<---Ejemplo de Arreglo Dinámico--->
```cpp
#include <iostream>

int main() {
    int size = 5;
    int* array = new int[size]; // Asignar memoria para un arreglo de enteros

    for(int i = 0; i < size; ++i) {
        array[i] = i * 10; // Inicializar el arreglo
    }

    for(int i = 0; i < size; ++i) {
        std::cout << array[i] << " "; // Salida: 0 10 20 30 40
    }
    std::cout << std::endl;

    delete[] array; // Liberar la memoria

    return 0;
}
<---Ejemplo de Arreglo Dinámico Result--->
<---Ejemplo Incorrecto--->
```cpp
int* ptr = new int(10);
delete ptr; // Liberar memoria
std::cout << *ptr << std::endl; // Acceso inválido: comportamiento indefinido
<---Ejemplo Incorrecto Result--->
<---Ejemplo Correcto--->
```cpp
int* ptr = new int(10);
delete ptr; // Liberar memoria
ptr = nullptr; // Evitar acceso inválido
```cpp
#include <iostream>
#include <cstring>

class String {
private:
    char* data;
    size_t size;

public:
    String(const char* str) {
        size = strlen(str);
        data = new char[size + 1];
        strcpy(data, str);
    }

    ~String() {
        delete[] data;
    }

    // Constructor de copia
    String(const String& other) {
        size = other.size;
        data = new char[size + 1];
        strcpy(data, other.data);
    }

    // Operador de asignación
    String& operator=(const String& other) {
        if (this == &other) return *this;

        delete[] data;

        size = other.size;
        data = new char[size + 1];
        strcpy(data, other.data);
        return *this;
    }

    void print() const {
        std::cout << data << std::endl;
    }
};

int main() {
    String str1("Hello");
    String str2 = str1; // Constructor de copia
    String str3("World");
    str3 = str1; // Operador de asignación
    str1.print(); // Salida: Hello
    str2.print(); // Salida: Hello
    str3.print(); // Salida: Hello

    return 0;
}
<---Ejemplo Correcto Result--->
<---Ejemplo con `std::unique_ptr`--->
```cpp
#include <iostream>
#include <memory>

int main() {
    std::unique_ptr<int> ptr = std::make_unique<int>(10);
    std::cout << *ptr << std::endl; // Salida: 10

    return 0;
}
<---Ejemplo con `std::unique_ptr` Result--->
<---Declaración de Punteros--->
```cpp
int* ptr; // Declara un puntero a un entero
<---Declaración de Punteros Result--->
<---Asignación y Acceso a Datos--->
```cpp
int var = 10;
int* ptr = &var; // ptr apunta a la dirección de var

std::cout << "Valor de var: " << var << std::endl; // Salida: 10
std::cout << "Dirección de var: " << &var << std::endl; // Dirección de var
std::cout << "Valor apuntado por ptr: " << *ptr << std::endl; // Salida: 10
```cpp
int arr[5] = {1, 2, 3, 4, 5};
int* ptr = arr; // ptr apunta al primer elemento del arreglo

for(int i = 0; i < 5; ++i) {
    std::cout << *(ptr + i) << " "; // Acceder a los elementos del arreglo usando punteros
}
// Salida: 1 2 3 4 5
```cpp
int arr[5] = {1, 2, 3, 4, 5};
int* ptr = arr;

std::cout << "Primer elemento: " << *ptr << std::endl; // Salida: 1
ptr++;
std::cout << "Segundo elemento: " << *ptr << std::endl; // Salida: 2
```cpp
int var = 10;
int* ptr = &var;
int** ptr2 = &ptr;

std::cout << "Valor de var: " << var << std::endl; // Salida: 10
std::cout << "Valor apuntado por ptr: " << *ptr << std::endl; // Salida: 10
std::cout << "Valor apuntado por ptr2: " << **ptr2 << std::endl; // Salida: 10
```cpp
int* ptr = nullptr; // Puntero inicializado a nullptr
```cpp
int* ptr = new int(10);
delete ptr; // Liberar memoria asignada
ptr = nullptr; // Evitar acceso a memoria liberada
```cpp
int* ptr = new int(10);
delete ptr;
ptr = nullptr; // Ahora ptr no es un puntero colgante
<---Asignación y Acceso a Datos Result--->
<---Paso por Referencia usando Punteros--->
```cpp
#include <iostream>

void incrementar(int* ptr) {
    (*ptr)++;
}

int main() {
    int var = 10;
    incrementar(&var);
    std::cout << "Valor de var después de incrementar: " << var << std::endl; // Salida: 11

    return 0;
}
<---Paso por Referencia usando Punteros Result--->
<---Ejemplo de Puntero a Función--->
```cpp
#include <iostream>

void saludo() {
    std::cout << "Hola, Mundo!" << std::endl;
}

void llamarFuncion(void (*func)()) {
    func();
}

int main() {
    void (*ptrFunc)() = &saludo;
    llamarFuncion(ptrFunc); // Salida: Hola, Mundo!

    return 0;
}
<---Ejemplo de Puntero a Función Result--->
<---Declaración Básica--->
```cpp
int var = 10;
int& ref = var; // ref es una referencia a var

std::cout << "var: " << var << std::endl; // Salida: 10
std::cout << "ref: " << ref << std::endl; // Salida: 10
<---Declaración Básica Result--->
<---Modificación a través de Referencias--->
```cpp
int var = 10;
int& ref = var;

ref = 20; // Modifica var a través de ref

std::cout << "var: " << var << std::endl; // Salida: 20
std::cout << "ref: " << ref << std::endl; // Salida: 20
<---Modificación a través de Referencias Result--->
<---Ejemplo de Paso por Referencia--->
```cpp
#include <iostream>

void incrementar(int& ref) {
    ref++;
}

int main() {
    int var = 10;
    incrementar(var);
    std::cout << "Valor de var después de incrementar: " << var << std::endl; // Salida: 11

    return 0;
}
<---Ejemplo de Paso por Referencia Result--->
<---Ejemplo de Referencia Constante--->
```cpp
#include <iostream>

void mostrar(const int& ref) {
    std::cout << "Valor: " << ref << std::endl;
}

int main() {
    int var = 10;
    mostrar(var); // Salida: 10

    return 0;
}
<---Ejemplo de Referencia Constante Result--->
<---Ejemplo de Constructor de Copia--->
```cpp
#include <iostream>

class MiClase {
private:
    int valor;

public:
    MiClase(int v) : valor(v) {}
    
    // Constructor de copia
    MiClase(const MiClase& otra) : valor(otra.valor) {
        std::cout << "Constructor de copia llamado" << std::endl;
    }

    int obtenerValor() const { return valor; }
};

int main() {
    MiClase obj1(10);
    MiClase obj2 = obj1; // Llama al constructor de copia

    std::cout << "Valor de obj1: " << obj1.obtenerValor() << std::endl; // Salida: 10
    std::cout << "Valor de obj2: " << obj2.obtenerValor() << std::endl; // Salida: 10

    return 0;
}
<---Ejemplo de Constructor de Copia Result--->
<---Ejemplo de Operador de Asignación--->
```cpp
#include <iostream>

class MiClase {
private:
    int valor;

public:
    MiClase(int v) : valor(v) {}
    
    // Operador de asignación
    MiClase& operator=(const MiClase& otra) {
        if (this != &otra) {
            valor = otra.valor;
        }
        return *this;
    }

    int obtenerValor() const { return valor; }
};

int main() {
    MiClase obj1(10);
    MiClase obj2(20);
    obj2 = obj1; // Llama al operador de asignación

    std::cout << "Valor de obj1: " << obj1.obtenerValor() << std::endl; // Salida: 10
    std::cout << "Valor de obj2: " << obj2.obtenerValor() << std::endl; // Salida: 10

    return 0;
}
<---Ejemplo de Operador de Asignación Result--->
<---Ejemplo de Referencia Dangling (a Evitar)--->
```cpp
int& funcion() {
    int var = 10;
    return var; // var se destruye al salir de la función
}

int main() {
    int& ref = funcion(); // ref ahora es una referencia dangling
    std::cout << ref << std::endl; // Comportamiento indefinido

    return 0;
}
```cpp
void mostrar(const int& ref) {
    std::cout << "Valor: " << ref << std::endl;
}
<---Ejemplo de Referencia Dangling (a Evitar) Result--->
<---Asignación de Memoria--->
```cpp
int* ptr = new int; // Asignar memoria para un entero
*ptr = 10;
std::cout << *ptr << std::endl; // Salida: 10

delete ptr; // Liberar la memoria asignada
<---Asignación de Memoria Result--->
<---Asignación de Memoria para Arreglos--->
```cpp
int size = 5;
int* arr = new int[size]; // Asignar memoria para un arreglo de enteros

for(int i = 0; i < size; ++i) {
    arr[i] = i * 10;
}

for(int i = 0; i < size; ++i) {
    std::cout << arr[i] << " "; // Salida: 0 10 20 30 40
}
std::cout << std::endl;

delete[] arr; // Liberar la memoria asignada para el arreglo
<---Asignación de Memoria para Arreglos Result--->
<---Ejemplo: Clase con Gestión de Memoria Dinámica--->
```cpp
#include <iostream>

class MiClase {
private:
    int* data;
    size_t size;

public:
    // Constructor
    MiClase(size_t s) : size(s) {
        data = new int[size];
        for(size_t i = 0; i < size; ++i) {
            data[i] = i * 10;
        }
    }

    // Destructor
    ~MiClase() {
        delete[] data;
    }

    // Constructor de copia
    MiClase(const MiClase& other) : size(other.size) {
        data = new int[size];
        std::copy(other.data, other.data + size, data);
    }

    // Operador de asignación
    MiClase& operator=(const MiClase& other) {
        if (this == &other) return *this;

        delete[] data;

        size = other.size;
        data = new int[size];
        std::copy(other.data, other.data + size, data);

        return *this;
    }

    void print() const {
        for(size_t i = 0; i < size; ++i) {
            std::cout << data[i] << " ";
        }
        std::cout << std::endl;
    }
};

int main() {
    MiClase obj1(5);
    obj1.print(); // Salida: 0 10 20 30 40

    MiClase obj2 = obj1; // Constructor de copia
    obj2.print(); // Salida: 0 10 20 30 40

    MiClase obj3(3);
    obj3 = obj1; // Operador de asignación
    obj3.print(); // Salida: 0 10 20 30 40

    return 0;
}
<---Ejemplo: Clase con Gestión de Memoria Dinámica Result--->
<---Ejemplo con `std::shared_ptr`--->
```cpp
#include <iostream>
#include <memory>

int main() {
    std::shared_ptr<int> ptr1 = std::make_shared<int>(20);
    std::shared_ptr<int> ptr2 = ptr1;

    std::cout << *ptr1 << std::endl; // Salida: 20
    std::cout << *ptr2 << std::endl; // Salida: 20

    return 0;
}
<---Ejemplo con `std::shared_ptr` Result--->
<---Ejemplo con `std::weak_ptr`--->
```cpp
#include <iostream>
#include <memory>

int main() {
    std::shared_ptr<int> sptr = std::make_shared<int>(30);
    std::weak_ptr<int> wptr = sptr;

    std::cout << "Use count: " << sptr.use_count() << std::endl; // Salida: 1

    if (auto spt = wptr.lock()) {
        std::cout << *spt << std::endl; // Salida: 30
    } else {
        std::cout << "wptr is expired" << std::endl;
    }

    return 0;
}
```cpp
int* ptr = new int(10);
// ...
delete ptr; // Liberar la memoria
```cpp
std::unique_ptr<int> ptr = std::make_unique<int>(10);
```cpp
int* ptr = new int(10);
delete ptr;
ptr = nullptr; // Evitar acceso a memoria liberada
```cpp
class Recurso {
public:
    Recurso() { /* adquirir recurso */ }
    ~Recurso() { /* liberar recurso */ }
};
<---Ejemplo con `std::weak_ptr` Result--->
<---Características:--->
<---Características: Result--->
<---Ejemplo de Uso de `std::unique_ptr`--->
```cpp
#include <iostream>
#include <memory>

int main() {
    std::unique_ptr<int> ptr = std::make_unique<int>(10); // Asignación de memoria
    std::cout << *ptr << std::endl; // Salida: 10

    // ptr2 = ptr; // Error: no se permite la copia de std::unique_ptr

    std::unique_ptr<int> ptr2 = std::move(ptr); // Transferencia de propiedad
    std::cout << *ptr2 << std::endl; // Salida: 10

    // La memoria se libera automáticamente al salir de ámbito
    return 0;
}
<---Ejemplo de Uso de `std::unique_ptr` Result--->
<---Ejemplo de Uso de `std::shared_ptr`--->
```cpp
#include <iostream>
#include <memory>

int main() {
    std::shared_ptr<int> ptr1 = std::make_shared<int>(20); // Asignación de memoria
    std::shared_ptr<int> ptr2 = ptr1; // Compartir la propiedad

    std::cout << *ptr1 << std::endl; // Salida: 20
    std::cout << *ptr2 << std::endl; // Salida: 20
    std::cout << "Use count: " << ptr1.use_count() << std::endl; // Salida: 2

    // La memoria se libera automáticamente cuando el último shared_ptr se destruye
    return 0;
}
<---Ejemplo de Uso de `std::shared_ptr` Result--->
<---Ejemplo de Uso de `std::weak_ptr`--->
```cpp
#include <iostream>
#include <memory>

int main() {
    std::shared_ptr<int> sptr = std::make_shared<int>(30);
    std::weak_ptr<int> wptr = sptr; // No incrementa el contador de referencias

    std::cout << "Use count: " << sptr.use_count() << std::endl; // Salida: 1

    if (auto spt = wptr.lock()) { // Comprobar si el recurso aún existe
        std::cout << *spt << std::endl; // Salida: 30
    } else {
        std::cout << "wptr is expired" << std::endl;
    }

    return 0;
}
```cpp
std::unique_ptr<int> ptr = std::make_unique<int>(10);
```cpp
std::shared_ptr<int> ptr1 = std::make_shared<int>(20);
std::shared_ptr<int> ptr2 = ptr1;
```cpp
class Nodo {
public:
    std::shared_ptr<Nodo> siguiente;
    std::weak_ptr<Nodo> anterior; // Evitar ciclo de referencia
};
<---Ejemplo de Uso de `std::weak_ptr` Result--->
<---Declaración y Asignación--->
```cpp
#include <iostream>
#include <memory>

int main() {
    std::shared_ptr<int> ptr1 = std::make_shared<int>(10);
    std::shared_ptr<int> ptr2 = ptr1; // ptr1 y ptr2 comparten la propiedad del mismo recurso

    std::cout << *ptr1 << std::endl; // Salida: 10
    std::cout << "Use count: " << ptr1.use_count() << std::endl; // Salida: 2

    // Memoria liberada automáticamente cuando el último shared_ptr sale del alcance
    return 0;
}
<---Declaración y Asignación Result--->
<---Declaración en el Archivo de Cabecera (.h)--->
```cpp
// MiClase.h
#ifndef MICLASE_H
#define MICLASE_H

#include <memory>
#include <string>

class MiClase {
public:
    MiClase(const std::string& nombre);
    void mostrar() const;

private:
    std::shared_ptr<std::string> nombre_;
};

#endif // MICLASE_H
<---Declaración en el Archivo de Cabecera (.h) Result--->
<---Definición en el Archivo de Implementación (.cpp)--->
```cpp
// MiClase.cpp
#include "MiClase.h"
#include <iostream>

// Constructor
MiClase::MiClase(const std::string& nombre)
    : nombre_(std::make_shared<std::string>(nombre)) {}

// Método mostrar
void MiClase::mostrar() const {
    std::cout << "Nombre: " << *nombre_ << std::endl;
}
<---Definición en el Archivo de Implementación (.cpp) Result--->
<---Ejemplo de Transferencia de Propiedad--->
```cpp
#include <iostream>
#include <memory>

void mostrar(std::unique_ptr<int> ptr) {
    std::cout << *ptr << std::endl;
}

int main() {
    std::unique_ptr<int> ptr = std::make_unique<int>(42);
    mostrar(std::move(ptr)); // Transferir la propiedad
    // ptr ya no es válido aquí
    return 0;
}
<---Ejemplo de Transferencia de Propiedad Result--->
<---1. Encapsulación de Recursos--->
```cpp
class Archivo {
public:
    Archivo(const std::string& nombre) : archivo_(std::fopen(nombre.c_str(), "r")) {
        if (!archivo_) {
            throw std::runtime_error("No se pudo abrir el archivo");
        }
    }

    ~Archivo() {
        if (archivo_) {
            std::fclose(archivo_);
        }
    }

private:
    std::unique_ptr<FILE, decltype(&std::fclose)> archivo_;
};
<---1. Encapsulación de Recursos Result--->
<---2. Uso en Contenedores--->
```cpp
#include <vector>
#include <memory>

int main() {
    std::vector<std::unique_ptr<int>> vec;
    vec.push_back(std::make_unique<int>(1));
    vec.push_back(std::make_unique<int>(2));
    vec.push_back(std::make_unique<int>(3));

    for (const auto& ptr : vec) {
        std::cout << *ptr << std::endl;
    }
    return 0;
}
<---2. Uso en Contenedores Result--->
<---3. Evitar el Uso de Punteros Crudos--->
<---3. Evitar el Uso de Punteros Crudos Result--->
<---Archivo de Cabecera (.h)--->
```cpp
// GestorRecurso.h
#ifndef GESTORRECURSO_H
#define GESTORRECURSO_H

#include <memory>
#include <string>

class GestorRecurso {
public:
    GestorRecurso(const std::string& nombre);
    void mostrarRecurso() const;

private:
    std::shared_ptr<std::string> recurso_;
};

class Contenedor {
public:
    void establecerRecurso(std::shared_ptr<GestorRecurso> recurso);
    void mostrar() const;

private:
    std::shared_ptr<GestorRecurso> recurso_;
};

#endif // GESTORRECURSO_H
<---Archivo de Cabecera (.h) Result--->
<---Archivo de Implementación (.cpp)--->
```cpp
// GestorRecurso.cpp
#include "GestorRecurso.h"
#include <iostream>

GestorRecurso::GestorRecurso(const std::string& nombre)
    : recurso_(std::make_shared<std::string>(nombre)) {}

void GestorRecurso::mostrarRecurso() const {
    std::cout << "Recurso: " << *recurso_ << std::endl;
}

void Contenedor::establecerRecurso(std::shared_ptr<GestorRecurso> recurso) {
    recurso_ = recurso;
}

void Contenedor::mostrar() const {
    if (recurso_) {
        recurso_->mostrarRecurso();
    } else {
        std::cout << "Sin recurso" << std::endl;
    }
}
<---Archivo de Implementación (.cpp) Result--->
<---Función Principal--->
```cpp
#include <iostream>
#include "GestorRecurso.h"

int main() {
    auto recurso = std::make_shared<GestorRecurso>("MiRecurso");
    Contenedor contenedor;
    contenedor.establecerRecurso(recurso);

    recurso->mostrarRecurso();
    contenedor.mostrar();

    return 0;
}
<---Función Principal Result--->
<---1. Compartición de Recursos--->
```cpp
#include <memory>
#include <vector>
#include <iostream>

class Nodo {
public:
    Nodo(int valor) : valor_(valor) {}

    void agregarHijo(std::shared_ptr<Nodo> hijo) {
        hijos_.push_back(hijo);
    }

    void mostrar() const {
        std::cout << "Nodo: " << valor_ << std::endl;
        for (const auto& hijo : hijos_) {
            hijo->mostrar();
        }
    }

private:
    int valor_;
    std::vector<std::shared_ptr<Nodo>> hijos_;
};

int main() {
    auto raiz = std::make_shared<Nodo>(1);
    auto hijo1 = std::make_shared<Nodo>(2);
    auto hijo2 = std::make_shared<Nodo>(3);

    raiz->agregarHijo(hijo1);
    raiz->agregarHijo(hijo2);

    raiz->mostrar(); // Muestra toda la jerarquía de nodos

    return 0;
}
<---1. Compartición de Recursos Result--->
<---2. Evitar Ciclos de Referencia--->
<---2. Evitar Ciclos de Referencia Result--->
<---Ejemplo de Ciclo de Referencia--->
```cpp
#include <memory>
#include <iostream>

class Nodo;

class Nodo {
public:
    Nodo(int valor) : valor_(valor) {}

    void establecerPadre(std::shared_ptr<Nodo> padre) {
        padre_ = padre;
    }

    void establecerHijo(std::shared_ptr<Nodo> hijo) {
        hijo_ = hijo;
    }

    ~Nodo() {
        std::cout << "Destruyendo nodo: " << valor_ << std::endl;
    }

private:
    int valor_;
    std::shared_ptr<Nodo> hijo_;
    std::shared_ptr<Nodo> padre_; // Ciclo de referencia
};

int main() {
    {
        auto nodo1 = std::make_shared<Nodo>(1);
        auto nodo2 = std::make_shared<Nodo>(2);

        nodo1->establecerHijo(nodo2);
        nodo2->establecerPadre(nodo1);
    } // Ciclo de referencia evita que los nodos sean destruidos

    return 0;
}
<---Ejemplo de Ciclo de Referencia Result--->
<---Solución usando `std::weak_ptr`--->
```cpp
#include <memory>
#include <iostream>

class Nodo;

class Nodo {
public:
    Nodo(int valor) : valor_(valor) {}

    void establecerPadre(std::shared_ptr<Nodo> padre) {
        padre_ = padre;
    }

    void establecerHijo(std::shared_ptr<Nodo> hijo) {
        hijo_ = hijo;
    }

    ~Nodo() {
        std::cout << "Destruyendo nodo: " << valor_ << std::endl;
    }

private:
    int valor_;
    std::shared_ptr<Nodo> hijo_;
    std::weak_ptr<Nodo> padre_; // Evitar ciclo de referencia
};

int main() {
    {
        auto nodo1 = std::make_shared<Nodo>(1);
        auto nodo2 = std::make_shared<Nodo>(2);

        nodo1->establecerHijo(nodo2);
        nodo2->establecerPadre(nodo1);
    } // Nodos correctamente destruidos

    return 0;
}
<---Solución usando `std::weak_ptr` Result--->
<---Memoria Estática--->
```cpp
#include <iostream>

int globalVariable = 10; // Variable global (memoria estática)

int main() {
    static int staticVariable = 20; // Variable estática local (memoria estática)
    return 0;
}
<---Memoria Estática Result--->
<---Memoria Dinámica--->
<---Memoria Dinámica Result--->
<---Ejemplo Básico de Asignación Dinámica--->
```cpp
#include <iostream>

int main() {
    int* ptr = new int; // Asignar memoria para un entero
    *ptr = 100; // Usar la memoria asignada
    std::cout << *ptr << std::endl; // Salida: 100
    delete ptr; // Liberar la memoria

    return 0;
}
<---Ejemplo Básico de Asignación Dinámica Result--->
<---Ejemplo de Arreglo Dinámico--->
```cpp
#include <iostream>

int main() {
    int size = 5;
    int* array = new int[size]; // Asignar memoria para un arreglo de enteros

    for(int i = 0; i < size; ++i) {
        array[i] = i * 10; // Inicializar el arreglo
    }

    for(int i = 0; i < size; ++i) {
        std::cout << array[i] << " "; // Salida: 0 10 20 30 40
    }
    std::cout << std::endl;

    delete[] array; // Liberar la memoria

    return 0;
}
<---Ejemplo de Arreglo Dinámico Result--->
<---Ejemplo Incorrecto--->
```cpp
int* ptr = new int(10);
delete ptr; // Liberar memoria
std::cout << *ptr << std::endl; // Acceso inválido: comportamiento indefinido
<---Ejemplo Incorrecto Result--->
<---Ejemplo Correcto--->
```cpp
int* ptr = new int(10);
delete ptr; // Liberar memoria
ptr = nullptr; // Evitar acceso inválido
```cpp
#include <iostream>
#include <cstring>

class String {
private:
    char* data;
    size_t size;

public:
    String(const char* str) {
        size = strlen(str);
        data = new char[size + 1];
        strcpy(data, str);
    }

    ~String() {
        delete[] data;
    }

    // Constructor de copia
    String(const String& other) {
        size = other.size;
        data = new char[size + 1];
        strcpy(data, other.data);
    }

    // Operador de asignación
    String& operator=(const String& other) {
        if (this == &other) return *this;

        delete[] data;

        size = other.size;
        data = new char[size + 1];
        strcpy(data, other.data);
        return *this;
    }

    void print() const {
        std::cout << data << std::endl;
    }
};

int main() {
    String str1("Hello");
    String str2 = str1; // Constructor de copia
    String str3("World");
    str3 = str1; // Operador de asignación
    str1.print(); // Salida: Hello
    str2.print(); // Salida: Hello
    str3.print(); // Salida: Hello

    return 0;
}
<---Ejemplo Correcto Result--->
<---Ejemplo con `std::unique_ptr`--->
```cpp
#include <iostream>
#include <memory>

int main() {
    std::unique_ptr<int> ptr = std::make_unique<int>(10);
    std::cout << *ptr << std::endl; // Salida: 10

    return 0;
}
<---Ejemplo con `std::unique_ptr` Result--->
<---Declaración de Punteros--->
```cpp
int* ptr; // Declara un puntero a un entero
<---Declaración de Punteros Result--->
<---Asignación y Acceso a Datos--->
```cpp
int var = 10;
int* ptr = &var; // ptr apunta a la dirección de var

std::cout << "Valor de var: " << var << std::endl; // Salida: 10
std::cout << "Dirección de var: " << &var << std::endl; // Dirección de var
std::cout << "Valor apuntado por ptr: " << *ptr << std::endl; // Salida: 10
```cpp
int arr[5] = {1, 2, 3, 4, 5};
int* ptr = arr; // ptr apunta al primer elemento del arreglo

for(int i = 0; i < 5; ++i) {
    std::cout << *(ptr + i) << " "; // Acceder a los elementos del arreglo usando punteros
}
// Salida: 1 2 3 4 5
```cpp
int arr[5] = {1, 2, 3, 4, 5};
int* ptr = arr;

std::cout << "Primer elemento: " << *ptr << std::endl; // Salida: 1
ptr++;
std::cout << "Segundo elemento: " << *ptr << std::endl; // Salida: 2
```cpp
int var = 10;
int* ptr = &var;
int** ptr2 = &ptr;

std::cout << "Valor de var: " << var << std::endl; // Salida: 10
std::cout << "Valor apuntado por ptr: " << *ptr << std::endl; // Salida: 10
std::cout << "Valor apuntado por ptr2: " << **ptr2 << std::endl; // Salida: 10
```cpp
int* ptr = nullptr; // Puntero inicializado a nullptr
```cpp
int* ptr = new int(10);
delete ptr; // Liberar memoria asignada
ptr = nullptr; // Evitar acceso a memoria liberada
```cpp
int* ptr = new int(10);
delete ptr;
ptr = nullptr; // Ahora ptr no es un puntero colgante
<---Asignación y Acceso a Datos Result--->
<---Paso por Referencia usando Punteros--->
```cpp
#include <iostream>

void incrementar(int* ptr) {
    (*ptr)++;
}

int main() {
    int var = 10;
    incrementar(&var);
    std::cout << "Valor de var después de incrementar: " << var << std::endl; // Salida: 11

    return 0;
}
<---Paso por Referencia usando Punteros Result--->
<---Ejemplo de Puntero a Función--->
```cpp
#include <iostream>

void saludo() {
    std::cout << "Hola, Mundo!" << std::endl;
}

void llamarFuncion(void (*func)()) {
    func();
}

int main() {
    void (*ptrFunc)() = &saludo;
    llamarFuncion(ptrFunc); // Salida: Hola, Mundo!

    return 0;
}
<---Ejemplo de Puntero a Función Result--->
<---Declaración Básica--->
```cpp
int var = 10;
int& ref = var; // ref es una referencia a var

std::cout << "var: " << var << std::endl; // Salida: 10
std::cout << "ref: " << ref << std::endl; // Salida: 10
<---Declaración Básica Result--->
<---Modificación a través de Referencias--->
```cpp
int var = 10;
int& ref = var;

ref = 20; // Modifica var a través de ref

std::cout << "var: " << var << std::endl; // Salida: 20
std::cout << "ref: " << ref << std::endl; // Salida: 20
<---Modificación a través de Referencias Result--->
<---Ejemplo de Paso por Referencia--->
```cpp
#include <iostream>

void incrementar(int& ref) {
    ref++;
}

int main() {
    int var = 10;
    incrementar(var);
    std::cout << "Valor de var después de incrementar: " << var << std::endl; // Salida: 11

    return 0;
}
<---Ejemplo de Paso por Referencia Result--->
<---Ejemplo de Referencia Constante--->
```cpp
#include <iostream>

void mostrar(const int& ref) {
    std::cout << "Valor: " << ref << std::endl;
}

int main() {
    int var = 10;
    mostrar(var); // Salida: 10

    return 0;
}
<---Ejemplo de Referencia Constante Result--->
<---Ejemplo de Constructor de Copia--->
```cpp
#include <iostream>

class MiClase {
private:
    int valor;

public:
    MiClase(int v) : valor(v) {}
    
    // Constructor de copia
    MiClase(const MiClase& otra) : valor(otra.valor) {
        std::cout << "Constructor de copia llamado" << std::endl;
    }

    int obtenerValor() const { return valor; }
};

int main() {
    MiClase obj1(10);
    MiClase obj2 = obj1; // Llama al constructor de copia

    std::cout << "Valor de obj1: " << obj1.obtenerValor() << std::endl; // Salida: 10
    std::cout << "Valor de obj2: " << obj2.obtenerValor() << std::endl; // Salida: 10

    return 0;
}
<---Ejemplo de Constructor de Copia Result--->
<---Ejemplo de Operador de Asignación--->
```cpp
#include <iostream>

class MiClase {
private:
    int valor;

public:
    MiClase(int v) : valor(v) {}
    
    // Operador de asignación
    MiClase& operator=(const MiClase& otra) {
        if (this != &otra) {
            valor = otra.valor;
        }
        return *this;
    }

    int obtenerValor() const { return valor; }
};

int main() {
    MiClase obj1(10);
    MiClase obj2(20);
    obj2 = obj1; // Llama al operador de asignación

    std::cout << "Valor de obj1: " << obj1.obtenerValor() << std::endl; // Salida: 10
    std::cout << "Valor de obj2: " << obj2.obtenerValor() << std::endl; // Salida: 10

    return 0;
}
<---Ejemplo de Operador de Asignación Result--->
<---Ejemplo de Referencia Dangling (a Evitar)--->
```cpp
int& funcion() {
    int var = 10;
    return var; // var se destruye al salir de la función
}

int main() {
    int& ref = funcion(); // ref ahora es una referencia dangling
    std::cout << ref << std::endl; // Comportamiento indefinido

    return 0;
}
```cpp
void mostrar(const int& ref) {
    std::cout << "Valor: " << ref << std::endl;
}
<---Ejemplo de Referencia Dangling (a Evitar) Result--->
<---Asignación de Memoria--->
```cpp
int* ptr = new int; // Asignar memoria para un entero
*ptr = 10;
std::cout << *ptr << std::endl; // Salida: 10

delete ptr; // Liberar la memoria asignada
<---Asignación de Memoria Result--->
<---Asignación de Memoria para Arreglos--->
```cpp
int size = 5;
int* arr = new int[size]; // Asignar memoria para un arreglo de enteros

for(int i = 0; i < size; ++i) {
    arr[i] = i * 10;
}

for(int i = 0; i < size; ++i) {
    std::cout << arr[i] << " "; // Salida: 0 10 20 30 40
}
std::cout << std::endl;

delete[] arr; // Liberar la memoria asignada para el arreglo
<---Asignación de Memoria para Arreglos Result--->
<---Ejemplo: Clase con Gestión de Memoria Dinámica--->
```cpp
#include <iostream>

class MiClase {
private:
    int* data;
    size_t size;

public:
    // Constructor
    MiClase(size_t s) : size(s) {
        data = new int[size];
        for(size_t i = 0; i < size; ++i) {
            data[i] = i * 10;
        }
    }

    // Destructor
    ~MiClase() {
        delete[] data;
    }

    // Constructor de copia
    MiClase(const MiClase& other) : size(other.size) {
        data = new int[size];
        std::copy(other.data, other.data + size, data);
    }

    // Operador de asignación
    MiClase& operator=(const MiClase& other) {
        if (this == &other) return *this;

        delete[] data;

        size = other.size;
        data = new int[size];
        std::copy(other.data, other.data + size, data);

        return *this;
    }

    void print() const {
        for(size_t i = 0; i < size; ++i) {
            std::cout << data[i] << " ";
        }
        std::cout << std::endl;
    }
};

int main() {
    MiClase obj1(5);
    obj1.print(); // Salida: 0 10 20 30 40

    MiClase obj2 = obj1; // Constructor de copia
    obj2.print(); // Salida: 0 10 20 30 40

    MiClase obj3(3);
    obj3 = obj1; // Operador de asignación
    obj3.print(); // Salida: 0 10 20 30 40

    return 0;
}
<---Ejemplo: Clase con Gestión de Memoria Dinámica Result--->
<---Ejemplo con `std::shared_ptr`--->
```cpp
#include <iostream>
#include <memory>

int main() {
    std::shared_ptr<int> ptr1 = std::make_shared<int>(20);
    std::shared_ptr<int> ptr2 = ptr1;

    std::cout << *ptr1 << std::endl; // Salida: 20
    std::cout << *ptr2 << std::endl; // Salida: 20

    return 0;
}
<---Ejemplo con `std::shared_ptr` Result--->
<---Ejemplo con `std::weak_ptr`--->
```cpp
#include <iostream>
#include <memory>

int main() {
    std::shared_ptr<int> sptr = std::make_shared<int>(30);
    std::weak_ptr<int> wptr = sptr;

    std::cout << "Use count: " << sptr.use_count() << std::endl; // Salida: 1

    if (auto spt = wptr.lock()) {
        std::cout << *spt << std::endl; // Salida: 30
    } else {
        std::cout << "wptr is expired" << std::endl;
    }

    return 0;
}
```cpp
int* ptr = new int(10);
// ...
delete ptr; // Liberar la memoria
```cpp
std::unique_ptr<int> ptr = std::make_unique<int>(10);
```cpp
int* ptr = new int(10);
delete ptr;
ptr = nullptr; // Evitar acceso a memoria liberada
```cpp
class Recurso {
public:
    Recurso() { /* adquirir recurso */ }
    ~Recurso() { /* liberar recurso */ }
};
<---Ejemplo con `std::weak_ptr` Result--->
<---Características:--->
<---Características: Result--->
<---Ejemplo de Uso de `std::unique_ptr`--->
```cpp
#include <iostream>
#include <memory>

int main() {
    std::unique_ptr<int> ptr = std::make_unique<int>(10); // Asignación de memoria
    std::cout << *ptr << std::endl; // Salida: 10

    // ptr2 = ptr; // Error: no se permite la copia de std::unique_ptr

    std::unique_ptr<int> ptr2 = std::move(ptr); // Transferencia de propiedad
    std::cout << *ptr2 << std::endl; // Salida: 10

    // La memoria se libera automáticamente al salir de ámbito
    return 0;
}
<---Ejemplo de Uso de `std::unique_ptr` Result--->
<---Ejemplo de Uso de `std::shared_ptr`--->
```cpp
#include <iostream>
#include <memory>

int main() {
    std::shared_ptr<int> ptr1 = std::make_shared<int>(20); // Asignación de memoria
    std::shared_ptr<int> ptr2 = ptr1; // Compartir la propiedad

    std::cout << *ptr1 << std::endl; // Salida: 20
    std::cout << *ptr2 << std::endl; // Salida: 20
    std::cout << "Use count: " << ptr1.use_count() << std::endl; // Salida: 2

    // La memoria se libera automáticamente cuando el último shared_ptr se destruye
    return 0;
}
<---Ejemplo de Uso de `std::shared_ptr` Result--->
<---Ejemplo de Uso de `std::weak_ptr`--->
```cpp
#include <iostream>
#include <memory>

int main() {
    std::shared_ptr<int> sptr = std::make_shared<int>(30);
    std::weak_ptr<int> wptr = sptr; // No incrementa el contador de referencias

    std::cout << "Use count: " << sptr.use_count() << std::endl; // Salida: 1

    if (auto spt = wptr.lock()) { // Comprobar si el recurso aún existe
        std::cout << *spt << std::endl; // Salida: 30
    } else {
        std::cout << "wptr is expired" << std::endl;
    }

    return 0;
}
```cpp
std::unique_ptr<int> ptr = std::make_unique<int>(10);
```cpp
std::shared_ptr<int> ptr1 = std::make_shared<int>(20);
std::shared_ptr<int> ptr2 = ptr1;
```cpp
class Nodo {
public:
    std::shared_ptr<Nodo> siguiente;
    std::weak_ptr<Nodo> anterior; // Evitar ciclo de referencia
};
<---Ejemplo de Uso de `std::weak_ptr` Result--->
<---Declaración y Asignación--->
```cpp
#include <iostream>
#include <memory>

int main() {
    std::shared_ptr<int> sptr = std::make_shared<int>(42);
    std::weak_ptr<int> wptr = sptr; // Inicializar con shared_ptr

    std::cout << "Use count: " << sptr.use_count() << std::endl; // Salida: 1
    return 0;
}
```cpp
#include <iostream>
#include <memory>

int main() {
    std::shared_ptr<int> sptr = std::make_shared<int>(42);
    std::weak_ptr<int> wptr = sptr;

    if (auto spt = wptr.lock()) { // Crear shared_ptr temporal
        std::cout << *spt << std::endl; // Salida: 42
    } else {
        std::cout << "El recurso ya no está disponible." << std::endl;
    }

    sptr.reset(); // Liberar el recurso

    if (auto spt = wptr.lock()) {
        std::cout << *spt << std::endl;
    } else {
        std::cout << "El recurso ya no está disponible." << std::endl; // Salida esperada
    }

    return 0;
}
<---Declaración y Asignación Result--->
<---Declaración en el Archivo de Cabecera (.h)--->
```cpp
// Nodo.h
#ifndef NODO_H
#define NODO_H

#include <memory>
#include <vector>

class Nodo {
public:
    Nodo(int valor);
    void agregarHijo(std::shared_ptr<Nodo> hijo);
    void establecerPadre(std::weak_ptr<Nodo> padre);
    void mostrar() const;

private:
    int valor_;
    std::vector<std::shared_ptr<Nodo>> hijos_;
    std::weak_ptr<Nodo> padre_; // Referencia no propietaria
};

#endif // NODO_H
<---Declaración en el Archivo de Cabecera (.h) Result--->
<---Definición en el Archivo de Implementación (.cpp)--->
```cpp
// Nodo.cpp
#include "Nodo.h"
#include <iostream>

Nodo::Nodo(int valor) : valor_(valor) {}

void Nodo::agregarHijo(std::shared_ptr<Nodo> hijo) {
    hijos_.push_back(hijo);
}

void Nodo::establecerPadre(std::weak_ptr<Nodo> padre) {
    padre_ = padre;
}

void Nodo::mostrar() const {
    std::cout << "Nodo: " << valor_ << std::endl;
    if (auto p = padre_.lock()) {
        std::cout << " Padre: " << p->valor_ << std::endl;
    } else {
        std::cout << " Sin padre" << std::endl;
    }
    for (const auto& hijo : hijos_) {
        hijo->mostrar();
    }
}
<---Definición en el Archivo de Implementación (.cpp) Result--->
<---Ejemplo de Transferencia de Propiedad--->
```cpp
#include <iostream>
#include <memory>

void mostrar(std::unique_ptr<int> ptr) {
    std::cout << *ptr << std::endl;
}

int main() {
    std::unique_ptr<int> ptr = std::make_unique<int>(42);
    mostrar(std::move(ptr)); // Transferir la propiedad
    // ptr ya no es válido aquí
    return 0;
}
<---Ejemplo de Transferencia de Propiedad Result--->
<---1. Encapsulación de Recursos--->
```cpp
class Archivo {
public:
    Archivo(const std::string& nombre) : archivo_(std::fopen(nombre.c_str(), "r")) {
        if (!archivo_) {
            throw std::runtime_error("No se pudo abrir el archivo");
        }
    }

    ~Archivo() {
        if (archivo_) {
            std::fclose(archivo_);
        }
    }

private:
    std::unique_ptr<FILE, decltype(&std::fclose)> archivo_;
};
<---1. Encapsulación de Recursos Result--->
<---2. Uso en Contenedores--->
```cpp
#include <vector>
#include <memory>

int main() {
    std::vector<std::unique_ptr<int>> vec;
    vec.push_back(std::make_unique<int>(1));
    vec.push_back(std::make_unique<int>(2));
    vec.push_back(std::make_unique<int>(3));

    for (const auto& ptr : vec) {
        std::cout << *ptr << std::endl;
    }
    return 0;
}
<---2. Uso en Contenedores Result--->
<---3. Evitar el Uso de Punteros Crudos--->
<---3. Evitar el Uso de Punteros Crudos Result--->
<---Archivo de Cabecera (.h)--->
```cpp
// GestorRecurso.h
#ifndef GESTORRECURSO_H
#define GESTORRECURSO_H

#include <memory>
#include <string>

class GestorRecurso {
public:
    GestorRecurso(const std::string& nombre);
    void mostrarRecurso() const;

private:
    std::shared_ptr<std::string> recurso_;
};

class Contenedor {
public:
    void establecerRecurso(std::shared_ptr<GestorRecurso> recurso);
    void mostrar() const;

private:
    std::shared_ptr<GestorRecurso> recurso_;
};

#endif // GESTORRECURSO_H
<---Archivo de Cabecera (.h) Result--->
<---Archivo de Implementación (.cpp)--->
```cpp
// GestorRecurso.cpp
#include "GestorRecurso.h"
#include <iostream>

GestorRecurso::GestorRecurso(const std::string& nombre)
    : recurso_(std::make_shared<std::string>(nombre)) {}

void GestorRecurso::mostrarRecurso() const {
    std::cout << "Recurso: " << *recurso_ << std::endl;
}

void Contenedor::establecerRecurso(std::shared_ptr<GestorRecurso> recurso) {
    recurso_ = recurso;
}

void Contenedor::mostrar() const {
    if (recurso_) {
        recurso_->mostrarRecurso();
    } else {
        std::cout << "Sin recurso" << std::endl;
    }
}
<---Archivo de Implementación (.cpp) Result--->
<---Función Principal--->
```cpp
#include <iostream>
#include "Nodo.h"

int main() {
    auto nodo1 = std::make_shared<Nodo>(1);
    auto nodo2 = std::make_shared<Nodo>(2);
    auto nodo3 = std::make_shared<Nodo>(3);

    nodo1->agregarHijo(nodo2);
    nodo2->establecerPadre(nodo1);
    nodo2->agregarHijo(nodo3);
    nodo3->establecerPadre(nodo2);

    nodo1->mostrar();

    return 0;
}
<---Función Principal Result--->
<---1. Compartición de Recursos--->
```cpp
#include <memory>
#include <vector>
#include <iostream>

class Nodo {
public:
    Nodo(int valor) : valor_(valor) {}

    void agregarHijo(std::shared_ptr<Nodo> hijo) {
        hijos_.push_back(hijo);
    }

    void mostrar() const {
        std::cout << "Nodo: " << valor_ << std::endl;
        for (const auto& hijo : hijos_) {
            hijo->mostrar();
        }
    }

private:
    int valor_;
    std::vector<std::shared_ptr<Nodo>> hijos_;
};

int main() {
    auto raiz = std::make_shared<Nodo>(1);
    auto hijo1 = std::make_shared<Nodo>(2);
    auto hijo2 = std::make_shared<Nodo>(3);

    raiz->agregarHijo(hijo1);
    raiz->agregarHijo(hijo2);

    raiz->mostrar(); // Muestra toda la jerarquía de nodos

    return 0;
}
<---1. Compartición de Recursos Result--->
<---2. Evitar Ciclos de Referencia--->
<---2. Evitar Ciclos de Referencia Result--->
<---Ejemplo de Ciclo de Referencia--->
```cpp
#include <memory>
#include <iostream>

class Nodo;

class Nodo {
public:
    Nodo(int valor) : valor_(valor) {}

    void establecerPadre(std::shared_ptr<Nodo> padre) {
        padre_ = padre;
    }

    void establecerHijo(std::shared_ptr<Nodo> hijo) {
        hijo_ = hijo;
    }

    ~Nodo() {
        std::cout << "Destruyendo nodo: " << valor_ << std::endl;
    }

private:
    int valor_;
    std::shared_ptr<Nodo> hijo_;
    std::shared_ptr<Nodo> padre_; // Ciclo de referencia
};

int main() {
    {
        auto nodo1 = std::make_shared<Nodo>(1);
        auto nodo2 = std::make_shared<Nodo>(2);

        nodo1->establecerHijo(nodo2);
        nodo2->establecerPadre(nodo1);
    } // Ciclo de referencia evita que los nodos sean destruidos

    return 0;
}
<---Ejemplo de Ciclo de Referencia Result--->
<---Solución usando `std::weak_ptr`--->
```cpp
#include <memory>
#include <iostream>

class Nodo;

class Nodo {
public:
    Nodo(int valor) : valor_(valor) {}

    void establecerPadre(std::shared_ptr<Nodo> padre) {
        padre_ = padre;
    }

    void establecerHijo(std::shared_ptr<Nodo> hijo) {
        hijo_ = hijo;
    }

    ~Nodo() {
        std::cout << "Destruyendo nodo: " << valor_ << std::endl;
    }

private:
    int valor_;
    std::shared_ptr<Nodo> hijo_;
    std::weak_ptr<Nodo> padre_; // Evitar ciclo de referencia
};

int main() {
    {
        auto nodo1 = std::make_shared<Nodo>(1);
        auto nodo2 = std::make_shared<Nodo>(2);

        nodo1->establecerHijo(nodo2);
        nodo2->establecerPadre(nodo1);
    } // Nodos correctamente destruidos

    return 0;
}
<---Solución usando `std::weak_ptr` Result--->
<---Ejemplo de Ciclo de Referencia Evitado con `std::weak_ptr`--->
<---Ejemplo de Ciclo de Referencia Evitado con `std::weak_ptr` Result--->
<---1. Utilizar `std::weak_ptr` para Referencias a Objetos de Vida Útil Controlada--->
```cpp
#include <iostream>
#include <memory>
#include <vector>

class Observador {
public:
    virtual void actualizar() = 0;
};

class Sujeto {
public:
    void agregarObservador(std::shared_ptr<Observador> obs) {
        observadores_.push_back(obs);
    }

    void notificar() {
        for (auto& obs : observadores_) {
            if (auto sp = obs.lock()) {
                sp->actualizar();
            }
        }
    }

private:
    std::vector<std::weak_ptr<Observador>> observadores_;
};

class ConcretoObservador : public Observador, public std::enable_shared_from_this<ConcretoObservador> {
public:
    void actualizar() override {
        std::cout << "Observador actualizado!" << std::endl;
    }

    void suscribirse(Sujeto& sujeto) {
        sujeto.agregarObservador(shared_from_this());
    }
};

int main() {
    Sujeto sujeto;
    auto obs = std::make_shared<ConcretoObservador>();
    obs->suscribirse(sujeto);

    sujeto.notificar(); // Salida: Observador actualizado!

    return 0;
}
<---1. Utilizar `std::weak_ptr` para Referencias a Objetos de Vida Útil Controlada Result--->
<---2. Usar `std::weak_ptr` en Estructuras de Datos Complejas--->
```cpp
#include <memory>
#include <iostream>

class Nodo {
public:
    Nodo(int valor) : valor_(valor) {}

    void agregarHijo(std::shared_ptr<Nodo> hijo) {
        hijos_.push_back(hijo);
        hijo->padre_ = weak_from_this();
    }

    void mostrar() const {
        std::cout << "Nodo: " << valor_ << std::endl;
        for (const auto& hijo : hijos_) {
            hijo->mostrar();
        }
    }

private:
    int valor_;
    std::vector<std::shared_ptr<Nodo>> hijos_;
    std::weak_ptr<Nodo> padre_; // Referencia no propietaria
};

int main() {
    auto nodo1 = std::make_shared<Nodo>(1);
    auto nodo2 = std::make_shared<Nodo>(2);
    auto nodo3 = std::make_shared<Nodo>(3);

    nodo1->agregarHijo(nodo2);
    nodo2->agregarHijo(nodo3);

    nodo1->mostrar(); // Muestra la jerarquía completa

    return 0;
}
<---2. Usar `std::weak_ptr` en Estructuras de Datos Complejas Result--->
<---Memoria Estática--->
```cpp
#include <iostream>

int globalVariable = 10; // Variable global (memoria estática)

int main() {
    static int staticVariable = 20; // Variable estática local (memoria estática)
    return 0;
}
<---Memoria Estática Result--->
<---Memoria Dinámica--->
<---Memoria Dinámica Result--->
<---Ejemplo Básico de Asignación Dinámica--->
```cpp
#include <iostream>

int main() {
    int* ptr = new int; // Asignar memoria para un entero
    *ptr = 100; // Usar la memoria asignada
    std::cout << *ptr << std::endl; // Salida: 100
    delete ptr; // Liberar la memoria

    return 0;
}
<---Ejemplo Básico de Asignación Dinámica Result--->
<---Ejemplo de Arreglo Dinámico--->
```cpp
#include <iostream>

int main() {
    int size = 5;
    int* array = new int[size]; // Asignar memoria para un arreglo de enteros

    for(int i = 0; i < size; ++i) {
        array[i] = i * 10; // Inicializar el arreglo
    }

    for(int i = 0; i < size; ++i) {
        std::cout << array[i] << " "; // Salida: 0 10 20 30 40
    }
    std::cout << std::endl;

    delete[] array; // Liberar la memoria

    return 0;
}
<---Ejemplo de Arreglo Dinámico Result--->
<---Ejemplo Incorrecto--->
```cpp
int* ptr = new int(10);
delete ptr; // Liberar memoria
std::cout << *ptr << std::endl; // Acceso inválido: comportamiento indefinido
<---Ejemplo Incorrecto Result--->
<---Ejemplo Correcto--->
```cpp
int* ptr = new int(10);
delete ptr; // Liberar memoria
ptr = nullptr; // Evitar acceso inválido
```cpp
#include <iostream>
#include <cstring>

class String {
private:
    char* data;
    size_t size;

public:
    String(const char* str) {
        size = strlen(str);
        data = new char[size + 1];
        strcpy(data, str);
    }

    ~String() {
        delete[] data;
    }

    // Constructor de copia
    String(const String& other) {
        size = other.size;
        data = new char[size + 1];
        strcpy(data, other.data);
    }

    // Operador de asignación
    String& operator=(const String& other) {
        if (this == &other) return *this;

        delete[] data;

        size = other.size;
        data = new char[size + 1];
        strcpy(data, other.data);
        return *this;
    }

    void print() const {
        std::cout << data << std::endl;
    }
};

int main() {
    String str1("Hello");
    String str2 = str1; // Constructor de copia
    String str3("World");
    str3 = str1; // Operador de asignación
    str1.print(); // Salida: Hello
    str2.print(); // Salida: Hello
    str3.print(); // Salida: Hello

    return 0;
}
<---Ejemplo Correcto Result--->
<---Ejemplo con `std::unique_ptr`--->
```cpp
#include <iostream>
#include <memory>

int main() {
    std::unique_ptr<int> ptr = std::make_unique<int>(10);
    std::cout << *ptr << std::endl; // Salida: 10

    return 0;
}
<---Ejemplo con `std::unique_ptr` Result--->
<---Declaración de Punteros--->
```cpp
int* ptr; // Declara un puntero a un entero
<---Declaración de Punteros Result--->
<---Asignación y Acceso a Datos--->
```cpp
int var = 10;
int* ptr = &var; // ptr apunta a la dirección de var

std::cout << "Valor de var: " << var << std::endl; // Salida: 10
std::cout << "Dirección de var: " << &var << std::endl; // Dirección de var
std::cout << "Valor apuntado por ptr: " << *ptr << std::endl; // Salida: 10
```cpp
int arr[5] = {1, 2, 3, 4, 5};
int* ptr = arr; // ptr apunta al primer elemento del arreglo

for(int i = 0; i < 5; ++i) {
    std::cout << *(ptr + i) << " "; // Acceder a los elementos del arreglo usando punteros
}
// Salida: 1 2 3 4 5
```cpp
int arr[5] = {1, 2, 3, 4, 5};
int* ptr = arr;

std::cout << "Primer elemento: " << *ptr << std::endl; // Salida: 1
ptr++;
std::cout << "Segundo elemento: " << *ptr << std::endl; // Salida: 2
```cpp
int var = 10;
int* ptr = &var;
int** ptr2 = &ptr;

std::cout << "Valor de var: " << var << std::endl; // Salida: 10
std::cout << "Valor apuntado por ptr: " << *ptr << std::endl; // Salida: 10
std::cout << "Valor apuntado por ptr2: " << **ptr2 << std::endl; // Salida: 10
```cpp
int* ptr = nullptr; // Puntero inicializado a nullptr
```cpp
int* ptr = new int(10);
delete ptr; // Liberar memoria asignada
ptr = nullptr; // Evitar acceso a memoria liberada
```cpp
int* ptr = new int(10);
delete ptr;
ptr = nullptr; // Ahora ptr no es un puntero colgante
<---Asignación y Acceso a Datos Result--->
<---Paso por Referencia usando Punteros--->
```cpp
#include <iostream>

void incrementar(int* ptr) {
    (*ptr)++;
}

int main() {
    int var = 10;
    incrementar(&var);
    std::cout << "Valor de var después de incrementar: " << var << std::endl; // Salida: 11

    return 0;
}
<---Paso por Referencia usando Punteros Result--->
<---Ejemplo de Puntero a Función--->
```cpp
#include <iostream>

void saludo() {
    std::cout << "Hola, Mundo!" << std::endl;
}

void llamarFuncion(void (*func)()) {
    func();
}

int main() {
    void (*ptrFunc)() = &saludo;
    llamarFuncion(ptrFunc); // Salida: Hola, Mundo!

    return 0;
}
<---Ejemplo de Puntero a Función Result--->
<---Declaración Básica--->
```cpp
int var = 10;
int& ref = var; // ref es una referencia a var

std::cout << "var: " << var << std::endl; // Salida: 10
std::cout << "ref: " << ref << std::endl; // Salida: 10
<---Declaración Básica Result--->
<---Modificación a través de Referencias--->
```cpp
int var = 10;
int& ref = var;

ref = 20; // Modifica var a través de ref

std::cout << "var: " << var << std::endl; // Salida: 20
std::cout << "ref: " << ref << std::endl; // Salida: 20
<---Modificación a través de Referencias Result--->
<---Ejemplo de Paso por Referencia--->
```cpp
#include <iostream>

void incrementar(int& ref) {
    ref++;
}

int main() {
    int var = 10;
    incrementar(var);
    std::cout << "Valor de var después de incrementar: " << var << std::endl; // Salida: 11

    return 0;
}
<---Ejemplo de Paso por Referencia Result--->
<---Ejemplo de Referencia Constante--->
```cpp
#include <iostream>

void mostrar(const int& ref) {
    std::cout << "Valor: " << ref << std::endl;
}

int main() {
    int var = 10;
    mostrar(var); // Salida: 10

    return 0;
}
<---Ejemplo de Referencia Constante Result--->
<---Ejemplo de Constructor de Copia--->
```cpp
#include <iostream>

class MiClase {
private:
    int valor;

public:
    MiClase(int v) : valor(v) {}
    
    // Constructor de copia
    MiClase(const MiClase& otra) : valor(otra.valor) {
        std::cout << "Constructor de copia llamado" << std::endl;
    }

    int obtenerValor() const { return valor; }
};

int main() {
    MiClase obj1(10);
    MiClase obj2 = obj1; // Llama al constructor de copia

    std::cout << "Valor de obj1: " << obj1.obtenerValor() << std::endl; // Salida: 10
    std::cout << "Valor de obj2: " << obj2.obtenerValor() << std::endl; // Salida: 10

    return 0;
}
<---Ejemplo de Constructor de Copia Result--->
<---Ejemplo de Operador de Asignación--->
```cpp
#include <iostream>

class MiClase {
private:
    int valor;

public:
    MiClase(int v) : valor(v) {}
    
    // Operador de asignación
    MiClase& operator=(const MiClase& otra) {
        if (this != &otra) {
            valor = otra.valor;
        }
        return *this;
    }

    int obtenerValor() const { return valor; }
};

int main() {
    MiClase obj1(10);
    MiClase obj2(20);
    obj2 = obj1; // Llama al operador de asignación

    std::cout << "Valor de obj1: " << obj1.obtenerValor() << std::endl; // Salida: 10
    std::cout << "Valor de obj2: " << obj2.obtenerValor() << std::endl; // Salida: 10

    return 0;
}
<---Ejemplo de Operador de Asignación Result--->
<---Ejemplo de Referencia Dangling (a Evitar)--->
```cpp
int& funcion() {
    int var = 10;
    return var; // var se destruye al salir de la función
}

int main() {
    int& ref = funcion(); // ref ahora es una referencia dangling
    std::cout << ref << std::endl; // Comportamiento indefinido

    return 0;
}
```cpp
void mostrar(const int& ref) {
    std::cout << "Valor: " << ref << std::endl;
}
<---Ejemplo de Referencia Dangling (a Evitar) Result--->
<---Asignación de Memoria--->
```cpp
int* ptr = new int; // Asignar memoria para un entero
*ptr = 10;
std::cout << *ptr << std::endl; // Salida: 10

delete ptr; // Liberar la memoria asignada
<---Asignación de Memoria Result--->
<---Asignación de Memoria para Arreglos--->
```cpp
int size = 5;
int* arr = new int[size]; // Asignar memoria para un arreglo de enteros

for(int i = 0; i < size; ++i) {
    arr[i] = i * 10;
}

for(int i = 0; i < size; ++i) {
    std::cout << arr[i] << " "; // Salida: 0 10 20 30 40
}
std::cout << std::endl;

delete[] arr; // Liberar la memoria asignada para el arreglo
<---Asignación de Memoria para Arreglos Result--->
<---Ejemplo: Clase con Gestión de Memoria Dinámica--->
```cpp
#include <iostream>

class MiClase {
private:
    int* data;
    size_t size;

public:
    // Constructor
    MiClase(size_t s) : size(s) {
        data = new int[size];
        for(size_t i = 0; i < size; ++i) {
            data[i] = i * 10;
        }
    }

    // Destructor
    ~MiClase() {
        delete[] data;
    }

    // Constructor de copia
    MiClase(const MiClase& other) : size(other.size) {
        data = new int[size];
        std::copy(other.data, other.data + size, data);
    }

    // Operador de asignación
    MiClase& operator=(const MiClase& other) {
        if (this == &other) return *this;

        delete[] data;

        size = other.size;
        data = new int[size];
        std::copy(other.data, other.data + size, data);

        return *this;
    }

    void print() const {
        for(size_t i = 0; i < size; ++i) {
            std::cout << data[i] << " ";
        }
        std::cout << std::endl;
    }
};

int main() {
    MiClase obj1(5);
    obj1.print(); // Salida: 0 10 20 30 40

    MiClase obj2 = obj1; // Constructor de copia
    obj2.print(); // Salida: 0 10 20 30 40

    MiClase obj3(3);
    obj3 = obj1; // Operador de asignación
    obj3.print(); // Salida: 0 10 20 30 40

    return 0;
}
<---Ejemplo: Clase con Gestión de Memoria Dinámica Result--->
<---Ejemplo con `std::shared_ptr`--->
```cpp
#include <iostream>
#include <memory>

int main() {
    std::shared_ptr<int> ptr1 = std::make_shared<int>(20);
    std::shared_ptr<int> ptr2 = ptr1;

    std::cout << *ptr1 << std::endl; // Salida: 20
    std::cout << *ptr2 << std::endl; // Salida: 20

    return 0;
}
<---Ejemplo con `std::shared_ptr` Result--->
<---Ejemplo con `std::weak_ptr`--->
```cpp
#include <iostream>
#include <memory>

int main() {
    std::shared_ptr<int> sptr = std::make_shared<int>(30);
    std::weak_ptr<int> wptr = sptr;

    std::cout << "Use count: " << sptr.use_count() << std::endl; // Salida: 1

    if (auto spt = wptr.lock()) {
        std::cout << *spt << std::endl; // Salida: 30
    } else {
        std::cout << "wptr is expired" << std::endl;
    }

    return 0;
}
```cpp
int* ptr = new int(10);
// ...
delete ptr; // Liberar la memoria
```cpp
std::unique_ptr<int> ptr = std::make_unique<int>(10);
```cpp
int* ptr = new int(10);
delete ptr;
ptr = nullptr; // Evitar acceso a memoria liberada
```cpp
class Recurso {
public:
    Recurso() { /* adquirir recurso */ }
    ~Recurso() { /* liberar recurso */ }
};
<---Ejemplo con `std::weak_ptr` Result--->
<---Características:--->
<---Características: Result--->
<---Ejemplo de Uso de `std::unique_ptr`--->
```cpp
#include <iostream>
#include <memory>

int main() {
    std::unique_ptr<int> ptr = std::make_unique<int>(10); // Asignación de memoria
    std::cout << *ptr << std::endl; // Salida: 10

    // ptr2 = ptr; // Error: no se permite la copia de std::unique_ptr

    std::unique_ptr<int> ptr2 = std::move(ptr); // Transferencia de propiedad
    std::cout << *ptr2 << std::endl; // Salida: 10

    // La memoria se libera automáticamente al salir de ámbito
    return 0;
}
<---Ejemplo de Uso de `std::unique_ptr` Result--->
<---Ejemplo de Uso de `std::shared_ptr`--->
```cpp
#include <iostream>
#include <memory>

int main() {
    std::shared_ptr<int> ptr1 = std::make_shared<int>(20); // Asignación de memoria
    std::shared_ptr<int> ptr2 = ptr1; // Compartir la propiedad

    std::cout << *ptr1 << std::endl; // Salida: 20
    std::cout << *ptr2 << std::endl; // Salida: 20
    std::cout << "Use count: " << ptr1.use_count() << std::endl; // Salida: 2

    // La memoria se libera automáticamente cuando el último shared_ptr se destruye
    return 0;
}
<---Ejemplo de Uso de `std::shared_ptr` Result--->
<---Ejemplo de Uso de `std::weak_ptr`--->
```cpp
#include <iostream>
#include <memory>

int main() {
    std::shared_ptr<int> sptr = std::make_shared<int>(30);
    std::weak_ptr<int> wptr = sptr; // No incrementa el contador de referencias

    std::cout << "Use count: " << sptr.use_count() << std::endl; // Salida: 1

    if (auto spt = wptr.lock()) { // Comprobar si el recurso aún existe
        std::cout << *spt << std::endl; // Salida: 30
    } else {
        std::cout << "wptr is expired" << std::endl;
    }

    return 0;
}
```cpp
std::unique_ptr<int> ptr = std::make_unique<int>(10);
```cpp
std::shared_ptr<int> ptr1 = std::make_shared<int>(20);
std::shared_ptr<int> ptr2 = ptr1;
```cpp
class Nodo {
public:
    std::shared_ptr<Nodo> siguiente;
    std::weak_ptr<Nodo> anterior; // Evitar ciclo de referencia
};
<---Ejemplo de Uso de `std::weak_ptr` Result--->
<---Declaración y Asignación--->
```cpp
#include <iostream>
#include <memory>

int main() {
    std::shared_ptr<int> sptr = std::make_shared<int>(42);
    std::weak_ptr<int> wptr = sptr; // Inicializar con shared_ptr

    std::cout << "Use count: " << sptr.use_count() << std::endl; // Salida: 1
    return 0;
}
```cpp
#include <iostream>
#include <memory>

int main() {
    std::shared_ptr<int> sptr = std::make_shared<int>(42);
    std::weak_ptr<int> wptr = sptr;

    if (auto spt = wptr.lock()) { // Crear shared_ptr temporal
        std::cout << *spt << std::endl; // Salida: 42
    } else {
        std::cout << "El recurso ya no está disponible." << std::endl;
    }

    sptr.reset(); // Liberar el recurso

    if (auto spt = wptr.lock()) {
        std::cout << *spt << std::endl;
    } else {
        std::cout << "El recurso ya no está disponible." << std::endl; // Salida esperada
    }

    return 0;
}
<---Declaración y Asignación Result--->
<---Declaración en el Archivo de Cabecera (.h)--->
```cpp
// ArregloDinamico.h
#ifndef ARREGLODINAMICO_H
#define ARREGLODINAMICO_H

class ArregloDinamico {
public:
    ArregloDinamico(int size);
    ~ArregloDinamico();

    void redimensionar(int newSize);
    void mostrar() const;

private:
    int* datos_;
    int size_;
};

#endif // ARREGLODINAMICO_H
<---Declaración en el Archivo de Cabecera (.h) Result--->
<---Definición en el Archivo de Implementación (.cpp)--->
```cpp
// ArregloDinamico.cpp
#include "ArregloDinamico.h"
#include <iostream>
#include <algorithm>

ArregloDinamico::ArregloDinamico(int size) : size_(size) {
    datos_ = new int[size_];
    for (int i = 0; i < size_; ++i) {
        datos_[i] = i * 10;
    }
}

ArregloDinamico::~ArregloDinamico() {
    delete[] datos_;
}

void ArregloDinamico::redimensionar(int newSize) {
    int* nuevosDatos = new int[newSize];
    std::copy(datos_, datos_ + size_, nuevosDatos);
    for (int i = size_; i < newSize; ++i) {
        nuevosDatos[i] = i * 10;
    }
    delete[] datos_;
    datos_ = nuevosDatos;
    size_ = newSize;
}

void ArregloDinamico::mostrar() const {
    for (int i = 0; i < size_; ++i) {
        std::cout << datos_[i] << " ";
    }
    std::cout << std::endl;
}
<---Definición en el Archivo de Implementación (.cpp) Result--->
<---Ejemplo de Transferencia de Propiedad--->
```cpp
#include <iostream>
#include <memory>

void mostrar(std::unique_ptr<int> ptr) {
    std::cout << *ptr << std::endl;
}

int main() {
    std::unique_ptr<int> ptr = std::make_unique<int>(42);
    mostrar(std::move(ptr)); // Transferir la propiedad
    // ptr ya no es válido aquí
    return 0;
}
<---Ejemplo de Transferencia de Propiedad Result--->
<---1. Encapsulación de Recursos--->
```cpp
class Archivo {
public:
    Archivo(const std::string& nombre) : archivo_(std::fopen(nombre.c_str(), "r")) {
        if (!archivo_) {
            throw std::runtime_error("No se pudo abrir el archivo");
        }
    }

    ~Archivo() {
        if (archivo_) {
            std::fclose(archivo_);
        }
    }

private:
    std::unique_ptr<FILE, decltype(&std::fclose)> archivo_;
};
<---1. Encapsulación de Recursos Result--->
<---2. Uso en Contenedores--->
```cpp
#include <vector>
#include <memory>

int main() {
    std::vector<std::unique_ptr<int>> vec;
    vec.push_back(std::make_unique<int>(1));
    vec.push_back(std::make_unique<int>(2));
    vec.push_back(std::make_unique<int>(3));

    for (const auto& ptr : vec) {
        std::cout << *ptr << std::endl;
    }
    return 0;
}
<---2. Uso en Contenedores Result--->
<---3. Evitar el Uso de Punteros Crudos--->
<---3. Evitar el Uso de Punteros Crudos Result--->
<---Archivo de Cabecera (.h)--->
```cpp
// GestorRecurso.h
#ifndef GESTORRECURSO_H
#define GESTORRECURSO_H

#include <memory>
#include <string>

class GestorRecurso {
public:
    GestorRecurso(const std::string& nombre);
    void mostrarRecurso() const;

private:
    std::shared_ptr<std::string> recurso_;
};

class Contenedor {
public:
    void establecerRecurso(std::shared_ptr<GestorRecurso> recurso);
    void mostrar() const;

private:
    std::shared_ptr<GestorRecurso> recurso_;
};

#endif // GESTORRECURSO_H
<---Archivo de Cabecera (.h) Result--->
<---Archivo de Implementación (.cpp)--->
```cpp
// GestorRecurso.cpp
#include "GestorRecurso.h"
#include <iostream>

GestorRecurso::GestorRecurso(const std::string& nombre)
    : recurso_(std::make_shared<std::string>(nombre)) {}

void GestorRecurso::mostrarRecurso() const {
    std::cout << "Recurso: " << *recurso_ << std::endl;
}

void Contenedor::establecerRecurso(std::shared_ptr<GestorRecurso> recurso) {
    recurso_ = recurso;
}

void Contenedor::mostrar() const {
    if (recurso_) {
        recurso_->mostrarRecurso();
    } else {
        std::cout << "Sin recurso" << std::endl;
    }
}
<---Archivo de Implementación (.cpp) Result--->
<---Función Principal--->
```cpp
#include <iostream>
#include "ArregloDinamico.h"

int main() {
    ArregloDinamico arreglo(5);
    arreglo.mostrar(); // Salida: 0 10 20 30 40

    arreglo.redimensionar(10);
    arreglo.mostrar(); // Salida: 0 10 20 30 40 50 60 70 80 90

    return 0;
}
```cpp
#include <iostream>
#include <vector>

int main() {
    std::vector<int> vec = {1, 2, 3, 4, 5};

    vec.push_back(6); // Agregar un nuevo elemento
    vec.push_back(7);

    for (const auto& val : vec) {
        std::cout << val << " "; // Salida: 1 2 3 4 5 6 7
    }
    std::cout << std::endl;

    return 0;
}
<---Función Principal Result--->
<---1. Compartición de Recursos--->
```cpp
#include <memory>
#include <vector>
#include <iostream>

class Nodo {
public:
    Nodo(int valor) : valor_(valor) {}

    void agregarHijo(std::shared_ptr<Nodo> hijo) {
        hijos_.push_back(hijo);
    }

    void mostrar() const {
        std::cout << "Nodo: " << valor_ << std::endl;
        for (const auto& hijo : hijos_) {
            hijo->mostrar();
        }
    }

private:
    int valor_;
    std::vector<std::shared_ptr<Nodo>> hijos_;
};

int main() {
    auto raiz = std::make_shared<Nodo>(1);
    auto hijo1 = std::make_shared<Nodo>(2);
    auto hijo2 = std::make_shared<Nodo>(3);

    raiz->agregarHijo(hijo1);
    raiz->agregarHijo(hijo2);

    raiz->mostrar(); // Muestra toda la jerarquía de nodos

    return 0;
}
<---1. Compartición de Recursos Result--->
<---2. Evitar Ciclos de Referencia--->
<---2. Evitar Ciclos de Referencia Result--->
<---Ejemplo de Ciclo de Referencia--->
```cpp
#include <memory>
#include <iostream>

class Nodo;

class Nodo {
public:
    Nodo(int valor) : valor_(valor) {}

    void establecerPadre(std::shared_ptr<Nodo> padre) {
        padre_ = padre;
    }

    void establecerHijo(std::shared_ptr<Nodo> hijo) {
        hijo_ = hijo;
    }

    ~Nodo() {
        std::cout << "Destruyendo nodo: " << valor_ << std::endl;
    }

private:
    int valor_;
    std::shared_ptr<Nodo> hijo_;
    std::shared_ptr<Nodo> padre_; // Ciclo de referencia
};

int main() {
    {
        auto nodo1 = std::make_shared<Nodo>(1);
        auto nodo2 = std::make_shared<Nodo>(2);

        nodo1->establecerHijo(nodo2);
        nodo2->establecerPadre(nodo1);
    } // Ciclo de referencia evita que los nodos sean destruidos

    return 0;
}
<---Ejemplo de Ciclo de Referencia Result--->
<---Solución usando `std::weak_ptr`--->
```cpp
#include <memory>
#include <iostream>

class Nodo;

class Nodo {
public:
    Nodo(int valor) : valor_(valor) {}

    void establecerPadre(std::shared_ptr<Nodo> padre) {
        padre_ = padre;
    }

    void establecerHijo(std::shared_ptr<Nodo> hijo) {
        hijo_ = hijo;
    }

    ~Nodo() {
        std::cout << "Destruyendo nodo: " << valor_ << std::endl;
    }

private:
    int valor_;
    std::shared_ptr<Nodo> hijo_;
    std::weak_ptr<Nodo> padre_; // Evitar ciclo de referencia
};

int main() {
    {
        auto nodo1 = std::make_shared<Nodo>(1);
        auto nodo2 = std::make_shared<Nodo>(2);

        nodo1->establecerHijo(nodo2);
        nodo2->establecerPadre(nodo1);
    } // Nodos correctamente destruidos

    return 0;
}
<---Solución usando `std::weak_ptr` Result--->
<---Ejemplo de Ciclo de Referencia Evitado con `std::weak_ptr`--->
<---Ejemplo de Ciclo de Referencia Evitado con `std::weak_ptr` Result--->
<---1. Utilizar `std::weak_ptr` para Referencias a Objetos de Vida Útil Controlada--->
```cpp
#include <iostream>
#include <memory>
#include <vector>

class Observador {
public:
    virtual void actualizar() = 0;
};

class Sujeto {
public:
    void agregarObservador(std::shared_ptr<Observador> obs) {
        observadores_.push_back(obs);
    }

    void notificar() {
        for (auto& obs : observadores_) {
            if (auto sp = obs.lock()) {
                sp->actualizar();
            }
        }
    }

private:
    std::vector<std::weak_ptr<Observador>> observadores_;
};

class ConcretoObservador : public Observador, public std::enable_shared_from_this<ConcretoObservador> {
public:
    void actualizar() override {
        std::cout << "Observador actualizado!" << std::endl;
    }

    void suscribirse(Sujeto& sujeto) {
        sujeto.agregarObservador(shared_from_this());
    }
};

int main() {
    Sujeto sujeto;
    auto obs = std::make_shared<ConcretoObservador>();
    obs->suscribirse(sujeto);

    sujeto.notificar(); // Salida: Observador actualizado!

    return 0;
}
<---1. Utilizar `std::weak_ptr` para Referencias a Objetos de Vida Útil Controlada Result--->
<---2. Usar `std::weak_ptr` en Estructuras de Datos Complejas--->
```cpp
#include <memory>
#include <iostream>

class Nodo {
public:
    Nodo(int valor) : valor_(valor) {}

    void agregarHijo(std::shared_ptr<Nodo> hijo) {
        hijos_.push_back(hijo);
        hijo->padre_ = weak_from_this();
    }

    void mostrar() const {
        std::cout << "Nodo: " << valor_ << std::endl;
        for (const auto& hijo : hijos_) {
            hijo->mostrar();
        }
    }

private:
    int valor_;
    std::vector<std::shared_ptr<Nodo>> hijos_;
    std::weak_ptr<Nodo> padre_; // Referencia no propietaria
};

int main() {
    auto nodo1 = std::make_shared<Nodo>(1);
    auto nodo2 = std::make_shared<Nodo>(2);
    auto nodo3 = std::make_shared<Nodo>(3);

    nodo1->agregarHijo(nodo2);
    nodo2->agregarHijo(nodo3);

    nodo1->mostrar(); // Muestra la jerarquía completa

    return 0;
}
<---2. Usar `std::weak_ptr` en Estructuras de Datos Complejas Result--->
<---Asignación y Liberación de Memoria con `new` y `delete[]`--->
```cpp
#include <iostream>

int main() {
    int size = 5;
    int* arr = new int[size]; // Asignar memoria para un arreglo de enteros

    // Inicializar el arreglo
    for (int i = 0; i < size; ++i) {
        arr[i] = i * 10;
    }

    // Acceder y mostrar los elementos del arreglo
    for (int i = 0; i < size; ++i) {
        std::cout << arr[i] << " "; // Salida: 0 10 20 30 40
    }
    std::cout << std::endl;

    delete[] arr; // Liberar la memoria asignada para el arreglo
    return 0;
}
<---Asignación y Liberación de Memoria con `new` y `delete[]` Result--->
<---Ejemplo de Redimensionamiento--->
```cpp
#include <iostream>
#include <algorithm> // Para std::copy

int main() {
    int size = 5;
    int* arr = new int[size]; // Asignar memoria para un arreglo de enteros

    // Inicializar el arreglo
    for (int i = 0; i < size; ++i) {
        arr[i] = i * 10;
    }

    // Nuevo tamaño del arreglo
    int newSize = 10;
    int* newArr = new int[newSize]; // Asignar memoria para el nuevo arreglo

    // Copiar elementos del arreglo original al nuevo arreglo
    std::copy(arr, arr + size, newArr);

    // Inicializar los nuevos elementos
    for (int i = size; i < newSize; ++i) {
        newArr[i] = i * 10;
    }

    // Liberar la memoria del arreglo original
    delete[] arr;

    // Asignar el puntero del nuevo arreglo al original
    arr = newArr;

    // Mostrar los elementos del nuevo arreglo
    for (int i = 0; i < newSize; ++i) {
        std::cout << arr[i] << " "; // Salida: 0 10 20 30 40 50 60 70 80 90
    }
    std::cout << std::endl;

    delete[] arr; // Liberar la memoria del nuevo arreglo
    return 0;
}
<---Ejemplo de Redimensionamiento Result--->
<---Memoria Estática--->
```cpp
#include <iostream>

int globalVariable = 10; // Variable global (memoria estática)

int main() {
    static int staticVariable = 20; // Variable estática local (memoria estática)
    return 0;
}
<---Memoria Estática Result--->
<---Memoria Dinámica--->
<---Memoria Dinámica Result--->
<---Ejemplo Básico de Asignación Dinámica--->
```cpp
#include <iostream>

int main() {
    int* ptr = new int; // Asignar memoria para un entero
    *ptr = 100; // Usar la memoria asignada
    std::cout << *ptr << std::endl; // Salida: 100
    delete ptr; // Liberar la memoria

    return 0;
}
<---Ejemplo Básico de Asignación Dinámica Result--->
<---Ejemplo de Arreglo Dinámico--->
```cpp
#include <iostream>

int main() {
    int size = 5;
    int* array = new int[size]; // Asignar memoria para un arreglo de enteros

    for(int i = 0; i < size; ++i) {
        array[i] = i * 10; // Inicializar el arreglo
    }

    for(int i = 0; i < size; ++i) {
        std::cout << array[i] << " "; // Salida: 0 10 20 30 40
    }
    std::cout << std::endl;

    delete[] array; // Liberar la memoria

    return 0;
}
<---Ejemplo de Arreglo Dinámico Result--->
<---Ejemplo Incorrecto--->
```cpp
int* ptr = new int(10);
delete ptr; // Liberar memoria
std::cout << *ptr << std::endl; // Acceso inválido: comportamiento indefinido
<---Ejemplo Incorrecto Result--->
<---Ejemplo Correcto--->
```cpp
int* ptr = new int(10);
delete ptr; // Liberar memoria
ptr = nullptr; // Evitar acceso inválido
```cpp
#include <iostream>
#include <cstring>

class String {
private:
    char* data;
    size_t size;

public:
    String(const char* str) {
        size = strlen(str);
        data = new char[size + 1];
        strcpy(data, str);
    }

    ~String() {
        delete[] data;
    }

    // Constructor de copia
    String(const String& other) {
        size = other.size;
        data = new char[size + 1];
        strcpy(data, other.data);
    }

    // Operador de asignación
    String& operator=(const String& other) {
        if (this == &other) return *this;

        delete[] data;

        size = other.size;
        data = new char[size + 1];
        strcpy(data, other.data);
        return *this;
    }

    void print() const {
        std::cout << data << std::endl;
    }
};

int main() {
    String str1("Hello");
    String str2 = str1; // Constructor de copia
    String str3("World");
    str3 = str1; // Operador de asignación
    str1.print(); // Salida: Hello
    str2.print(); // Salida: Hello
    str3.print(); // Salida: Hello

    return 0;
}
<---Ejemplo Correcto Result--->
<---Ejemplo con `std::unique_ptr`--->
```cpp
#include <iostream>
#include <memory>

int main() {
    std::unique_ptr<int> ptr = std::make_unique<int>(10);
    std::cout << *ptr << std::endl; // Salida: 10

    return 0;
}
<---Ejemplo con `std::unique_ptr` Result--->
<---Declaración de Punteros--->
```cpp
int* ptr; // Declara un puntero a un entero
<---Declaración de Punteros Result--->
<---Asignación y Acceso a Datos--->
```cpp
int var = 10;
int* ptr = &var; // ptr apunta a la dirección de var

std::cout << "Valor de var: " << var << std::endl; // Salida: 10
std::cout << "Dirección de var: " << &var << std::endl; // Dirección de var
std::cout << "Valor apuntado por ptr: " << *ptr << std::endl; // Salida: 10
```cpp
int arr[5] = {1, 2, 3, 4, 5};
int* ptr = arr; // ptr apunta al primer elemento del arreglo

for(int i = 0; i < 5; ++i) {
    std::cout << *(ptr + i) << " "; // Acceder a los elementos del arreglo usando punteros
}
// Salida: 1 2 3 4 5
```cpp
int arr[5] = {1, 2, 3, 4, 5};
int* ptr = arr;

std::cout << "Primer elemento: " << *ptr << std::endl; // Salida: 1
ptr++;
std::cout << "Segundo elemento: " << *ptr << std::endl; // Salida: 2
```cpp
int var = 10;
int* ptr = &var;
int** ptr2 = &ptr;

std::cout << "Valor de var: " << var << std::endl; // Salida: 10
std::cout << "Valor apuntado por ptr: " << *ptr << std::endl; // Salida: 10
std::cout << "Valor apuntado por ptr2: " << **ptr2 << std::endl; // Salida: 10
```cpp
int* ptr = nullptr; // Puntero inicializado a nullptr
```cpp
int* ptr = new int(10);
delete ptr; // Liberar memoria asignada
ptr = nullptr; // Evitar acceso a memoria liberada
```cpp
int* ptr = new int(10);
delete ptr;
ptr = nullptr; // Ahora ptr no es un puntero colgante
<---Asignación y Acceso a Datos Result--->
<---Paso por Referencia usando Punteros--->
```cpp
#include <iostream>

void incrementar(int* ptr) {
    (*ptr)++;
}

int main() {
    int var = 10;
    incrementar(&var);
    std::cout << "Valor de var después de incrementar: " << var << std::endl; // Salida: 11

    return 0;
}
<---Paso por Referencia usando Punteros Result--->
<---Ejemplo de Puntero a Función--->
```cpp
#include <iostream>

void saludo() {
    std::cout << "Hola, Mundo!" << std::endl;
}

void llamarFuncion(void (*func)()) {
    func();
}

int main() {
    void (*ptrFunc)() = &saludo;
    llamarFuncion(ptrFunc); // Salida: Hola, Mundo!

    return 0;
}
<---Ejemplo de Puntero a Función Result--->
<---Declaración Básica--->
```cpp
int var = 10;
int& ref = var; // ref es una referencia a var

std::cout << "var: " << var << std::endl; // Salida: 10
std::cout << "ref: " << ref << std::endl; // Salida: 10
<---Declaración Básica Result--->
<---Modificación a través de Referencias--->
```cpp
int var = 10;
int& ref = var;

ref = 20; // Modifica var a través de ref

std::cout << "var: " << var << std::endl; // Salida: 20
std::cout << "ref: " << ref << std::endl; // Salida: 20
<---Modificación a través de Referencias Result--->
<---Ejemplo de Paso por Referencia--->
```cpp
#include <iostream>

void incrementar(int& ref) {
    ref++;
}

int main() {
    int var = 10;
    incrementar(var);
    std::cout << "Valor de var después de incrementar: " << var << std::endl; // Salida: 11

    return 0;
}
<---Ejemplo de Paso por Referencia Result--->
<---Ejemplo de Referencia Constante--->
```cpp
#include <iostream>

void mostrar(const int& ref) {
    std::cout << "Valor: " << ref << std::endl;
}

int main() {
    int var = 10;
    mostrar(var); // Salida: 10

    return 0;
}
<---Ejemplo de Referencia Constante Result--->
<---Ejemplo de Constructor de Copia--->
```cpp
#include <iostream>

class MiClase {
private:
    int valor;

public:
    MiClase(int v) : valor(v) {}
    
    // Constructor de copia
    MiClase(const MiClase& otra) : valor(otra.valor) {
        std::cout << "Constructor de copia llamado" << std::endl;
    }

    int obtenerValor() const { return valor; }
};

int main() {
    MiClase obj1(10);
    MiClase obj2 = obj1; // Llama al constructor de copia

    std::cout << "Valor de obj1: " << obj1.obtenerValor() << std::endl; // Salida: 10
    std::cout << "Valor de obj2: " << obj2.obtenerValor() << std::endl; // Salida: 10

    return 0;
}
<---Ejemplo de Constructor de Copia Result--->
<---Ejemplo de Operador de Asignación--->
```cpp
#include <iostream>

class MiClase {
private:
    int valor;

public:
    MiClase(int v) : valor(v) {}
    
    // Operador de asignación
    MiClase& operator=(const MiClase& otra) {
        if (this != &otra) {
            valor = otra.valor;
        }
        return *this;
    }

    int obtenerValor() const { return valor; }
};

int main() {
    MiClase obj1(10);
    MiClase obj2(20);
    obj2 = obj1; // Llama al operador de asignación

    std::cout << "Valor de obj1: " << obj1.obtenerValor() << std::endl; // Salida: 10
    std::cout << "Valor de obj2: " << obj2.obtenerValor() << std::endl; // Salida: 10

    return 0;
}
<---Ejemplo de Operador de Asignación Result--->
<---Ejemplo de Referencia Dangling (a Evitar)--->
```cpp
int& funcion() {
    int var = 10;
    return var; // var se destruye al salir de la función
}

int main() {
    int& ref = funcion(); // ref ahora es una referencia dangling
    std::cout << ref << std::endl; // Comportamiento indefinido

    return 0;
}
```cpp
void mostrar(const int& ref) {
    std::cout << "Valor: " << ref << std::endl;
}
<---Ejemplo de Referencia Dangling (a Evitar) Result--->
<---Asignación de Memoria--->
```cpp
int* ptr = new int; // Asignar memoria para un entero
*ptr = 10;
std::cout << *ptr << std::endl; // Salida: 10

delete ptr; // Liberar la memoria asignada
<---Asignación de Memoria Result--->
<---Asignación de Memoria para Arreglos--->
```cpp
int size = 5;
int* arr = new int[size]; // Asignar memoria para un arreglo de enteros

for(int i = 0; i < size; ++i) {
    arr[i] = i * 10;
}

for(int i = 0; i < size; ++i) {
    std::cout << arr[i] << " "; // Salida: 0 10 20 30 40
}
std::cout << std::endl;

delete[] arr; // Liberar la memoria asignada para el arreglo
<---Asignación de Memoria para Arreglos Result--->
<---Ejemplo: Clase con Gestión de Memoria Dinámica--->
```cpp
#include <iostream>

class MiClase {
private:
    int* data;
    size_t size;

public:
    // Constructor
    MiClase(size_t s) : size(s) {
        data = new int[size];
        for(size_t i = 0; i < size; ++i) {
            data[i] = i * 10;
        }
    }

    // Destructor
    ~MiClase() {
        delete[] data;
    }

    // Constructor de copia
    MiClase(const MiClase& other) : size(other.size) {
        data = new int[size];
        std::copy(other.data, other.data + size, data);
    }

    // Operador de asignación
    MiClase& operator=(const MiClase& other) {
        if (this == &other) return *this;

        delete[] data;

        size = other.size;
        data = new int[size];
        std::copy(other.data, other.data + size, data);

        return *this;
    }

    void print() const {
        for(size_t i = 0; i < size; ++i) {
            std::cout << data[i] << " ";
        }
        std::cout << std::endl;
    }
};

int main() {
    MiClase obj1(5);
    obj1.print(); // Salida: 0 10 20 30 40

    MiClase obj2 = obj1; // Constructor de copia
    obj2.print(); // Salida: 0 10 20 30 40

    MiClase obj3(3);
    obj3 = obj1; // Operador de asignación
    obj3.print(); // Salida: 0 10 20 30 40

    return 0;
}
<---Ejemplo: Clase con Gestión de Memoria Dinámica Result--->
<---Ejemplo con `std::shared_ptr`--->
```cpp
#include <iostream>
#include <memory>

int main() {
    std::shared_ptr<int> ptr1 = std::make_shared<int>(20);
    std::shared_ptr<int> ptr2 = ptr1;

    std::cout << *ptr1 << std::endl; // Salida: 20
    std::cout << *ptr2 << std::endl; // Salida: 20

    return 0;
}
<---Ejemplo con `std::shared_ptr` Result--->
<---Ejemplo con `std::weak_ptr`--->
```cpp
#include <iostream>
#include <memory>

int main() {
    std::shared_ptr<int> sptr = std::make_shared<int>(30);
    std::weak_ptr<int> wptr = sptr;

    std::cout << "Use count: " << sptr.use_count() << std::endl; // Salida: 1

    if (auto spt = wptr.lock()) {
        std::cout << *spt << std::endl; // Salida: 30
    } else {
        std::cout << "wptr is expired" << std::endl;
    }

    return 0;
}
```cpp
int* ptr = new int(10);
// ...
delete ptr; // Liberar la memoria
```cpp
std::unique_ptr<int> ptr = std::make_unique<int>(10);
```cpp
int* ptr = new int(10);
delete ptr;
ptr = nullptr; // Evitar acceso a memoria liberada
```cpp
class Recurso {
public:
    Recurso() { /* adquirir recurso */ }
    ~Recurso() { /* liberar recurso */ }
};
<---Ejemplo con `std::weak_ptr` Result--->
<---Características:--->
<---Características: Result--->
<---Ejemplo de Uso de `std::unique_ptr`--->
```cpp
#include <iostream>
#include <memory>

int main() {
    std::unique_ptr<int> ptr = std::make_unique<int>(10); // Asignación de memoria
    std::cout << *ptr << std::endl; // Salida: 10

    // ptr2 = ptr; // Error: no se permite la copia de std::unique_ptr

    std::unique_ptr<int> ptr2 = std::move(ptr); // Transferencia de propiedad
    std::cout << *ptr2 << std::endl; // Salida: 10

    // La memoria se libera automáticamente al salir de ámbito
    return 0;
}
<---Ejemplo de Uso de `std::unique_ptr` Result--->
<---Ejemplo de Uso de `std::shared_ptr`--->
```cpp
#include <iostream>
#include <memory>

int main() {
    std::shared_ptr<int> ptr1 = std::make_shared<int>(20); // Asignación de memoria
    std::shared_ptr<int> ptr2 = ptr1; // Compartir la propiedad

    std::cout << *ptr1 << std::endl; // Salida: 20
    std::cout << *ptr2 << std::endl; // Salida: 20
    std::cout << "Use count: " << ptr1.use_count() << std::endl; // Salida: 2

    // La memoria se libera automáticamente cuando el último shared_ptr se destruye
    return 0;
}
<---Ejemplo de Uso de `std::shared_ptr` Result--->
<---Ejemplo de Uso de `std::weak_ptr`--->
```cpp
#include <iostream>
#include <memory>

int main() {
    std::shared_ptr<int> sptr = std::make_shared<int>(30);
    std::weak_ptr<int> wptr = sptr; // No incrementa el contador de referencias

    std::cout << "Use count: " << sptr.use_count() << std::endl; // Salida: 1

    if (auto spt = wptr.lock()) { // Comprobar si el recurso aún existe
        std::cout << *spt << std::endl; // Salida: 30
    } else {
        std::cout << "wptr is expired" << std::endl;
    }

    return 0;
}
```cpp
std::unique_ptr<int> ptr = std::make_unique<int>(10);
```cpp
std::shared_ptr<int> ptr1 = std::make_shared<int>(20);
std::shared_ptr<int> ptr2 = ptr1;
```cpp
class Nodo {
public:
    std::shared_ptr<Nodo> siguiente;
    std::weak_ptr<Nodo> anterior; // Evitar ciclo de referencia
};
<---Ejemplo de Uso de `std::weak_ptr` Result--->
<---Declaración y Asignación--->
```cpp
#include <iostream>
#include <memory>

int main() {
    std::shared_ptr<int> sptr = std::make_shared<int>(42);
    std::weak_ptr<int> wptr = sptr; // Inicializar con shared_ptr

    std::cout << "Use count: " << sptr.use_count() << std::endl; // Salida: 1
    return 0;
}
```cpp
#include <iostream>
#include <memory>

int main() {
    std::shared_ptr<int> sptr = std::make_shared<int>(42);
    std::weak_ptr<int> wptr = sptr;

    if (auto spt = wptr.lock()) { // Crear shared_ptr temporal
        std::cout << *spt << std::endl; // Salida: 42
    } else {
        std::cout << "El recurso ya no está disponible." << std::endl;
    }

    sptr.reset(); // Liberar el recurso

    if (auto spt = wptr.lock()) {
        std::cout << *spt << std::endl;
    } else {
        std::cout << "El recurso ya no está disponible." << std::endl; // Salida esperada
    }

    return 0;
}
<---Declaración y Asignación Result--->
<---Declaración en el Archivo de Cabecera (.h)--->
```cpp
// ArregloDinamico.h
#ifndef ARREGLODINAMICO_H
#define ARREGLODINAMICO_H

class ArregloDinamico {
public:
    ArregloDinamico(int size);
    ~ArregloDinamico();

    void redimensionar(int newSize);
    void mostrar() const;

private:
    int* datos_;
    int size_;
};

#endif // ARREGLODINAMICO_H
<---Declaración en el Archivo de Cabecera (.h) Result--->
<---Definición en el Archivo de Implementación (.cpp)--->
```cpp
// ArregloDinamico.cpp
#include "ArregloDinamico.h"
#include <iostream>
#include <algorithm>

ArregloDinamico::ArregloDinamico(int size) : size_(size) {
    datos_ = new int[size_];
    for (int i = 0; i < size_; ++i) {
        datos_[i] = i * 10;
    }
}

ArregloDinamico::~ArregloDinamico() {
    delete[] datos_;
}

void ArregloDinamico::redimensionar(int newSize) {
    int* nuevosDatos = new int[newSize];
    std::copy(datos_, datos_ + size_, nuevosDatos);
    for (int i = size_; i < newSize; ++i) {
        nuevosDatos[i] = i * 10;
    }
    delete[] datos_;
    datos_ = nuevosDatos;
    size_ = newSize;
}

void ArregloDinamico::mostrar() const {
    for (int i = 0; i < size_; ++i) {
        std::cout << datos_[i] << " ";
    }
    std::cout << std::endl;
}
<---Definición en el Archivo de Implementación (.cpp) Result--->
<---Ejemplo de Transferencia de Propiedad--->
```cpp
#include <iostream>
#include <memory>

void mostrar(std::unique_ptr<int> ptr) {
    std::cout << *ptr << std::endl;
}

int main() {
    std::unique_ptr<int> ptr = std::make_unique<int>(42);
    mostrar(std::move(ptr)); // Transferir la propiedad
    // ptr ya no es válido aquí
    return 0;
}
<---Ejemplo de Transferencia de Propiedad Result--->
<---1. Encapsulación de Recursos--->
```cpp
class Archivo {
public:
    Archivo(const std::string& nombre) : archivo_(std::fopen(nombre.c_str(), "r")) {
        if (!archivo_) {
            throw std::runtime_error("No se pudo abrir el archivo");
        }
    }

    ~Archivo() {
        if (archivo_) {
            std::fclose(archivo_);
        }
    }

private:
    std::unique_ptr<FILE, decltype(&std::fclose)> archivo_;
};
<---1. Encapsulación de Recursos Result--->
<---2. Uso en Contenedores--->
```cpp
#include <vector>
#include <memory>

int main() {
    std::vector<std::unique_ptr<int>> vec;
    vec.push_back(std::make_unique<int>(1));
    vec.push_back(std::make_unique<int>(2));
    vec.push_back(std::make_unique<int>(3));

    for (const auto& ptr : vec) {
        std::cout << *ptr << std::endl;
    }
    return 0;
}
<---2. Uso en Contenedores Result--->
<---3. Evitar el Uso de Punteros Crudos--->
<---3. Evitar el Uso de Punteros Crudos Result--->
<---Archivo de Cabecera (.h)--->
```cpp
// GestorRecurso.h
#ifndef GESTORRECURSO_H
#define GESTORRECURSO_H

#include <memory>
#include <string>

class GestorRecurso {
public:
    GestorRecurso(const std::string& nombre);
    void mostrarRecurso() const;

private:
    std::shared_ptr<std::string> recurso_;
};

class Contenedor {
public:
    void establecerRecurso(std::shared_ptr<GestorRecurso> recurso);
    void mostrar() const;

private:
    std::shared_ptr<GestorRecurso> recurso_;
};

#endif // GESTORRECURSO_H
<---Archivo de Cabecera (.h) Result--->
<---Archivo de Implementación (.cpp)--->
```cpp
// GestorRecurso.cpp
#include "GestorRecurso.h"
#include <iostream>

GestorRecurso::GestorRecurso(const std::string& nombre)
    : recurso_(std::make_shared<std::string>(nombre)) {}

void GestorRecurso::mostrarRecurso() const {
    std::cout << "Recurso: " << *recurso_ << std::endl;
}

void Contenedor::establecerRecurso(std::shared_ptr<GestorRecurso> recurso) {
    recurso_ = recurso;
}

void Contenedor::mostrar() const {
    if (recurso_) {
        recurso_->mostrarRecurso();
    } else {
        std::cout << "Sin recurso" << std::endl;
    }
}
<---Archivo de Implementación (.cpp) Result--->
<---Función Principal--->
```cpp
#include <iostream>
#include "ArregloDinamico.h"

int main() {
    ArregloDinamico arreglo(5);
    arreglo.mostrar(); // Salida: 0 10 20 30 40

    arreglo.redimensionar(10);
    arreglo.mostrar(); // Salida: 0 10 20 30 40 50 60 70 80 90

    return 0;
}
```cpp
#include <iostream>
#include <vector>

int main() {
    std::vector<int> vec = {1, 2, 3, 4, 5};

    vec.push_back(6); // Agregar un nuevo elemento
    vec.push_back(7);

    for (const auto& val : vec) {
        std::cout << val << " "; // Salida: 1 2 3 4 5 6 7
    }
    std::cout << std::endl;

    return 0;
}
<---Función Principal Result--->
<---1. Compartición de Recursos--->
```cpp
#include <memory>
#include <vector>
#include <iostream>

class Nodo {
public:
    Nodo(int valor) : valor_(valor) {}

    void agregarHijo(std::shared_ptr<Nodo> hijo) {
        hijos_.push_back(hijo);
    }

    void mostrar() const {
        std::cout << "Nodo: " << valor_ << std::endl;
        for (const auto& hijo : hijos_) {
            hijo->mostrar();
        }
    }

private:
    int valor_;
    std::vector<std::shared_ptr<Nodo>> hijos_;
};

int main() {
    auto raiz = std::make_shared<Nodo>(1);
    auto hijo1 = std::make_shared<Nodo>(2);
    auto hijo2 = std::make_shared<Nodo>(3);

    raiz->agregarHijo(hijo1);
    raiz->agregarHijo(hijo2);

    raiz->mostrar(); // Muestra toda la jerarquía de nodos

    return 0;
}
<---1. Compartición de Recursos Result--->
<---2. Evitar Ciclos de Referencia--->
<---2. Evitar Ciclos de Referencia Result--->
<---Ejemplo de Ciclo de Referencia--->
```cpp
#include <memory>
#include <iostream>

class Nodo;

class Nodo {
public:
    Nodo(int valor) : valor_(valor) {}

    void establecerPadre(std::shared_ptr<Nodo> padre) {
        padre_ = padre;
    }

    void establecerHijo(std::shared_ptr<Nodo> hijo) {
        hijo_ = hijo;
    }

    ~Nodo() {
        std::cout << "Destruyendo nodo: " << valor_ << std::endl;
    }

private:
    int valor_;
    std::shared_ptr<Nodo> hijo_;
    std::shared_ptr<Nodo> padre_; // Ciclo de referencia
};

int main() {
    {
        auto nodo1 = std::make_shared<Nodo>(1);
        auto nodo2 = std::make_shared<Nodo>(2);

        nodo1->establecerHijo(nodo2);
        nodo2->establecerPadre(nodo1);
    } // Ciclo de referencia evita que los nodos sean destruidos

    return 0;
}
<---Ejemplo de Ciclo de Referencia Result--->
<---Solución usando `std::weak_ptr`--->
```cpp
#include <memory>
#include <iostream>

class Nodo;

class Nodo {
public:
    Nodo(int valor) : valor_(valor) {}

    void establecerPadre(std::shared_ptr<Nodo> padre) {
        padre_ = padre;
    }

    void establecerHijo(std::shared_ptr<Nodo> hijo) {
        hijo_ = hijo;
    }

    ~Nodo() {
        std::cout << "Destruyendo nodo: " << valor_ << std::endl;
    }

private:
    int valor_;
    std::shared_ptr<Nodo> hijo_;
    std::weak_ptr<Nodo> padre_; // Evitar ciclo de referencia
};

int main() {
    {
        auto nodo1 = std::make_shared<Nodo>(1);
        auto nodo2 = std::make_shared<Nodo>(2);

        nodo1->establecerHijo(nodo2);
        nodo2->establecerPadre(nodo1);
    } // Nodos correctamente destruidos

    return 0;
}
<---Solución usando `std::weak_ptr` Result--->
<---Ejemplo de Ciclo de Referencia Evitado con `std::weak_ptr`--->
<---Ejemplo de Ciclo de Referencia Evitado con `std::weak_ptr` Result--->
<---1. Utilizar `std::weak_ptr` para Referencias a Objetos de Vida Útil Controlada--->
```cpp
#include <iostream>
#include <memory>
#include <vector>

class Observador {
public:
    virtual void actualizar() = 0;
};

class Sujeto {
public:
    void agregarObservador(std::shared_ptr<Observador> obs) {
        observadores_.push_back(obs);
    }

    void notificar() {
        for (auto& obs : observadores_) {
            if (auto sp = obs.lock()) {
                sp->actualizar();
            }
        }
    }

private:
    std::vector<std::weak_ptr<Observador>> observadores_;
};

class ConcretoObservador : public Observador, public std::enable_shared_from_this<ConcretoObservador> {
public:
    void actualizar() override {
        std::cout << "Observador actualizado!" << std::endl;
    }

    void suscribirse(Sujeto& sujeto) {
        sujeto.agregarObservador(shared_from_this());
    }
};

int main() {
    Sujeto sujeto;
    auto obs = std::make_shared<ConcretoObservador>();
    obs->suscribirse(sujeto);

    sujeto.notificar(); // Salida: Observador actualizado!

    return 0;
}
<---1. Utilizar `std::weak_ptr` para Referencias a Objetos de Vida Útil Controlada Result--->
<---2. Usar `std::weak_ptr` en Estructuras de Datos Complejas--->
```cpp
#include <memory>
#include <iostream>

class Nodo {
public:
    Nodo(int valor) : valor_(valor) {}

    void agregarHijo(std::shared_ptr<Nodo> hijo) {
        hijos_.push_back(hijo);
        hijo->padre_ = weak_from_this();
    }

    void mostrar() const {
        std::cout << "Nodo: " << valor_ << std::endl;
        for (const auto& hijo : hijos_) {
            hijo->mostrar();
        }
    }

private:
    int valor_;
    std::vector<std::shared_ptr<Nodo>> hijos_;
    std::weak_ptr<Nodo> padre_; // Referencia no propietaria
};

int main() {
    auto nodo1 = std::make_shared<Nodo>(1);
    auto nodo2 = std::make_shared<Nodo>(2);
    auto nodo3 = std::make_shared<Nodo>(3);

    nodo1->agregarHijo(nodo2);
    nodo2->agregarHijo(nodo3);

    nodo1->mostrar(); // Muestra la jerarquía completa

    return 0;
}
<---2. Usar `std::weak_ptr` en Estructuras de Datos Complejas Result--->
<---Asignación y Liberación de Memoria con `new` y `delete[]`--->
```cpp
#include <iostream>

int main() {
    int size = 5;
    int* arr = new int[size]; // Asignar memoria para un arreglo de enteros

    // Inicializar el arreglo
    for (int i = 0; i < size; ++i) {
        arr[i] = i * 10;
    }

    // Acceder y mostrar los elementos del arreglo
    for (int i = 0; i < size; ++i) {
        std::cout << arr[i] << " "; // Salida: 0 10 20 30 40
    }
    std::cout << std::endl;

    delete[] arr; // Liberar la memoria asignada para el arreglo
    return 0;
}
<---Asignación y Liberación de Memoria con `new` y `delete[]` Result--->
<---Ejemplo de Redimensionamiento--->
```cpp
#include <iostream>
#include <algorithm> // Para std::copy

int main() {
    int size = 5;
    int* arr = new int[size]; // Asignar memoria para un arreglo de enteros

    // Inicializar el arreglo
    for (int i = 0; i < size; ++i) {
        arr[i] = i * 10;
    }

    // Nuevo tamaño del arreglo
    int newSize = 10;
    int* newArr = new int[newSize]; // Asignar memoria para el nuevo arreglo

    // Copiar elementos del arreglo original al nuevo arreglo
    std::copy(arr, arr + size, newArr);

    // Inicializar los nuevos elementos
    for (int i = size; i < newSize; ++i) {
        newArr[i] = i * 10;
    }

    // Liberar la memoria del arreglo original
    delete[] arr;

    // Asignar el puntero del nuevo arreglo al original
    arr = newArr;

    // Mostrar los elementos del nuevo arreglo
    for (int i = 0; i < newSize; ++i) {
        std::cout << arr[i] << " "; // Salida: 0 10 20 30 40 50 60 70 80 90
    }
    std::cout << std::endl;

    delete[] arr; // Liberar la memoria del nuevo arreglo
    return 0;
}
<---Ejemplo de Redimensionamiento Result--->
<---Características del Stack--->
<---Características del Stack Result--->
<---Ejemplo de Uso del Stack--->
```cpp
#include <iostream>

void funcion() {
    int localVar = 10; // Variable local en el stack
    std::cout << "Valor de localVar: " << localVar << std::endl;
}

int main() {
    funcion(); // Llamada a la función
    return 0;
}
<---Ejemplo de Uso del Stack Result--->
<---Características del Heap--->
<---Características del Heap Result--->
<---Ejemplo de Uso del Heap--->
```cpp
#include <iostream>

void funcion() {
    int* heapVar = new int(20); // Variable asignada en el heap
    std::cout << "Valor de heapVar: " << *heapVar << std::endl;
    delete heapVar; // Liberar la memoria asignada en el heap
}

int main() {
    funcion(); // Llamada a la función
    return 0;
}
<---Ejemplo de Uso del Heap Result--->
<---Memoria Estática--->
```cpp
#include <iostream>

int globalVariable = 10; // Variable global (memoria estática)

int main() {
    static int staticVariable = 20; // Variable estática local (memoria estática)
    return 0;
}
<---Memoria Estática Result--->
<---Memoria Dinámica--->
<---Memoria Dinámica Result--->
<---Ejemplo Básico de Asignación Dinámica--->
```cpp
#include <iostream>

int main() {
    int* ptr = new int; // Asignar memoria para un entero
    *ptr = 100; // Usar la memoria asignada
    std::cout << *ptr << std::endl; // Salida: 100
    delete ptr; // Liberar la memoria

    return 0;
}
<---Ejemplo Básico de Asignación Dinámica Result--->
<---Ejemplo de Arreglo Dinámico--->
```cpp
#include <iostream>

int main() {
    int size = 5;
    int* array = new int[size]; // Asignar memoria para un arreglo de enteros

    for(int i = 0; i < size; ++i) {
        array[i] = i * 10; // Inicializar el arreglo
    }

    for(int i = 0; i < size; ++i) {
        std::cout << array[i] << " "; // Salida: 0 10 20 30 40
    }
    std::cout << std::endl;

    delete[] array; // Liberar la memoria

    return 0;
}
<---Ejemplo de Arreglo Dinámico Result--->
<---Ejemplo Incorrecto--->
```cpp
int* ptr = new int(10);
delete ptr; // Liberar memoria
std::cout << *ptr << std::endl; // Acceso inválido: comportamiento indefinido
<---Ejemplo Incorrecto Result--->
<---Ejemplo Correcto--->
```cpp
int* ptr = new int(10);
delete ptr; // Liberar memoria
ptr = nullptr; // Evitar acceso inválido
```cpp
#include <iostream>
#include <cstring>

class String {
private:
    char* data;
    size_t size;

public:
    String(const char* str) {
        size = strlen(str);
        data = new char[size + 1];
        strcpy(data, str);
    }

    ~String() {
        delete[] data;
    }

    // Constructor de copia
    String(const String& other) {
        size = other.size;
        data = new char[size + 1];
        strcpy(data, other.data);
    }

    // Operador de asignación
    String& operator=(const String& other) {
        if (this == &other) return *this;

        delete[] data;

        size = other.size;
        data = new char[size + 1];
        strcpy(data, other.data);
        return *this;
    }

    void print() const {
        std::cout << data << std::endl;
    }
};

int main() {
    String str1("Hello");
    String str2 = str1; // Constructor de copia
    String str3("World");
    str3 = str1; // Operador de asignación
    str1.print(); // Salida: Hello
    str2.print(); // Salida: Hello
    str3.print(); // Salida: Hello

    return 0;
}
<---Ejemplo Correcto Result--->
<---Ejemplo con `std::unique_ptr`--->
```cpp
#include <iostream>
#include <memory>

int main() {
    std::unique_ptr<int> ptr = std::make_unique<int>(10);
    std::cout << *ptr << std::endl; // Salida: 10

    return 0;
}
<---Ejemplo con `std::unique_ptr` Result--->
<---Declaración de Punteros--->
```cpp
int* ptr; // Declara un puntero a un entero
<---Declaración de Punteros Result--->
<---Asignación y Acceso a Datos--->
```cpp
int var = 10;
int* ptr = &var; // ptr apunta a la dirección de var

std::cout << "Valor de var: " << var << std::endl; // Salida: 10
std::cout << "Dirección de var: " << &var << std::endl; // Dirección de var
std::cout << "Valor apuntado por ptr: " << *ptr << std::endl; // Salida: 10
```cpp
int arr[5] = {1, 2, 3, 4, 5};
int* ptr = arr; // ptr apunta al primer elemento del arreglo

for(int i = 0; i < 5; ++i) {
    std::cout << *(ptr + i) << " "; // Acceder a los elementos del arreglo usando punteros
}
// Salida: 1 2 3 4 5
```cpp
int arr[5] = {1, 2, 3, 4, 5};
int* ptr = arr;

std::cout << "Primer elemento: " << *ptr << std::endl; // Salida: 1
ptr++;
std::cout << "Segundo elemento: " << *ptr << std::endl; // Salida: 2
```cpp
int var = 10;
int* ptr = &var;
int** ptr2 = &ptr;

std::cout << "Valor de var: " << var << std::endl; // Salida: 10
std::cout << "Valor apuntado por ptr: " << *ptr << std::endl; // Salida: 10
std::cout << "Valor apuntado por ptr2: " << **ptr2 << std::endl; // Salida: 10
```cpp
int* ptr = nullptr; // Puntero inicializado a nullptr
```cpp
int* ptr = new int(10);
delete ptr; // Liberar memoria asignada
ptr = nullptr; // Evitar acceso a memoria liberada
```cpp
int* ptr = new int(10);
delete ptr;
ptr = nullptr; // Ahora ptr no es un puntero colgante
<---Asignación y Acceso a Datos Result--->
<---Paso por Referencia usando Punteros--->
```cpp
#include <iostream>

void incrementar(int* ptr) {
    (*ptr)++;
}

int main() {
    int var = 10;
    incrementar(&var);
    std::cout << "Valor de var después de incrementar: " << var << std::endl; // Salida: 11

    return 0;
}
<---Paso por Referencia usando Punteros Result--->
<---Ejemplo de Puntero a Función--->
```cpp
#include <iostream>

void saludo() {
    std::cout << "Hola, Mundo!" << std::endl;
}

void llamarFuncion(void (*func)()) {
    func();
}

int main() {
    void (*ptrFunc)() = &saludo;
    llamarFuncion(ptrFunc); // Salida: Hola, Mundo!

    return 0;
}
<---Ejemplo de Puntero a Función Result--->
<---Declaración Básica--->
```cpp
int var = 10;
int& ref = var; // ref es una referencia a var

std::cout << "var: " << var << std::endl; // Salida: 10
std::cout << "ref: " << ref << std::endl; // Salida: 10
<---Declaración Básica Result--->
<---Modificación a través de Referencias--->
```cpp
int var = 10;
int& ref = var;

ref = 20; // Modifica var a través de ref

std::cout << "var: " << var << std::endl; // Salida: 20
std::cout << "ref: " << ref << std::endl; // Salida: 20
<---Modificación a través de Referencias Result--->
<---Ejemplo de Paso por Referencia--->
```cpp
#include <iostream>

void incrementar(int& ref) {
    ref++;
}

int main() {
    int var = 10;
    incrementar(var);
    std::cout << "Valor de var después de incrementar: " << var << std::endl; // Salida: 11

    return 0;
}
<---Ejemplo de Paso por Referencia Result--->
<---Ejemplo de Referencia Constante--->
```cpp
#include <iostream>

void mostrar(const int& ref) {
    std::cout << "Valor: " << ref << std::endl;
}

int main() {
    int var = 10;
    mostrar(var); // Salida: 10

    return 0;
}
<---Ejemplo de Referencia Constante Result--->
<---Ejemplo de Constructor de Copia--->
```cpp
#include <iostream>

class MiClase {
private:
    int valor;

public:
    MiClase(int v) : valor(v) {}
    
    // Constructor de copia
    MiClase(const MiClase& otra) : valor(otra.valor) {
        std::cout << "Constructor de copia llamado" << std::endl;
    }

    int obtenerValor() const { return valor; }
};

int main() {
    MiClase obj1(10);
    MiClase obj2 = obj1; // Llama al constructor de copia

    std::cout << "Valor de obj1: " << obj1.obtenerValor() << std::endl; // Salida: 10
    std::cout << "Valor de obj2: " << obj2.obtenerValor() << std::endl; // Salida: 10

    return 0;
}
<---Ejemplo de Constructor de Copia Result--->
<---Ejemplo de Operador de Asignación--->
```cpp
#include <iostream>

class MiClase {
private:
    int valor;

public:
    MiClase(int v) : valor(v) {}
    
    // Operador de asignación
    MiClase& operator=(const MiClase& otra) {
        if (this != &otra) {
            valor = otra.valor;
        }
        return *this;
    }

    int obtenerValor() const { return valor; }
};

int main() {
    MiClase obj1(10);
    MiClase obj2(20);
    obj2 = obj1; // Llama al operador de asignación

    std::cout << "Valor de obj1: " << obj1.obtenerValor() << std::endl; // Salida: 10
    std::cout << "Valor de obj2: " << obj2.obtenerValor() << std::endl; // Salida: 10

    return 0;
}
<---Ejemplo de Operador de Asignación Result--->
<---Ejemplo de Referencia Dangling (a Evitar)--->
```cpp
int& funcion() {
    int var = 10;
    return var; // var se destruye al salir de la función
}

int main() {
    int& ref = funcion(); // ref ahora es una referencia dangling
    std::cout << ref << std::endl; // Comportamiento indefinido

    return 0;
}
```cpp
void mostrar(const int& ref) {
    std::cout << "Valor: " << ref << std::endl;
}
<---Ejemplo de Referencia Dangling (a Evitar) Result--->
<---Asignación de Memoria--->
```cpp
int* ptr = new int; // Asignar memoria para un entero
*ptr = 10;
std::cout << *ptr << std::endl; // Salida: 10

delete ptr; // Liberar la memoria asignada
<---Asignación de Memoria Result--->
<---Asignación de Memoria para Arreglos--->
```cpp
int size = 5;
int* arr = new int[size]; // Asignar memoria para un arreglo de enteros

for(int i = 0; i < size; ++i) {
    arr[i] = i * 10;
}

for(int i = 0; i < size; ++i) {
    std::cout << arr[i] << " "; // Salida: 0 10 20 30 40
}
std::cout << std::endl;

delete[] arr; // Liberar la memoria asignada para el arreglo
<---Asignación de Memoria para Arreglos Result--->
<---Ejemplo: Clase con Gestión de Memoria Dinámica--->
```cpp
#include <iostream>

class MiClase {
private:
    int* data;
    size_t size;

public:
    // Constructor
    MiClase(size_t s) : size(s) {
        data = new int[size];
        for(size_t i = 0; i < size; ++i) {
            data[i] = i * 10;
        }
    }

    // Destructor
    ~MiClase() {
        delete[] data;
    }

    // Constructor de copia
    MiClase(const MiClase& other) : size(other.size) {
        data = new int[size];
        std::copy(other.data, other.data + size, data);
    }

    // Operador de asignación
    MiClase& operator=(const MiClase& other) {
        if (this == &other) return *this;

        delete[] data;

        size = other.size;
        data = new int[size];
        std::copy(other.data, other.data + size, data);

        return *this;
    }

    void print() const {
        for(size_t i = 0; i < size; ++i) {
            std::cout << data[i] << " ";
        }
        std::cout << std::endl;
    }
};

int main() {
    MiClase obj1(5);
    obj1.print(); // Salida: 0 10 20 30 40

    MiClase obj2 = obj1; // Constructor de copia
    obj2.print(); // Salida: 0 10 20 30 40

    MiClase obj3(3);
    obj3 = obj1; // Operador de asignación
    obj3.print(); // Salida: 0 10 20 30 40

    return 0;
}
<---Ejemplo: Clase con Gestión de Memoria Dinámica Result--->
<---Ejemplo con `std::shared_ptr`--->
```cpp
#include <iostream>
#include <memory>

int main() {
    std::shared_ptr<int> ptr1 = std::make_shared<int>(20);
    std::shared_ptr<int> ptr2 = ptr1;

    std::cout << *ptr1 << std::endl; // Salida: 20
    std::cout << *ptr2 << std::endl; // Salida: 20

    return 0;
}
<---Ejemplo con `std::shared_ptr` Result--->
<---Ejemplo con `std::weak_ptr`--->
```cpp
#include <iostream>
#include <memory>

int main() {
    std::shared_ptr<int> sptr = std::make_shared<int>(30);
    std::weak_ptr<int> wptr = sptr;

    std::cout << "Use count: " << sptr.use_count() << std::endl; // Salida: 1

    if (auto spt = wptr.lock()) {
        std::cout << *spt << std::endl; // Salida: 30
    } else {
        std::cout << "wptr is expired" << std::endl;
    }

    return 0;
}
```cpp
int* ptr = new int(10);
// ...
delete ptr; // Liberar la memoria
```cpp
std::unique_ptr<int> ptr = std::make_unique<int>(10);
```cpp
int* ptr = new int(10);
delete ptr;
ptr = nullptr; // Evitar acceso a memoria liberada
```cpp
class Recurso {
public:
    Recurso() { /* adquirir recurso */ }
    ~Recurso() { /* liberar recurso */ }
};
<---Ejemplo con `std::weak_ptr` Result--->
<---Características:--->
<---Características: Result--->
<---Ejemplo de Uso de `std::unique_ptr`--->
```cpp
#include <iostream>
#include <memory>

int main() {
    std::unique_ptr<int> ptr = std::make_unique<int>(10); // Asignación de memoria
    std::cout << *ptr << std::endl; // Salida: 10

    // ptr2 = ptr; // Error: no se permite la copia de std::unique_ptr

    std::unique_ptr<int> ptr2 = std::move(ptr); // Transferencia de propiedad
    std::cout << *ptr2 << std::endl; // Salida: 10

    // La memoria se libera automáticamente al salir de ámbito
    return 0;
}
<---Ejemplo de Uso de `std::unique_ptr` Result--->
<---Ejemplo de Uso de `std::shared_ptr`--->
```cpp
#include <iostream>
#include <memory>

int main() {
    std::shared_ptr<int> ptr1 = std::make_shared<int>(20); // Asignación de memoria
    std::shared_ptr<int> ptr2 = ptr1; // Compartir la propiedad

    std::cout << *ptr1 << std::endl; // Salida: 20
    std::cout << *ptr2 << std::endl; // Salida: 20
    std::cout << "Use count: " << ptr1.use_count() << std::endl; // Salida: 2

    // La memoria se libera automáticamente cuando el último shared_ptr se destruye
    return 0;
}
<---Ejemplo de Uso de `std::shared_ptr` Result--->
<---Ejemplo de Uso de `std::weak_ptr`--->
```cpp
#include <iostream>
#include <memory>

int main() {
    std::shared_ptr<int> sptr = std::make_shared<int>(30);
    std::weak_ptr<int> wptr = sptr; // No incrementa el contador de referencias

    std::cout << "Use count: " << sptr.use_count() << std::endl; // Salida: 1

    if (auto spt = wptr.lock()) { // Comprobar si el recurso aún existe
        std::cout << *spt << std::endl; // Salida: 30
    } else {
        std::cout << "wptr is expired" << std::endl;
    }

    return 0;
}
```cpp
std::unique_ptr<int> ptr = std::make_unique<int>(10);
```cpp
std::shared_ptr<int> ptr1 = std::make_shared<int>(20);
std::shared_ptr<int> ptr2 = ptr1;
```cpp
class Nodo {
public:
    std::shared_ptr<Nodo> siguiente;
    std::weak_ptr<Nodo> anterior; // Evitar ciclo de referencia
};
<---Ejemplo de Uso de `std::weak_ptr` Result--->
<---Declaración y Asignación--->
```cpp
#include <iostream>
#include <memory>

int main() {
    std::shared_ptr<int> sptr = std::make_shared<int>(42);
    std::weak_ptr<int> wptr = sptr; // Inicializar con shared_ptr

    std::cout << "Use count: " << sptr.use_count() << std::endl; // Salida: 1
    return 0;
}
```cpp
#include <iostream>
#include <memory>

int main() {
    std::shared_ptr<int> sptr = std::make_shared<int>(42);
    std::weak_ptr<int> wptr = sptr;

    if (auto spt = wptr.lock()) { // Crear shared_ptr temporal
        std::cout << *spt << std::endl; // Salida: 42
    } else {
        std::cout << "El recurso ya no está disponible." << std::endl;
    }

    sptr.reset(); // Liberar el recurso

    if (auto spt = wptr.lock()) {
        std::cout << *spt << std::endl;
    } else {
        std::cout << "El recurso ya no está disponible." << std::endl; // Salida esperada
    }

    return 0;
}
<---Declaración y Asignación Result--->
<---Declaración en el Archivo de Cabecera (.h)--->
```cpp
// ArregloDinamico.h
#ifndef ARREGLODINAMICO_H
#define ARREGLODINAMICO_H

class ArregloDinamico {
public:
    ArregloDinamico(int size);
    ~ArregloDinamico();

    void redimensionar(int newSize);
    void mostrar() const;

private:
    int* datos_;
    int size_;
};

#endif // ARREGLODINAMICO_H
<---Declaración en el Archivo de Cabecera (.h) Result--->
<---Definición en el Archivo de Implementación (.cpp)--->
```cpp
// ArregloDinamico.cpp
#include "ArregloDinamico.h"
#include <iostream>
#include <algorithm>

ArregloDinamico::ArregloDinamico(int size) : size_(size) {
    datos_ = new int[size_];
    for (int i = 0; i < size_; ++i) {
        datos_[i] = i * 10;
    }
}

ArregloDinamico::~ArregloDinamico() {
    delete[] datos_;
}

void ArregloDinamico::redimensionar(int newSize) {
    int* nuevosDatos = new int[newSize];
    std::copy(datos_, datos_ + size_, nuevosDatos);
    for (int i = size_; i < newSize; ++i) {
        nuevosDatos[i] = i * 10;
    }
    delete[] datos_;
    datos_ = nuevosDatos;
    size_ = newSize;
}

void ArregloDinamico::mostrar() const {
    for (int i = 0; i < size_; ++i) {
        std::cout << datos_[i] << " ";
    }
    std::cout << std::endl;
}
<---Definición en el Archivo de Implementación (.cpp) Result--->
<---Ejemplo de Transferencia de Propiedad--->
```cpp
#include <iostream>
#include <memory>

void mostrar(std::unique_ptr<int> ptr) {
    std::cout << *ptr << std::endl;
}

int main() {
    std::unique_ptr<int> ptr = std::make_unique<int>(42);
    mostrar(std::move(ptr)); // Transferir la propiedad
    // ptr ya no es válido aquí
    return 0;
}
<---Ejemplo de Transferencia de Propiedad Result--->
<---1. Encapsulación de Recursos--->
```cpp
class Archivo {
public:
    Archivo(const std::string& nombre) : archivo_(std::fopen(nombre.c_str(), "r")) {
        if (!archivo_) {
            throw std::runtime_error("No se pudo abrir el archivo");
        }
    }

    ~Archivo() {
        if (archivo_) {
            std::fclose(archivo_);
        }
    }

private:
    std::unique_ptr<FILE, decltype(&std::fclose)> archivo_;
};
<---1. Encapsulación de Recursos Result--->
<---2. Uso en Contenedores--->
```cpp
#include <vector>
#include <memory>

int main() {
    std::vector<std::unique_ptr<int>> vec;
    vec.push_back(std::make_unique<int>(1));
    vec.push_back(std::make_unique<int>(2));
    vec.push_back(std::make_unique<int>(3));

    for (const auto& ptr : vec) {
        std::cout << *ptr << std::endl;
    }
    return 0;
}
<---2. Uso en Contenedores Result--->
<---3. Evitar el Uso de Punteros Crudos--->
<---3. Evitar el Uso de Punteros Crudos Result--->
<---Archivo de Cabecera (.h)--->
```cpp
// GestorRecurso.h
#ifndef GESTORRECURSO_H
#define GESTORRECURSO_H

#include <memory>
#include <string>

class GestorRecurso {
public:
    GestorRecurso(const std::string& nombre);
    void mostrarRecurso() const;

private:
    std::shared_ptr<std::string> recurso_;
};

class Contenedor {
public:
    void establecerRecurso(std::shared_ptr<GestorRecurso> recurso);
    void mostrar() const;

private:
    std::shared_ptr<GestorRecurso> recurso_;
};

#endif // GESTORRECURSO_H
<---Archivo de Cabecera (.h) Result--->
<---Archivo de Implementación (.cpp)--->
```cpp
// GestorRecurso.cpp
#include "GestorRecurso.h"
#include <iostream>

GestorRecurso::GestorRecurso(const std::string& nombre)
    : recurso_(std::make_shared<std::string>(nombre)) {}

void GestorRecurso::mostrarRecurso() const {
    std::cout << "Recurso: " << *recurso_ << std::endl;
}

void Contenedor::establecerRecurso(std::shared_ptr<GestorRecurso> recurso) {
    recurso_ = recurso;
}

void Contenedor::mostrar() const {
    if (recurso_) {
        recurso_->mostrarRecurso();
    } else {
        std::cout << "Sin recurso" << std::endl;
    }
}
<---Archivo de Implementación (.cpp) Result--->
<---Función Principal--->
```cpp
#include <iostream>
#include "ArregloDinamico.h"

int main() {
    ArregloDinamico arreglo(5);
    arreglo.mostrar(); // Salida: 0 10 20 30 40

    arreglo.redimensionar(10);
    arreglo.mostrar(); // Salida: 0 10 20 30 40 50 60 70 80 90

    return 0;
}
```cpp
#include <iostream>
#include <vector>

int main() {
    std::vector<int> vec = {1, 2, 3, 4, 5};

    vec.push_back(6); // Agregar un nuevo elemento
    vec.push_back(7);

    for (const auto& val : vec) {
        std::cout << val << " "; // Salida: 1 2 3 4 5 6 7
    }
    std::cout << std::endl;

    return 0;
}
<---Función Principal Result--->
<---1. Compartición de Recursos--->
```cpp
#include <memory>
#include <vector>
#include <iostream>

class Nodo {
public:
    Nodo(int valor) : valor_(valor) {}

    void agregarHijo(std::shared_ptr<Nodo> hijo) {
        hijos_.push_back(hijo);
    }

    void mostrar() const {
        std::cout << "Nodo: " << valor_ << std::endl;
        for (const auto& hijo : hijos_) {
            hijo->mostrar();
        }
    }

private:
    int valor_;
    std::vector<std::shared_ptr<Nodo>> hijos_;
};

int main() {
    auto raiz = std::make_shared<Nodo>(1);
    auto hijo1 = std::make_shared<Nodo>(2);
    auto hijo2 = std::make_shared<Nodo>(3);

    raiz->agregarHijo(hijo1);
    raiz->agregarHijo(hijo2);

    raiz->mostrar(); // Muestra toda la jerarquía de nodos

    return 0;
}
<---1. Compartición de Recursos Result--->
<---2. Evitar Ciclos de Referencia--->
<---2. Evitar Ciclos de Referencia Result--->
<---Ejemplo de Ciclo de Referencia--->
```cpp
#include <memory>
#include <iostream>

class Nodo;

class Nodo {
public:
    Nodo(int valor) : valor_(valor) {}

    void establecerPadre(std::shared_ptr<Nodo> padre) {
        padre_ = padre;
    }

    void establecerHijo(std::shared_ptr<Nodo> hijo) {
        hijo_ = hijo;
    }

    ~Nodo() {
        std::cout << "Destruyendo nodo: " << valor_ << std::endl;
    }

private:
    int valor_;
    std::shared_ptr<Nodo> hijo_;
    std::shared_ptr<Nodo> padre_; // Ciclo de referencia
};

int main() {
    {
        auto nodo1 = std::make_shared<Nodo>(1);
        auto nodo2 = std::make_shared<Nodo>(2);

        nodo1->establecerHijo(nodo2);
        nodo2->establecerPadre(nodo1);
    } // Ciclo de referencia evita que los nodos sean destruidos

    return 0;
}
<---Ejemplo de Ciclo de Referencia Result--->
<---Solución usando `std::weak_ptr`--->
```cpp
#include <memory>
#include <iostream>

class Nodo;

class Nodo {
public:
    Nodo(int valor) : valor_(valor) {}

    void establecerPadre(std::shared_ptr<Nodo> padre) {
        padre_ = padre;
    }

    void establecerHijo(std::shared_ptr<Nodo> hijo) {
        hijo_ = hijo;
    }

    ~Nodo() {
        std::cout << "Destruyendo nodo: " << valor_ << std::endl;
    }

private:
    int valor_;
    std::shared_ptr<Nodo> hijo_;
    std::weak_ptr<Nodo> padre_; // Evitar ciclo de referencia
};

int main() {
    {
        auto nodo1 = std::make_shared<Nodo>(1);
        auto nodo2 = std::make_shared<Nodo>(2);

        nodo1->establecerHijo(nodo2);
        nodo2->establecerPadre(nodo1);
    } // Nodos correctamente destruidos

    return 0;
}
<---Solución usando `std::weak_ptr` Result--->
<---Ejemplo de Ciclo de Referencia Evitado con `std::weak_ptr`--->
<---Ejemplo de Ciclo de Referencia Evitado con `std::weak_ptr` Result--->
<---1. Utilizar `std::weak_ptr` para Referencias a Objetos de Vida Útil Controlada--->
```cpp
#include <iostream>
#include <memory>
#include <vector>

class Observador {
public:
    virtual void actualizar() = 0;
};

class Sujeto {
public:
    void agregarObservador(std::shared_ptr<Observador> obs) {
        observadores_.push_back(obs);
    }

    void notificar() {
        for (auto& obs : observadores_) {
            if (auto sp = obs.lock()) {
                sp->actualizar();
            }
        }
    }

private:
    std::vector<std::weak_ptr<Observador>> observadores_;
};

class ConcretoObservador : public Observador, public std::enable_shared_from_this<ConcretoObservador> {
public:
    void actualizar() override {
        std::cout << "Observador actualizado!" << std::endl;
    }

    void suscribirse(Sujeto& sujeto) {
        sujeto.agregarObservador(shared_from_this());
    }
};

int main() {
    Sujeto sujeto;
    auto obs = std::make_shared<ConcretoObservador>();
    obs->suscribirse(sujeto);

    sujeto.notificar(); // Salida: Observador actualizado!

    return 0;
}
<---1. Utilizar `std::weak_ptr` para Referencias a Objetos de Vida Útil Controlada Result--->
<---2. Usar `std::weak_ptr` en Estructuras de Datos Complejas--->
```cpp
#include <memory>
#include <iostream>

class Nodo {
public:
    Nodo(int valor) : valor_(valor) {}

    void agregarHijo(std::shared_ptr<Nodo> hijo) {
        hijos_.push_back(hijo);
        hijo->padre_ = weak_from_this();
    }

    void mostrar() const {
        std::cout << "Nodo: " << valor_ << std::endl;
        for (const auto& hijo : hijos_) {
            hijo->mostrar();
        }
    }

private:
    int valor_;
    std::vector<std::shared_ptr<Nodo>> hijos_;
    std::weak_ptr<Nodo> padre_; // Referencia no propietaria
};

int main() {
    auto nodo1 = std::make_shared<Nodo>(1);
    auto nodo2 = std::make_shared<Nodo>(2);
    auto nodo3 = std::make_shared<Nodo>(3);

    nodo1->agregarHijo(nodo2);
    nodo2->agregarHijo(nodo3);

    nodo1->mostrar(); // Muestra la jerarquía completa

    return 0;
}
<---2. Usar `std::weak_ptr` en Estructuras de Datos Complejas Result--->
<---Asignación y Liberación de Memoria con `new` y `delete[]`--->
```cpp
#include <iostream>

int main() {
    int size = 5;
    int* arr = new int[size]; // Asignar memoria para un arreglo de enteros

    // Inicializar el arreglo
    for (int i = 0; i < size; ++i) {
        arr[i] = i * 10;
    }

    // Acceder y mostrar los elementos del arreglo
    for (int i = 0; i < size; ++i) {
        std::cout << arr[i] << " "; // Salida: 0 10 20 30 40
    }
    std::cout << std::endl;

    delete[] arr; // Liberar la memoria asignada para el arreglo
    return 0;
}
<---Asignación y Liberación de Memoria con `new` y `delete[]` Result--->
<---Ejemplo de Redimensionamiento--->
```cpp
#include <iostream>
#include <algorithm> // Para std::copy

int main() {
    int size = 5;
    int* arr = new int[size]; // Asignar memoria para un arreglo de enteros

    // Inicializar el arreglo
    for (int i = 0; i < size; ++i) {
        arr[i] = i * 10;
    }

    // Nuevo tamaño del arreglo
    int newSize = 10;
    int* newArr = new int[newSize]; // Asignar memoria para el nuevo arreglo

    // Copiar elementos del arreglo original al nuevo arreglo
    std::copy(arr, arr + size, newArr);

    // Inicializar los nuevos elementos
    for (int i = size; i < newSize; ++i) {
        newArr[i] = i * 10;
    }

    // Liberar la memoria del arreglo original
    delete[] arr;

    // Asignar el puntero del nuevo arreglo al original
    arr = newArr;

    // Mostrar los elementos del nuevo arreglo
    for (int i = 0; i < newSize; ++i) {
        std::cout << arr[i] << " "; // Salida: 0 10 20 30 40 50 60 70 80 90
    }
    std::cout << std::endl;

    delete[] arr; // Liberar la memoria del nuevo arreglo
    return 0;
}
<---Ejemplo de Redimensionamiento Result--->
<---Características del Stack--->
<---Características del Stack Result--->
<---Ejemplo de Uso del Stack--->
```cpp
#include <iostream>

void funcion() {
    int localVar = 10; // Variable local en el stack
    std::cout << "Valor de localVar: " << localVar << std::endl;
}

int main() {
    funcion(); // Llamada a la función
    return 0;
}
<---Ejemplo de Uso del Stack Result--->
<---Características del Heap--->
<---Características del Heap Result--->
<---Ejemplo de Uso del Heap--->
```cpp
#include <iostream>

void funcion() {
    int* heapVar = new int(20); // Variable asignada en el heap
    std::cout << "Valor de heapVar: " << *heapVar << std::endl;
    delete heapVar; // Liberar la memoria asignada en el heap
}

int main() {
    funcion(); // Llamada a la función
    return 0;
}
<---Ejemplo de Uso del Heap Result--->
<---Fuga de Memoria Simple--->
```cpp
#include <iostream>

void funcion() {
    int* ptr = new int(10); // Asignar memoria en el heap
    // ptr se pierde al salir de la función sin liberar la memoria
}

int main() {
    funcion();
    // La memoria asignada no se libera
    return 0;
}
<---Fuga de Memoria Simple Result--->
<---Fuga de Memoria en un Bucle--->
```cpp
#include <iostream>

void funcion() {
    for (int i = 0; i < 10; ++i) {
        int* ptr = new int(i); // Asignar memoria en el heap en cada iteración
        // Sin delete, cada iteración causa una fuga de memoria
    }
}

int main() {
    funcion();
    return 0;
}
```cpp
#include <iostream>

void funcion() {
    int* ptr = new int(10);
    // Usar ptr
    delete ptr; // Liberar la memoria
}

int main() {
    funcion();
    return 0;
}
<---Fuga de Memoria en un Bucle Result--->
<---`std::unique_ptr`--->
```cpp
#include <iostream>
#include <memory>

void funcion() {
    std::unique_ptr<int> ptr = std::make_unique<int>(10); // Memoria gestionada automáticamente
    // Usar ptr
}

int main() {
    funcion();
    return 0;
}
<---`std::unique_ptr` Result--->
<---`std::shared_ptr`--->
```cpp
#include <iostream>
#include <memory>

void funcion() {
    std::shared_ptr<int> ptr1 = std::make_shared<int>(10);
    std::shared_ptr<int> ptr2 = ptr1; // Compartir la propiedad del recurso
    // Usar ptr1 y ptr2
}

int main() {
    funcion();
    return 0;
}
<---`std::shared_ptr` Result--->
<---Uso Básico de Valgrind--->
<---Uso Básico de Valgrind Result--->
<---Ejemplo de Clase con Fuga de Memoria--->
```cpp
#include <iostream>

class MiClase {
public:
    MiClase() {
        ptr_ = new int[10]; // Asignar memoria dinámica
    }
    ~MiClase() {
        // Falta delete[] ptr_, causando una fuga de memoria
    }

private:
    int* ptr_;
};

int main() {
    MiClase obj;
    return 0;
}
<---Ejemplo de Clase con Fuga de Memoria Result--->
<---Solución con Destructor Correcto--->
```cpp
#include <iostream>

class MiClase {
public:
    MiClase() {
        ptr_ = new int[10]; // Asignar memoria dinámica
    }
    ~MiClase() {
        delete[] ptr_; // Liberar la memoria asignada
    }

private:
    int* ptr_;
};

int main() {
    MiClase obj;
    return 0;
}
```cpp
#include <iostream>
#include <memory>

class MiClase {
public:
    MiClase() {
        ptr_ = std::make_unique<int[]>(10); // Uso de unique_ptr
    }
    // No se necesita destructor explícito

private:
    std::unique_ptr<int[]> ptr_;
};

int main() {
    MiClase obj;
    return 0;
}
<---Solución con Destructor Correcto Result--->
