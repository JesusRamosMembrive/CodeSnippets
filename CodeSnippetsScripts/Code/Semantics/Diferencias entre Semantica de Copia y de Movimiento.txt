<---EXPLANATION--->
### Move Semantics y Definición de L-Value en C++

Las move semantics (semánticas de movimiento) y el concepto de L-value son fundamentales en C++ moderno para la gestión eficiente de recursos y la optimización del rendimiento. Comprender estos conceptos es crucial para escribir código C++ eficiente y robusto.

#### Definición de L-Value

En C++, un **L-value** (Left value) es una expresión que representa una ubicación en memoria que tiene un identificador persistente. Los L-values se pueden encontrar en el lado izquierdo de una asignación, lo que significa que pueden recibir un valor.

##### Características de L-Value

- **Asignabilidad:** Los L-values pueden aparecer en el lado izquierdo de una asignación.
- **Dirección en Memoria:** Los L-values tienen una dirección en memoria, lo que significa que se puede tomar su dirección utilizando el operador `&`.
- **Persistencia:** Representan una entidad que persiste más allá de la expresión en la que se usan.

##### Ejemplos de L-Value

```cpp
int x = 5;         // 'x' es un L-value
int* p = &x;       // 'p' es un L-value que contiene la dirección de 'x'
x = 10;            // 'x' puede estar en el lado izquierdo de la asignación
*p = 20;           // '*p' es un L-value que puede estar en el lado izquierdo de la asignación

int& ref = x;      // 'ref' es un L-value reference a 'x'
ref = 30;          // 'ref' puede estar en el lado izquierdo de la asignación
```

En este ejemplo:
- `x`, `p`, `*p` y `ref` son L-values porque tienen una ubicación en memoria y pueden recibir un valor.

#### Move Semantics

Las **move semantics** se introdujeron en C++11 para optimizar la transferencia de recursos entre objetos. En lugar de copiar recursos (lo cual puede ser costoso), las move semantics permiten mover recursos de un objeto a otro, dejando el objeto original en un estado válido pero no especificado.

##### R-Value

Antes de entrar en detalles sobre las move semantics, es importante entender los R-values. Un **R-value** (Right value) es una expresión que no tiene una dirección en memoria accesible y es temporal. Los R-values típicamente se utilizan en el lado derecho de una asignación.

##### Ejemplos de R-Value

```cpp
int y = 5;         // '5' es un R-value
int z = y + 3;     // 'y + 3' es un R-value
```

En este ejemplo:
- `5` y `y + 3` son R-values porque son temporales y no tienen una dirección en memoria accesible directamente.

##### Move Constructor y Move Assignment Operator

Las move semantics se implementan principalmente mediante el constructor de movimiento (move constructor) y el operador de asignación por movimiento (move assignment operator).

###### Move Constructor

El move constructor transfiere recursos de un objeto a otro, dejando el objeto original en un estado válido pero indeterminado.

```cpp
#include <iostream>
#include <utility>

class MiClase {
private:
    int* data;

public:
    // Constructor
    MiClase(int value) : data(new int(value)) {
        std::cout << "Constructor llamado para " << *data << std::endl;
    }

    // Destructor
    ~MiClase() {
        delete data;
        std::cout << "Destructor llamado" << std::endl;
    }

    // Move Constructor
    MiClase(MiClase&& other) noexcept : data(other.data) {
        other.data = nullptr;
        std::cout << "Move Constructor llamado" << std::endl;
    }

    // Move Assignment Operator
    MiClase& operator=(MiClase&& other) noexcept {
        if (this != &other) {
            delete data;
            data = other.data;
            other.data = nullptr;
            std::cout << "Move Assignment Operator llamado" << std::endl;
        }
        return *this;
    }

    void mostrar() const {
        if (data) {
            std::cout << "Valor: " << *data << std::endl;
        } else {
            std::cout << "No hay datos" << std::endl;
        }
    }
};

int main() {
    MiClase obj1(10);
    MiClase obj2 = std::move(obj1);  // Move Constructor llamado
    obj2.mostrar();
    obj1.mostrar();  // No hay datos, ya que los datos fueron movidos

    MiClase obj3(20);
    obj3 = std::move(obj2);  // Move Assignment Operator llamado
    obj3.mostrar();
    obj2.mostrar();  // No hay datos, ya que los datos fueron movidos

    return 0;
}
```

En este ejemplo:
- `MiClase` tiene un move constructor y un move assignment operator.
- `std::move` se utiliza para convertir un L-value a un R-value, permitiendo que las move semantics se apliquen.

#### Ventajas de Move Semantics

1. **Eficiencia:** Evitan copias innecesarias de recursos, lo que puede mejorar significativamente el rendimiento, especialmente para objetos grandes o que gestionan recursos externos como memoria dinámica o archivos.
2. **Seguridad:** Las move semantics dejan el objeto original en un estado válido pero indeterminado, evitando problemas de recursos duplicados.

### Conclusión

Entender los L-values y R-values, junto con las move semantics, es esencial para escribir código C++ eficiente y robusto. Las move semantics permiten transferir recursos de manera eficiente, optimizando el rendimiento y evitando copias costosas. Al implementar correctamente el move constructor y el move assignment operator, los desarrolladores pueden aprovechar estas optimizaciones en sus programas.
### Definición de R-Value en C++

En C++, un **R-value** (Right value) es una expresión que no tiene una dirección en memoria accesible directamente y es generalmente temporal. Los R-values típicamente aparecen en el lado derecho de una asignación, de ahí su nombre. A diferencia de los L-values, los R-values no tienen un identificador persistente ni una dirección en memoria que pueda ser tomada con el operador `&`.

#### Características de los R-Values

1. **Temporalidad:** Los R-values son generalmente temporales y solo existen durante la evaluación de una expresión.
2. **No Asignables:** No se pueden asignar valores a R-values porque no tienen un identificador persistente ni una ubicación en memoria accesible.
3. **Optimización:** Los R-values son fundamentales para las optimizaciones como las move semantics, que permiten la transferencia eficiente de recursos.

#### Ejemplos de R-Values

- Literales de datos, como números y cadenas.
- El resultado de operaciones aritméticas.
- Objetos temporales creados como resultado de una expresión.

##### Ejemplos Prácticos

```cpp
int x = 5;         // '5' es un R-value
int y = x + 2;     // 'x + 2' es un R-value

std::string s1 = "hello";        // "hello" es un R-value
std::string s2 = s1 + " world";  // 's1 + " world"' es un R-value
```

En estos ejemplos:
- `5` y `x + 2` son R-values porque son valores temporales que no tienen un identificador persistente.
- `"hello"` y `s1 + " world"` son R-values porque son valores temporales que resultan de expresiones.

#### R-Value References

Introducidas en C++11, las **R-value references** permiten tomar posesión de un R-value, proporcionando un mecanismo para implementar move semantics y optimizar el manejo de recursos.

##### Sintaxis

```cpp
int&& rvalue_ref = 10;  // rvalue_ref es una referencia a un R-value
```

##### Ejemplo con R-Value References

```cpp
#include <iostream>

class MiClase {
public:
    int* data;

    // Constructor normal
    MiClase(int value) : data(new int(value)) {
        std::cout << "Constructor llamado para " << *data << std::endl;
    }

    // Destructor
    ~MiClase() {
        delete data;
        std::cout << "Destructor llamado" << std::endl;
    }

    // Move Constructor
    MiClase(MiClase&& other) noexcept : data(other.data) {
        other.data = nullptr;
        std::cout << "Move Constructor llamado" << std::endl;
    }

    // Move Assignment Operator
    MiClase& operator=(MiClase&& other) noexcept {
        if (this != &other) {
            delete data;
            data = other.data;
            other.data = nullptr;
            std::cout << "Move Assignment Operator llamado" << std::endl;
        }
        return *this;
    }

    void mostrar() const {
        if (data) {
            std::cout << "Valor: " << *data << std::endl;
        } else {
            std::cout << "No hay datos" << std::endl;
        }
    }
};

int main() {
    MiClase obj1(10);
    MiClase obj2 = std::move(obj1);  // Move Constructor llamado
    obj2.mostrar();
    obj1.mostrar();  // No hay datos, ya que los datos fueron movidos

    MiClase obj3(20);
    obj3 = std::move(obj2);  // Move Assignment Operator llamado
    obj3.mostrar();
    obj2.mostrar();  // No hay datos, ya que los datos fueron movidos

    return 0;
}
```

En este ejemplo:
- `std::move` convierte un L-value en un R-value, permitiendo que las move semantics se apliquen.
- `MiClase` utiliza un move constructor y un move assignment operator para transferir eficientemente recursos de un objeto a otro.

### Conclusión

En C++, un R-value es una expresión temporal que no tiene una dirección en memoria accesible directamente. Los R-values son fundamentales para las optimizaciones de rendimiento como las move semantics, que permiten la transferencia eficiente de recursos en el lenguaje. Entender los R-values y cómo utilizarlos a través de R-value references es esencial para escribir código C++ eficiente y moderno.
### Identificación de un R-Value en C++

En C++, identificar un R-value (Right value) es esencial para comprender el comportamiento de las expresiones y cómo se gestionan los recursos. Los R-values son temporales y no tienen una dirección en memoria accesible. Aquí se explicará cómo identificarlos y se proporcionarán ejemplos prácticos.

#### Características de los R-Values

1. **Temporalidad:** Los R-values son temporales y existen solo durante la evaluación de una expresión.
2. **No Asignables:** No pueden aparecer en el lado izquierdo de una asignación.
3. **No Pueden Tomarse Direcciones:** No tienen una dirección de memoria accesible directamente mediante el operador `&`.

#### Ejemplos de R-Values

1. **Literales:** Los valores literales como números y cadenas.
2. **Resultados de Expresiones:** El resultado de operaciones aritméticas y lógicas.
3. **Llamadas a Funciones que Devuelven R-Values:** Llamadas a funciones que devuelven valores temporales.

##### Ejemplos Prácticos

```cpp
#include <iostream>

int main() {
    // Literales
    int x = 5;         // '5' es un R-value
    double y = 3.14;   // '3.14' es un R-value

    // Resultados de Expresiones
    int z = x + 2;     // 'x + 2' es un R-value

    // Llamadas a Funciones que Devuelven R-Values
    std::string s1 = "hello";          // "hello" es un R-value
    std::string s2 = s1 + " world";    // 's1 + " world"' es un R-value

    // Mostrando los valores
    std::cout << "x: " << x << std::endl;
    std::cout << "y: " << y << std::endl;
    std::cout << "z: " << z << std::endl;
    std::cout << "s1: " << s1 << std::endl;
    std::cout << "s2: " << s2 << std::endl;

    return 0;
}
```

En este ejemplo:
- `5`, `3.14`, `x + 2`, `"hello"`, y `s1 + " world"` son R-values porque son valores temporales.

#### R-Value References

En C++11 y posteriores, las R-value references (`&&`) permiten capturar y manipular R-values. Son esenciales para implementar move semantics y optimizar el rendimiento.

##### Ejemplo de R-Value References

```cpp
#include <iostream>

class MiClase {
public:
    int* data;

    // Constructor normal
    MiClase(int value) : data(new int(value)) {
        std::cout << "Constructor llamado para " << *data << std::endl;
    }

    // Destructor
    ~MiClase() {
        delete data;
        std::cout << "Destructor llamado" << std::endl;
    }

    // Move Constructor
    MiClase(MiClase&& other) noexcept : data(other.data) {
        other.data = nullptr;
        std::cout << "Move Constructor llamado" << std::endl;
    }

    // Move Assignment Operator
    MiClase& operator=(MiClase&& other) noexcept {
        if (this != &other) {
            delete data;
            data = other.data;
            other.data = nullptr;
            std::cout << "Move Assignment Operator llamado" << std::endl;
        }
        return *this;
    }

    void mostrar() const {
        if (data) {
            std::cout << "Valor: " << *data << std::endl;
        } else {
            std::cout << "No hay datos" << std::endl;
        }
    }
};

int main() {
    MiClase obj1(10);
    MiClase obj2 = std::move(obj1);  // Move Constructor llamado
    obj2.mostrar();
    obj1.mostrar();  // No hay datos, ya que los datos fueron movidos

    MiClase obj3(20);
    obj3 = std::move(obj2);  // Move Assignment Operator llamado
    obj3.mostrar();
    obj2.mostrar();  // No hay datos, ya que los datos fueron movidos

    return 0;
}
```

En este ejemplo:
- `std::move` se usa para convertir un L-value en un R-value, permitiendo que las move semantics se apliquen.
- `MiClase` utiliza un move constructor y un move assignment operator para transferir eficientemente recursos de un objeto a otro.

### Identificación de R-Values en Funciones

Al escribir funciones, es útil identificar cuándo se están utilizando R-values y cuándo L-values. Esto puede influir en la sobrecarga de funciones y en la eficiencia del código.

##### Ejemplo de Sobrecarga de Funciones con L-Values y R-Values

```cpp
#include <iostream>

void procesar(int& x) {
    std::cout << "L-value reference: " << x << std::endl;
}

void procesar(int&& x) {
    std::cout << "R-value reference: " << x << std::endl;
}

int main() {
    int a = 5;
    procesar(a);        // Llama a la versión de L-value reference
    procesar(10);       // Llama a la versión de R-value reference
    procesar(a + 3);    // Llama a la versión de R-value reference

    return 0;
}
```

En este ejemplo:
- `procesar(int& x)` maneja L-values.
- `procesar(int&& x)` maneja R-values.
- `a` es un L-value, mientras que `10` y `a + 3` son R-values.

### Conclusión

Identificar R-values es crucial para escribir código C++ eficiente y seguro. Los R-values son valores temporales y no asignables que se encuentran típicamente en el lado derecho de una asignación. Con el uso de R-value references y move semantics, se pueden optimizar significativamente las operaciones de transferencia de recursos, mejorando el rendimiento y reduciendo la sobrecarga en el manejo de datos temporales. Entender la distinción entre L-values y R-values es esencial para cualquier desarrollador de C++ moderno.
### Operaciones Permitidas con un R-Value en C++

Los R-values en C++ son valores temporales que no tienen una dirección de memoria accesible. Aunque no pueden aparecer en el lado izquierdo de una asignación, hay varias operaciones que se pueden realizar con ellos. A continuación, se describen las operaciones permitidas con R-values, junto con ejemplos prácticos.

#### Operaciones Comunes con R-Values

1. **Asignación a una Variable:**
   - Los R-values se pueden asignar a variables. Esto es común cuando se asigna el resultado de una expresión a una variable.

2. **Paso como Argumentos a Funciones:**
   - Los R-values se pueden pasar como argumentos a funciones, especialmente a funciones que toman parámetros por valor o R-value references.

3. **Inicialización de Variables:**
   - Los R-values se pueden utilizar para inicializar variables.

4. **Operadores y Expresiones:**
   - Los R-values se pueden usar en expresiones y con operadores aritméticos, lógicos, y relacionales.

5. **Uso con R-Value References (`&&`):**
   - Los R-values se pueden capturar con R-value references, lo que permite optimizaciones de movimiento (move semantics).

#### Ejemplos de Operaciones con R-Values

##### Asignación a una Variable

```cpp
int x = 5;         // '5' es un R-value asignado a 'x'
double y = 3.14;   // '3.14' es un R-value asignado a 'y'
```

En este ejemplo:
- `5` y `3.14` son R-values que se asignan a las variables `x` y `y`.

##### Paso como Argumentos a Funciones

```cpp
#include <iostream>

// Función que toma un parámetro por valor
void procesar(int x) {
    std::cout << "Valor: " << x << std::endl;
}

int main() {
    procesar(10);   // '10' es un R-value pasado como argumento
    return 0;
}
```

En este ejemplo:
- `10` es un R-value que se pasa como argumento a la función `procesar`.

##### Inicialización de Variables

```cpp
int a = 5;         // '5' es un R-value usado para inicializar 'a'
double b = a + 3;  // 'a + 3' es un R-value usado para inicializar 'b'
```

En este ejemplo:
- `5` y `a + 3` son R-values que se usan para inicializar `a` y `b`.

##### Uso en Expresiones y Operadores

```cpp
#include <iostream>

int main() {
    int x = 5;
    int y = 10;
    int z = x + y;  // 'x + y' es un R-value usado en una expresión

    std::cout << "Resultado: " << z << std::endl;
    return 0;
}
```

En este ejemplo:
- `x + y` es un R-value resultante de la expresión que se asigna a `z`.

##### Uso con R-Value References

```cpp
#include <iostream>

class MiClase {
public:
    int* data;

    // Constructor normal
    MiClase(int value) : data(new int(value)) {
        std::cout << "Constructor llamado para " << *data << std::endl;
    }

    // Destructor
    ~MiClase() {
        delete data;
        std::cout << "Destructor llamado" << std::endl;
    }

    // Move Constructor
    MiClase(MiClase&& other) noexcept : data(other.data) {
        other.data = nullptr;
        std::cout << "Move Constructor llamado" << std::endl;
    }

    // Move Assignment Operator
    MiClase& operator=(MiClase&& other) noexcept {
        if (this != &other) {
            delete data;
            data = other.data;
            other.data = nullptr;
            std::cout << "Move Assignment Operator llamado" << std::endl;
        }
        return *this;
    }

    void mostrar() const {
        if (data) {
            std::cout << "Valor: " << *data << std::endl;
        } else {
            std::cout << "No hay datos" << std::endl;
        }
    }
};

int main() {
    MiClase obj1(10);
    MiClase obj2 = std::move(obj1);  // 'std::move(obj1)' convierte 'obj1' en un R-value
    obj2.mostrar();
    obj1.mostrar();  // No hay datos, ya que los datos fueron movidos

    MiClase obj3(20);
    obj3 = std::move(obj2);  // 'std::move(obj2)' convierte 'obj2' en un R-value
    obj3.mostrar();
    obj2.mostrar();  // No hay datos, ya que los datos fueron movidos

    return 0;
}
```

En este ejemplo:
- `std::move` convierte un L-value (`obj1` y `obj2`) en un R-value, permitiendo que las move semantics se apliquen.

### Resumen de Operaciones Permitidas con R-Values

1. **Asignación a Variables:** Los R-values se pueden asignar a variables de tipos compatibles.
2. **Paso como Argumentos a Funciones:** Los R-values se pueden pasar como argumentos a funciones, especialmente aquellas que aceptan R-value references (`&&`).
3. **Inicialización de Variables:** Los R-values se pueden usar para inicializar variables.
4. **Uso en Expresiones:** Los R-values se pueden usar en expresiones aritméticas, lógicas, y relacionales.
5. **Move Semantics:** Los R-values se pueden usar con move semantics para transferir recursos eficientemente.

### Conclusión

Los R-values son fundamentales en C++ para trabajar con valores temporales y optimizar el manejo de recursos. Entender las operaciones permitidas con R-values y cómo utilizarlos correctamente es crucial para escribir código C++ moderno y eficiente. Las move semantics, habilitadas por las R-value references, permiten una gestión de recursos más eficiente y un rendimiento mejorado en aplicaciones críticas.
### Conversión de un L-Value a un R-Value en C++

En C++, convertir un L-value (Left value) a un R-value (Right value) es un proceso fundamental para habilitar ciertas optimizaciones y técnicas avanzadas, como las move semantics. La principal herramienta para realizar esta conversión es la función `std::move`, introducida en C++11.

#### `std::move`

`std::move` es una función de la biblioteca estándar que convierte un L-value en un R-value, permitiendo que se aplique el move constructor o el move assignment operator en lugar del copy constructor o copy assignment operator.

##### Sintaxis

```cpp
#include <utility>

std::move(obj);  // Convierte 'obj' en un R-value
```

#### Ejemplo Práctico con `std::move`

Vamos a ver un ejemplo detallado de cómo `std::move` se usa para convertir un L-value en un R-value y habilitar las move semantics.

##### Definición de una Clase con Move Semantics

```cpp
#include <iostream>
#include <utility>  // Para std::move

class MiClase {
public:
    int* data;

    // Constructor normal
    MiClase(int value) : data(new int(value)) {
        std::cout << "Constructor llamado para " << *data << std::endl;
    }

    // Destructor
    ~MiClase() {
        delete data;
        std::cout << "Destructor llamado" << std::endl;
    }

    // Move Constructor
    MiClase(MiClase&& other) noexcept : data(other.data) {
        other.data = nullptr;
        std::cout << "Move Constructor llamado" << std::endl;
    }

    // Move Assignment Operator
    MiClase& operator=(MiClase&& other) noexcept {
        if (this != &other) {
            delete data;
            data = other.data;
            other.data = nullptr;
            std::cout << "Move Assignment Operator llamado" << std::endl;
        }
        return *this;
    }

    void mostrar() const {
        if (data) {
            std::cout << "Valor: " << *data << std::endl;
        } else {
            std::cout << "No hay datos" << std::endl;
        }
    }
};

int main() {
    MiClase obj1(10);
    MiClase obj2 = std::move(obj1);  // std::move convierte 'obj1' en un R-value
    obj2.mostrar();
    obj1.mostrar();  // No hay datos, ya que los datos fueron movidos

    MiClase obj3(20);
    obj3 = std::move(obj2);  // std::move convierte 'obj2' en un R-value
    obj3.mostrar();
    obj2.mostrar();  // No hay datos, ya que los datos fueron movidos

    return 0;
}
```

En este ejemplo:
- `std::move` se utiliza para convertir `obj1` y `obj2` en R-values, permitiendo que se aplique el move constructor y el move assignment operator.

#### ¿Qué Hace `std::move`?

`std::move` no mueve realmente el objeto. En su lugar, simplemente convierte el L-value en un R-value, lo que indica al compilador que puede aplicar las move semantics. La implementación de `std::move` es simple y se define en `<utility>`.

##### Implementación Simplificada de `std::move`

```cpp
namespace std {
    template <typename T>
    typename remove_reference<T>::type&& move(T&& arg) noexcept {
        return static_cast<typename remove_reference<T>::type&&>(arg);
    }
}
```

En esta implementación:
- `std::move` usa `static_cast` para convertir `arg` en un R-value reference.
- `remove_reference<T>::type` asegura que se elimine cualquier referencia, devolviendo un R-value reference.

#### Aplicaciones y Beneficios

Convertir L-values a R-values es crucial en varias situaciones:

1. **Move Semantics:** Permite la transferencia eficiente de recursos en lugar de copiar, mejorando el rendimiento.
2. **Optimización de Recursos:** Reduce la sobrecarga en operaciones de copia para objetos grandes o que gestionan recursos externos como memoria dinámica o archivos.
3. **Interfaces y API Modernas:** Facilita el uso de técnicas avanzadas en el diseño de bibliotecas y aplicaciones.

#### Consideraciones y Buenas Prácticas

1. **Uso Adecuado:** Use `std::move` solo cuando esté seguro de que el objeto no se necesita en su estado original después de la operación de movimiento.
2. **Estado del Objeto:** Después de aplicar `std::move`, el objeto original queda en un estado válido pero indeterminado.
3. **Compatibilidad:** Asegúrese de que las clases y estructuras de datos implementen correctamente el move constructor y el move assignment operator para aprovechar completamente las ventajas de `std::move`.

### Conclusión

La conversión de un L-value a un R-value en C++ mediante `std::move` es una técnica esencial para habilitar las move semantics y optimizar el manejo de recursos. Entender cómo y cuándo usar `std::move` permite a los desarrolladores escribir código más eficiente y moderno, aprovechando al máximo las capacidades de C++ en la gestión de memoria y rendimiento.
### Implicaciones de una Conversión de L-Value a R-Value en C++

La conversión de un L-value a un R-value, principalmente a través de `std::move`, tiene varias implicaciones importantes en términos de semántica del lenguaje, manejo de recursos, y diseño del software. Entender estas implicaciones es crucial para escribir código eficiente y seguro en C++.

#### 1. **Semántica de Movimiento**

La conversión de un L-value a un R-value permite aplicar las move semantics en lugar de las copy semantics. Esto significa que los recursos (como memoria dinámica, archivos, etc.) pueden ser "movidos" de un objeto a otro, en lugar de ser copiados. Este proceso es más eficiente porque evita la sobrecarga de duplicar recursos.

##### Ejemplo: Move Constructor y Move Assignment Operator

```cpp
#include <iostream>
#include <utility>

class MiClase {
public:
    int* data;

    // Constructor normal
    MiClase(int value) : data(new int(value)) {
        std::cout << "Constructor llamado para " << *data << std::endl;
    }

    // Destructor
    ~MiClase() {
        delete data;
        std::cout << "Destructor llamado" << std::endl;
    }

    // Move Constructor
    MiClase(MiClase&& other) noexcept : data(other.data) {
        other.data = nullptr;
        std::cout << "Move Constructor llamado" << std::endl;
    }

    // Move Assignment Operator
    MiClase& operator=(MiClase&& other) noexcept {
        if (this != &other) {
            delete data;
            data = other.data;
            other.data = nullptr;
            std::cout << "Move Assignment Operator llamado" << std::endl;
        }
        return *this;
    }

    void mostrar() const {
        if (data) {
            std::cout << "Valor: " << *data << std::endl;
        } else {
            std::cout << "No hay datos" << std::endl;
        }
    }
};

int main() {
    MiClase obj1(10);
    MiClase obj2 = std::move(obj1);  // Move Constructor llamado
    obj2.mostrar();
    obj1.mostrar();  // No hay datos, ya que los datos fueron movidos

    MiClase obj3(20);
    obj3 = std::move(obj2);  // Move Assignment Operator llamado
    obj3.mostrar();
    obj2.mostrar();  // No hay datos, ya que los datos fueron movidos

    return 0;
}
```

#### 2. **Estado del Objeto Original**

Después de una conversión de L-value a R-value y la consiguiente operación de movimiento, el objeto original se deja en un estado válido pero indeterminado. Es decir, el objeto puede ser destruido, reasignado, o puesto en un estado que no debe ser utilizado hasta que se vuelva a asignar un valor válido.

##### Ejemplo

```cpp
MiClase obj1(10);
MiClase obj2 = std::move(obj1);  // obj1 ahora está en un estado indeterminado
```

En este ejemplo, `obj1` ha transferido sus recursos a `obj2`, y no debe ser utilizado directamente hasta que se le reasigne un nuevo valor.

#### 3. **Optimización de Rendimiento**

Las move semantics permiten optimizar el rendimiento, especialmente en situaciones donde los objetos contienen recursos pesados como memoria dinámica o manejadores de archivo. En lugar de copiar estos recursos, que puede ser costoso, los recursos se transfieren, lo que es mucho más eficiente.

##### Comparación de Copy vs Move

```cpp
#include <vector>

std::vector<int> generarVector() {
    std::vector<int> v = {1, 2, 3, 4, 5};
    return v;  // Devuelve un R-value que puede ser movido en lugar de copiado
}

int main() {
    std::vector<int> vec = generarVector();  // Move semantics optimizan esta operación
    return 0;
}
```

En este ejemplo, `generarVector` devuelve un R-value que se mueve en lugar de copiarse, optimizando la operación.

#### 4. **Diseño de API y Bibliotecas**

Al diseñar APIs y bibliotecas, el uso de move semantics permite definir interfaces que son más eficientes y expresivas. Las funciones pueden aceptar y devolver R-values para transferir la propiedad de los recursos sin costo adicional de copia.

##### Ejemplo de API con Move Semantics

```cpp
#include <vector>
#include <utility>

class Contenedor {
    std::vector<int> datos;

public:
    void setDatos(std::vector<int>&& nuevosDatos) {
        datos = std::move(nuevosDatos);  // Mueve los datos en lugar de copiarlos
    }

    const std::vector<int>& getDatos() const {
        return datos;
    }
};
```

En este ejemplo, `setDatos` acepta un R-value reference, permitiendo que los datos se muevan en lugar de copiarse.

#### 5. **Uso de `std::move`**

`std::move` es una herramienta poderosa pero debe ser usada con cuidado. Convierte un L-value en un R-value, lo que indica que los recursos del objeto pueden ser transferidos. Sin embargo, es responsabilidad del programador asegurarse de que el objeto original no se utilice de manera inapropiada después de la operación de movimiento.

##### Consideraciones al Usar `std::move`

- **Evitar Uso Posterior Inadecuado:** Después de aplicar `std::move`, el objeto original no debe ser utilizado hasta que se le reasigne un nuevo valor.
- **Validación:** Asegúrese de que las clases tienen implementaciones correctas del move constructor y move assignment operator para evitar problemas de manejo de recursos.

### Conclusión

Convertir un L-value a un R-value en C++ mediante `std::move` tiene implicaciones significativas para la gestión de recursos y el rendimiento del software. Las move semantics permiten transferir recursos de manera eficiente, optimizando el rendimiento y reduciendo la sobrecarga. Sin embargo, esta técnica debe ser utilizada con cuidado, asegurando que el objeto original no se utilice indebidamente después de la operación de movimiento. Comprender estas implicaciones es crucial para escribir código C++ moderno y eficiente.
### `std::move` en C++

`std::move` es una función de la biblioteca estándar de C++ que se introdujo en C++11. Esta función es fundamental para habilitar las move semantics (semánticas de movimiento), que permiten la transferencia eficiente de recursos entre objetos. El uso de `std::move` puede mejorar significativamente el rendimiento de un programa al evitar copias innecesarias y optimizar el manejo de recursos.

#### Definición y Uso de `std::move`

`std::move` no realiza un movimiento en sí mismo; en su lugar, convierte un L-value en un R-value, permitiendo que se aplique el move constructor o el move assignment operator en lugar del copy constructor o copy assignment operator.

##### Sintaxis

```cpp
#include <utility>

std::move(obj);  // Convierte 'obj' en un R-value
```

##### Ejemplo Básico

```cpp
#include <iostream>
#include <utility>

class MiClase {
public:
    int* data;

    // Constructor
    MiClase(int value) : data(new int(value)) {
        std::cout << "Constructor llamado para " << *data << std::endl;
    }

    // Destructor
    ~MiClase() {
        delete data;
        std::cout << "Destructor llamado" << std::endl;
    }

    // Move Constructor
    MiClase(MiClase&& other) noexcept : data(other.data) {
        other.data = nullptr;
        std::cout << "Move Constructor llamado" << std::endl;
    }

    // Move Assignment Operator
    MiClase& operator=(MiClase&& other) noexcept {
        if (this != &other) {
            delete data;
            data = other.data;
            other.data = nullptr;
            std::cout << "Move Assignment Operator llamado" << std::endl;
        }
        return *this;
    }

    void mostrar() const {
        if (data) {
            std::cout << "Valor: " << *data << std::endl;
        } else {
            std::cout << "No hay datos" << std::endl;
        }
    }
};

int main() {
    MiClase obj1(10);
    MiClase obj2 = std::move(obj1);  // std::move convierte 'obj1' en un R-value
    obj2.mostrar();
    obj1.mostrar();  // No hay datos, ya que los datos fueron movidos

    MiClase obj3(20);
    obj3 = std::move(obj2);  // std::move convierte 'obj2' en un R-value
    obj3.mostrar();
    obj2.mostrar();  // No hay datos, ya que los datos fueron movidos

    return 0;
}
```

En este ejemplo:
- `std::move` se utiliza para convertir `obj1` y `obj2` en R-values, permitiendo que se apliquen el move constructor y el move assignment operator.

### Beneficios de `std::move`

El uso de `std::move` y las move semantics en C++ conllevan varios beneficios significativos, especialmente en términos de rendimiento y eficiencia en la gestión de recursos.

#### 1. **Optimización de Rendimiento**

El beneficio más evidente de `std::move` es la optimización de rendimiento. Al mover recursos en lugar de copiarlos, se puede evitar el costo de duplicar recursos pesados como memoria dinámica, archivos, o conexiones de red.

##### Ejemplo de Optimización de Rendimiento

```cpp
#include <vector>
#include <iostream>

std::vector<int> generarVector() {
    std::vector<int> v = {1, 2, 3, 4, 5};
    return v;  // Devuelve un R-value que puede ser movido en lugar de copiado
}

int main() {
    std::vector<int> vec = generarVector();  // Move semantics optimizan esta operación
    for (int num : vec) {
        std::cout << num << " ";
    }
    std::cout << std::endl;
    return 0;
}
```

En este ejemplo:
- La función `generarVector` devuelve un R-value que se mueve en lugar de copiarse, mejorando la eficiencia.

#### 2. **Gestión Eficiente de Recursos**

Las move semantics permiten la transferencia eficiente de recursos de un objeto a otro sin la sobrecarga de duplicar esos recursos. Esto es especialmente útil para clases que manejan recursos externos como memoria dinámica, archivos, o sockets de red.

##### Ejemplo de Gestión Eficiente de Recursos

```cpp
#include <iostream>
#include <utility>

class Archivo {
public:
    FILE* file;

    // Constructor
    Archivo(const char* nombre, const char* modo) : file(fopen(nombre, modo)) {
        if (file) {
            std::cout << "Archivo abierto: " << nombre << std::endl;
        } else {
            std::cerr << "Error al abrir el archivo: " << nombre << std::endl;
        }
    }

    // Destructor
    ~Archivo() {
        if (file) {
            fclose(file);
            std::cout << "Archivo cerrado" << std::endl;
        }
    }

    // Move Constructor
    Archivo(Archivo&& other) noexcept : file(other.file) {
        other.file = nullptr;
        std::cout << "Move Constructor llamado" << std::endl;
    }

    // Move Assignment Operator
    Archivo& operator=(Archivo&& other) noexcept {
        if (this != &other) {
            if (file) {
                fclose(file);
            }
            file = other.file;
            other.file = nullptr;
            std::cout << "Move Assignment Operator llamado" << std::endl;
        }
        return *this;
    }

    // Prohibir la copia
    Archivo(const Archivo&) = delete;
    Archivo& operator=(const Archivo&) = delete;
};

int main() {
    Archivo archivo1("example.txt", "w");
    Archivo archivo2 = std::move(archivo1);  // std::move convierte 'archivo1' en un R-value

    // archivo1 no debe usarse después de ser movido
    return 0;
}
```

En este ejemplo:
- La clase `Archivo` gestiona el recurso de un archivo abierto. El uso de move constructor y move assignment operator permite transferir la propiedad del archivo sin duplicar el recurso.

#### 3. **Evitar Copias Costosas**

Para objetos que contienen grandes cantidades de datos o manejan recursos externos, las copias pueden ser costosas en términos de tiempo y memoria. Las move semantics permiten evitar estas copias innecesarias.

##### Ejemplo de Evitar Copias Costosas

```cpp
#include <iostream>
#include <string>

class CadenaGrande {
public:
    std::string* datos;

    CadenaGrande(const std::string& str) : datos(new std::string(str)) {
        std::cout << "Constructor llamado para " << *datos << std::endl;
    }

    ~CadenaGrande() {
        delete datos;
        std::cout << "Destructor llamado" << std::endl;
    }

    // Move Constructor
    CadenaGrande(CadenaGrande&& other) noexcept : datos(other.datos) {
        other.datos = nullptr;
        std::cout << "Move Constructor llamado" << std::endl;
    }

    // Move Assignment Operator
    CadenaGrande& operator=(CadenaGrande&& other) noexcept {
        if (this != &other) {
            delete datos;
            datos = other.datos;
            other.datos = nullptr;
            std::cout << "Move Assignment Operator llamado" << std::endl;
        }
        return *this;
    }
};

int main() {
    CadenaGrande str1("Una cadena muy grande y costosa de copiar");
    CadenaGrande str2 = std::move(str1);  // std::move convierte 'str1' en un R-value

    return 0;
}
```

En este ejemplo:
- `CadenaGrande` evita la costosa operación de copiar grandes cadenas al usar move semantics.

#### 4. **Facilitar el Diseño de APIs y Bibliotecas**

Las move semantics y `std::move` permiten a los desarrolladores diseñar APIs y bibliotecas que son más eficientes y flexibles, proporcionando interfaces que permiten mover recursos en lugar de copiarlos.

### Conclusión

`std::move` es una herramienta poderosa en C++ que permite la conversión de L-values a R-values, habilitando las move semantics para optimizar el rendimiento y la gestión de recursos. Los beneficios de usar `std::move` incluyen una mejor eficiencia de rendimiento, gestión eficiente de recursos, evitación de copias costosas y la capacidad de diseñar APIs y bibliotecas más flexibles y eficientes. Entender y utilizar `std::move` correctamente es esencial para escribir código C++ moderno y eficiente.
### Mover un L-Value en C++ y sus Implicaciones

Mover un L-value en C++ implica convertirlo en un R-value mediante `std::move`, lo que permite aplicar las move semantics para transferir recursos de manera eficiente. Aunque esta técnica ofrece numerosas ventajas, también conlleva importantes implicaciones que deben ser comprendidas y manejadas adecuadamente.

#### ¿Qué Significa Mover un L-Value?

Mover un L-value significa transferir la propiedad de los recursos que el L-value gestiona a otro objeto. Esto se realiza utilizando `std::move`, que convierte un L-value en un R-value. El proceso de mover puede involucrar:
- Transferir punteros a datos dinámicos.
- Nulificar o resetear el objeto original para indicar que ya no posee esos recursos.

##### Ejemplo Básico de Movimiento

```cpp
#include <iostream>
#include <utility>

class MiClase {
public:
    int* data;

    // Constructor normal
    MiClase(int value) : data(new int(value)) {
        std::cout << "Constructor llamado para " << *data << std::endl;
    }

    // Destructor
    ~MiClase() {
        delete data;
        std::cout << "Destructor llamado" << std::endl;
    }

    // Move Constructor
    MiClase(MiClase&& other) noexcept : data(other.data) {
        other.data = nullptr;
        std::cout << "Move Constructor llamado" << std::endl;
    }

    // Move Assignment Operator
    MiClase& operator=(MiClase&& other) noexcept {
        if (this != &other) {
            delete data;
            data = other.data;
            other.data = nullptr;
            std::cout << "Move Assignment Operator llamado" << std::endl;
        }
        return *this;
    }

    void mostrar() const {
        if (data) {
            std::cout << "Valor: " << *data << std::endl;
        } else {
            std::cout << "No hay datos" << std::endl;
        }
    }
};

int main() {
    MiClase obj1(10);
    MiClase obj2 = std::move(obj1);  // std::move convierte 'obj1' en un R-value
    obj2.mostrar();
    obj1.mostrar();  // No hay datos, ya que los datos fueron movidos

    MiClase obj3(20);
    obj3 = std::move(obj2);  // std::move convierte 'obj2' en un R-value
    obj3.mostrar();
    obj2.mostrar();  // No hay datos, ya que los datos fueron movidos

    return 0;
}
```

En este ejemplo:
- `std::move` se utiliza para mover los recursos de `obj1` a `obj2` y de `obj2` a `obj3`.

#### Implicaciones de Mover un L-Value

##### 1. **Estado del Objeto Original**

Después de mover un L-value, el objeto original queda en un estado válido pero indeterminado. Esto significa que el objeto todavía existe y es seguro de destruir, pero no debería ser utilizado hasta que se le reasigne un nuevo valor.

###### Ejemplo

```cpp
MiClase obj1(10);
MiClase obj2 = std::move(obj1);  // obj1 ahora está en un estado indeterminado
```

- `obj1` ha transferido sus recursos a `obj2`, y no debe ser utilizado directamente hasta que se le reasigne un nuevo valor.

##### 2. **Evitar Uso Inadecuado**

Es crucial evitar el uso del objeto original después de que haya sido movido. Usar el objeto original en su estado indeterminado puede llevar a errores difíciles de depurar.

###### Ejemplo Incorrecto

```cpp
MiClase obj1(10);
MiClase obj2 = std::move(obj1);
obj1.mostrar();  // No se debe usar obj1 después de mover sus recursos
```

- `obj1` no debe ser utilizado después de ser movido, ya que su estado es indeterminado.

##### 3. **Implementación Correcta de Move Semantics**

Las clases que utilizan move semantics deben implementar correctamente el move constructor y el move assignment operator para gestionar adecuadamente los recursos.

###### Ejemplo

```cpp
class MiClase {
public:
    int* data;

    MiClase(int value) : data(new int(value)) {}

    ~MiClase() {
        delete data;
    }

    // Move Constructor
    MiClase(MiClase&& other) noexcept : data(other.data) {
        other.data = nullptr;
    }

    // Move Assignment Operator
    MiClase& operator=(MiClase&& other) noexcept {
        if (this != &other) {
            delete data;
            data = other.data;
            other.data = nullptr;
        }
        return *this;
    }

    // Prohibir la copia
    MiClase(const MiClase&) = delete;
    MiClase& operator=(const MiClase&) = delete;
};
```

- Implementar correctamente el move constructor y el move assignment operator es esencial para asegurar la correcta gestión de recursos.

##### 4. **Beneficios de Rendimiento**

Mover recursos en lugar de copiarlos puede mejorar significativamente el rendimiento, especialmente para objetos grandes o que gestionan recursos externos como memoria dinámica, archivos o conexiones de red.

###### Ejemplo de Optimización de Rendimiento

```cpp
#include <vector>

std::vector<int> generarVector() {
    std::vector<int> v = {1, 2, 3, 4, 5};
    return v;  // Devuelve un R-value que puede ser movido en lugar de copiado
}

int main() {
    std::vector<int> vec = generarVector();  // Move semantics optimizan esta operación
    for (int num : vec) {
        std::cout << num << " ";
    }
    std::cout << std::endl;
    return 0;
}
```

- La función `generarVector` devuelve un R-value que se mueve en lugar de copiarse, optimizando la operación.

### Conclusión

Mover un L-value en C++ mediante `std::move` es una técnica poderosa para habilitar las move semantics y mejorar la eficiencia del manejo de recursos. Sin embargo, esta técnica conlleva implicaciones importantes:
- El objeto original queda en un estado válido pero indeterminado.
- Se debe evitar el uso del objeto original después de que haya sido movido.
- Es crucial implementar correctamente el move constructor y el move assignment operator para gestionar los recursos adecuadamente.

Entender y manejar estas implicaciones permite escribir código C++ moderno y eficiente, aprovechando al máximo las capacidades de las move semantics para optimizar el rendimiento y la gestión de recursos.
### Diferencias entre Semántica de Copia y de Movimiento en C++

Las semánticas de copia y de movimiento son dos mecanismos fundamentales para la gestión de recursos en C++. Aunque ambos se utilizan para transferir datos de un objeto a otro, funcionan de manera diferente y tienen implicaciones distintas en términos de eficiencia y uso de recursos. Aquí se describen las diferencias clave entre la semántica de copia y la de movimiento.

#### Semántica de Copia

La semántica de copia implica la creación de una copia completa de los recursos gestionados por un objeto. Esto se realiza mediante el copy constructor y el copy assignment operator.

##### Copy Constructor

El copy constructor se llama cuando se crea un nuevo objeto a partir de otro objeto existente.

```cpp
class MiClase {
public:
    int* data;

    // Constructor
    MiClase(int value) : data(new int(value)) {}

    // Copy Constructor
    MiClase(const MiClase& other) : data(new int(*other.data)) {
        std::cout << "Copy Constructor llamado" << std::endl;
    }
};
```

##### Copy Assignment Operator

El copy assignment operator se llama cuando un objeto existente se asigna a partir de otro objeto existente.

```cpp
class MiClase {
public:
    int* data;

    // Constructor
    MiClase(int value) : data(new int(value)) {}

    // Copy Assignment Operator
    MiClase& operator=(const MiClase& other) {
        if (this != &other) {
            delete data;
            data = new int(*other.data);
            std::cout << "Copy Assignment Operator llamado" << std::endl;
        }
        return *this;
    }
};
```

##### Ejemplo de Semántica de Copia

```cpp
int main() {
    MiClase obj1(10);
    MiClase obj2 = obj1;  // Llama al copy constructor
    MiClase obj3(20);
    obj3 = obj1;          // Llama al copy assignment operator
    return 0;
}
```

En este ejemplo:
- `obj2` se crea a partir de `obj1` utilizando el copy constructor.
- `obj3` se asigna a partir de `obj1` utilizando el copy assignment operator.

#### Semántica de Movimiento

La semántica de movimiento, introducida en C++11, permite transferir recursos de un objeto a otro en lugar de copiarlos. Esto se realiza mediante el move constructor y el move assignment operator.

##### Move Constructor

El move constructor se llama cuando se crea un nuevo objeto transfiriendo recursos desde un objeto existente.

```cpp
class MiClase {
public:
    int* data;

    // Constructor
    MiClase(int value) : data(new int(value)) {}

    // Move Constructor
    MiClase(MiClase&& other) noexcept : data(other.data) {
        other.data = nullptr;
        std::cout << "Move Constructor llamado" << std::endl;
    }
};
```

##### Move Assignment Operator

El move assignment operator se llama cuando un objeto existente se asigna transfiriendo recursos desde otro objeto existente.

```cpp
class MiClase {
public:
    int* data;

    // Constructor
    MiClase(int value) : data(new int(value)) {}

    // Move Assignment Operator
    MiClase& operator=(MiClase&& other) noexcept {
        if (this != &other) {
            delete data;
            data = other.data;
            other.data = nullptr;
            std::cout << "Move Assignment Operator llamado" << std::endl;
        }
        return *this;
    }
};
```

##### Ejemplo de Semántica de Movimiento

```cpp
#include <utility>

int main() {
    MiClase obj1(10);
    MiClase obj2 = std::move(obj1);  // Llama al move constructor
    MiClase obj3(20);
    obj3 = std::move(obj2);          // Llama al move assignment operator
    return 0;
}
```

En este ejemplo:
- `obj2` se crea a partir de `obj1` utilizando el move constructor.
- `obj3` se asigna a partir de `obj2` utilizando el move assignment operator.

### Diferencias Clave

#### 1. **Eficiencia**

- **Copia:** Implica duplicar recursos, lo cual puede ser costoso en términos de tiempo y memoria, especialmente para objetos grandes o que gestionan recursos externos.
- **Movimiento:** Transfiere recursos en lugar de duplicarlos, lo que es más eficiente y evita la sobrecarga de copia.

#### 2. **Estado del Objeto Original**

- **Copia:** El objeto original permanece inalterado y sigue siendo completamente funcional después de la copia.
- **Movimiento:** El objeto original queda en un estado válido pero indeterminado después del movimiento y no debe ser utilizado hasta que se le reasigne un nuevo valor.

#### 3. **Uso de Recursos**

- **Copia:** Requiere asignar memoria adicional y otros recursos necesarios para mantener la copia.
- **Movimiento:** No requiere memoria adicional significativa ya que los recursos simplemente se transfieren.

#### 4. **Implementación**

- **Copia:** Requiere la implementación de un copy constructor y un copy assignment operator.
- **Movimiento:** Requiere la implementación de un move constructor y un move assignment operator.

#### 5. **Ejemplo Comparativo**

##### Semántica de Copia

```cpp
class MiClase {
public:
    int* data;

    MiClase(int value) : data(new int(value)) {}

    MiClase(const MiClase& other) : data(new int(*other.data)) {
        std::cout << "Copy Constructor llamado" << std::endl;
    }

    MiClase& operator=(const MiClase& other) {
        if (this != &other) {
            delete data;
            data = new int(*other.data);
            std::cout << "Copy Assignment Operator llamado" << std::endl;
        }
        return *this;
    }

    ~MiClase() {
        delete data;
    }
};
```

##### Semántica de Movimiento

```cpp
class MiClase {
public:
    int* data;

    MiClase(int value) : data(new int(value)) {}

    MiClase(MiClase&& other) noexcept : data(other.data) {
        other.data = nullptr;
        std::cout << "Move Constructor llamado" << std::endl;
    }

    MiClase& operator=(MiClase&& other) noexcept {
        if (this != &other) {
            delete data;
            data = other.data;
            other.data = nullptr;
            std::cout << "Move Assignment Operator llamado" << std::endl;
        }
        return *this;
    }

    ~MiClase() {
        delete data;
    }
};
```

### Conclusión

La semántica de copia y la de movimiento en C++ ofrecen diferentes mecanismos para transferir datos entre objetos. La semántica de copia implica duplicar recursos, lo cual puede ser costoso en términos de rendimiento. En contraste, la semántica de movimiento permite transferir recursos de manera eficiente, evitando la sobrecarga de copia y mejorando el rendimiento general del programa. Comprender y utilizar adecuadamente estas semánticas es crucial para escribir código C++ moderno y eficiente.
<---FILES--->
Características de L-Value
Características de L-Value Result
Ejemplos de L-Value
Ejemplos de L-Value Result
R-Value
R-Value Result
Ejemplos de R-Value
Ejemplos de R-Value Result
Move Constructor y Move Assignment Operator
Move Constructor y Move Assignment Operator Result
Move Constructor
Move Constructor Result
Características de L-Value
Características de L-Value Result
Ejemplos de L-Value
Ejemplos de L-Value Result
R-Value
R-Value Result
Ejemplos de R-Value
Ejemplos de R-Value Result
Move Constructor y Move Assignment Operator
Move Constructor y Move Assignment Operator Result
Move Constructor
Move Constructor Result
Ejemplos Prácticos
Ejemplos Prácticos Result
Sintaxis
Sintaxis Result
Ejemplo con R-Value References
Ejemplo con R-Value References Result
Características de L-Value
Características de L-Value Result
Ejemplos de L-Value
Ejemplos de L-Value Result
R-Value
R-Value Result
Ejemplos de R-Value
Ejemplos de R-Value Result
Move Constructor y Move Assignment Operator
Move Constructor y Move Assignment Operator Result
Move Constructor
Move Constructor Result
Ejemplos Prácticos
Ejemplos Prácticos Result
Sintaxis
Sintaxis Result
Ejemplo con R-Value References
Ejemplo con R-Value References Result
Ejemplo de R-Value References
Ejemplo de R-Value References Result
Ejemplo de Sobrecarga de Funciones con L-Values y R-Values
Ejemplo de Sobrecarga de Funciones con L-Values y R-Values Result
Características de L-Value
Características de L-Value Result
Ejemplos de L-Value
Ejemplos de L-Value Result
R-Value
R-Value Result
Ejemplos de R-Value
Ejemplos de R-Value Result
Move Constructor y Move Assignment Operator
Move Constructor y Move Assignment Operator Result
Move Constructor
Move Constructor Result
Ejemplos Prácticos
Ejemplos Prácticos Result
Sintaxis
Sintaxis Result
Ejemplo con R-Value References
Ejemplo con R-Value References Result
Ejemplo de R-Value References
Ejemplo de R-Value References Result
Ejemplo de Sobrecarga de Funciones con L-Values y R-Values
Ejemplo de Sobrecarga de Funciones con L-Values y R-Values Result
Asignación a una Variable
Asignación a una Variable Result
Paso como Argumentos a Funciones
Paso como Argumentos a Funciones Result
Inicialización de Variables
Inicialización de Variables Result
Uso en Expresiones y Operadores
Uso en Expresiones y Operadores Result
Uso con R-Value References
Uso con R-Value References Result
Características de L-Value
Características de L-Value Result
Ejemplos de L-Value
Ejemplos de L-Value Result
R-Value
R-Value Result
Ejemplos de R-Value
Ejemplos de R-Value Result
Move Constructor y Move Assignment Operator
Move Constructor y Move Assignment Operator Result
Move Constructor
Move Constructor Result
Ejemplos Prácticos
Ejemplos Prácticos Result
Sintaxis
Sintaxis Result
Ejemplo con R-Value References
Ejemplo con R-Value References Result
Ejemplo de R-Value References
Ejemplo de R-Value References Result
Ejemplo de Sobrecarga de Funciones con L-Values y R-Values
Ejemplo de Sobrecarga de Funciones con L-Values y R-Values Result
Asignación a una Variable
Asignación a una Variable Result
Paso como Argumentos a Funciones
Paso como Argumentos a Funciones Result
Inicialización de Variables
Inicialización de Variables Result
Uso en Expresiones y Operadores
Uso en Expresiones y Operadores Result
Uso con R-Value References
Uso con R-Value References Result
Definición de una Clase con Move Semantics
Definición de una Clase con Move Semantics Result
Implementación Simplificada de `std::move`
Implementación Simplificada de `std::move` Result
Características de L-Value
Características de L-Value Result
Ejemplos de L-Value
Ejemplos de L-Value Result
R-Value
R-Value Result
Ejemplos de R-Value
Ejemplos de R-Value Result
Move Constructor y Move Assignment Operator
Move Constructor y Move Assignment Operator Result
Move Constructor
Move Constructor Result
Ejemplos Prácticos
Ejemplos Prácticos Result
Sintaxis
Sintaxis Result
Ejemplo con R-Value References
Ejemplo con R-Value References Result
Ejemplo de R-Value References
Ejemplo de R-Value References Result
Ejemplo de Sobrecarga de Funciones con L-Values y R-Values
Ejemplo de Sobrecarga de Funciones con L-Values y R-Values Result
Asignación a una Variable
Asignación a una Variable Result
Paso como Argumentos a Funciones
Paso como Argumentos a Funciones Result
Inicialización de Variables
Inicialización de Variables Result
Uso en Expresiones y Operadores
Uso en Expresiones y Operadores Result
Uso con R-Value References
Uso con R-Value References Result
Definición de una Clase con Move Semantics
Definición de una Clase con Move Semantics Result
Implementación Simplificada de `std::move`
Implementación Simplificada de `std::move` Result
Ejemplo: Move Constructor y Move Assignment Operator
Ejemplo: Move Constructor y Move Assignment Operator Result
Ejemplo
Ejemplo Result
Comparación de Copy vs Move
Comparación de Copy vs Move Result
Ejemplo de API con Move Semantics
Ejemplo de API con Move Semantics Result
Consideraciones al Usar `std::move`
Consideraciones al Usar `std::move` Result
Características de L-Value
Características de L-Value Result
Ejemplos de L-Value
Ejemplos de L-Value Result
R-Value
R-Value Result
Ejemplos de R-Value
Ejemplos de R-Value Result
Move Constructor y Move Assignment Operator
Move Constructor y Move Assignment Operator Result
Move Constructor
Move Constructor Result
Ejemplos Prácticos
Ejemplos Prácticos Result
Sintaxis
Sintaxis Result
Ejemplo con R-Value References
Ejemplo con R-Value References Result
Ejemplo de R-Value References
Ejemplo de R-Value References Result
Ejemplo de Sobrecarga de Funciones con L-Values y R-Values
Ejemplo de Sobrecarga de Funciones con L-Values y R-Values Result
Asignación a una Variable
Asignación a una Variable Result
Paso como Argumentos a Funciones
Paso como Argumentos a Funciones Result
Inicialización de Variables
Inicialización de Variables Result
Uso en Expresiones y Operadores
Uso en Expresiones y Operadores Result
Uso con R-Value References
Uso con R-Value References Result
Definición de una Clase con Move Semantics
Definición de una Clase con Move Semantics Result
Implementación Simplificada de `std::move`
Implementación Simplificada de `std::move` Result
Ejemplo: Move Constructor y Move Assignment Operator
Ejemplo: Move Constructor y Move Assignment Operator Result
Ejemplo
Ejemplo Result
Comparación de Copy vs Move
Comparación de Copy vs Move Result
Ejemplo de API con Move Semantics
Ejemplo de API con Move Semantics Result
Consideraciones al Usar `std::move`
Consideraciones al Usar `std::move` Result
Ejemplo Básico
Ejemplo Básico Result
Ejemplo de Optimización de Rendimiento
Ejemplo de Optimización de Rendimiento Result
Ejemplo de Gestión Eficiente de Recursos
Ejemplo de Gestión Eficiente de Recursos Result
Ejemplo de Evitar Copias Costosas
Ejemplo de Evitar Copias Costosas Result
Características de L-Value
Características de L-Value Result
Ejemplos de L-Value
Ejemplos de L-Value Result
R-Value
R-Value Result
Ejemplos de R-Value
Ejemplos de R-Value Result
Move Constructor y Move Assignment Operator
Move Constructor y Move Assignment Operator Result
Move Constructor
Move Constructor Result
Ejemplos Prácticos
Ejemplos Prácticos Result
Sintaxis
Sintaxis Result
Ejemplo con R-Value References
Ejemplo con R-Value References Result
Ejemplo de R-Value References
Ejemplo de R-Value References Result
Ejemplo de Sobrecarga de Funciones con L-Values y R-Values
Ejemplo de Sobrecarga de Funciones con L-Values y R-Values Result
Asignación a una Variable
Asignación a una Variable Result
Paso como Argumentos a Funciones
Paso como Argumentos a Funciones Result
Inicialización de Variables
Inicialización de Variables Result
Uso en Expresiones y Operadores
Uso en Expresiones y Operadores Result
Uso con R-Value References
Uso con R-Value References Result
Definición de una Clase con Move Semantics
Definición de una Clase con Move Semantics Result
Implementación Simplificada de `std::move`
Implementación Simplificada de `std::move` Result
Ejemplo: Move Constructor y Move Assignment Operator
Ejemplo: Move Constructor y Move Assignment Operator Result
Ejemplo
Ejemplo Result
Comparación de Copy vs Move
Comparación de Copy vs Move Result
Ejemplo de API con Move Semantics
Ejemplo de API con Move Semantics Result
Consideraciones al Usar `std::move`
Consideraciones al Usar `std::move` Result
Ejemplo Básico
Ejemplo Básico Result
Ejemplo de Optimización de Rendimiento
Ejemplo de Optimización de Rendimiento Result
Ejemplo de Gestión Eficiente de Recursos
Ejemplo de Gestión Eficiente de Recursos Result
Ejemplo de Evitar Copias Costosas
Ejemplo de Evitar Copias Costosas Result
Ejemplo Básico de Movimiento
Ejemplo Básico de Movimiento Result
1. **Estado del Objeto Original**
1. **Estado del Objeto Original** Result
2. **Evitar Uso Inadecuado**
2. **Evitar Uso Inadecuado** Result
Ejemplo Incorrecto
Ejemplo Incorrecto Result
3. **Implementación Correcta de Move Semantics**
3. **Implementación Correcta de Move Semantics** Result
4. **Beneficios de Rendimiento**
4. **Beneficios de Rendimiento** Result
Características de L-Value
Características de L-Value Result
Ejemplos de L-Value
Ejemplos de L-Value Result
R-Value
R-Value Result
Ejemplos de R-Value
Ejemplos de R-Value Result
Move Constructor y Move Assignment Operator
Move Constructor y Move Assignment Operator Result
Move Constructor
Move Constructor Result
Ejemplos Prácticos
Ejemplos Prácticos Result
Sintaxis
Sintaxis Result
Ejemplo con R-Value References
Ejemplo con R-Value References Result
Ejemplo de R-Value References
Ejemplo de R-Value References Result
Ejemplo de Sobrecarga de Funciones con L-Values y R-Values
Ejemplo de Sobrecarga de Funciones con L-Values y R-Values Result
Asignación a una Variable
Asignación a una Variable Result
Paso como Argumentos a Funciones
Paso como Argumentos a Funciones Result
Inicialización de Variables
Inicialización de Variables Result
Uso en Expresiones y Operadores
Uso en Expresiones y Operadores Result
Uso con R-Value References
Uso con R-Value References Result
Definición de una Clase con Move Semantics
Definición de una Clase con Move Semantics Result
Implementación Simplificada de `std::move`
Implementación Simplificada de `std::move` Result
Ejemplo: Move Constructor y Move Assignment Operator
Ejemplo: Move Constructor y Move Assignment Operator Result
Ejemplo
Ejemplo Result
Comparación de Copy vs Move
Comparación de Copy vs Move Result
Ejemplo de API con Move Semantics
Ejemplo de API con Move Semantics Result
Consideraciones al Usar `std::move`
Consideraciones al Usar `std::move` Result
Ejemplo Básico
Ejemplo Básico Result
Ejemplo de Optimización de Rendimiento
Ejemplo de Optimización de Rendimiento Result
Ejemplo de Gestión Eficiente de Recursos
Ejemplo de Gestión Eficiente de Recursos Result
Ejemplo de Evitar Copias Costosas
Ejemplo de Evitar Copias Costosas Result
Ejemplo Básico de Movimiento
Ejemplo Básico de Movimiento Result
1. **Estado del Objeto Original**
1. **Estado del Objeto Original** Result
2. **Evitar Uso Inadecuado**
2. **Evitar Uso Inadecuado** Result
Ejemplo Incorrecto
Ejemplo Incorrecto Result
3. **Implementación Correcta de Move Semantics**
3. **Implementación Correcta de Move Semantics** Result
4. **Beneficios de Rendimiento**
4. **Beneficios de Rendimiento** Result
Copy Constructor
Copy Constructor Result
Copy Assignment Operator
Copy Assignment Operator Result
Ejemplo de Semántica de Copia
Ejemplo de Semántica de Copia Result
Move Assignment Operator
Move Assignment Operator Result
Ejemplo de Semántica de Movimiento
Ejemplo de Semántica de Movimiento Result
Semántica de Copia
Semántica de Copia Result
Semántica de Movimiento
Semántica de Movimiento Result
<---Características de L-Value--->
<---Características de L-Value Result--->
<---Ejemplos de L-Value--->
```cpp
int x = 5;         // 'x' es un L-value
int* p = &x;       // 'p' es un L-value que contiene la dirección de 'x'
x = 10;            // 'x' puede estar en el lado izquierdo de la asignación
*p = 20;           // '*p' es un L-value que puede estar en el lado izquierdo de la asignación

int& ref = x;      // 'ref' es un L-value reference a 'x'
ref = 30;          // 'ref' puede estar en el lado izquierdo de la asignación
<---Ejemplos de L-Value Result--->
<---R-Value--->
<---R-Value Result--->
<---Ejemplos de R-Value--->
```cpp
int y = 5;         // '5' es un R-value
int z = y + 3;     // 'y + 3' es un R-value
<---Ejemplos de R-Value Result--->
<---Move Constructor y Move Assignment Operator--->
<---Move Constructor y Move Assignment Operator Result--->
<---Move Constructor--->
```cpp
#include <iostream>
#include <utility>

class MiClase {
private:
    int* data;

public:
    // Constructor
    MiClase(int value) : data(new int(value)) {
        std::cout << "Constructor llamado para " << *data << std::endl;
    }

    // Destructor
    ~MiClase() {
        delete data;
        std::cout << "Destructor llamado" << std::endl;
    }

    // Move Constructor
    MiClase(MiClase&& other) noexcept : data(other.data) {
        other.data = nullptr;
        std::cout << "Move Constructor llamado" << std::endl;
    }

    // Move Assignment Operator
    MiClase& operator=(MiClase&& other) noexcept {
        if (this != &other) {
            delete data;
            data = other.data;
            other.data = nullptr;
            std::cout << "Move Assignment Operator llamado" << std::endl;
        }
        return *this;
    }

    void mostrar() const {
        if (data) {
            std::cout << "Valor: " << *data << std::endl;
        } else {
            std::cout << "No hay datos" << std::endl;
        }
    }
};

int main() {
    MiClase obj1(10);
    MiClase obj2 = std::move(obj1);  // Move Constructor llamado
    obj2.mostrar();
    obj1.mostrar();  // No hay datos, ya que los datos fueron movidos

    MiClase obj3(20);
    obj3 = std::move(obj2);  // Move Assignment Operator llamado
    obj3.mostrar();
    obj2.mostrar();  // No hay datos, ya que los datos fueron movidos

    return 0;
}
<---Move Constructor Result--->
<---Características de L-Value--->
<---Características de L-Value Result--->
<---Ejemplos de L-Value--->
```cpp
int x = 5;         // 'x' es un L-value
int* p = &x;       // 'p' es un L-value que contiene la dirección de 'x'
x = 10;            // 'x' puede estar en el lado izquierdo de la asignación
*p = 20;           // '*p' es un L-value que puede estar en el lado izquierdo de la asignación

int& ref = x;      // 'ref' es un L-value reference a 'x'
ref = 30;          // 'ref' puede estar en el lado izquierdo de la asignación
<---Ejemplos de L-Value Result--->
<---R-Value--->
<---R-Value Result--->
<---Ejemplos de R-Value--->
```cpp
int y = 5;         // '5' es un R-value
int z = y + 3;     // 'y + 3' es un R-value
<---Ejemplos de R-Value Result--->
<---Move Constructor y Move Assignment Operator--->
<---Move Constructor y Move Assignment Operator Result--->
<---Move Constructor--->
```cpp
#include <iostream>
#include <utility>

class MiClase {
private:
    int* data;

public:
    // Constructor
    MiClase(int value) : data(new int(value)) {
        std::cout << "Constructor llamado para " << *data << std::endl;
    }

    // Destructor
    ~MiClase() {
        delete data;
        std::cout << "Destructor llamado" << std::endl;
    }

    // Move Constructor
    MiClase(MiClase&& other) noexcept : data(other.data) {
        other.data = nullptr;
        std::cout << "Move Constructor llamado" << std::endl;
    }

    // Move Assignment Operator
    MiClase& operator=(MiClase&& other) noexcept {
        if (this != &other) {
            delete data;
            data = other.data;
            other.data = nullptr;
            std::cout << "Move Assignment Operator llamado" << std::endl;
        }
        return *this;
    }

    void mostrar() const {
        if (data) {
            std::cout << "Valor: " << *data << std::endl;
        } else {
            std::cout << "No hay datos" << std::endl;
        }
    }
};

int main() {
    MiClase obj1(10);
    MiClase obj2 = std::move(obj1);  // Move Constructor llamado
    obj2.mostrar();
    obj1.mostrar();  // No hay datos, ya que los datos fueron movidos

    MiClase obj3(20);
    obj3 = std::move(obj2);  // Move Assignment Operator llamado
    obj3.mostrar();
    obj2.mostrar();  // No hay datos, ya que los datos fueron movidos

    return 0;
}
<---Move Constructor Result--->
<---Ejemplos Prácticos--->
```cpp
int x = 5;         // '5' es un R-value
int y = x + 2;     // 'x + 2' es un R-value

std::string s1 = "hello";        // "hello" es un R-value
std::string s2 = s1 + " world";  // 's1 + " world"' es un R-value
<---Ejemplos Prácticos Result--->
<---Sintaxis--->
```cpp
int&& rvalue_ref = 10;  // rvalue_ref es una referencia a un R-value
<---Sintaxis Result--->
<---Ejemplo con R-Value References--->
```cpp
#include <iostream>

class MiClase {
public:
    int* data;

    // Constructor normal
    MiClase(int value) : data(new int(value)) {
        std::cout << "Constructor llamado para " << *data << std::endl;
    }

    // Destructor
    ~MiClase() {
        delete data;
        std::cout << "Destructor llamado" << std::endl;
    }

    // Move Constructor
    MiClase(MiClase&& other) noexcept : data(other.data) {
        other.data = nullptr;
        std::cout << "Move Constructor llamado" << std::endl;
    }

    // Move Assignment Operator
    MiClase& operator=(MiClase&& other) noexcept {
        if (this != &other) {
            delete data;
            data = other.data;
            other.data = nullptr;
            std::cout << "Move Assignment Operator llamado" << std::endl;
        }
        return *this;
    }

    void mostrar() const {
        if (data) {
            std::cout << "Valor: " << *data << std::endl;
        } else {
            std::cout << "No hay datos" << std::endl;
        }
    }
};

int main() {
    MiClase obj1(10);
    MiClase obj2 = std::move(obj1);  // Move Constructor llamado
    obj2.mostrar();
    obj1.mostrar();  // No hay datos, ya que los datos fueron movidos

    MiClase obj3(20);
    obj3 = std::move(obj2);  // Move Assignment Operator llamado
    obj3.mostrar();
    obj2.mostrar();  // No hay datos, ya que los datos fueron movidos

    return 0;
}
<---Ejemplo con R-Value References Result--->
<---Características de L-Value--->
<---Características de L-Value Result--->
<---Ejemplos de L-Value--->
```cpp
int x = 5;         // 'x' es un L-value
int* p = &x;       // 'p' es un L-value que contiene la dirección de 'x'
x = 10;            // 'x' puede estar en el lado izquierdo de la asignación
*p = 20;           // '*p' es un L-value que puede estar en el lado izquierdo de la asignación

int& ref = x;      // 'ref' es un L-value reference a 'x'
ref = 30;          // 'ref' puede estar en el lado izquierdo de la asignación
<---Ejemplos de L-Value Result--->
<---R-Value--->
<---R-Value Result--->
<---Ejemplos de R-Value--->
```cpp
int y = 5;         // '5' es un R-value
int z = y + 3;     // 'y + 3' es un R-value
<---Ejemplos de R-Value Result--->
<---Move Constructor y Move Assignment Operator--->
<---Move Constructor y Move Assignment Operator Result--->
<---Move Constructor--->
```cpp
#include <iostream>
#include <utility>

class MiClase {
private:
    int* data;

public:
    // Constructor
    MiClase(int value) : data(new int(value)) {
        std::cout << "Constructor llamado para " << *data << std::endl;
    }

    // Destructor
    ~MiClase() {
        delete data;
        std::cout << "Destructor llamado" << std::endl;
    }

    // Move Constructor
    MiClase(MiClase&& other) noexcept : data(other.data) {
        other.data = nullptr;
        std::cout << "Move Constructor llamado" << std::endl;
    }

    // Move Assignment Operator
    MiClase& operator=(MiClase&& other) noexcept {
        if (this != &other) {
            delete data;
            data = other.data;
            other.data = nullptr;
            std::cout << "Move Assignment Operator llamado" << std::endl;
        }
        return *this;
    }

    void mostrar() const {
        if (data) {
            std::cout << "Valor: " << *data << std::endl;
        } else {
            std::cout << "No hay datos" << std::endl;
        }
    }
};

int main() {
    MiClase obj1(10);
    MiClase obj2 = std::move(obj1);  // Move Constructor llamado
    obj2.mostrar();
    obj1.mostrar();  // No hay datos, ya que los datos fueron movidos

    MiClase obj3(20);
    obj3 = std::move(obj2);  // Move Assignment Operator llamado
    obj3.mostrar();
    obj2.mostrar();  // No hay datos, ya que los datos fueron movidos

    return 0;
}
<---Move Constructor Result--->
<---Ejemplos Prácticos--->
```cpp
#include <iostream>

int main() {
    // Literales
    int x = 5;         // '5' es un R-value
    double y = 3.14;   // '3.14' es un R-value

    // Resultados de Expresiones
    int z = x + 2;     // 'x + 2' es un R-value

    // Llamadas a Funciones que Devuelven R-Values
    std::string s1 = "hello";          // "hello" es un R-value
    std::string s2 = s1 + " world";    // 's1 + " world"' es un R-value

    // Mostrando los valores
    std::cout << "x: " << x << std::endl;
    std::cout << "y: " << y << std::endl;
    std::cout << "z: " << z << std::endl;
    std::cout << "s1: " << s1 << std::endl;
    std::cout << "s2: " << s2 << std::endl;

    return 0;
}
<---Ejemplos Prácticos Result--->
<---Sintaxis--->
```cpp
int&& rvalue_ref = 10;  // rvalue_ref es una referencia a un R-value
<---Sintaxis Result--->
<---Ejemplo con R-Value References--->
```cpp
#include <iostream>

class MiClase {
public:
    int* data;

    // Constructor normal
    MiClase(int value) : data(new int(value)) {
        std::cout << "Constructor llamado para " << *data << std::endl;
    }

    // Destructor
    ~MiClase() {
        delete data;
        std::cout << "Destructor llamado" << std::endl;
    }

    // Move Constructor
    MiClase(MiClase&& other) noexcept : data(other.data) {
        other.data = nullptr;
        std::cout << "Move Constructor llamado" << std::endl;
    }

    // Move Assignment Operator
    MiClase& operator=(MiClase&& other) noexcept {
        if (this != &other) {
            delete data;
            data = other.data;
            other.data = nullptr;
            std::cout << "Move Assignment Operator llamado" << std::endl;
        }
        return *this;
    }

    void mostrar() const {
        if (data) {
            std::cout << "Valor: " << *data << std::endl;
        } else {
            std::cout << "No hay datos" << std::endl;
        }
    }
};

int main() {
    MiClase obj1(10);
    MiClase obj2 = std::move(obj1);  // Move Constructor llamado
    obj2.mostrar();
    obj1.mostrar();  // No hay datos, ya que los datos fueron movidos

    MiClase obj3(20);
    obj3 = std::move(obj2);  // Move Assignment Operator llamado
    obj3.mostrar();
    obj2.mostrar();  // No hay datos, ya que los datos fueron movidos

    return 0;
}
<---Ejemplo con R-Value References Result--->
<---Ejemplo de R-Value References--->
```cpp
#include <iostream>

class MiClase {
public:
    int* data;

    // Constructor normal
    MiClase(int value) : data(new int(value)) {
        std::cout << "Constructor llamado para " << *data << std::endl;
    }

    // Destructor
    ~MiClase() {
        delete data;
        std::cout << "Destructor llamado" << std::endl;
    }

    // Move Constructor
    MiClase(MiClase&& other) noexcept : data(other.data) {
        other.data = nullptr;
        std::cout << "Move Constructor llamado" << std::endl;
    }

    // Move Assignment Operator
    MiClase& operator=(MiClase&& other) noexcept {
        if (this != &other) {
            delete data;
            data = other.data;
            other.data = nullptr;
            std::cout << "Move Assignment Operator llamado" << std::endl;
        }
        return *this;
    }

    void mostrar() const {
        if (data) {
            std::cout << "Valor: " << *data << std::endl;
        } else {
            std::cout << "No hay datos" << std::endl;
        }
    }
};

int main() {
    MiClase obj1(10);
    MiClase obj2 = std::move(obj1);  // Move Constructor llamado
    obj2.mostrar();
    obj1.mostrar();  // No hay datos, ya que los datos fueron movidos

    MiClase obj3(20);
    obj3 = std::move(obj2);  // Move Assignment Operator llamado
    obj3.mostrar();
    obj2.mostrar();  // No hay datos, ya que los datos fueron movidos

    return 0;
}
<---Ejemplo de R-Value References Result--->
<---Ejemplo de Sobrecarga de Funciones con L-Values y R-Values--->
```cpp
#include <iostream>

void procesar(int& x) {
    std::cout << "L-value reference: " << x << std::endl;
}

void procesar(int&& x) {
    std::cout << "R-value reference: " << x << std::endl;
}

int main() {
    int a = 5;
    procesar(a);        // Llama a la versión de L-value reference
    procesar(10);       // Llama a la versión de R-value reference
    procesar(a + 3);    // Llama a la versión de R-value reference

    return 0;
}
<---Ejemplo de Sobrecarga de Funciones con L-Values y R-Values Result--->
<---Características de L-Value--->
<---Características de L-Value Result--->
<---Ejemplos de L-Value--->
```cpp
int x = 5;         // 'x' es un L-value
int* p = &x;       // 'p' es un L-value que contiene la dirección de 'x'
x = 10;            // 'x' puede estar en el lado izquierdo de la asignación
*p = 20;           // '*p' es un L-value que puede estar en el lado izquierdo de la asignación

int& ref = x;      // 'ref' es un L-value reference a 'x'
ref = 30;          // 'ref' puede estar en el lado izquierdo de la asignación
<---Ejemplos de L-Value Result--->
<---R-Value--->
<---R-Value Result--->
<---Ejemplos de R-Value--->
```cpp
int y = 5;         // '5' es un R-value
int z = y + 3;     // 'y + 3' es un R-value
<---Ejemplos de R-Value Result--->
<---Move Constructor y Move Assignment Operator--->
<---Move Constructor y Move Assignment Operator Result--->
<---Move Constructor--->
```cpp
#include <iostream>
#include <utility>

class MiClase {
private:
    int* data;

public:
    // Constructor
    MiClase(int value) : data(new int(value)) {
        std::cout << "Constructor llamado para " << *data << std::endl;
    }

    // Destructor
    ~MiClase() {
        delete data;
        std::cout << "Destructor llamado" << std::endl;
    }

    // Move Constructor
    MiClase(MiClase&& other) noexcept : data(other.data) {
        other.data = nullptr;
        std::cout << "Move Constructor llamado" << std::endl;
    }

    // Move Assignment Operator
    MiClase& operator=(MiClase&& other) noexcept {
        if (this != &other) {
            delete data;
            data = other.data;
            other.data = nullptr;
            std::cout << "Move Assignment Operator llamado" << std::endl;
        }
        return *this;
    }

    void mostrar() const {
        if (data) {
            std::cout << "Valor: " << *data << std::endl;
        } else {
            std::cout << "No hay datos" << std::endl;
        }
    }
};

int main() {
    MiClase obj1(10);
    MiClase obj2 = std::move(obj1);  // Move Constructor llamado
    obj2.mostrar();
    obj1.mostrar();  // No hay datos, ya que los datos fueron movidos

    MiClase obj3(20);
    obj3 = std::move(obj2);  // Move Assignment Operator llamado
    obj3.mostrar();
    obj2.mostrar();  // No hay datos, ya que los datos fueron movidos

    return 0;
}
<---Move Constructor Result--->
<---Ejemplos Prácticos--->
```cpp
#include <iostream>

int main() {
    // Literales
    int x = 5;         // '5' es un R-value
    double y = 3.14;   // '3.14' es un R-value

    // Resultados de Expresiones
    int z = x + 2;     // 'x + 2' es un R-value

    // Llamadas a Funciones que Devuelven R-Values
    std::string s1 = "hello";          // "hello" es un R-value
    std::string s2 = s1 + " world";    // 's1 + " world"' es un R-value

    // Mostrando los valores
    std::cout << "x: " << x << std::endl;
    std::cout << "y: " << y << std::endl;
    std::cout << "z: " << z << std::endl;
    std::cout << "s1: " << s1 << std::endl;
    std::cout << "s2: " << s2 << std::endl;

    return 0;
}
<---Ejemplos Prácticos Result--->
<---Sintaxis--->
```cpp
int&& rvalue_ref = 10;  // rvalue_ref es una referencia a un R-value
<---Sintaxis Result--->
<---Ejemplo con R-Value References--->
```cpp
#include <iostream>

class MiClase {
public:
    int* data;

    // Constructor normal
    MiClase(int value) : data(new int(value)) {
        std::cout << "Constructor llamado para " << *data << std::endl;
    }

    // Destructor
    ~MiClase() {
        delete data;
        std::cout << "Destructor llamado" << std::endl;
    }

    // Move Constructor
    MiClase(MiClase&& other) noexcept : data(other.data) {
        other.data = nullptr;
        std::cout << "Move Constructor llamado" << std::endl;
    }

    // Move Assignment Operator
    MiClase& operator=(MiClase&& other) noexcept {
        if (this != &other) {
            delete data;
            data = other.data;
            other.data = nullptr;
            std::cout << "Move Assignment Operator llamado" << std::endl;
        }
        return *this;
    }

    void mostrar() const {
        if (data) {
            std::cout << "Valor: " << *data << std::endl;
        } else {
            std::cout << "No hay datos" << std::endl;
        }
    }
};

int main() {
    MiClase obj1(10);
    MiClase obj2 = std::move(obj1);  // Move Constructor llamado
    obj2.mostrar();
    obj1.mostrar();  // No hay datos, ya que los datos fueron movidos

    MiClase obj3(20);
    obj3 = std::move(obj2);  // Move Assignment Operator llamado
    obj3.mostrar();
    obj2.mostrar();  // No hay datos, ya que los datos fueron movidos

    return 0;
}
<---Ejemplo con R-Value References Result--->
<---Ejemplo de R-Value References--->
```cpp
#include <iostream>

class MiClase {
public:
    int* data;

    // Constructor normal
    MiClase(int value) : data(new int(value)) {
        std::cout << "Constructor llamado para " << *data << std::endl;
    }

    // Destructor
    ~MiClase() {
        delete data;
        std::cout << "Destructor llamado" << std::endl;
    }

    // Move Constructor
    MiClase(MiClase&& other) noexcept : data(other.data) {
        other.data = nullptr;
        std::cout << "Move Constructor llamado" << std::endl;
    }

    // Move Assignment Operator
    MiClase& operator=(MiClase&& other) noexcept {
        if (this != &other) {
            delete data;
            data = other.data;
            other.data = nullptr;
            std::cout << "Move Assignment Operator llamado" << std::endl;
        }
        return *this;
    }

    void mostrar() const {
        if (data) {
            std::cout << "Valor: " << *data << std::endl;
        } else {
            std::cout << "No hay datos" << std::endl;
        }
    }
};

int main() {
    MiClase obj1(10);
    MiClase obj2 = std::move(obj1);  // Move Constructor llamado
    obj2.mostrar();
    obj1.mostrar();  // No hay datos, ya que los datos fueron movidos

    MiClase obj3(20);
    obj3 = std::move(obj2);  // Move Assignment Operator llamado
    obj3.mostrar();
    obj2.mostrar();  // No hay datos, ya que los datos fueron movidos

    return 0;
}
<---Ejemplo de R-Value References Result--->
<---Ejemplo de Sobrecarga de Funciones con L-Values y R-Values--->
```cpp
#include <iostream>

void procesar(int& x) {
    std::cout << "L-value reference: " << x << std::endl;
}

void procesar(int&& x) {
    std::cout << "R-value reference: " << x << std::endl;
}

int main() {
    int a = 5;
    procesar(a);        // Llama a la versión de L-value reference
    procesar(10);       // Llama a la versión de R-value reference
    procesar(a + 3);    // Llama a la versión de R-value reference

    return 0;
}
<---Ejemplo de Sobrecarga de Funciones con L-Values y R-Values Result--->
<---Asignación a una Variable--->
```cpp
int x = 5;         // '5' es un R-value asignado a 'x'
double y = 3.14;   // '3.14' es un R-value asignado a 'y'
<---Asignación a una Variable Result--->
<---Paso como Argumentos a Funciones--->
```cpp
#include <iostream>

// Función que toma un parámetro por valor
void procesar(int x) {
    std::cout << "Valor: " << x << std::endl;
}

int main() {
    procesar(10);   // '10' es un R-value pasado como argumento
    return 0;
}
<---Paso como Argumentos a Funciones Result--->
<---Inicialización de Variables--->
```cpp
int a = 5;         // '5' es un R-value usado para inicializar 'a'
double b = a + 3;  // 'a + 3' es un R-value usado para inicializar 'b'
<---Inicialización de Variables Result--->
<---Uso en Expresiones y Operadores--->
```cpp
#include <iostream>

int main() {
    int x = 5;
    int y = 10;
    int z = x + y;  // 'x + y' es un R-value usado en una expresión

    std::cout << "Resultado: " << z << std::endl;
    return 0;
}
<---Uso en Expresiones y Operadores Result--->
<---Uso con R-Value References--->
```cpp
#include <iostream>

class MiClase {
public:
    int* data;

    // Constructor normal
    MiClase(int value) : data(new int(value)) {
        std::cout << "Constructor llamado para " << *data << std::endl;
    }

    // Destructor
    ~MiClase() {
        delete data;
        std::cout << "Destructor llamado" << std::endl;
    }

    // Move Constructor
    MiClase(MiClase&& other) noexcept : data(other.data) {
        other.data = nullptr;
        std::cout << "Move Constructor llamado" << std::endl;
    }

    // Move Assignment Operator
    MiClase& operator=(MiClase&& other) noexcept {
        if (this != &other) {
            delete data;
            data = other.data;
            other.data = nullptr;
            std::cout << "Move Assignment Operator llamado" << std::endl;
        }
        return *this;
    }

    void mostrar() const {
        if (data) {
            std::cout << "Valor: " << *data << std::endl;
        } else {
            std::cout << "No hay datos" << std::endl;
        }
    }
};

int main() {
    MiClase obj1(10);
    MiClase obj2 = std::move(obj1);  // 'std::move(obj1)' convierte 'obj1' en un R-value
    obj2.mostrar();
    obj1.mostrar();  // No hay datos, ya que los datos fueron movidos

    MiClase obj3(20);
    obj3 = std::move(obj2);  // 'std::move(obj2)' convierte 'obj2' en un R-value
    obj3.mostrar();
    obj2.mostrar();  // No hay datos, ya que los datos fueron movidos

    return 0;
}
<---Uso con R-Value References Result--->
<---Características de L-Value--->
<---Características de L-Value Result--->
<---Ejemplos de L-Value--->
```cpp
int x = 5;         // 'x' es un L-value
int* p = &x;       // 'p' es un L-value que contiene la dirección de 'x'
x = 10;            // 'x' puede estar en el lado izquierdo de la asignación
*p = 20;           // '*p' es un L-value que puede estar en el lado izquierdo de la asignación

int& ref = x;      // 'ref' es un L-value reference a 'x'
ref = 30;          // 'ref' puede estar en el lado izquierdo de la asignación
<---Ejemplos de L-Value Result--->
<---R-Value--->
<---R-Value Result--->
<---Ejemplos de R-Value--->
```cpp
int y = 5;         // '5' es un R-value
int z = y + 3;     // 'y + 3' es un R-value
<---Ejemplos de R-Value Result--->
<---Move Constructor y Move Assignment Operator--->
<---Move Constructor y Move Assignment Operator Result--->
<---Move Constructor--->
```cpp
#include <iostream>
#include <utility>

class MiClase {
private:
    int* data;

public:
    // Constructor
    MiClase(int value) : data(new int(value)) {
        std::cout << "Constructor llamado para " << *data << std::endl;
    }

    // Destructor
    ~MiClase() {
        delete data;
        std::cout << "Destructor llamado" << std::endl;
    }

    // Move Constructor
    MiClase(MiClase&& other) noexcept : data(other.data) {
        other.data = nullptr;
        std::cout << "Move Constructor llamado" << std::endl;
    }

    // Move Assignment Operator
    MiClase& operator=(MiClase&& other) noexcept {
        if (this != &other) {
            delete data;
            data = other.data;
            other.data = nullptr;
            std::cout << "Move Assignment Operator llamado" << std::endl;
        }
        return *this;
    }

    void mostrar() const {
        if (data) {
            std::cout << "Valor: " << *data << std::endl;
        } else {
            std::cout << "No hay datos" << std::endl;
        }
    }
};

int main() {
    MiClase obj1(10);
    MiClase obj2 = std::move(obj1);  // Move Constructor llamado
    obj2.mostrar();
    obj1.mostrar();  // No hay datos, ya que los datos fueron movidos

    MiClase obj3(20);
    obj3 = std::move(obj2);  // Move Assignment Operator llamado
    obj3.mostrar();
    obj2.mostrar();  // No hay datos, ya que los datos fueron movidos

    return 0;
}
<---Move Constructor Result--->
<---Ejemplos Prácticos--->
```cpp
#include <iostream>

int main() {
    // Literales
    int x = 5;         // '5' es un R-value
    double y = 3.14;   // '3.14' es un R-value

    // Resultados de Expresiones
    int z = x + 2;     // 'x + 2' es un R-value

    // Llamadas a Funciones que Devuelven R-Values
    std::string s1 = "hello";          // "hello" es un R-value
    std::string s2 = s1 + " world";    // 's1 + " world"' es un R-value

    // Mostrando los valores
    std::cout << "x: " << x << std::endl;
    std::cout << "y: " << y << std::endl;
    std::cout << "z: " << z << std::endl;
    std::cout << "s1: " << s1 << std::endl;
    std::cout << "s2: " << s2 << std::endl;

    return 0;
}
<---Ejemplos Prácticos Result--->
<---Sintaxis--->
```cpp
#include <utility>

std::move(obj);  // Convierte 'obj' en un R-value
<---Sintaxis Result--->
<---Ejemplo con R-Value References--->
```cpp
#include <iostream>

class MiClase {
public:
    int* data;

    // Constructor normal
    MiClase(int value) : data(new int(value)) {
        std::cout << "Constructor llamado para " << *data << std::endl;
    }

    // Destructor
    ~MiClase() {
        delete data;
        std::cout << "Destructor llamado" << std::endl;
    }

    // Move Constructor
    MiClase(MiClase&& other) noexcept : data(other.data) {
        other.data = nullptr;
        std::cout << "Move Constructor llamado" << std::endl;
    }

    // Move Assignment Operator
    MiClase& operator=(MiClase&& other) noexcept {
        if (this != &other) {
            delete data;
            data = other.data;
            other.data = nullptr;
            std::cout << "Move Assignment Operator llamado" << std::endl;
        }
        return *this;
    }

    void mostrar() const {
        if (data) {
            std::cout << "Valor: " << *data << std::endl;
        } else {
            std::cout << "No hay datos" << std::endl;
        }
    }
};

int main() {
    MiClase obj1(10);
    MiClase obj2 = std::move(obj1);  // Move Constructor llamado
    obj2.mostrar();
    obj1.mostrar();  // No hay datos, ya que los datos fueron movidos

    MiClase obj3(20);
    obj3 = std::move(obj2);  // Move Assignment Operator llamado
    obj3.mostrar();
    obj2.mostrar();  // No hay datos, ya que los datos fueron movidos

    return 0;
}
<---Ejemplo con R-Value References Result--->
<---Ejemplo de R-Value References--->
```cpp
#include <iostream>

class MiClase {
public:
    int* data;

    // Constructor normal
    MiClase(int value) : data(new int(value)) {
        std::cout << "Constructor llamado para " << *data << std::endl;
    }

    // Destructor
    ~MiClase() {
        delete data;
        std::cout << "Destructor llamado" << std::endl;
    }

    // Move Constructor
    MiClase(MiClase&& other) noexcept : data(other.data) {
        other.data = nullptr;
        std::cout << "Move Constructor llamado" << std::endl;
    }

    // Move Assignment Operator
    MiClase& operator=(MiClase&& other) noexcept {
        if (this != &other) {
            delete data;
            data = other.data;
            other.data = nullptr;
            std::cout << "Move Assignment Operator llamado" << std::endl;
        }
        return *this;
    }

    void mostrar() const {
        if (data) {
            std::cout << "Valor: " << *data << std::endl;
        } else {
            std::cout << "No hay datos" << std::endl;
        }
    }
};

int main() {
    MiClase obj1(10);
    MiClase obj2 = std::move(obj1);  // Move Constructor llamado
    obj2.mostrar();
    obj1.mostrar();  // No hay datos, ya que los datos fueron movidos

    MiClase obj3(20);
    obj3 = std::move(obj2);  // Move Assignment Operator llamado
    obj3.mostrar();
    obj2.mostrar();  // No hay datos, ya que los datos fueron movidos

    return 0;
}
<---Ejemplo de R-Value References Result--->
<---Ejemplo de Sobrecarga de Funciones con L-Values y R-Values--->
```cpp
#include <iostream>

void procesar(int& x) {
    std::cout << "L-value reference: " << x << std::endl;
}

void procesar(int&& x) {
    std::cout << "R-value reference: " << x << std::endl;
}

int main() {
    int a = 5;
    procesar(a);        // Llama a la versión de L-value reference
    procesar(10);       // Llama a la versión de R-value reference
    procesar(a + 3);    // Llama a la versión de R-value reference

    return 0;
}
<---Ejemplo de Sobrecarga de Funciones con L-Values y R-Values Result--->
<---Asignación a una Variable--->
```cpp
int x = 5;         // '5' es un R-value asignado a 'x'
double y = 3.14;   // '3.14' es un R-value asignado a 'y'
<---Asignación a una Variable Result--->
<---Paso como Argumentos a Funciones--->
```cpp
#include <iostream>

// Función que toma un parámetro por valor
void procesar(int x) {
    std::cout << "Valor: " << x << std::endl;
}

int main() {
    procesar(10);   // '10' es un R-value pasado como argumento
    return 0;
}
<---Paso como Argumentos a Funciones Result--->
<---Inicialización de Variables--->
```cpp
int a = 5;         // '5' es un R-value usado para inicializar 'a'
double b = a + 3;  // 'a + 3' es un R-value usado para inicializar 'b'
<---Inicialización de Variables Result--->
<---Uso en Expresiones y Operadores--->
```cpp
#include <iostream>

int main() {
    int x = 5;
    int y = 10;
    int z = x + y;  // 'x + y' es un R-value usado en una expresión

    std::cout << "Resultado: " << z << std::endl;
    return 0;
}
<---Uso en Expresiones y Operadores Result--->
<---Uso con R-Value References--->
```cpp
#include <iostream>

class MiClase {
public:
    int* data;

    // Constructor normal
    MiClase(int value) : data(new int(value)) {
        std::cout << "Constructor llamado para " << *data << std::endl;
    }

    // Destructor
    ~MiClase() {
        delete data;
        std::cout << "Destructor llamado" << std::endl;
    }

    // Move Constructor
    MiClase(MiClase&& other) noexcept : data(other.data) {
        other.data = nullptr;
        std::cout << "Move Constructor llamado" << std::endl;
    }

    // Move Assignment Operator
    MiClase& operator=(MiClase&& other) noexcept {
        if (this != &other) {
            delete data;
            data = other.data;
            other.data = nullptr;
            std::cout << "Move Assignment Operator llamado" << std::endl;
        }
        return *this;
    }

    void mostrar() const {
        if (data) {
            std::cout << "Valor: " << *data << std::endl;
        } else {
            std::cout << "No hay datos" << std::endl;
        }
    }
};

int main() {
    MiClase obj1(10);
    MiClase obj2 = std::move(obj1);  // 'std::move(obj1)' convierte 'obj1' en un R-value
    obj2.mostrar();
    obj1.mostrar();  // No hay datos, ya que los datos fueron movidos

    MiClase obj3(20);
    obj3 = std::move(obj2);  // 'std::move(obj2)' convierte 'obj2' en un R-value
    obj3.mostrar();
    obj2.mostrar();  // No hay datos, ya que los datos fueron movidos

    return 0;
}
<---Uso con R-Value References Result--->
<---Definición de una Clase con Move Semantics--->
```cpp
#include <iostream>
#include <utility>  // Para std::move

class MiClase {
public:
    int* data;

    // Constructor normal
    MiClase(int value) : data(new int(value)) {
        std::cout << "Constructor llamado para " << *data << std::endl;
    }

    // Destructor
    ~MiClase() {
        delete data;
        std::cout << "Destructor llamado" << std::endl;
    }

    // Move Constructor
    MiClase(MiClase&& other) noexcept : data(other.data) {
        other.data = nullptr;
        std::cout << "Move Constructor llamado" << std::endl;
    }

    // Move Assignment Operator
    MiClase& operator=(MiClase&& other) noexcept {
        if (this != &other) {
            delete data;
            data = other.data;
            other.data = nullptr;
            std::cout << "Move Assignment Operator llamado" << std::endl;
        }
        return *this;
    }

    void mostrar() const {
        if (data) {
            std::cout << "Valor: " << *data << std::endl;
        } else {
            std::cout << "No hay datos" << std::endl;
        }
    }
};

int main() {
    MiClase obj1(10);
    MiClase obj2 = std::move(obj1);  // std::move convierte 'obj1' en un R-value
    obj2.mostrar();
    obj1.mostrar();  // No hay datos, ya que los datos fueron movidos

    MiClase obj3(20);
    obj3 = std::move(obj2);  // std::move convierte 'obj2' en un R-value
    obj3.mostrar();
    obj2.mostrar();  // No hay datos, ya que los datos fueron movidos

    return 0;
}
<---Definición de una Clase con Move Semantics Result--->
<---Implementación Simplificada de `std::move`--->
```cpp
namespace std {
    template <typename T>
    typename remove_reference<T>::type&& move(T&& arg) noexcept {
        return static_cast<typename remove_reference<T>::type&&>(arg);
    }
}
<---Implementación Simplificada de `std::move` Result--->
<---Características de L-Value--->
<---Características de L-Value Result--->
<---Ejemplos de L-Value--->
```cpp
int x = 5;         // 'x' es un L-value
int* p = &x;       // 'p' es un L-value que contiene la dirección de 'x'
x = 10;            // 'x' puede estar en el lado izquierdo de la asignación
*p = 20;           // '*p' es un L-value que puede estar en el lado izquierdo de la asignación

int& ref = x;      // 'ref' es un L-value reference a 'x'
ref = 30;          // 'ref' puede estar en el lado izquierdo de la asignación
<---Ejemplos de L-Value Result--->
<---R-Value--->
<---R-Value Result--->
<---Ejemplos de R-Value--->
```cpp
int y = 5;         // '5' es un R-value
int z = y + 3;     // 'y + 3' es un R-value
<---Ejemplos de R-Value Result--->
<---Move Constructor y Move Assignment Operator--->
<---Move Constructor y Move Assignment Operator Result--->
<---Move Constructor--->
```cpp
#include <iostream>
#include <utility>

class MiClase {
private:
    int* data;

public:
    // Constructor
    MiClase(int value) : data(new int(value)) {
        std::cout << "Constructor llamado para " << *data << std::endl;
    }

    // Destructor
    ~MiClase() {
        delete data;
        std::cout << "Destructor llamado" << std::endl;
    }

    // Move Constructor
    MiClase(MiClase&& other) noexcept : data(other.data) {
        other.data = nullptr;
        std::cout << "Move Constructor llamado" << std::endl;
    }

    // Move Assignment Operator
    MiClase& operator=(MiClase&& other) noexcept {
        if (this != &other) {
            delete data;
            data = other.data;
            other.data = nullptr;
            std::cout << "Move Assignment Operator llamado" << std::endl;
        }
        return *this;
    }

    void mostrar() const {
        if (data) {
            std::cout << "Valor: " << *data << std::endl;
        } else {
            std::cout << "No hay datos" << std::endl;
        }
    }
};

int main() {
    MiClase obj1(10);
    MiClase obj2 = std::move(obj1);  // Move Constructor llamado
    obj2.mostrar();
    obj1.mostrar();  // No hay datos, ya que los datos fueron movidos

    MiClase obj3(20);
    obj3 = std::move(obj2);  // Move Assignment Operator llamado
    obj3.mostrar();
    obj2.mostrar();  // No hay datos, ya que los datos fueron movidos

    return 0;
}
<---Move Constructor Result--->
<---Ejemplos Prácticos--->
```cpp
#include <iostream>

int main() {
    // Literales
    int x = 5;         // '5' es un R-value
    double y = 3.14;   // '3.14' es un R-value

    // Resultados de Expresiones
    int z = x + 2;     // 'x + 2' es un R-value

    // Llamadas a Funciones que Devuelven R-Values
    std::string s1 = "hello";          // "hello" es un R-value
    std::string s2 = s1 + " world";    // 's1 + " world"' es un R-value

    // Mostrando los valores
    std::cout << "x: " << x << std::endl;
    std::cout << "y: " << y << std::endl;
    std::cout << "z: " << z << std::endl;
    std::cout << "s1: " << s1 << std::endl;
    std::cout << "s2: " << s2 << std::endl;

    return 0;
}
<---Ejemplos Prácticos Result--->
<---Sintaxis--->
```cpp
#include <utility>

std::move(obj);  // Convierte 'obj' en un R-value
<---Sintaxis Result--->
<---Ejemplo con R-Value References--->
```cpp
#include <iostream>

class MiClase {
public:
    int* data;

    // Constructor normal
    MiClase(int value) : data(new int(value)) {
        std::cout << "Constructor llamado para " << *data << std::endl;
    }

    // Destructor
    ~MiClase() {
        delete data;
        std::cout << "Destructor llamado" << std::endl;
    }

    // Move Constructor
    MiClase(MiClase&& other) noexcept : data(other.data) {
        other.data = nullptr;
        std::cout << "Move Constructor llamado" << std::endl;
    }

    // Move Assignment Operator
    MiClase& operator=(MiClase&& other) noexcept {
        if (this != &other) {
            delete data;
            data = other.data;
            other.data = nullptr;
            std::cout << "Move Assignment Operator llamado" << std::endl;
        }
        return *this;
    }

    void mostrar() const {
        if (data) {
            std::cout << "Valor: " << *data << std::endl;
        } else {
            std::cout << "No hay datos" << std::endl;
        }
    }
};

int main() {
    MiClase obj1(10);
    MiClase obj2 = std::move(obj1);  // Move Constructor llamado
    obj2.mostrar();
    obj1.mostrar();  // No hay datos, ya que los datos fueron movidos

    MiClase obj3(20);
    obj3 = std::move(obj2);  // Move Assignment Operator llamado
    obj3.mostrar();
    obj2.mostrar();  // No hay datos, ya que los datos fueron movidos

    return 0;
}
<---Ejemplo con R-Value References Result--->
<---Ejemplo de R-Value References--->
```cpp
#include <iostream>

class MiClase {
public:
    int* data;

    // Constructor normal
    MiClase(int value) : data(new int(value)) {
        std::cout << "Constructor llamado para " << *data << std::endl;
    }

    // Destructor
    ~MiClase() {
        delete data;
        std::cout << "Destructor llamado" << std::endl;
    }

    // Move Constructor
    MiClase(MiClase&& other) noexcept : data(other.data) {
        other.data = nullptr;
        std::cout << "Move Constructor llamado" << std::endl;
    }

    // Move Assignment Operator
    MiClase& operator=(MiClase&& other) noexcept {
        if (this != &other) {
            delete data;
            data = other.data;
            other.data = nullptr;
            std::cout << "Move Assignment Operator llamado" << std::endl;
        }
        return *this;
    }

    void mostrar() const {
        if (data) {
            std::cout << "Valor: " << *data << std::endl;
        } else {
            std::cout << "No hay datos" << std::endl;
        }
    }
};

int main() {
    MiClase obj1(10);
    MiClase obj2 = std::move(obj1);  // Move Constructor llamado
    obj2.mostrar();
    obj1.mostrar();  // No hay datos, ya que los datos fueron movidos

    MiClase obj3(20);
    obj3 = std::move(obj2);  // Move Assignment Operator llamado
    obj3.mostrar();
    obj2.mostrar();  // No hay datos, ya que los datos fueron movidos

    return 0;
}
<---Ejemplo de R-Value References Result--->
<---Ejemplo de Sobrecarga de Funciones con L-Values y R-Values--->
```cpp
#include <iostream>

void procesar(int& x) {
    std::cout << "L-value reference: " << x << std::endl;
}

void procesar(int&& x) {
    std::cout << "R-value reference: " << x << std::endl;
}

int main() {
    int a = 5;
    procesar(a);        // Llama a la versión de L-value reference
    procesar(10);       // Llama a la versión de R-value reference
    procesar(a + 3);    // Llama a la versión de R-value reference

    return 0;
}
<---Ejemplo de Sobrecarga de Funciones con L-Values y R-Values Result--->
<---Asignación a una Variable--->
```cpp
int x = 5;         // '5' es un R-value asignado a 'x'
double y = 3.14;   // '3.14' es un R-value asignado a 'y'
<---Asignación a una Variable Result--->
<---Paso como Argumentos a Funciones--->
```cpp
#include <iostream>

// Función que toma un parámetro por valor
void procesar(int x) {
    std::cout << "Valor: " << x << std::endl;
}

int main() {
    procesar(10);   // '10' es un R-value pasado como argumento
    return 0;
}
<---Paso como Argumentos a Funciones Result--->
<---Inicialización de Variables--->
```cpp
int a = 5;         // '5' es un R-value usado para inicializar 'a'
double b = a + 3;  // 'a + 3' es un R-value usado para inicializar 'b'
<---Inicialización de Variables Result--->
<---Uso en Expresiones y Operadores--->
```cpp
#include <iostream>

int main() {
    int x = 5;
    int y = 10;
    int z = x + y;  // 'x + y' es un R-value usado en una expresión

    std::cout << "Resultado: " << z << std::endl;
    return 0;
}
<---Uso en Expresiones y Operadores Result--->
<---Uso con R-Value References--->
```cpp
#include <iostream>

class MiClase {
public:
    int* data;

    // Constructor normal
    MiClase(int value) : data(new int(value)) {
        std::cout << "Constructor llamado para " << *data << std::endl;
    }

    // Destructor
    ~MiClase() {
        delete data;
        std::cout << "Destructor llamado" << std::endl;
    }

    // Move Constructor
    MiClase(MiClase&& other) noexcept : data(other.data) {
        other.data = nullptr;
        std::cout << "Move Constructor llamado" << std::endl;
    }

    // Move Assignment Operator
    MiClase& operator=(MiClase&& other) noexcept {
        if (this != &other) {
            delete data;
            data = other.data;
            other.data = nullptr;
            std::cout << "Move Assignment Operator llamado" << std::endl;
        }
        return *this;
    }

    void mostrar() const {
        if (data) {
            std::cout << "Valor: " << *data << std::endl;
        } else {
            std::cout << "No hay datos" << std::endl;
        }
    }
};

int main() {
    MiClase obj1(10);
    MiClase obj2 = std::move(obj1);  // 'std::move(obj1)' convierte 'obj1' en un R-value
    obj2.mostrar();
    obj1.mostrar();  // No hay datos, ya que los datos fueron movidos

    MiClase obj3(20);
    obj3 = std::move(obj2);  // 'std::move(obj2)' convierte 'obj2' en un R-value
    obj3.mostrar();
    obj2.mostrar();  // No hay datos, ya que los datos fueron movidos

    return 0;
}
<---Uso con R-Value References Result--->
<---Definición de una Clase con Move Semantics--->
```cpp
#include <iostream>
#include <utility>  // Para std::move

class MiClase {
public:
    int* data;

    // Constructor normal
    MiClase(int value) : data(new int(value)) {
        std::cout << "Constructor llamado para " << *data << std::endl;
    }

    // Destructor
    ~MiClase() {
        delete data;
        std::cout << "Destructor llamado" << std::endl;
    }

    // Move Constructor
    MiClase(MiClase&& other) noexcept : data(other.data) {
        other.data = nullptr;
        std::cout << "Move Constructor llamado" << std::endl;
    }

    // Move Assignment Operator
    MiClase& operator=(MiClase&& other) noexcept {
        if (this != &other) {
            delete data;
            data = other.data;
            other.data = nullptr;
            std::cout << "Move Assignment Operator llamado" << std::endl;
        }
        return *this;
    }

    void mostrar() const {
        if (data) {
            std::cout << "Valor: " << *data << std::endl;
        } else {
            std::cout << "No hay datos" << std::endl;
        }
    }
};

int main() {
    MiClase obj1(10);
    MiClase obj2 = std::move(obj1);  // std::move convierte 'obj1' en un R-value
    obj2.mostrar();
    obj1.mostrar();  // No hay datos, ya que los datos fueron movidos

    MiClase obj3(20);
    obj3 = std::move(obj2);  // std::move convierte 'obj2' en un R-value
    obj3.mostrar();
    obj2.mostrar();  // No hay datos, ya que los datos fueron movidos

    return 0;
}
<---Definición de una Clase con Move Semantics Result--->
<---Implementación Simplificada de `std::move`--->
```cpp
namespace std {
    template <typename T>
    typename remove_reference<T>::type&& move(T&& arg) noexcept {
        return static_cast<typename remove_reference<T>::type&&>(arg);
    }
}
<---Implementación Simplificada de `std::move` Result--->
<---Ejemplo: Move Constructor y Move Assignment Operator--->
```cpp
#include <iostream>
#include <utility>

class MiClase {
public:
    int* data;

    // Constructor normal
    MiClase(int value) : data(new int(value)) {
        std::cout << "Constructor llamado para " << *data << std::endl;
    }

    // Destructor
    ~MiClase() {
        delete data;
        std::cout << "Destructor llamado" << std::endl;
    }

    // Move Constructor
    MiClase(MiClase&& other) noexcept : data(other.data) {
        other.data = nullptr;
        std::cout << "Move Constructor llamado" << std::endl;
    }

    // Move Assignment Operator
    MiClase& operator=(MiClase&& other) noexcept {
        if (this != &other) {
            delete data;
            data = other.data;
            other.data = nullptr;
            std::cout << "Move Assignment Operator llamado" << std::endl;
        }
        return *this;
    }

    void mostrar() const {
        if (data) {
            std::cout << "Valor: " << *data << std::endl;
        } else {
            std::cout << "No hay datos" << std::endl;
        }
    }
};

int main() {
    MiClase obj1(10);
    MiClase obj2 = std::move(obj1);  // Move Constructor llamado
    obj2.mostrar();
    obj1.mostrar();  // No hay datos, ya que los datos fueron movidos

    MiClase obj3(20);
    obj3 = std::move(obj2);  // Move Assignment Operator llamado
    obj3.mostrar();
    obj2.mostrar();  // No hay datos, ya que los datos fueron movidos

    return 0;
}
<---Ejemplo: Move Constructor y Move Assignment Operator Result--->
<---Ejemplo--->
```cpp
MiClase obj1(10);
MiClase obj2 = std::move(obj1);  // obj1 ahora está en un estado indeterminado
<---Ejemplo Result--->
<---Comparación de Copy vs Move--->
```cpp
#include <vector>

std::vector<int> generarVector() {
    std::vector<int> v = {1, 2, 3, 4, 5};
    return v;  // Devuelve un R-value que puede ser movido en lugar de copiado
}

int main() {
    std::vector<int> vec = generarVector();  // Move semantics optimizan esta operación
    return 0;
}
<---Comparación de Copy vs Move Result--->
<---Ejemplo de API con Move Semantics--->
```cpp
#include <vector>
#include <utility>

class Contenedor {
    std::vector<int> datos;

public:
    void setDatos(std::vector<int>&& nuevosDatos) {
        datos = std::move(nuevosDatos);  // Mueve los datos en lugar de copiarlos
    }

    const std::vector<int>& getDatos() const {
        return datos;
    }
};
<---Ejemplo de API con Move Semantics Result--->
<---Consideraciones al Usar `std::move`--->
<---Consideraciones al Usar `std::move` Result--->
<---Características de L-Value--->
<---Características de L-Value Result--->
<---Ejemplos de L-Value--->
```cpp
int x = 5;         // 'x' es un L-value
int* p = &x;       // 'p' es un L-value que contiene la dirección de 'x'
x = 10;            // 'x' puede estar en el lado izquierdo de la asignación
*p = 20;           // '*p' es un L-value que puede estar en el lado izquierdo de la asignación

int& ref = x;      // 'ref' es un L-value reference a 'x'
ref = 30;          // 'ref' puede estar en el lado izquierdo de la asignación
<---Ejemplos de L-Value Result--->
<---R-Value--->
<---R-Value Result--->
<---Ejemplos de R-Value--->
```cpp
int y = 5;         // '5' es un R-value
int z = y + 3;     // 'y + 3' es un R-value
<---Ejemplos de R-Value Result--->
<---Move Constructor y Move Assignment Operator--->
<---Move Constructor y Move Assignment Operator Result--->
<---Move Constructor--->
```cpp
#include <iostream>
#include <utility>

class MiClase {
private:
    int* data;

public:
    // Constructor
    MiClase(int value) : data(new int(value)) {
        std::cout << "Constructor llamado para " << *data << std::endl;
    }

    // Destructor
    ~MiClase() {
        delete data;
        std::cout << "Destructor llamado" << std::endl;
    }

    // Move Constructor
    MiClase(MiClase&& other) noexcept : data(other.data) {
        other.data = nullptr;
        std::cout << "Move Constructor llamado" << std::endl;
    }

    // Move Assignment Operator
    MiClase& operator=(MiClase&& other) noexcept {
        if (this != &other) {
            delete data;
            data = other.data;
            other.data = nullptr;
            std::cout << "Move Assignment Operator llamado" << std::endl;
        }
        return *this;
    }

    void mostrar() const {
        if (data) {
            std::cout << "Valor: " << *data << std::endl;
        } else {
            std::cout << "No hay datos" << std::endl;
        }
    }
};

int main() {
    MiClase obj1(10);
    MiClase obj2 = std::move(obj1);  // Move Constructor llamado
    obj2.mostrar();
    obj1.mostrar();  // No hay datos, ya que los datos fueron movidos

    MiClase obj3(20);
    obj3 = std::move(obj2);  // Move Assignment Operator llamado
    obj3.mostrar();
    obj2.mostrar();  // No hay datos, ya que los datos fueron movidos

    return 0;
}
<---Move Constructor Result--->
<---Ejemplos Prácticos--->
```cpp
#include <iostream>

int main() {
    // Literales
    int x = 5;         // '5' es un R-value
    double y = 3.14;   // '3.14' es un R-value

    // Resultados de Expresiones
    int z = x + 2;     // 'x + 2' es un R-value

    // Llamadas a Funciones que Devuelven R-Values
    std::string s1 = "hello";          // "hello" es un R-value
    std::string s2 = s1 + " world";    // 's1 + " world"' es un R-value

    // Mostrando los valores
    std::cout << "x: " << x << std::endl;
    std::cout << "y: " << y << std::endl;
    std::cout << "z: " << z << std::endl;
    std::cout << "s1: " << s1 << std::endl;
    std::cout << "s2: " << s2 << std::endl;

    return 0;
}
<---Ejemplos Prácticos Result--->
<---Sintaxis--->
```cpp
#include <utility>

std::move(obj);  // Convierte 'obj' en un R-value
<---Sintaxis Result--->
<---Ejemplo con R-Value References--->
```cpp
#include <iostream>

class MiClase {
public:
    int* data;

    // Constructor normal
    MiClase(int value) : data(new int(value)) {
        std::cout << "Constructor llamado para " << *data << std::endl;
    }

    // Destructor
    ~MiClase() {
        delete data;
        std::cout << "Destructor llamado" << std::endl;
    }

    // Move Constructor
    MiClase(MiClase&& other) noexcept : data(other.data) {
        other.data = nullptr;
        std::cout << "Move Constructor llamado" << std::endl;
    }

    // Move Assignment Operator
    MiClase& operator=(MiClase&& other) noexcept {
        if (this != &other) {
            delete data;
            data = other.data;
            other.data = nullptr;
            std::cout << "Move Assignment Operator llamado" << std::endl;
        }
        return *this;
    }

    void mostrar() const {
        if (data) {
            std::cout << "Valor: " << *data << std::endl;
        } else {
            std::cout << "No hay datos" << std::endl;
        }
    }
};

int main() {
    MiClase obj1(10);
    MiClase obj2 = std::move(obj1);  // Move Constructor llamado
    obj2.mostrar();
    obj1.mostrar();  // No hay datos, ya que los datos fueron movidos

    MiClase obj3(20);
    obj3 = std::move(obj2);  // Move Assignment Operator llamado
    obj3.mostrar();
    obj2.mostrar();  // No hay datos, ya que los datos fueron movidos

    return 0;
}
<---Ejemplo con R-Value References Result--->
<---Ejemplo de R-Value References--->
```cpp
#include <iostream>

class MiClase {
public:
    int* data;

    // Constructor normal
    MiClase(int value) : data(new int(value)) {
        std::cout << "Constructor llamado para " << *data << std::endl;
    }

    // Destructor
    ~MiClase() {
        delete data;
        std::cout << "Destructor llamado" << std::endl;
    }

    // Move Constructor
    MiClase(MiClase&& other) noexcept : data(other.data) {
        other.data = nullptr;
        std::cout << "Move Constructor llamado" << std::endl;
    }

    // Move Assignment Operator
    MiClase& operator=(MiClase&& other) noexcept {
        if (this != &other) {
            delete data;
            data = other.data;
            other.data = nullptr;
            std::cout << "Move Assignment Operator llamado" << std::endl;
        }
        return *this;
    }

    void mostrar() const {
        if (data) {
            std::cout << "Valor: " << *data << std::endl;
        } else {
            std::cout << "No hay datos" << std::endl;
        }
    }
};

int main() {
    MiClase obj1(10);
    MiClase obj2 = std::move(obj1);  // Move Constructor llamado
    obj2.mostrar();
    obj1.mostrar();  // No hay datos, ya que los datos fueron movidos

    MiClase obj3(20);
    obj3 = std::move(obj2);  // Move Assignment Operator llamado
    obj3.mostrar();
    obj2.mostrar();  // No hay datos, ya que los datos fueron movidos

    return 0;
}
<---Ejemplo de R-Value References Result--->
<---Ejemplo de Sobrecarga de Funciones con L-Values y R-Values--->
```cpp
#include <iostream>

void procesar(int& x) {
    std::cout << "L-value reference: " << x << std::endl;
}

void procesar(int&& x) {
    std::cout << "R-value reference: " << x << std::endl;
}

int main() {
    int a = 5;
    procesar(a);        // Llama a la versión de L-value reference
    procesar(10);       // Llama a la versión de R-value reference
    procesar(a + 3);    // Llama a la versión de R-value reference

    return 0;
}
<---Ejemplo de Sobrecarga de Funciones con L-Values y R-Values Result--->
<---Asignación a una Variable--->
```cpp
int x = 5;         // '5' es un R-value asignado a 'x'
double y = 3.14;   // '3.14' es un R-value asignado a 'y'
<---Asignación a una Variable Result--->
<---Paso como Argumentos a Funciones--->
```cpp
#include <iostream>

// Función que toma un parámetro por valor
void procesar(int x) {
    std::cout << "Valor: " << x << std::endl;
}

int main() {
    procesar(10);   // '10' es un R-value pasado como argumento
    return 0;
}
<---Paso como Argumentos a Funciones Result--->
<---Inicialización de Variables--->
```cpp
int a = 5;         // '5' es un R-value usado para inicializar 'a'
double b = a + 3;  // 'a + 3' es un R-value usado para inicializar 'b'
<---Inicialización de Variables Result--->
<---Uso en Expresiones y Operadores--->
```cpp
#include <iostream>

int main() {
    int x = 5;
    int y = 10;
    int z = x + y;  // 'x + y' es un R-value usado en una expresión

    std::cout << "Resultado: " << z << std::endl;
    return 0;
}
<---Uso en Expresiones y Operadores Result--->
<---Uso con R-Value References--->
```cpp
#include <iostream>

class MiClase {
public:
    int* data;

    // Constructor normal
    MiClase(int value) : data(new int(value)) {
        std::cout << "Constructor llamado para " << *data << std::endl;
    }

    // Destructor
    ~MiClase() {
        delete data;
        std::cout << "Destructor llamado" << std::endl;
    }

    // Move Constructor
    MiClase(MiClase&& other) noexcept : data(other.data) {
        other.data = nullptr;
        std::cout << "Move Constructor llamado" << std::endl;
    }

    // Move Assignment Operator
    MiClase& operator=(MiClase&& other) noexcept {
        if (this != &other) {
            delete data;
            data = other.data;
            other.data = nullptr;
            std::cout << "Move Assignment Operator llamado" << std::endl;
        }
        return *this;
    }

    void mostrar() const {
        if (data) {
            std::cout << "Valor: " << *data << std::endl;
        } else {
            std::cout << "No hay datos" << std::endl;
        }
    }
};

int main() {
    MiClase obj1(10);
    MiClase obj2 = std::move(obj1);  // 'std::move(obj1)' convierte 'obj1' en un R-value
    obj2.mostrar();
    obj1.mostrar();  // No hay datos, ya que los datos fueron movidos

    MiClase obj3(20);
    obj3 = std::move(obj2);  // 'std::move(obj2)' convierte 'obj2' en un R-value
    obj3.mostrar();
    obj2.mostrar();  // No hay datos, ya que los datos fueron movidos

    return 0;
}
<---Uso con R-Value References Result--->
<---Definición de una Clase con Move Semantics--->
```cpp
#include <iostream>
#include <utility>  // Para std::move

class MiClase {
public:
    int* data;

    // Constructor normal
    MiClase(int value) : data(new int(value)) {
        std::cout << "Constructor llamado para " << *data << std::endl;
    }

    // Destructor
    ~MiClase() {
        delete data;
        std::cout << "Destructor llamado" << std::endl;
    }

    // Move Constructor
    MiClase(MiClase&& other) noexcept : data(other.data) {
        other.data = nullptr;
        std::cout << "Move Constructor llamado" << std::endl;
    }

    // Move Assignment Operator
    MiClase& operator=(MiClase&& other) noexcept {
        if (this != &other) {
            delete data;
            data = other.data;
            other.data = nullptr;
            std::cout << "Move Assignment Operator llamado" << std::endl;
        }
        return *this;
    }

    void mostrar() const {
        if (data) {
            std::cout << "Valor: " << *data << std::endl;
        } else {
            std::cout << "No hay datos" << std::endl;
        }
    }
};

int main() {
    MiClase obj1(10);
    MiClase obj2 = std::move(obj1);  // std::move convierte 'obj1' en un R-value
    obj2.mostrar();
    obj1.mostrar();  // No hay datos, ya que los datos fueron movidos

    MiClase obj3(20);
    obj3 = std::move(obj2);  // std::move convierte 'obj2' en un R-value
    obj3.mostrar();
    obj2.mostrar();  // No hay datos, ya que los datos fueron movidos

    return 0;
}
<---Definición de una Clase con Move Semantics Result--->
<---Implementación Simplificada de `std::move`--->
```cpp
namespace std {
    template <typename T>
    typename remove_reference<T>::type&& move(T&& arg) noexcept {
        return static_cast<typename remove_reference<T>::type&&>(arg);
    }
}
<---Implementación Simplificada de `std::move` Result--->
<---Ejemplo: Move Constructor y Move Assignment Operator--->
```cpp
#include <iostream>
#include <utility>

class MiClase {
public:
    int* data;

    // Constructor normal
    MiClase(int value) : data(new int(value)) {
        std::cout << "Constructor llamado para " << *data << std::endl;
    }

    // Destructor
    ~MiClase() {
        delete data;
        std::cout << "Destructor llamado" << std::endl;
    }

    // Move Constructor
    MiClase(MiClase&& other) noexcept : data(other.data) {
        other.data = nullptr;
        std::cout << "Move Constructor llamado" << std::endl;
    }

    // Move Assignment Operator
    MiClase& operator=(MiClase&& other) noexcept {
        if (this != &other) {
            delete data;
            data = other.data;
            other.data = nullptr;
            std::cout << "Move Assignment Operator llamado" << std::endl;
        }
        return *this;
    }

    void mostrar() const {
        if (data) {
            std::cout << "Valor: " << *data << std::endl;
        } else {
            std::cout << "No hay datos" << std::endl;
        }
    }
};

int main() {
    MiClase obj1(10);
    MiClase obj2 = std::move(obj1);  // Move Constructor llamado
    obj2.mostrar();
    obj1.mostrar();  // No hay datos, ya que los datos fueron movidos

    MiClase obj3(20);
    obj3 = std::move(obj2);  // Move Assignment Operator llamado
    obj3.mostrar();
    obj2.mostrar();  // No hay datos, ya que los datos fueron movidos

    return 0;
}
<---Ejemplo: Move Constructor y Move Assignment Operator Result--->
<---Ejemplo--->
```cpp
MiClase obj1(10);
MiClase obj2 = std::move(obj1);  // obj1 ahora está en un estado indeterminado
<---Ejemplo Result--->
<---Comparación de Copy vs Move--->
```cpp
#include <vector>

std::vector<int> generarVector() {
    std::vector<int> v = {1, 2, 3, 4, 5};
    return v;  // Devuelve un R-value que puede ser movido en lugar de copiado
}

int main() {
    std::vector<int> vec = generarVector();  // Move semantics optimizan esta operación
    return 0;
}
<---Comparación de Copy vs Move Result--->
<---Ejemplo de API con Move Semantics--->
```cpp
#include <vector>
#include <utility>

class Contenedor {
    std::vector<int> datos;

public:
    void setDatos(std::vector<int>&& nuevosDatos) {
        datos = std::move(nuevosDatos);  // Mueve los datos en lugar de copiarlos
    }

    const std::vector<int>& getDatos() const {
        return datos;
    }
};
<---Ejemplo de API con Move Semantics Result--->
<---Consideraciones al Usar `std::move`--->
<---Consideraciones al Usar `std::move` Result--->
<---Ejemplo Básico--->
```cpp
#include <iostream>
#include <utility>

class MiClase {
public:
    int* data;

    // Constructor
    MiClase(int value) : data(new int(value)) {
        std::cout << "Constructor llamado para " << *data << std::endl;
    }

    // Destructor
    ~MiClase() {
        delete data;
        std::cout << "Destructor llamado" << std::endl;
    }

    // Move Constructor
    MiClase(MiClase&& other) noexcept : data(other.data) {
        other.data = nullptr;
        std::cout << "Move Constructor llamado" << std::endl;
    }

    // Move Assignment Operator
    MiClase& operator=(MiClase&& other) noexcept {
        if (this != &other) {
            delete data;
            data = other.data;
            other.data = nullptr;
            std::cout << "Move Assignment Operator llamado" << std::endl;
        }
        return *this;
    }

    void mostrar() const {
        if (data) {
            std::cout << "Valor: " << *data << std::endl;
        } else {
            std::cout << "No hay datos" << std::endl;
        }
    }
};

int main() {
    MiClase obj1(10);
    MiClase obj2 = std::move(obj1);  // std::move convierte 'obj1' en un R-value
    obj2.mostrar();
    obj1.mostrar();  // No hay datos, ya que los datos fueron movidos

    MiClase obj3(20);
    obj3 = std::move(obj2);  // std::move convierte 'obj2' en un R-value
    obj3.mostrar();
    obj2.mostrar();  // No hay datos, ya que los datos fueron movidos

    return 0;
}
<---Ejemplo Básico Result--->
<---Ejemplo de Optimización de Rendimiento--->
```cpp
#include <vector>
#include <iostream>

std::vector<int> generarVector() {
    std::vector<int> v = {1, 2, 3, 4, 5};
    return v;  // Devuelve un R-value que puede ser movido en lugar de copiado
}

int main() {
    std::vector<int> vec = generarVector();  // Move semantics optimizan esta operación
    for (int num : vec) {
        std::cout << num << " ";
    }
    std::cout << std::endl;
    return 0;
}
<---Ejemplo de Optimización de Rendimiento Result--->
<---Ejemplo de Gestión Eficiente de Recursos--->
```cpp
#include <iostream>
#include <utility>

class Archivo {
public:
    FILE* file;

    // Constructor
    Archivo(const char* nombre, const char* modo) : file(fopen(nombre, modo)) {
        if (file) {
            std::cout << "Archivo abierto: " << nombre << std::endl;
        } else {
            std::cerr << "Error al abrir el archivo: " << nombre << std::endl;
        }
    }

    // Destructor
    ~Archivo() {
        if (file) {
            fclose(file);
            std::cout << "Archivo cerrado" << std::endl;
        }
    }

    // Move Constructor
    Archivo(Archivo&& other) noexcept : file(other.file) {
        other.file = nullptr;
        std::cout << "Move Constructor llamado" << std::endl;
    }

    // Move Assignment Operator
    Archivo& operator=(Archivo&& other) noexcept {
        if (this != &other) {
            if (file) {
                fclose(file);
            }
            file = other.file;
            other.file = nullptr;
            std::cout << "Move Assignment Operator llamado" << std::endl;
        }
        return *this;
    }

    // Prohibir la copia
    Archivo(const Archivo&) = delete;
    Archivo& operator=(const Archivo&) = delete;
};

int main() {
    Archivo archivo1("example.txt", "w");
    Archivo archivo2 = std::move(archivo1);  // std::move convierte 'archivo1' en un R-value

    // archivo1 no debe usarse después de ser movido
    return 0;
}
<---Ejemplo de Gestión Eficiente de Recursos Result--->
<---Ejemplo de Evitar Copias Costosas--->
```cpp
#include <iostream>
#include <string>

class CadenaGrande {
public:
    std::string* datos;

    CadenaGrande(const std::string& str) : datos(new std::string(str)) {
        std::cout << "Constructor llamado para " << *datos << std::endl;
    }

    ~CadenaGrande() {
        delete datos;
        std::cout << "Destructor llamado" << std::endl;
    }

    // Move Constructor
    CadenaGrande(CadenaGrande&& other) noexcept : datos(other.datos) {
        other.datos = nullptr;
        std::cout << "Move Constructor llamado" << std::endl;
    }

    // Move Assignment Operator
    CadenaGrande& operator=(CadenaGrande&& other) noexcept {
        if (this != &other) {
            delete datos;
            datos = other.datos;
            other.datos = nullptr;
            std::cout << "Move Assignment Operator llamado" << std::endl;
        }
        return *this;
    }
};

int main() {
    CadenaGrande str1("Una cadena muy grande y costosa de copiar");
    CadenaGrande str2 = std::move(str1);  // std::move convierte 'str1' en un R-value

    return 0;
}
<---Ejemplo de Evitar Copias Costosas Result--->
<---Características de L-Value--->
<---Características de L-Value Result--->
<---Ejemplos de L-Value--->
```cpp
int x = 5;         // 'x' es un L-value
int* p = &x;       // 'p' es un L-value que contiene la dirección de 'x'
x = 10;            // 'x' puede estar en el lado izquierdo de la asignación
*p = 20;           // '*p' es un L-value que puede estar en el lado izquierdo de la asignación

int& ref = x;      // 'ref' es un L-value reference a 'x'
ref = 30;          // 'ref' puede estar en el lado izquierdo de la asignación
<---Ejemplos de L-Value Result--->
<---R-Value--->
<---R-Value Result--->
<---Ejemplos de R-Value--->
```cpp
int y = 5;         // '5' es un R-value
int z = y + 3;     // 'y + 3' es un R-value
<---Ejemplos de R-Value Result--->
<---Move Constructor y Move Assignment Operator--->
<---Move Constructor y Move Assignment Operator Result--->
<---Move Constructor--->
```cpp
#include <iostream>
#include <utility>

class MiClase {
private:
    int* data;

public:
    // Constructor
    MiClase(int value) : data(new int(value)) {
        std::cout << "Constructor llamado para " << *data << std::endl;
    }

    // Destructor
    ~MiClase() {
        delete data;
        std::cout << "Destructor llamado" << std::endl;
    }

    // Move Constructor
    MiClase(MiClase&& other) noexcept : data(other.data) {
        other.data = nullptr;
        std::cout << "Move Constructor llamado" << std::endl;
    }

    // Move Assignment Operator
    MiClase& operator=(MiClase&& other) noexcept {
        if (this != &other) {
            delete data;
            data = other.data;
            other.data = nullptr;
            std::cout << "Move Assignment Operator llamado" << std::endl;
        }
        return *this;
    }

    void mostrar() const {
        if (data) {
            std::cout << "Valor: " << *data << std::endl;
        } else {
            std::cout << "No hay datos" << std::endl;
        }
    }
};

int main() {
    MiClase obj1(10);
    MiClase obj2 = std::move(obj1);  // Move Constructor llamado
    obj2.mostrar();
    obj1.mostrar();  // No hay datos, ya que los datos fueron movidos

    MiClase obj3(20);
    obj3 = std::move(obj2);  // Move Assignment Operator llamado
    obj3.mostrar();
    obj2.mostrar();  // No hay datos, ya que los datos fueron movidos

    return 0;
}
<---Move Constructor Result--->
<---Ejemplos Prácticos--->
```cpp
#include <iostream>

int main() {
    // Literales
    int x = 5;         // '5' es un R-value
    double y = 3.14;   // '3.14' es un R-value

    // Resultados de Expresiones
    int z = x + 2;     // 'x + 2' es un R-value

    // Llamadas a Funciones que Devuelven R-Values
    std::string s1 = "hello";          // "hello" es un R-value
    std::string s2 = s1 + " world";    // 's1 + " world"' es un R-value

    // Mostrando los valores
    std::cout << "x: " << x << std::endl;
    std::cout << "y: " << y << std::endl;
    std::cout << "z: " << z << std::endl;
    std::cout << "s1: " << s1 << std::endl;
    std::cout << "s2: " << s2 << std::endl;

    return 0;
}
<---Ejemplos Prácticos Result--->
<---Sintaxis--->
```cpp
#include <utility>

std::move(obj);  // Convierte 'obj' en un R-value
<---Sintaxis Result--->
<---Ejemplo con R-Value References--->
```cpp
#include <iostream>

class MiClase {
public:
    int* data;

    // Constructor normal
    MiClase(int value) : data(new int(value)) {
        std::cout << "Constructor llamado para " << *data << std::endl;
    }

    // Destructor
    ~MiClase() {
        delete data;
        std::cout << "Destructor llamado" << std::endl;
    }

    // Move Constructor
    MiClase(MiClase&& other) noexcept : data(other.data) {
        other.data = nullptr;
        std::cout << "Move Constructor llamado" << std::endl;
    }

    // Move Assignment Operator
    MiClase& operator=(MiClase&& other) noexcept {
        if (this != &other) {
            delete data;
            data = other.data;
            other.data = nullptr;
            std::cout << "Move Assignment Operator llamado" << std::endl;
        }
        return *this;
    }

    void mostrar() const {
        if (data) {
            std::cout << "Valor: " << *data << std::endl;
        } else {
            std::cout << "No hay datos" << std::endl;
        }
    }
};

int main() {
    MiClase obj1(10);
    MiClase obj2 = std::move(obj1);  // Move Constructor llamado
    obj2.mostrar();
    obj1.mostrar();  // No hay datos, ya que los datos fueron movidos

    MiClase obj3(20);
    obj3 = std::move(obj2);  // Move Assignment Operator llamado
    obj3.mostrar();
    obj2.mostrar();  // No hay datos, ya que los datos fueron movidos

    return 0;
}
<---Ejemplo con R-Value References Result--->
<---Ejemplo de R-Value References--->
```cpp
#include <iostream>

class MiClase {
public:
    int* data;

    // Constructor normal
    MiClase(int value) : data(new int(value)) {
        std::cout << "Constructor llamado para " << *data << std::endl;
    }

    // Destructor
    ~MiClase() {
        delete data;
        std::cout << "Destructor llamado" << std::endl;
    }

    // Move Constructor
    MiClase(MiClase&& other) noexcept : data(other.data) {
        other.data = nullptr;
        std::cout << "Move Constructor llamado" << std::endl;
    }

    // Move Assignment Operator
    MiClase& operator=(MiClase&& other) noexcept {
        if (this != &other) {
            delete data;
            data = other.data;
            other.data = nullptr;
            std::cout << "Move Assignment Operator llamado" << std::endl;
        }
        return *this;
    }

    void mostrar() const {
        if (data) {
            std::cout << "Valor: " << *data << std::endl;
        } else {
            std::cout << "No hay datos" << std::endl;
        }
    }
};

int main() {
    MiClase obj1(10);
    MiClase obj2 = std::move(obj1);  // Move Constructor llamado
    obj2.mostrar();
    obj1.mostrar();  // No hay datos, ya que los datos fueron movidos

    MiClase obj3(20);
    obj3 = std::move(obj2);  // Move Assignment Operator llamado
    obj3.mostrar();
    obj2.mostrar();  // No hay datos, ya que los datos fueron movidos

    return 0;
}
<---Ejemplo de R-Value References Result--->
<---Ejemplo de Sobrecarga de Funciones con L-Values y R-Values--->
```cpp
#include <iostream>

void procesar(int& x) {
    std::cout << "L-value reference: " << x << std::endl;
}

void procesar(int&& x) {
    std::cout << "R-value reference: " << x << std::endl;
}

int main() {
    int a = 5;
    procesar(a);        // Llama a la versión de L-value reference
    procesar(10);       // Llama a la versión de R-value reference
    procesar(a + 3);    // Llama a la versión de R-value reference

    return 0;
}
<---Ejemplo de Sobrecarga de Funciones con L-Values y R-Values Result--->
<---Asignación a una Variable--->
```cpp
int x = 5;         // '5' es un R-value asignado a 'x'
double y = 3.14;   // '3.14' es un R-value asignado a 'y'
<---Asignación a una Variable Result--->
<---Paso como Argumentos a Funciones--->
```cpp
#include <iostream>

// Función que toma un parámetro por valor
void procesar(int x) {
    std::cout << "Valor: " << x << std::endl;
}

int main() {
    procesar(10);   // '10' es un R-value pasado como argumento
    return 0;
}
<---Paso como Argumentos a Funciones Result--->
<---Inicialización de Variables--->
```cpp
int a = 5;         // '5' es un R-value usado para inicializar 'a'
double b = a + 3;  // 'a + 3' es un R-value usado para inicializar 'b'
<---Inicialización de Variables Result--->
<---Uso en Expresiones y Operadores--->
```cpp
#include <iostream>

int main() {
    int x = 5;
    int y = 10;
    int z = x + y;  // 'x + y' es un R-value usado en una expresión

    std::cout << "Resultado: " << z << std::endl;
    return 0;
}
<---Uso en Expresiones y Operadores Result--->
<---Uso con R-Value References--->
```cpp
#include <iostream>

class MiClase {
public:
    int* data;

    // Constructor normal
    MiClase(int value) : data(new int(value)) {
        std::cout << "Constructor llamado para " << *data << std::endl;
    }

    // Destructor
    ~MiClase() {
        delete data;
        std::cout << "Destructor llamado" << std::endl;
    }

    // Move Constructor
    MiClase(MiClase&& other) noexcept : data(other.data) {
        other.data = nullptr;
        std::cout << "Move Constructor llamado" << std::endl;
    }

    // Move Assignment Operator
    MiClase& operator=(MiClase&& other) noexcept {
        if (this != &other) {
            delete data;
            data = other.data;
            other.data = nullptr;
            std::cout << "Move Assignment Operator llamado" << std::endl;
        }
        return *this;
    }

    void mostrar() const {
        if (data) {
            std::cout << "Valor: " << *data << std::endl;
        } else {
            std::cout << "No hay datos" << std::endl;
        }
    }
};

int main() {
    MiClase obj1(10);
    MiClase obj2 = std::move(obj1);  // 'std::move(obj1)' convierte 'obj1' en un R-value
    obj2.mostrar();
    obj1.mostrar();  // No hay datos, ya que los datos fueron movidos

    MiClase obj3(20);
    obj3 = std::move(obj2);  // 'std::move(obj2)' convierte 'obj2' en un R-value
    obj3.mostrar();
    obj2.mostrar();  // No hay datos, ya que los datos fueron movidos

    return 0;
}
<---Uso con R-Value References Result--->
<---Definición de una Clase con Move Semantics--->
```cpp
#include <iostream>
#include <utility>  // Para std::move

class MiClase {
public:
    int* data;

    // Constructor normal
    MiClase(int value) : data(new int(value)) {
        std::cout << "Constructor llamado para " << *data << std::endl;
    }

    // Destructor
    ~MiClase() {
        delete data;
        std::cout << "Destructor llamado" << std::endl;
    }

    // Move Constructor
    MiClase(MiClase&& other) noexcept : data(other.data) {
        other.data = nullptr;
        std::cout << "Move Constructor llamado" << std::endl;
    }

    // Move Assignment Operator
    MiClase& operator=(MiClase&& other) noexcept {
        if (this != &other) {
            delete data;
            data = other.data;
            other.data = nullptr;
            std::cout << "Move Assignment Operator llamado" << std::endl;
        }
        return *this;
    }

    void mostrar() const {
        if (data) {
            std::cout << "Valor: " << *data << std::endl;
        } else {
            std::cout << "No hay datos" << std::endl;
        }
    }
};

int main() {
    MiClase obj1(10);
    MiClase obj2 = std::move(obj1);  // std::move convierte 'obj1' en un R-value
    obj2.mostrar();
    obj1.mostrar();  // No hay datos, ya que los datos fueron movidos

    MiClase obj3(20);
    obj3 = std::move(obj2);  // std::move convierte 'obj2' en un R-value
    obj3.mostrar();
    obj2.mostrar();  // No hay datos, ya que los datos fueron movidos

    return 0;
}
<---Definición de una Clase con Move Semantics Result--->
<---Implementación Simplificada de `std::move`--->
```cpp
namespace std {
    template <typename T>
    typename remove_reference<T>::type&& move(T&& arg) noexcept {
        return static_cast<typename remove_reference<T>::type&&>(arg);
    }
}
<---Implementación Simplificada de `std::move` Result--->
<---Ejemplo: Move Constructor y Move Assignment Operator--->
```cpp
#include <iostream>
#include <utility>

class MiClase {
public:
    int* data;

    // Constructor normal
    MiClase(int value) : data(new int(value)) {
        std::cout << "Constructor llamado para " << *data << std::endl;
    }

    // Destructor
    ~MiClase() {
        delete data;
        std::cout << "Destructor llamado" << std::endl;
    }

    // Move Constructor
    MiClase(MiClase&& other) noexcept : data(other.data) {
        other.data = nullptr;
        std::cout << "Move Constructor llamado" << std::endl;
    }

    // Move Assignment Operator
    MiClase& operator=(MiClase&& other) noexcept {
        if (this != &other) {
            delete data;
            data = other.data;
            other.data = nullptr;
            std::cout << "Move Assignment Operator llamado" << std::endl;
        }
        return *this;
    }

    void mostrar() const {
        if (data) {
            std::cout << "Valor: " << *data << std::endl;
        } else {
            std::cout << "No hay datos" << std::endl;
        }
    }
};

int main() {
    MiClase obj1(10);
    MiClase obj2 = std::move(obj1);  // Move Constructor llamado
    obj2.mostrar();
    obj1.mostrar();  // No hay datos, ya que los datos fueron movidos

    MiClase obj3(20);
    obj3 = std::move(obj2);  // Move Assignment Operator llamado
    obj3.mostrar();
    obj2.mostrar();  // No hay datos, ya que los datos fueron movidos

    return 0;
}
<---Ejemplo: Move Constructor y Move Assignment Operator Result--->
<---Ejemplo--->
```cpp
class MiClase {
public:
    int* data;

    MiClase(int value) : data(new int(value)) {}

    ~MiClase() {
        delete data;
    }

    // Move Constructor
    MiClase(MiClase&& other) noexcept : data(other.data) {
        other.data = nullptr;
    }

    // Move Assignment Operator
    MiClase& operator=(MiClase&& other) noexcept {
        if (this != &other) {
            delete data;
            data = other.data;
            other.data = nullptr;
        }
        return *this;
    }

    // Prohibir la copia
    MiClase(const MiClase&) = delete;
    MiClase& operator=(const MiClase&) = delete;
};
<---Ejemplo Result--->
<---Comparación de Copy vs Move--->
```cpp
#include <vector>

std::vector<int> generarVector() {
    std::vector<int> v = {1, 2, 3, 4, 5};
    return v;  // Devuelve un R-value que puede ser movido en lugar de copiado
}

int main() {
    std::vector<int> vec = generarVector();  // Move semantics optimizan esta operación
    return 0;
}
<---Comparación de Copy vs Move Result--->
<---Ejemplo de API con Move Semantics--->
```cpp
#include <vector>
#include <utility>

class Contenedor {
    std::vector<int> datos;

public:
    void setDatos(std::vector<int>&& nuevosDatos) {
        datos = std::move(nuevosDatos);  // Mueve los datos en lugar de copiarlos
    }

    const std::vector<int>& getDatos() const {
        return datos;
    }
};
<---Ejemplo de API con Move Semantics Result--->
<---Consideraciones al Usar `std::move`--->
<---Consideraciones al Usar `std::move` Result--->
<---Ejemplo Básico--->
```cpp
#include <iostream>
#include <utility>

class MiClase {
public:
    int* data;

    // Constructor
    MiClase(int value) : data(new int(value)) {
        std::cout << "Constructor llamado para " << *data << std::endl;
    }

    // Destructor
    ~MiClase() {
        delete data;
        std::cout << "Destructor llamado" << std::endl;
    }

    // Move Constructor
    MiClase(MiClase&& other) noexcept : data(other.data) {
        other.data = nullptr;
        std::cout << "Move Constructor llamado" << std::endl;
    }

    // Move Assignment Operator
    MiClase& operator=(MiClase&& other) noexcept {
        if (this != &other) {
            delete data;
            data = other.data;
            other.data = nullptr;
            std::cout << "Move Assignment Operator llamado" << std::endl;
        }
        return *this;
    }

    void mostrar() const {
        if (data) {
            std::cout << "Valor: " << *data << std::endl;
        } else {
            std::cout << "No hay datos" << std::endl;
        }
    }
};

int main() {
    MiClase obj1(10);
    MiClase obj2 = std::move(obj1);  // std::move convierte 'obj1' en un R-value
    obj2.mostrar();
    obj1.mostrar();  // No hay datos, ya que los datos fueron movidos

    MiClase obj3(20);
    obj3 = std::move(obj2);  // std::move convierte 'obj2' en un R-value
    obj3.mostrar();
    obj2.mostrar();  // No hay datos, ya que los datos fueron movidos

    return 0;
}
<---Ejemplo Básico Result--->
<---Ejemplo de Optimización de Rendimiento--->
```cpp
#include <vector>

std::vector<int> generarVector() {
    std::vector<int> v = {1, 2, 3, 4, 5};
    return v;  // Devuelve un R-value que puede ser movido en lugar de copiado
}

int main() {
    std::vector<int> vec = generarVector();  // Move semantics optimizan esta operación
    for (int num : vec) {
        std::cout << num << " ";
    }
    std::cout << std::endl;
    return 0;
}
<---Ejemplo de Optimización de Rendimiento Result--->
<---Ejemplo de Gestión Eficiente de Recursos--->
```cpp
#include <iostream>
#include <utility>

class Archivo {
public:
    FILE* file;

    // Constructor
    Archivo(const char* nombre, const char* modo) : file(fopen(nombre, modo)) {
        if (file) {
            std::cout << "Archivo abierto: " << nombre << std::endl;
        } else {
            std::cerr << "Error al abrir el archivo: " << nombre << std::endl;
        }
    }

    // Destructor
    ~Archivo() {
        if (file) {
            fclose(file);
            std::cout << "Archivo cerrado" << std::endl;
        }
    }

    // Move Constructor
    Archivo(Archivo&& other) noexcept : file(other.file) {
        other.file = nullptr;
        std::cout << "Move Constructor llamado" << std::endl;
    }

    // Move Assignment Operator
    Archivo& operator=(Archivo&& other) noexcept {
        if (this != &other) {
            if (file) {
                fclose(file);
            }
            file = other.file;
            other.file = nullptr;
            std::cout << "Move Assignment Operator llamado" << std::endl;
        }
        return *this;
    }

    // Prohibir la copia
    Archivo(const Archivo&) = delete;
    Archivo& operator=(const Archivo&) = delete;
};

int main() {
    Archivo archivo1("example.txt", "w");
    Archivo archivo2 = std::move(archivo1);  // std::move convierte 'archivo1' en un R-value

    // archivo1 no debe usarse después de ser movido
    return 0;
}
<---Ejemplo de Gestión Eficiente de Recursos Result--->
<---Ejemplo de Evitar Copias Costosas--->
```cpp
#include <iostream>
#include <string>

class CadenaGrande {
public:
    std::string* datos;

    CadenaGrande(const std::string& str) : datos(new std::string(str)) {
        std::cout << "Constructor llamado para " << *datos << std::endl;
    }

    ~CadenaGrande() {
        delete datos;
        std::cout << "Destructor llamado" << std::endl;
    }

    // Move Constructor
    CadenaGrande(CadenaGrande&& other) noexcept : datos(other.datos) {
        other.datos = nullptr;
        std::cout << "Move Constructor llamado" << std::endl;
    }

    // Move Assignment Operator
    CadenaGrande& operator=(CadenaGrande&& other) noexcept {
        if (this != &other) {
            delete datos;
            datos = other.datos;
            other.datos = nullptr;
            std::cout << "Move Assignment Operator llamado" << std::endl;
        }
        return *this;
    }
};

int main() {
    CadenaGrande str1("Una cadena muy grande y costosa de copiar");
    CadenaGrande str2 = std::move(str1);  // std::move convierte 'str1' en un R-value

    return 0;
}
<---Ejemplo de Evitar Copias Costosas Result--->
<---Ejemplo Básico de Movimiento--->
```cpp
#include <iostream>
#include <utility>

class MiClase {
public:
    int* data;

    // Constructor normal
    MiClase(int value) : data(new int(value)) {
        std::cout << "Constructor llamado para " << *data << std::endl;
    }

    // Destructor
    ~MiClase() {
        delete data;
        std::cout << "Destructor llamado" << std::endl;
    }

    // Move Constructor
    MiClase(MiClase&& other) noexcept : data(other.data) {
        other.data = nullptr;
        std::cout << "Move Constructor llamado" << std::endl;
    }

    // Move Assignment Operator
    MiClase& operator=(MiClase&& other) noexcept {
        if (this != &other) {
            delete data;
            data = other.data;
            other.data = nullptr;
            std::cout << "Move Assignment Operator llamado" << std::endl;
        }
        return *this;
    }

    void mostrar() const {
        if (data) {
            std::cout << "Valor: " << *data << std::endl;
        } else {
            std::cout << "No hay datos" << std::endl;
        }
    }
};

int main() {
    MiClase obj1(10);
    MiClase obj2 = std::move(obj1);  // std::move convierte 'obj1' en un R-value
    obj2.mostrar();
    obj1.mostrar();  // No hay datos, ya que los datos fueron movidos

    MiClase obj3(20);
    obj3 = std::move(obj2);  // std::move convierte 'obj2' en un R-value
    obj3.mostrar();
    obj2.mostrar();  // No hay datos, ya que los datos fueron movidos

    return 0;
}
<---Ejemplo Básico de Movimiento Result--->
<---1. **Estado del Objeto Original**--->
<---1. **Estado del Objeto Original** Result--->
<---2. **Evitar Uso Inadecuado**--->
<---2. **Evitar Uso Inadecuado** Result--->
<---Ejemplo Incorrecto--->
```cpp
MiClase obj1(10);
MiClase obj2 = std::move(obj1);
obj1.mostrar();  // No se debe usar obj1 después de mover sus recursos
<---Ejemplo Incorrecto Result--->
<---3. **Implementación Correcta de Move Semantics**--->
<---3. **Implementación Correcta de Move Semantics** Result--->
<---4. **Beneficios de Rendimiento**--->
<---4. **Beneficios de Rendimiento** Result--->
<---Características de L-Value--->
<---Características de L-Value Result--->
<---Ejemplos de L-Value--->
```cpp
int x = 5;         // 'x' es un L-value
int* p = &x;       // 'p' es un L-value que contiene la dirección de 'x'
x = 10;            // 'x' puede estar en el lado izquierdo de la asignación
*p = 20;           // '*p' es un L-value que puede estar en el lado izquierdo de la asignación

int& ref = x;      // 'ref' es un L-value reference a 'x'
ref = 30;          // 'ref' puede estar en el lado izquierdo de la asignación
<---Ejemplos de L-Value Result--->
<---R-Value--->
<---R-Value Result--->
<---Ejemplos de R-Value--->
```cpp
int y = 5;         // '5' es un R-value
int z = y + 3;     // 'y + 3' es un R-value
<---Ejemplos de R-Value Result--->
<---Move Constructor y Move Assignment Operator--->
<---Move Constructor y Move Assignment Operator Result--->
<---Move Constructor--->
```cpp
class MiClase {
public:
    int* data;

    // Constructor
    MiClase(int value) : data(new int(value)) {}

    // Move Constructor
    MiClase(MiClase&& other) noexcept : data(other.data) {
        other.data = nullptr;
        std::cout << "Move Constructor llamado" << std::endl;
    }
};
<---Move Constructor Result--->
<---Ejemplos Prácticos--->
```cpp
#include <iostream>

int main() {
    // Literales
    int x = 5;         // '5' es un R-value
    double y = 3.14;   // '3.14' es un R-value

    // Resultados de Expresiones
    int z = x + 2;     // 'x + 2' es un R-value

    // Llamadas a Funciones que Devuelven R-Values
    std::string s1 = "hello";          // "hello" es un R-value
    std::string s2 = s1 + " world";    // 's1 + " world"' es un R-value

    // Mostrando los valores
    std::cout << "x: " << x << std::endl;
    std::cout << "y: " << y << std::endl;
    std::cout << "z: " << z << std::endl;
    std::cout << "s1: " << s1 << std::endl;
    std::cout << "s2: " << s2 << std::endl;

    return 0;
}
<---Ejemplos Prácticos Result--->
<---Sintaxis--->
```cpp
#include <utility>

std::move(obj);  // Convierte 'obj' en un R-value
<---Sintaxis Result--->
<---Ejemplo con R-Value References--->
```cpp
#include <iostream>

class MiClase {
public:
    int* data;

    // Constructor normal
    MiClase(int value) : data(new int(value)) {
        std::cout << "Constructor llamado para " << *data << std::endl;
    }

    // Destructor
    ~MiClase() {
        delete data;
        std::cout << "Destructor llamado" << std::endl;
    }

    // Move Constructor
    MiClase(MiClase&& other) noexcept : data(other.data) {
        other.data = nullptr;
        std::cout << "Move Constructor llamado" << std::endl;
    }

    // Move Assignment Operator
    MiClase& operator=(MiClase&& other) noexcept {
        if (this != &other) {
            delete data;
            data = other.data;
            other.data = nullptr;
            std::cout << "Move Assignment Operator llamado" << std::endl;
        }
        return *this;
    }

    void mostrar() const {
        if (data) {
            std::cout << "Valor: " << *data << std::endl;
        } else {
            std::cout << "No hay datos" << std::endl;
        }
    }
};

int main() {
    MiClase obj1(10);
    MiClase obj2 = std::move(obj1);  // Move Constructor llamado
    obj2.mostrar();
    obj1.mostrar();  // No hay datos, ya que los datos fueron movidos

    MiClase obj3(20);
    obj3 = std::move(obj2);  // Move Assignment Operator llamado
    obj3.mostrar();
    obj2.mostrar();  // No hay datos, ya que los datos fueron movidos

    return 0;
}
<---Ejemplo con R-Value References Result--->
<---Ejemplo de R-Value References--->
```cpp
#include <iostream>

class MiClase {
public:
    int* data;

    // Constructor normal
    MiClase(int value) : data(new int(value)) {
        std::cout << "Constructor llamado para " << *data << std::endl;
    }

    // Destructor
    ~MiClase() {
        delete data;
        std::cout << "Destructor llamado" << std::endl;
    }

    // Move Constructor
    MiClase(MiClase&& other) noexcept : data(other.data) {
        other.data = nullptr;
        std::cout << "Move Constructor llamado" << std::endl;
    }

    // Move Assignment Operator
    MiClase& operator=(MiClase&& other) noexcept {
        if (this != &other) {
            delete data;
            data = other.data;
            other.data = nullptr;
            std::cout << "Move Assignment Operator llamado" << std::endl;
        }
        return *this;
    }

    void mostrar() const {
        if (data) {
            std::cout << "Valor: " << *data << std::endl;
        } else {
            std::cout << "No hay datos" << std::endl;
        }
    }
};

int main() {
    MiClase obj1(10);
    MiClase obj2 = std::move(obj1);  // Move Constructor llamado
    obj2.mostrar();
    obj1.mostrar();  // No hay datos, ya que los datos fueron movidos

    MiClase obj3(20);
    obj3 = std::move(obj2);  // Move Assignment Operator llamado
    obj3.mostrar();
    obj2.mostrar();  // No hay datos, ya que los datos fueron movidos

    return 0;
}
<---Ejemplo de R-Value References Result--->
<---Ejemplo de Sobrecarga de Funciones con L-Values y R-Values--->
```cpp
#include <iostream>

void procesar(int& x) {
    std::cout << "L-value reference: " << x << std::endl;
}

void procesar(int&& x) {
    std::cout << "R-value reference: " << x << std::endl;
}

int main() {
    int a = 5;
    procesar(a);        // Llama a la versión de L-value reference
    procesar(10);       // Llama a la versión de R-value reference
    procesar(a + 3);    // Llama a la versión de R-value reference

    return 0;
}
<---Ejemplo de Sobrecarga de Funciones con L-Values y R-Values Result--->
<---Asignación a una Variable--->
```cpp
int x = 5;         // '5' es un R-value asignado a 'x'
double y = 3.14;   // '3.14' es un R-value asignado a 'y'
<---Asignación a una Variable Result--->
<---Paso como Argumentos a Funciones--->
```cpp
#include <iostream>

// Función que toma un parámetro por valor
void procesar(int x) {
    std::cout << "Valor: " << x << std::endl;
}

int main() {
    procesar(10);   // '10' es un R-value pasado como argumento
    return 0;
}
<---Paso como Argumentos a Funciones Result--->
<---Inicialización de Variables--->
```cpp
int a = 5;         // '5' es un R-value usado para inicializar 'a'
double b = a + 3;  // 'a + 3' es un R-value usado para inicializar 'b'
<---Inicialización de Variables Result--->
<---Uso en Expresiones y Operadores--->
```cpp
#include <iostream>

int main() {
    int x = 5;
    int y = 10;
    int z = x + y;  // 'x + y' es un R-value usado en una expresión

    std::cout << "Resultado: " << z << std::endl;
    return 0;
}
<---Uso en Expresiones y Operadores Result--->
<---Uso con R-Value References--->
```cpp
#include <iostream>

class MiClase {
public:
    int* data;

    // Constructor normal
    MiClase(int value) : data(new int(value)) {
        std::cout << "Constructor llamado para " << *data << std::endl;
    }

    // Destructor
    ~MiClase() {
        delete data;
        std::cout << "Destructor llamado" << std::endl;
    }

    // Move Constructor
    MiClase(MiClase&& other) noexcept : data(other.data) {
        other.data = nullptr;
        std::cout << "Move Constructor llamado" << std::endl;
    }

    // Move Assignment Operator
    MiClase& operator=(MiClase&& other) noexcept {
        if (this != &other) {
            delete data;
            data = other.data;
            other.data = nullptr;
            std::cout << "Move Assignment Operator llamado" << std::endl;
        }
        return *this;
    }

    void mostrar() const {
        if (data) {
            std::cout << "Valor: " << *data << std::endl;
        } else {
            std::cout << "No hay datos" << std::endl;
        }
    }
};

int main() {
    MiClase obj1(10);
    MiClase obj2 = std::move(obj1);  // 'std::move(obj1)' convierte 'obj1' en un R-value
    obj2.mostrar();
    obj1.mostrar();  // No hay datos, ya que los datos fueron movidos

    MiClase obj3(20);
    obj3 = std::move(obj2);  // 'std::move(obj2)' convierte 'obj2' en un R-value
    obj3.mostrar();
    obj2.mostrar();  // No hay datos, ya que los datos fueron movidos

    return 0;
}
<---Uso con R-Value References Result--->
<---Definición de una Clase con Move Semantics--->
```cpp
#include <iostream>
#include <utility>  // Para std::move

class MiClase {
public:
    int* data;

    // Constructor normal
    MiClase(int value) : data(new int(value)) {
        std::cout << "Constructor llamado para " << *data << std::endl;
    }

    // Destructor
    ~MiClase() {
        delete data;
        std::cout << "Destructor llamado" << std::endl;
    }

    // Move Constructor
    MiClase(MiClase&& other) noexcept : data(other.data) {
        other.data = nullptr;
        std::cout << "Move Constructor llamado" << std::endl;
    }

    // Move Assignment Operator
    MiClase& operator=(MiClase&& other) noexcept {
        if (this != &other) {
            delete data;
            data = other.data;
            other.data = nullptr;
            std::cout << "Move Assignment Operator llamado" << std::endl;
        }
        return *this;
    }

    void mostrar() const {
        if (data) {
            std::cout << "Valor: " << *data << std::endl;
        } else {
            std::cout << "No hay datos" << std::endl;
        }
    }
};

int main() {
    MiClase obj1(10);
    MiClase obj2 = std::move(obj1);  // std::move convierte 'obj1' en un R-value
    obj2.mostrar();
    obj1.mostrar();  // No hay datos, ya que los datos fueron movidos

    MiClase obj3(20);
    obj3 = std::move(obj2);  // std::move convierte 'obj2' en un R-value
    obj3.mostrar();
    obj2.mostrar();  // No hay datos, ya que los datos fueron movidos

    return 0;
}
<---Definición de una Clase con Move Semantics Result--->
<---Implementación Simplificada de `std::move`--->
```cpp
namespace std {
    template <typename T>
    typename remove_reference<T>::type&& move(T&& arg) noexcept {
        return static_cast<typename remove_reference<T>::type&&>(arg);
    }
}
<---Implementación Simplificada de `std::move` Result--->
<---Ejemplo: Move Constructor y Move Assignment Operator--->
```cpp
#include <iostream>
#include <utility>

class MiClase {
public:
    int* data;

    // Constructor normal
    MiClase(int value) : data(new int(value)) {
        std::cout << "Constructor llamado para " << *data << std::endl;
    }

    // Destructor
    ~MiClase() {
        delete data;
        std::cout << "Destructor llamado" << std::endl;
    }

    // Move Constructor
    MiClase(MiClase&& other) noexcept : data(other.data) {
        other.data = nullptr;
        std::cout << "Move Constructor llamado" << std::endl;
    }

    // Move Assignment Operator
    MiClase& operator=(MiClase&& other) noexcept {
        if (this != &other) {
            delete data;
            data = other.data;
            other.data = nullptr;
            std::cout << "Move Assignment Operator llamado" << std::endl;
        }
        return *this;
    }

    void mostrar() const {
        if (data) {
            std::cout << "Valor: " << *data << std::endl;
        } else {
            std::cout << "No hay datos" << std::endl;
        }
    }
};

int main() {
    MiClase obj1(10);
    MiClase obj2 = std::move(obj1);  // Move Constructor llamado
    obj2.mostrar();
    obj1.mostrar();  // No hay datos, ya que los datos fueron movidos

    MiClase obj3(20);
    obj3 = std::move(obj2);  // Move Assignment Operator llamado
    obj3.mostrar();
    obj2.mostrar();  // No hay datos, ya que los datos fueron movidos

    return 0;
}
<---Ejemplo: Move Constructor y Move Assignment Operator Result--->
<---Ejemplo--->
```cpp
class MiClase {
public:
    int* data;

    MiClase(int value) : data(new int(value)) {}

    ~MiClase() {
        delete data;
    }

    // Move Constructor
    MiClase(MiClase&& other) noexcept : data(other.data) {
        other.data = nullptr;
    }

    // Move Assignment Operator
    MiClase& operator=(MiClase&& other) noexcept {
        if (this != &other) {
            delete data;
            data = other.data;
            other.data = nullptr;
        }
        return *this;
    }

    // Prohibir la copia
    MiClase(const MiClase&) = delete;
    MiClase& operator=(const MiClase&) = delete;
};
<---Ejemplo Result--->
<---Comparación de Copy vs Move--->
```cpp
#include <vector>

std::vector<int> generarVector() {
    std::vector<int> v = {1, 2, 3, 4, 5};
    return v;  // Devuelve un R-value que puede ser movido en lugar de copiado
}

int main() {
    std::vector<int> vec = generarVector();  // Move semantics optimizan esta operación
    return 0;
}
<---Comparación de Copy vs Move Result--->
<---Ejemplo de API con Move Semantics--->
```cpp
#include <vector>
#include <utility>

class Contenedor {
    std::vector<int> datos;

public:
    void setDatos(std::vector<int>&& nuevosDatos) {
        datos = std::move(nuevosDatos);  // Mueve los datos en lugar de copiarlos
    }

    const std::vector<int>& getDatos() const {
        return datos;
    }
};
<---Ejemplo de API con Move Semantics Result--->
<---Consideraciones al Usar `std::move`--->
<---Consideraciones al Usar `std::move` Result--->
<---Ejemplo Básico--->
```cpp
#include <iostream>
#include <utility>

class MiClase {
public:
    int* data;

    // Constructor
    MiClase(int value) : data(new int(value)) {
        std::cout << "Constructor llamado para " << *data << std::endl;
    }

    // Destructor
    ~MiClase() {
        delete data;
        std::cout << "Destructor llamado" << std::endl;
    }

    // Move Constructor
    MiClase(MiClase&& other) noexcept : data(other.data) {
        other.data = nullptr;
        std::cout << "Move Constructor llamado" << std::endl;
    }

    // Move Assignment Operator
    MiClase& operator=(MiClase&& other) noexcept {
        if (this != &other) {
            delete data;
            data = other.data;
            other.data = nullptr;
            std::cout << "Move Assignment Operator llamado" << std::endl;
        }
        return *this;
    }

    void mostrar() const {
        if (data) {
            std::cout << "Valor: " << *data << std::endl;
        } else {
            std::cout << "No hay datos" << std::endl;
        }
    }
};

int main() {
    MiClase obj1(10);
    MiClase obj2 = std::move(obj1);  // std::move convierte 'obj1' en un R-value
    obj2.mostrar();
    obj1.mostrar();  // No hay datos, ya que los datos fueron movidos

    MiClase obj3(20);
    obj3 = std::move(obj2);  // std::move convierte 'obj2' en un R-value
    obj3.mostrar();
    obj2.mostrar();  // No hay datos, ya que los datos fueron movidos

    return 0;
}
<---Ejemplo Básico Result--->
<---Ejemplo de Optimización de Rendimiento--->
```cpp
#include <vector>

std::vector<int> generarVector() {
    std::vector<int> v = {1, 2, 3, 4, 5};
    return v;  // Devuelve un R-value que puede ser movido en lugar de copiado
}

int main() {
    std::vector<int> vec = generarVector();  // Move semantics optimizan esta operación
    for (int num : vec) {
        std::cout << num << " ";
    }
    std::cout << std::endl;
    return 0;
}
<---Ejemplo de Optimización de Rendimiento Result--->
<---Ejemplo de Gestión Eficiente de Recursos--->
```cpp
#include <iostream>
#include <utility>

class Archivo {
public:
    FILE* file;

    // Constructor
    Archivo(const char* nombre, const char* modo) : file(fopen(nombre, modo)) {
        if (file) {
            std::cout << "Archivo abierto: " << nombre << std::endl;
        } else {
            std::cerr << "Error al abrir el archivo: " << nombre << std::endl;
        }
    }

    // Destructor
    ~Archivo() {
        if (file) {
            fclose(file);
            std::cout << "Archivo cerrado" << std::endl;
        }
    }

    // Move Constructor
    Archivo(Archivo&& other) noexcept : file(other.file) {
        other.file = nullptr;
        std::cout << "Move Constructor llamado" << std::endl;
    }

    // Move Assignment Operator
    Archivo& operator=(Archivo&& other) noexcept {
        if (this != &other) {
            if (file) {
                fclose(file);
            }
            file = other.file;
            other.file = nullptr;
            std::cout << "Move Assignment Operator llamado" << std::endl;
        }
        return *this;
    }

    // Prohibir la copia
    Archivo(const Archivo&) = delete;
    Archivo& operator=(const Archivo&) = delete;
};

int main() {
    Archivo archivo1("example.txt", "w");
    Archivo archivo2 = std::move(archivo1);  // std::move convierte 'archivo1' en un R-value

    // archivo1 no debe usarse después de ser movido
    return 0;
}
<---Ejemplo de Gestión Eficiente de Recursos Result--->
<---Ejemplo de Evitar Copias Costosas--->
```cpp
#include <iostream>
#include <string>

class CadenaGrande {
public:
    std::string* datos;

    CadenaGrande(const std::string& str) : datos(new std::string(str)) {
        std::cout << "Constructor llamado para " << *datos << std::endl;
    }

    ~CadenaGrande() {
        delete datos;
        std::cout << "Destructor llamado" << std::endl;
    }

    // Move Constructor
    CadenaGrande(CadenaGrande&& other) noexcept : datos(other.datos) {
        other.datos = nullptr;
        std::cout << "Move Constructor llamado" << std::endl;
    }

    // Move Assignment Operator
    CadenaGrande& operator=(CadenaGrande&& other) noexcept {
        if (this != &other) {
            delete datos;
            datos = other.datos;
            other.datos = nullptr;
            std::cout << "Move Assignment Operator llamado" << std::endl;
        }
        return *this;
    }
};

int main() {
    CadenaGrande str1("Una cadena muy grande y costosa de copiar");
    CadenaGrande str2 = std::move(str1);  // std::move convierte 'str1' en un R-value

    return 0;
}
<---Ejemplo de Evitar Copias Costosas Result--->
<---Ejemplo Básico de Movimiento--->
```cpp
#include <iostream>
#include <utility>

class MiClase {
public:
    int* data;

    // Constructor normal
    MiClase(int value) : data(new int(value)) {
        std::cout << "Constructor llamado para " << *data << std::endl;
    }

    // Destructor
    ~MiClase() {
        delete data;
        std::cout << "Destructor llamado" << std::endl;
    }

    // Move Constructor
    MiClase(MiClase&& other) noexcept : data(other.data) {
        other.data = nullptr;
        std::cout << "Move Constructor llamado" << std::endl;
    }

    // Move Assignment Operator
    MiClase& operator=(MiClase&& other) noexcept {
        if (this != &other) {
            delete data;
            data = other.data;
            other.data = nullptr;
            std::cout << "Move Assignment Operator llamado" << std::endl;
        }
        return *this;
    }

    void mostrar() const {
        if (data) {
            std::cout << "Valor: " << *data << std::endl;
        } else {
            std::cout << "No hay datos" << std::endl;
        }
    }
};

int main() {
    MiClase obj1(10);
    MiClase obj2 = std::move(obj1);  // std::move convierte 'obj1' en un R-value
    obj2.mostrar();
    obj1.mostrar();  // No hay datos, ya que los datos fueron movidos

    MiClase obj3(20);
    obj3 = std::move(obj2);  // std::move convierte 'obj2' en un R-value
    obj3.mostrar();
    obj2.mostrar();  // No hay datos, ya que los datos fueron movidos

    return 0;
}
<---Ejemplo Básico de Movimiento Result--->
<---1. **Estado del Objeto Original**--->
<---1. **Estado del Objeto Original** Result--->
<---2. **Evitar Uso Inadecuado**--->
<---2. **Evitar Uso Inadecuado** Result--->
<---Ejemplo Incorrecto--->
```cpp
MiClase obj1(10);
MiClase obj2 = std::move(obj1);
obj1.mostrar();  // No se debe usar obj1 después de mover sus recursos
<---Ejemplo Incorrecto Result--->
<---3. **Implementación Correcta de Move Semantics**--->
<---3. **Implementación Correcta de Move Semantics** Result--->
<---4. **Beneficios de Rendimiento**--->
<---4. **Beneficios de Rendimiento** Result--->
<---Copy Constructor--->
```cpp
class MiClase {
public:
    int* data;

    // Constructor
    MiClase(int value) : data(new int(value)) {}

    // Copy Constructor
    MiClase(const MiClase& other) : data(new int(*other.data)) {
        std::cout << "Copy Constructor llamado" << std::endl;
    }
};
<---Copy Constructor Result--->
<---Copy Assignment Operator--->
```cpp
class MiClase {
public:
    int* data;

    // Constructor
    MiClase(int value) : data(new int(value)) {}

    // Copy Assignment Operator
    MiClase& operator=(const MiClase& other) {
        if (this != &other) {
            delete data;
            data = new int(*other.data);
            std::cout << "Copy Assignment Operator llamado" << std::endl;
        }
        return *this;
    }
};
<---Copy Assignment Operator Result--->
<---Ejemplo de Semántica de Copia--->
```cpp
int main() {
    MiClase obj1(10);
    MiClase obj2 = obj1;  // Llama al copy constructor
    MiClase obj3(20);
    obj3 = obj1;          // Llama al copy assignment operator
    return 0;
}
<---Ejemplo de Semántica de Copia Result--->
<---Move Assignment Operator--->
```cpp
class MiClase {
public:
    int* data;

    // Constructor
    MiClase(int value) : data(new int(value)) {}

    // Move Assignment Operator
    MiClase& operator=(MiClase&& other) noexcept {
        if (this != &other) {
            delete data;
            data = other.data;
            other.data = nullptr;
            std::cout << "Move Assignment Operator llamado" << std::endl;
        }
        return *this;
    }
};
<---Move Assignment Operator Result--->
<---Ejemplo de Semántica de Movimiento--->
```cpp
#include <utility>

int main() {
    MiClase obj1(10);
    MiClase obj2 = std::move(obj1);  // Llama al move constructor
    MiClase obj3(20);
    obj3 = std::move(obj2);          // Llama al move assignment operator
    return 0;
}
<---Ejemplo de Semántica de Movimiento Result--->
<---Semántica de Copia--->
```cpp
class MiClase {
public:
    int* data;

    MiClase(int value) : data(new int(value)) {}

    MiClase(const MiClase& other) : data(new int(*other.data)) {
        std::cout << "Copy Constructor llamado" << std::endl;
    }

    MiClase& operator=(const MiClase& other) {
        if (this != &other) {
            delete data;
            data = new int(*other.data);
            std::cout << "Copy Assignment Operator llamado" << std::endl;
        }
        return *this;
    }

    ~MiClase() {
        delete data;
    }
};
<---Semántica de Copia Result--->
<---Semántica de Movimiento--->
```cpp
class MiClase {
public:
    int* data;

    MiClase(int value) : data(new int(value)) {}

    MiClase(MiClase&& other) noexcept : data(other.data) {
        other.data = nullptr;
        std::cout << "Move Constructor llamado" << std::endl;
    }

    MiClase& operator=(MiClase&& other) noexcept {
        if (this != &other) {
            delete data;
            data = other.data;
            other.data = nullptr;
            std::cout << "Move Assignment Operator llamado" << std::endl;
        }
        return *this;
    }

    ~MiClase() {
        delete data;
    }
};
<---Semántica de Movimiento Result--->
