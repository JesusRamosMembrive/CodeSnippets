<---EXPLANATION--->
### Move Semantics y Definición de L-Value en C++

Las move semantics (semánticas de movimiento) y el concepto de L-value son fundamentales en C++ moderno para la gestión eficiente de recursos y la optimización del rendimiento. Comprender estos conceptos es crucial para escribir código C++ eficiente y robusto.

#### Definición de L-Value

En C++, un **L-value** (Left value) es una expresión que representa una ubicación en memoria que tiene un identificador persistente. Los L-values se pueden encontrar en el lado izquierdo de una asignación, lo que significa que pueden recibir un valor.

##### Características de L-Value

- **Asignabilidad:** Los L-values pueden aparecer en el lado izquierdo de una asignación.
- **Dirección en Memoria:** Los L-values tienen una dirección en memoria, lo que significa que se puede tomar su dirección utilizando el operador `&`.
- **Persistencia:** Representan una entidad que persiste más allá de la expresión en la que se usan.

##### Ejemplos de L-Value

```cpp
int x = 5;         // 'x' es un L-value
int* p = &x;       // 'p' es un L-value que contiene la dirección de 'x'
x = 10;            // 'x' puede estar en el lado izquierdo de la asignación
*p = 20;           // '*p' es un L-value que puede estar en el lado izquierdo de la asignación

int& ref = x;      // 'ref' es un L-value reference a 'x'
ref = 30;          // 'ref' puede estar en el lado izquierdo de la asignación
```

En este ejemplo:
- `x`, `p`, `*p` y `ref` son L-values porque tienen una ubicación en memoria y pueden recibir un valor.

#### Move Semantics

Las **move semantics** se introdujeron en C++11 para optimizar la transferencia de recursos entre objetos. En lugar de copiar recursos (lo cual puede ser costoso), las move semantics permiten mover recursos de un objeto a otro, dejando el objeto original en un estado válido pero no especificado.

##### R-Value

Antes de entrar en detalles sobre las move semantics, es importante entender los R-values. Un **R-value** (Right value) es una expresión que no tiene una dirección en memoria accesible y es temporal. Los R-values típicamente se utilizan en el lado derecho de una asignación.

##### Ejemplos de R-Value

```cpp
int y = 5;         // '5' es un R-value
int z = y + 3;     // 'y + 3' es un R-value
```

En este ejemplo:
- `5` y `y + 3` son R-values porque son temporales y no tienen una dirección en memoria accesible directamente.

##### Move Constructor y Move Assignment Operator

Las move semantics se implementan principalmente mediante el constructor de movimiento (move constructor) y el operador de asignación por movimiento (move assignment operator).

###### Move Constructor

El move constructor transfiere recursos de un objeto a otro, dejando el objeto original en un estado válido pero indeterminado.

```cpp
#include <iostream>
#include <utility>

class MiClase {
private:
    int* data;

public:
    // Constructor
    MiClase(int value) : data(new int(value)) {
        std::cout << "Constructor llamado para " << *data << std::endl;
    }

    // Destructor
    ~MiClase() {
        delete data;
        std::cout << "Destructor llamado" << std::endl;
    }

    // Move Constructor
    MiClase(MiClase&& other) noexcept : data(other.data) {
        other.data = nullptr;
        std::cout << "Move Constructor llamado" << std::endl;
    }

    // Move Assignment Operator
    MiClase& operator=(MiClase&& other) noexcept {
        if (this != &other) {
            delete data;
            data = other.data;
            other.data = nullptr;
            std::cout << "Move Assignment Operator llamado" << std::endl;
        }
        return *this;
    }

    void mostrar() const {
        if (data) {
            std::cout << "Valor: " << *data << std::endl;
        } else {
            std::cout << "No hay datos" << std::endl;
        }
    }
};

int main() {
    MiClase obj1(10);
    MiClase obj2 = std::move(obj1);  // Move Constructor llamado
    obj2.mostrar();
    obj1.mostrar();  // No hay datos, ya que los datos fueron movidos

    MiClase obj3(20);
    obj3 = std::move(obj2);  // Move Assignment Operator llamado
    obj3.mostrar();
    obj2.mostrar();  // No hay datos, ya que los datos fueron movidos

    return 0;
}
```

En este ejemplo:
- `MiClase` tiene un move constructor y un move assignment operator.
- `std::move` se utiliza para convertir un L-value a un R-value, permitiendo que las move semantics se apliquen.

#### Ventajas de Move Semantics

1. **Eficiencia:** Evitan copias innecesarias de recursos, lo que puede mejorar significativamente el rendimiento, especialmente para objetos grandes o que gestionan recursos externos como memoria dinámica o archivos.
2. **Seguridad:** Las move semantics dejan el objeto original en un estado válido pero indeterminado, evitando problemas de recursos duplicados.

### Conclusión

Entender los L-values y R-values, junto con las move semantics, es esencial para escribir código C++ eficiente y robusto. Las move semantics permiten transferir recursos de manera eficiente, optimizando el rendimiento y evitando copias costosas. Al implementar correctamente el move constructor y el move assignment operator, los desarrolladores pueden aprovechar estas optimizaciones en sus programas.
### Definición de R-Value en C++

En C++, un **R-value** (Right value) es una expresión que no tiene una dirección en memoria accesible directamente y es generalmente temporal. Los R-values típicamente aparecen en el lado derecho de una asignación, de ahí su nombre. A diferencia de los L-values, los R-values no tienen un identificador persistente ni una dirección en memoria que pueda ser tomada con el operador `&`.

#### Características de los R-Values

1. **Temporalidad:** Los R-values son generalmente temporales y solo existen durante la evaluación de una expresión.
2. **No Asignables:** No se pueden asignar valores a R-values porque no tienen un identificador persistente ni una ubicación en memoria accesible.
3. **Optimización:** Los R-values son fundamentales para las optimizaciones como las move semantics, que permiten la transferencia eficiente de recursos.

#### Ejemplos de R-Values

- Literales de datos, como números y cadenas.
- El resultado de operaciones aritméticas.
- Objetos temporales creados como resultado de una expresión.

##### Ejemplos Prácticos

```cpp
int x = 5;         // '5' es un R-value
int y = x + 2;     // 'x + 2' es un R-value

std::string s1 = "hello";        // "hello" es un R-value
std::string s2 = s1 + " world";  // 's1 + " world"' es un R-value
```

En estos ejemplos:
- `5` y `x + 2` son R-values porque son valores temporales que no tienen un identificador persistente.
- `"hello"` y `s1 + " world"` son R-values porque son valores temporales que resultan de expresiones.

#### R-Value References

Introducidas en C++11, las **R-value references** permiten tomar posesión de un R-value, proporcionando un mecanismo para implementar move semantics y optimizar el manejo de recursos.

##### Sintaxis

```cpp
int&& rvalue_ref = 10;  // rvalue_ref es una referencia a un R-value
```

##### Ejemplo con R-Value References

```cpp
#include <iostream>

class MiClase {
public:
    int* data;

    // Constructor normal
    MiClase(int value) : data(new int(value)) {
        std::cout << "Constructor llamado para " << *data << std::endl;
    }

    // Destructor
    ~MiClase() {
        delete data;
        std::cout << "Destructor llamado" << std::endl;
    }

    // Move Constructor
    MiClase(MiClase&& other) noexcept : data(other.data) {
        other.data = nullptr;
        std::cout << "Move Constructor llamado" << std::endl;
    }

    // Move Assignment Operator
    MiClase& operator=(MiClase&& other) noexcept {
        if (this != &other) {
            delete data;
            data = other.data;
            other.data = nullptr;
            std::cout << "Move Assignment Operator llamado" << std::endl;
        }
        return *this;
    }

    void mostrar() const {
        if (data) {
            std::cout << "Valor: " << *data << std::endl;
        } else {
            std::cout << "No hay datos" << std::endl;
        }
    }
};

int main() {
    MiClase obj1(10);
    MiClase obj2 = std::move(obj1);  // Move Constructor llamado
    obj2.mostrar();
    obj1.mostrar();  // No hay datos, ya que los datos fueron movidos

    MiClase obj3(20);
    obj3 = std::move(obj2);  // Move Assignment Operator llamado
    obj3.mostrar();
    obj2.mostrar();  // No hay datos, ya que los datos fueron movidos

    return 0;
}
```

En este ejemplo:
- `std::move` convierte un L-value en un R-value, permitiendo que las move semantics se apliquen.
- `MiClase` utiliza un move constructor y un move assignment operator para transferir eficientemente recursos de un objeto a otro.

### Conclusión

En C++, un R-value es una expresión temporal que no tiene una dirección en memoria accesible directamente. Los R-values son fundamentales para las optimizaciones de rendimiento como las move semantics, que permiten la transferencia eficiente de recursos en el lenguaje. Entender los R-values y cómo utilizarlos a través de R-value references es esencial para escribir código C++ eficiente y moderno.
### Identificación de un R-Value en C++

En C++, identificar un R-value (Right value) es esencial para comprender el comportamiento de las expresiones y cómo se gestionan los recursos. Los R-values son temporales y no tienen una dirección en memoria accesible. Aquí se explicará cómo identificarlos y se proporcionarán ejemplos prácticos.

#### Características de los R-Values

1. **Temporalidad:** Los R-values son temporales y existen solo durante la evaluación de una expresión.
2. **No Asignables:** No pueden aparecer en el lado izquierdo de una asignación.
3. **No Pueden Tomarse Direcciones:** No tienen una dirección de memoria accesible directamente mediante el operador `&`.

#### Ejemplos de R-Values

1. **Literales:** Los valores literales como números y cadenas.
2. **Resultados de Expresiones:** El resultado de operaciones aritméticas y lógicas.
3. **Llamadas a Funciones que Devuelven R-Values:** Llamadas a funciones que devuelven valores temporales.

##### Ejemplos Prácticos

```cpp
#include <iostream>

int main() {
    // Literales
    int x = 5;         // '5' es un R-value
    double y = 3.14;   // '3.14' es un R-value

    // Resultados de Expresiones
    int z = x + 2;     // 'x + 2' es un R-value

    // Llamadas a Funciones que Devuelven R-Values
    std::string s1 = "hello";          // "hello" es un R-value
    std::string s2 = s1 + " world";    // 's1 + " world"' es un R-value

    // Mostrando los valores
    std::cout << "x: " << x << std::endl;
    std::cout << "y: " << y << std::endl;
    std::cout << "z: " << z << std::endl;
    std::cout << "s1: " << s1 << std::endl;
    std::cout << "s2: " << s2 << std::endl;

    return 0;
}
```

En este ejemplo:
- `5`, `3.14`, `x + 2`, `"hello"`, y `s1 + " world"` son R-values porque son valores temporales.

#### R-Value References

En C++11 y posteriores, las R-value references (`&&`) permiten capturar y manipular R-values. Son esenciales para implementar move semantics y optimizar el rendimiento.

##### Ejemplo de R-Value References

```cpp
#include <iostream>

class MiClase {
public:
    int* data;

    // Constructor normal
    MiClase(int value) : data(new int(value)) {
        std::cout << "Constructor llamado para " << *data << std::endl;
    }

    // Destructor
    ~MiClase() {
        delete data;
        std::cout << "Destructor llamado" << std::endl;
    }

    // Move Constructor
    MiClase(MiClase&& other) noexcept : data(other.data) {
        other.data = nullptr;
        std::cout << "Move Constructor llamado" << std::endl;
    }

    // Move Assignment Operator
    MiClase& operator=(MiClase&& other) noexcept {
        if (this != &other) {
            delete data;
            data = other.data;
            other.data = nullptr;
            std::cout << "Move Assignment Operator llamado" << std::endl;
        }
        return *this;
    }

    void mostrar() const {
        if (data) {
            std::cout << "Valor: " << *data << std::endl;
        } else {
            std::cout << "No hay datos" << std::endl;
        }
    }
};

int main() {
    MiClase obj1(10);
    MiClase obj2 = std::move(obj1);  // Move Constructor llamado
    obj2.mostrar();
    obj1.mostrar();  // No hay datos, ya que los datos fueron movidos

    MiClase obj3(20);
    obj3 = std::move(obj2);  // Move Assignment Operator llamado
    obj3.mostrar();
    obj2.mostrar();  // No hay datos, ya que los datos fueron movidos

    return 0;
}
```

En este ejemplo:
- `std::move` se usa para convertir un L-value en un R-value, permitiendo que las move semantics se apliquen.
- `MiClase` utiliza un move constructor y un move assignment operator para transferir eficientemente recursos de un objeto a otro.

### Identificación de R-Values en Funciones

Al escribir funciones, es útil identificar cuándo se están utilizando R-values y cuándo L-values. Esto puede influir en la sobrecarga de funciones y en la eficiencia del código.

##### Ejemplo de Sobrecarga de Funciones con L-Values y R-Values

```cpp
#include <iostream>

void procesar(int& x) {
    std::cout << "L-value reference: " << x << std::endl;
}

void procesar(int&& x) {
    std::cout << "R-value reference: " << x << std::endl;
}

int main() {
    int a = 5;
    procesar(a);        // Llama a la versión de L-value reference
    procesar(10);       // Llama a la versión de R-value reference
    procesar(a + 3);    // Llama a la versión de R-value reference

    return 0;
}
```

En este ejemplo:
- `procesar(int& x)` maneja L-values.
- `procesar(int&& x)` maneja R-values.
- `a` es un L-value, mientras que `10` y `a + 3` son R-values.

### Conclusión

Identificar R-values es crucial para escribir código C++ eficiente y seguro. Los R-values son valores temporales y no asignables que se encuentran típicamente en el lado derecho de una asignación. Con el uso de R-value references y move semantics, se pueden optimizar significativamente las operaciones de transferencia de recursos, mejorando el rendimiento y reduciendo la sobrecarga en el manejo de datos temporales. Entender la distinción entre L-values y R-values es esencial para cualquier desarrollador de C++ moderno.
### Operaciones Permitidas con un R-Value en C++

Los R-values en C++ son valores temporales que no tienen una dirección de memoria accesible. Aunque no pueden aparecer en el lado izquierdo de una asignación, hay varias operaciones que se pueden realizar con ellos. A continuación, se describen las operaciones permitidas con R-values, junto con ejemplos prácticos.

#### Operaciones Comunes con R-Values

1. **Asignación a una Variable:**
   - Los R-values se pueden asignar a variables. Esto es común cuando se asigna el resultado de una expresión a una variable.

2. **Paso como Argumentos a Funciones:**
   - Los R-values se pueden pasar como argumentos a funciones, especialmente a funciones que toman parámetros por valor o R-value references.

3. **Inicialización de Variables:**
   - Los R-values se pueden utilizar para inicializar variables.

4. **Operadores y Expresiones:**
   - Los R-values se pueden usar en expresiones y con operadores aritméticos, lógicos, y relacionales.

5. **Uso con R-Value References (`&&`):**
   - Los R-values se pueden capturar con R-value references, lo que permite optimizaciones de movimiento (move semantics).

#### Ejemplos de Operaciones con R-Values

##### Asignación a una Variable

```cpp
int x = 5;         // '5' es un R-value asignado a 'x'
double y = 3.14;   // '3.14' es un R-value asignado a 'y'
```

En este ejemplo:
- `5` y `3.14` son R-values que se asignan a las variables `x` y `y`.

##### Paso como Argumentos a Funciones

```cpp
#include <iostream>

// Función que toma un parámetro por valor
void procesar(int x) {
    std::cout << "Valor: " << x << std::endl;
}

int main() {
    procesar(10);   // '10' es un R-value pasado como argumento
    return 0;
}
```

En este ejemplo:
- `10` es un R-value que se pasa como argumento a la función `procesar`.

##### Inicialización de Variables

```cpp
int a = 5;         // '5' es un R-value usado para inicializar 'a'
double b = a + 3;  // 'a + 3' es un R-value usado para inicializar 'b'
```

En este ejemplo:
- `5` y `a + 3` son R-values que se usan para inicializar `a` y `b`.

##### Uso en Expresiones y Operadores

```cpp
#include <iostream>

int main() {
    int x = 5;
    int y = 10;
    int z = x + y;  // 'x + y' es un R-value usado en una expresión

    std::cout << "Resultado: " << z << std::endl;
    return 0;
}
```

En este ejemplo:
- `x + y` es un R-value resultante de la expresión que se asigna a `z`.

##### Uso con R-Value References

```cpp
#include <iostream>

class MiClase {
public:
    int* data;

    // Constructor normal
    MiClase(int value) : data(new int(value)) {
        std::cout << "Constructor llamado para " << *data << std::endl;
    }

    // Destructor
    ~MiClase() {
        delete data;
        std::cout << "Destructor llamado" << std::endl;
    }

    // Move Constructor
    MiClase(MiClase&& other) noexcept : data(other.data) {
        other.data = nullptr;
        std::cout << "Move Constructor llamado" << std::endl;
    }

    // Move Assignment Operator
    MiClase& operator=(MiClase&& other) noexcept {
        if (this != &other) {
            delete data;
            data = other.data;
            other.data = nullptr;
            std::cout << "Move Assignment Operator llamado" << std::endl;
        }
        return *this;
    }

    void mostrar() const {
        if (data) {
            std::cout << "Valor: " << *data << std::endl;
        } else {
            std::cout << "No hay datos" << std::endl;
        }
    }
};

int main() {
    MiClase obj1(10);
    MiClase obj2 = std::move(obj1);  // 'std::move(obj1)' convierte 'obj1' en un R-value
    obj2.mostrar();
    obj1.mostrar();  // No hay datos, ya que los datos fueron movidos

    MiClase obj3(20);
    obj3 = std::move(obj2);  // 'std::move(obj2)' convierte 'obj2' en un R-value
    obj3.mostrar();
    obj2.mostrar();  // No hay datos, ya que los datos fueron movidos

    return 0;
}
```

En este ejemplo:
- `std::move` convierte un L-value (`obj1` y `obj2`) en un R-value, permitiendo que las move semantics se apliquen.

### Resumen de Operaciones Permitidas con R-Values

1. **Asignación a Variables:** Los R-values se pueden asignar a variables de tipos compatibles.
2. **Paso como Argumentos a Funciones:** Los R-values se pueden pasar como argumentos a funciones, especialmente aquellas que aceptan R-value references (`&&`).
3. **Inicialización de Variables:** Los R-values se pueden usar para inicializar variables.
4. **Uso en Expresiones:** Los R-values se pueden usar en expresiones aritméticas, lógicas, y relacionales.
5. **Move Semantics:** Los R-values se pueden usar con move semantics para transferir recursos eficientemente.

### Conclusión

Los R-values son fundamentales en C++ para trabajar con valores temporales y optimizar el manejo de recursos. Entender las operaciones permitidas con R-values y cómo utilizarlos correctamente es crucial para escribir código C++ moderno y eficiente. Las move semantics, habilitadas por las R-value references, permiten una gestión de recursos más eficiente y un rendimiento mejorado en aplicaciones críticas.
### Conversión de un L-Value a un R-Value en C++

En C++, convertir un L-value (Left value) a un R-value (Right value) es un proceso fundamental para habilitar ciertas optimizaciones y técnicas avanzadas, como las move semantics. La principal herramienta para realizar esta conversión es la función `std::move`, introducida en C++11.

#### `std::move`

`std::move` es una función de la biblioteca estándar que convierte un L-value en un R-value, permitiendo que se aplique el move constructor o el move assignment operator en lugar del copy constructor o copy assignment operator.

##### Sintaxis

```cpp
#include <utility>

std::move(obj);  // Convierte 'obj' en un R-value
```

#### Ejemplo Práctico con `std::move`

Vamos a ver un ejemplo detallado de cómo `std::move` se usa para convertir un L-value en un R-value y habilitar las move semantics.

##### Definición de una Clase con Move Semantics

```cpp
#include <iostream>
#include <utility>  // Para std::move

class MiClase {
public:
    int* data;

    // Constructor normal
    MiClase(int value) : data(new int(value)) {
        std::cout << "Constructor llamado para " << *data << std::endl;
    }

    // Destructor
    ~MiClase() {
        delete data;
        std::cout << "Destructor llamado" << std::endl;
    }

    // Move Constructor
    MiClase(MiClase&& other) noexcept : data(other.data) {
        other.data = nullptr;
        std::cout << "Move Constructor llamado" << std::endl;
    }

    // Move Assignment Operator
    MiClase& operator=(MiClase&& other) noexcept {
        if (this != &other) {
            delete data;
            data = other.data;
            other.data = nullptr;
            std::cout << "Move Assignment Operator llamado" << std::endl;
        }
        return *this;
    }

    void mostrar() const {
        if (data) {
            std::cout << "Valor: " << *data << std::endl;
        } else {
            std::cout << "No hay datos" << std::endl;
        }
    }
};

int main() {
    MiClase obj1(10);
    MiClase obj2 = std::move(obj1);  // std::move convierte 'obj1' en un R-value
    obj2.mostrar();
    obj1.mostrar();  // No hay datos, ya que los datos fueron movidos

    MiClase obj3(20);
    obj3 = std::move(obj2);  // std::move convierte 'obj2' en un R-value
    obj3.mostrar();
    obj2.mostrar();  // No hay datos, ya que los datos fueron movidos

    return 0;
}
```

En este ejemplo:
- `std::move` se utiliza para convertir `obj1` y `obj2` en R-values, permitiendo que se aplique el move constructor y el move assignment operator.

#### ¿Qué Hace `std::move`?

`std::move` no mueve realmente el objeto. En su lugar, simplemente convierte el L-value en un R-value, lo que indica al compilador que puede aplicar las move semantics. La implementación de `std::move` es simple y se define en `<utility>`.

##### Implementación Simplificada de `std::move`

```cpp
namespace std {
    template <typename T>
    typename remove_reference<T>::type&& move(T&& arg) noexcept {
        return static_cast<typename remove_reference<T>::type&&>(arg);
    }
}
```

En esta implementación:
- `std::move` usa `static_cast` para convertir `arg` en un R-value reference.
- `remove_reference<T>::type` asegura que se elimine cualquier referencia, devolviendo un R-value reference.

#### Aplicaciones y Beneficios

Convertir L-values a R-values es crucial en varias situaciones:

1. **Move Semantics:** Permite la transferencia eficiente de recursos en lugar de copiar, mejorando el rendimiento.
2. **Optimización de Recursos:** Reduce la sobrecarga en operaciones de copia para objetos grandes o que gestionan recursos externos como memoria dinámica o archivos.
3. **Interfaces y API Modernas:** Facilita el uso de técnicas avanzadas en el diseño de bibliotecas y aplicaciones.

#### Consideraciones y Buenas Prácticas

1. **Uso Adecuado:** Use `std::move` solo cuando esté seguro de que el objeto no se necesita en su estado original después de la operación de movimiento.
2. **Estado del Objeto:** Después de aplicar `std::move`, el objeto original queda en un estado válido pero indeterminado.
3. **Compatibilidad:** Asegúrese de que las clases y estructuras de datos implementen correctamente el move constructor y el move assignment operator para aprovechar completamente las ventajas de `std::move`.

### Conclusión

La conversión de un L-value a un R-value en C++ mediante `std::move` es una técnica esencial para habilitar las move semantics y optimizar el manejo de recursos. Entender cómo y cuándo usar `std::move` permite a los desarrolladores escribir código más eficiente y moderno, aprovechando al máximo las capacidades de C++ en la gestión de memoria y rendimiento.
<---FILES--->
Características de L-Value
Características de L-Value Result
Ejemplos de L-Value
Ejemplos de L-Value Result
R-Value
R-Value Result
Ejemplos de R-Value
Ejemplos de R-Value Result
Move Constructor y Move Assignment Operator
Move Constructor y Move Assignment Operator Result
Move Constructor
Move Constructor Result
Características de L-Value
Características de L-Value Result
Ejemplos de L-Value
Ejemplos de L-Value Result
R-Value
R-Value Result
Ejemplos de R-Value
Ejemplos de R-Value Result
Move Constructor y Move Assignment Operator
Move Constructor y Move Assignment Operator Result
Move Constructor
Move Constructor Result
Ejemplos Prácticos
Ejemplos Prácticos Result
Sintaxis
Sintaxis Result
Ejemplo con R-Value References
Ejemplo con R-Value References Result
Características de L-Value
Características de L-Value Result
Ejemplos de L-Value
Ejemplos de L-Value Result
R-Value
R-Value Result
Ejemplos de R-Value
Ejemplos de R-Value Result
Move Constructor y Move Assignment Operator
Move Constructor y Move Assignment Operator Result
Move Constructor
Move Constructor Result
Ejemplos Prácticos
Ejemplos Prácticos Result
Sintaxis
Sintaxis Result
Ejemplo con R-Value References
Ejemplo con R-Value References Result
Ejemplo de R-Value References
Ejemplo de R-Value References Result
Ejemplo de Sobrecarga de Funciones con L-Values y R-Values
Ejemplo de Sobrecarga de Funciones con L-Values y R-Values Result
Características de L-Value
Características de L-Value Result
Ejemplos de L-Value
Ejemplos de L-Value Result
R-Value
R-Value Result
Ejemplos de R-Value
Ejemplos de R-Value Result
Move Constructor y Move Assignment Operator
Move Constructor y Move Assignment Operator Result
Move Constructor
Move Constructor Result
Ejemplos Prácticos
Ejemplos Prácticos Result
Sintaxis
Sintaxis Result
Ejemplo con R-Value References
Ejemplo con R-Value References Result
Ejemplo de R-Value References
Ejemplo de R-Value References Result
Ejemplo de Sobrecarga de Funciones con L-Values y R-Values
Ejemplo de Sobrecarga de Funciones con L-Values y R-Values Result
Asignación a una Variable
Asignación a una Variable Result
Paso como Argumentos a Funciones
Paso como Argumentos a Funciones Result
Inicialización de Variables
Inicialización de Variables Result
Uso en Expresiones y Operadores
Uso en Expresiones y Operadores Result
Uso con R-Value References
Uso con R-Value References Result
Características de L-Value
Características de L-Value Result
Ejemplos de L-Value
Ejemplos de L-Value Result
R-Value
R-Value Result
Ejemplos de R-Value
Ejemplos de R-Value Result
Move Constructor y Move Assignment Operator
Move Constructor y Move Assignment Operator Result
Move Constructor
Move Constructor Result
Ejemplos Prácticos
Ejemplos Prácticos Result
Sintaxis
Sintaxis Result
Ejemplo con R-Value References
Ejemplo con R-Value References Result
Ejemplo de R-Value References
Ejemplo de R-Value References Result
Ejemplo de Sobrecarga de Funciones con L-Values y R-Values
Ejemplo de Sobrecarga de Funciones con L-Values y R-Values Result
Asignación a una Variable
Asignación a una Variable Result
Paso como Argumentos a Funciones
Paso como Argumentos a Funciones Result
Inicialización de Variables
Inicialización de Variables Result
Uso en Expresiones y Operadores
Uso en Expresiones y Operadores Result
Uso con R-Value References
Uso con R-Value References Result
Definición de una Clase con Move Semantics
Definición de una Clase con Move Semantics Result
Implementación Simplificada de `std::move`
Implementación Simplificada de `std::move` Result
<---Características de L-Value--->
<---Características de L-Value Result--->
<---Ejemplos de L-Value--->
```cpp
int x = 5;         // 'x' es un L-value
int* p = &x;       // 'p' es un L-value que contiene la dirección de 'x'
x = 10;            // 'x' puede estar en el lado izquierdo de la asignación
*p = 20;           // '*p' es un L-value que puede estar en el lado izquierdo de la asignación

int& ref = x;      // 'ref' es un L-value reference a 'x'
ref = 30;          // 'ref' puede estar en el lado izquierdo de la asignación
<---Ejemplos de L-Value Result--->
<---R-Value--->
<---R-Value Result--->
<---Ejemplos de R-Value--->
```cpp
int y = 5;         // '5' es un R-value
int z = y + 3;     // 'y + 3' es un R-value
<---Ejemplos de R-Value Result--->
<---Move Constructor y Move Assignment Operator--->
<---Move Constructor y Move Assignment Operator Result--->
<---Move Constructor--->
```cpp
#include <iostream>
#include <utility>

class MiClase {
private:
    int* data;

public:
    // Constructor
    MiClase(int value) : data(new int(value)) {
        std::cout << "Constructor llamado para " << *data << std::endl;
    }

    // Destructor
    ~MiClase() {
        delete data;
        std::cout << "Destructor llamado" << std::endl;
    }

    // Move Constructor
    MiClase(MiClase&& other) noexcept : data(other.data) {
        other.data = nullptr;
        std::cout << "Move Constructor llamado" << std::endl;
    }

    // Move Assignment Operator
    MiClase& operator=(MiClase&& other) noexcept {
        if (this != &other) {
            delete data;
            data = other.data;
            other.data = nullptr;
            std::cout << "Move Assignment Operator llamado" << std::endl;
        }
        return *this;
    }

    void mostrar() const {
        if (data) {
            std::cout << "Valor: " << *data << std::endl;
        } else {
            std::cout << "No hay datos" << std::endl;
        }
    }
};

int main() {
    MiClase obj1(10);
    MiClase obj2 = std::move(obj1);  // Move Constructor llamado
    obj2.mostrar();
    obj1.mostrar();  // No hay datos, ya que los datos fueron movidos

    MiClase obj3(20);
    obj3 = std::move(obj2);  // Move Assignment Operator llamado
    obj3.mostrar();
    obj2.mostrar();  // No hay datos, ya que los datos fueron movidos

    return 0;
}
<---Move Constructor Result--->
<---Características de L-Value--->
<---Características de L-Value Result--->
<---Ejemplos de L-Value--->
```cpp
int x = 5;         // 'x' es un L-value
int* p = &x;       // 'p' es un L-value que contiene la dirección de 'x'
x = 10;            // 'x' puede estar en el lado izquierdo de la asignación
*p = 20;           // '*p' es un L-value que puede estar en el lado izquierdo de la asignación

int& ref = x;      // 'ref' es un L-value reference a 'x'
ref = 30;          // 'ref' puede estar en el lado izquierdo de la asignación
<---Ejemplos de L-Value Result--->
<---R-Value--->
<---R-Value Result--->
<---Ejemplos de R-Value--->
```cpp
int y = 5;         // '5' es un R-value
int z = y + 3;     // 'y + 3' es un R-value
<---Ejemplos de R-Value Result--->
<---Move Constructor y Move Assignment Operator--->
<---Move Constructor y Move Assignment Operator Result--->
<---Move Constructor--->
```cpp
#include <iostream>
#include <utility>

class MiClase {
private:
    int* data;

public:
    // Constructor
    MiClase(int value) : data(new int(value)) {
        std::cout << "Constructor llamado para " << *data << std::endl;
    }

    // Destructor
    ~MiClase() {
        delete data;
        std::cout << "Destructor llamado" << std::endl;
    }

    // Move Constructor
    MiClase(MiClase&& other) noexcept : data(other.data) {
        other.data = nullptr;
        std::cout << "Move Constructor llamado" << std::endl;
    }

    // Move Assignment Operator
    MiClase& operator=(MiClase&& other) noexcept {
        if (this != &other) {
            delete data;
            data = other.data;
            other.data = nullptr;
            std::cout << "Move Assignment Operator llamado" << std::endl;
        }
        return *this;
    }

    void mostrar() const {
        if (data) {
            std::cout << "Valor: " << *data << std::endl;
        } else {
            std::cout << "No hay datos" << std::endl;
        }
    }
};

int main() {
    MiClase obj1(10);
    MiClase obj2 = std::move(obj1);  // Move Constructor llamado
    obj2.mostrar();
    obj1.mostrar();  // No hay datos, ya que los datos fueron movidos

    MiClase obj3(20);
    obj3 = std::move(obj2);  // Move Assignment Operator llamado
    obj3.mostrar();
    obj2.mostrar();  // No hay datos, ya que los datos fueron movidos

    return 0;
}
<---Move Constructor Result--->
<---Ejemplos Prácticos--->
```cpp
int x = 5;         // '5' es un R-value
int y = x + 2;     // 'x + 2' es un R-value

std::string s1 = "hello";        // "hello" es un R-value
std::string s2 = s1 + " world";  // 's1 + " world"' es un R-value
<---Ejemplos Prácticos Result--->
<---Sintaxis--->
```cpp
int&& rvalue_ref = 10;  // rvalue_ref es una referencia a un R-value
<---Sintaxis Result--->
<---Ejemplo con R-Value References--->
```cpp
#include <iostream>

class MiClase {
public:
    int* data;

    // Constructor normal
    MiClase(int value) : data(new int(value)) {
        std::cout << "Constructor llamado para " << *data << std::endl;
    }

    // Destructor
    ~MiClase() {
        delete data;
        std::cout << "Destructor llamado" << std::endl;
    }

    // Move Constructor
    MiClase(MiClase&& other) noexcept : data(other.data) {
        other.data = nullptr;
        std::cout << "Move Constructor llamado" << std::endl;
    }

    // Move Assignment Operator
    MiClase& operator=(MiClase&& other) noexcept {
        if (this != &other) {
            delete data;
            data = other.data;
            other.data = nullptr;
            std::cout << "Move Assignment Operator llamado" << std::endl;
        }
        return *this;
    }

    void mostrar() const {
        if (data) {
            std::cout << "Valor: " << *data << std::endl;
        } else {
            std::cout << "No hay datos" << std::endl;
        }
    }
};

int main() {
    MiClase obj1(10);
    MiClase obj2 = std::move(obj1);  // Move Constructor llamado
    obj2.mostrar();
    obj1.mostrar();  // No hay datos, ya que los datos fueron movidos

    MiClase obj3(20);
    obj3 = std::move(obj2);  // Move Assignment Operator llamado
    obj3.mostrar();
    obj2.mostrar();  // No hay datos, ya que los datos fueron movidos

    return 0;
}
<---Ejemplo con R-Value References Result--->
<---Características de L-Value--->
<---Características de L-Value Result--->
<---Ejemplos de L-Value--->
```cpp
int x = 5;         // 'x' es un L-value
int* p = &x;       // 'p' es un L-value que contiene la dirección de 'x'
x = 10;            // 'x' puede estar en el lado izquierdo de la asignación
*p = 20;           // '*p' es un L-value que puede estar en el lado izquierdo de la asignación

int& ref = x;      // 'ref' es un L-value reference a 'x'
ref = 30;          // 'ref' puede estar en el lado izquierdo de la asignación
<---Ejemplos de L-Value Result--->
<---R-Value--->
<---R-Value Result--->
<---Ejemplos de R-Value--->
```cpp
int y = 5;         // '5' es un R-value
int z = y + 3;     // 'y + 3' es un R-value
<---Ejemplos de R-Value Result--->
<---Move Constructor y Move Assignment Operator--->
<---Move Constructor y Move Assignment Operator Result--->
<---Move Constructor--->
```cpp
#include <iostream>
#include <utility>

class MiClase {
private:
    int* data;

public:
    // Constructor
    MiClase(int value) : data(new int(value)) {
        std::cout << "Constructor llamado para " << *data << std::endl;
    }

    // Destructor
    ~MiClase() {
        delete data;
        std::cout << "Destructor llamado" << std::endl;
    }

    // Move Constructor
    MiClase(MiClase&& other) noexcept : data(other.data) {
        other.data = nullptr;
        std::cout << "Move Constructor llamado" << std::endl;
    }

    // Move Assignment Operator
    MiClase& operator=(MiClase&& other) noexcept {
        if (this != &other) {
            delete data;
            data = other.data;
            other.data = nullptr;
            std::cout << "Move Assignment Operator llamado" << std::endl;
        }
        return *this;
    }

    void mostrar() const {
        if (data) {
            std::cout << "Valor: " << *data << std::endl;
        } else {
            std::cout << "No hay datos" << std::endl;
        }
    }
};

int main() {
    MiClase obj1(10);
    MiClase obj2 = std::move(obj1);  // Move Constructor llamado
    obj2.mostrar();
    obj1.mostrar();  // No hay datos, ya que los datos fueron movidos

    MiClase obj3(20);
    obj3 = std::move(obj2);  // Move Assignment Operator llamado
    obj3.mostrar();
    obj2.mostrar();  // No hay datos, ya que los datos fueron movidos

    return 0;
}
<---Move Constructor Result--->
<---Ejemplos Prácticos--->
```cpp
#include <iostream>

int main() {
    // Literales
    int x = 5;         // '5' es un R-value
    double y = 3.14;   // '3.14' es un R-value

    // Resultados de Expresiones
    int z = x + 2;     // 'x + 2' es un R-value

    // Llamadas a Funciones que Devuelven R-Values
    std::string s1 = "hello";          // "hello" es un R-value
    std::string s2 = s1 + " world";    // 's1 + " world"' es un R-value

    // Mostrando los valores
    std::cout << "x: " << x << std::endl;
    std::cout << "y: " << y << std::endl;
    std::cout << "z: " << z << std::endl;
    std::cout << "s1: " << s1 << std::endl;
    std::cout << "s2: " << s2 << std::endl;

    return 0;
}
<---Ejemplos Prácticos Result--->
<---Sintaxis--->
```cpp
int&& rvalue_ref = 10;  // rvalue_ref es una referencia a un R-value
<---Sintaxis Result--->
<---Ejemplo con R-Value References--->
```cpp
#include <iostream>

class MiClase {
public:
    int* data;

    // Constructor normal
    MiClase(int value) : data(new int(value)) {
        std::cout << "Constructor llamado para " << *data << std::endl;
    }

    // Destructor
    ~MiClase() {
        delete data;
        std::cout << "Destructor llamado" << std::endl;
    }

    // Move Constructor
    MiClase(MiClase&& other) noexcept : data(other.data) {
        other.data = nullptr;
        std::cout << "Move Constructor llamado" << std::endl;
    }

    // Move Assignment Operator
    MiClase& operator=(MiClase&& other) noexcept {
        if (this != &other) {
            delete data;
            data = other.data;
            other.data = nullptr;
            std::cout << "Move Assignment Operator llamado" << std::endl;
        }
        return *this;
    }

    void mostrar() const {
        if (data) {
            std::cout << "Valor: " << *data << std::endl;
        } else {
            std::cout << "No hay datos" << std::endl;
        }
    }
};

int main() {
    MiClase obj1(10);
    MiClase obj2 = std::move(obj1);  // Move Constructor llamado
    obj2.mostrar();
    obj1.mostrar();  // No hay datos, ya que los datos fueron movidos

    MiClase obj3(20);
    obj3 = std::move(obj2);  // Move Assignment Operator llamado
    obj3.mostrar();
    obj2.mostrar();  // No hay datos, ya que los datos fueron movidos

    return 0;
}
<---Ejemplo con R-Value References Result--->
<---Ejemplo de R-Value References--->
```cpp
#include <iostream>

class MiClase {
public:
    int* data;

    // Constructor normal
    MiClase(int value) : data(new int(value)) {
        std::cout << "Constructor llamado para " << *data << std::endl;
    }

    // Destructor
    ~MiClase() {
        delete data;
        std::cout << "Destructor llamado" << std::endl;
    }

    // Move Constructor
    MiClase(MiClase&& other) noexcept : data(other.data) {
        other.data = nullptr;
        std::cout << "Move Constructor llamado" << std::endl;
    }

    // Move Assignment Operator
    MiClase& operator=(MiClase&& other) noexcept {
        if (this != &other) {
            delete data;
            data = other.data;
            other.data = nullptr;
            std::cout << "Move Assignment Operator llamado" << std::endl;
        }
        return *this;
    }

    void mostrar() const {
        if (data) {
            std::cout << "Valor: " << *data << std::endl;
        } else {
            std::cout << "No hay datos" << std::endl;
        }
    }
};

int main() {
    MiClase obj1(10);
    MiClase obj2 = std::move(obj1);  // Move Constructor llamado
    obj2.mostrar();
    obj1.mostrar();  // No hay datos, ya que los datos fueron movidos

    MiClase obj3(20);
    obj3 = std::move(obj2);  // Move Assignment Operator llamado
    obj3.mostrar();
    obj2.mostrar();  // No hay datos, ya que los datos fueron movidos

    return 0;
}
<---Ejemplo de R-Value References Result--->
<---Ejemplo de Sobrecarga de Funciones con L-Values y R-Values--->
```cpp
#include <iostream>

void procesar(int& x) {
    std::cout << "L-value reference: " << x << std::endl;
}

void procesar(int&& x) {
    std::cout << "R-value reference: " << x << std::endl;
}

int main() {
    int a = 5;
    procesar(a);        // Llama a la versión de L-value reference
    procesar(10);       // Llama a la versión de R-value reference
    procesar(a + 3);    // Llama a la versión de R-value reference

    return 0;
}
<---Ejemplo de Sobrecarga de Funciones con L-Values y R-Values Result--->
<---Características de L-Value--->
<---Características de L-Value Result--->
<---Ejemplos de L-Value--->
```cpp
int x = 5;         // 'x' es un L-value
int* p = &x;       // 'p' es un L-value que contiene la dirección de 'x'
x = 10;            // 'x' puede estar en el lado izquierdo de la asignación
*p = 20;           // '*p' es un L-value que puede estar en el lado izquierdo de la asignación

int& ref = x;      // 'ref' es un L-value reference a 'x'
ref = 30;          // 'ref' puede estar en el lado izquierdo de la asignación
<---Ejemplos de L-Value Result--->
<---R-Value--->
<---R-Value Result--->
<---Ejemplos de R-Value--->
```cpp
int y = 5;         // '5' es un R-value
int z = y + 3;     // 'y + 3' es un R-value
<---Ejemplos de R-Value Result--->
<---Move Constructor y Move Assignment Operator--->
<---Move Constructor y Move Assignment Operator Result--->
<---Move Constructor--->
```cpp
#include <iostream>
#include <utility>

class MiClase {
private:
    int* data;

public:
    // Constructor
    MiClase(int value) : data(new int(value)) {
        std::cout << "Constructor llamado para " << *data << std::endl;
    }

    // Destructor
    ~MiClase() {
        delete data;
        std::cout << "Destructor llamado" << std::endl;
    }

    // Move Constructor
    MiClase(MiClase&& other) noexcept : data(other.data) {
        other.data = nullptr;
        std::cout << "Move Constructor llamado" << std::endl;
    }

    // Move Assignment Operator
    MiClase& operator=(MiClase&& other) noexcept {
        if (this != &other) {
            delete data;
            data = other.data;
            other.data = nullptr;
            std::cout << "Move Assignment Operator llamado" << std::endl;
        }
        return *this;
    }

    void mostrar() const {
        if (data) {
            std::cout << "Valor: " << *data << std::endl;
        } else {
            std::cout << "No hay datos" << std::endl;
        }
    }
};

int main() {
    MiClase obj1(10);
    MiClase obj2 = std::move(obj1);  // Move Constructor llamado
    obj2.mostrar();
    obj1.mostrar();  // No hay datos, ya que los datos fueron movidos

    MiClase obj3(20);
    obj3 = std::move(obj2);  // Move Assignment Operator llamado
    obj3.mostrar();
    obj2.mostrar();  // No hay datos, ya que los datos fueron movidos

    return 0;
}
<---Move Constructor Result--->
<---Ejemplos Prácticos--->
```cpp
#include <iostream>

int main() {
    // Literales
    int x = 5;         // '5' es un R-value
    double y = 3.14;   // '3.14' es un R-value

    // Resultados de Expresiones
    int z = x + 2;     // 'x + 2' es un R-value

    // Llamadas a Funciones que Devuelven R-Values
    std::string s1 = "hello";          // "hello" es un R-value
    std::string s2 = s1 + " world";    // 's1 + " world"' es un R-value

    // Mostrando los valores
    std::cout << "x: " << x << std::endl;
    std::cout << "y: " << y << std::endl;
    std::cout << "z: " << z << std::endl;
    std::cout << "s1: " << s1 << std::endl;
    std::cout << "s2: " << s2 << std::endl;

    return 0;
}
<---Ejemplos Prácticos Result--->
<---Sintaxis--->
```cpp
int&& rvalue_ref = 10;  // rvalue_ref es una referencia a un R-value
<---Sintaxis Result--->
<---Ejemplo con R-Value References--->
```cpp
#include <iostream>

class MiClase {
public:
    int* data;

    // Constructor normal
    MiClase(int value) : data(new int(value)) {
        std::cout << "Constructor llamado para " << *data << std::endl;
    }

    // Destructor
    ~MiClase() {
        delete data;
        std::cout << "Destructor llamado" << std::endl;
    }

    // Move Constructor
    MiClase(MiClase&& other) noexcept : data(other.data) {
        other.data = nullptr;
        std::cout << "Move Constructor llamado" << std::endl;
    }

    // Move Assignment Operator
    MiClase& operator=(MiClase&& other) noexcept {
        if (this != &other) {
            delete data;
            data = other.data;
            other.data = nullptr;
            std::cout << "Move Assignment Operator llamado" << std::endl;
        }
        return *this;
    }

    void mostrar() const {
        if (data) {
            std::cout << "Valor: " << *data << std::endl;
        } else {
            std::cout << "No hay datos" << std::endl;
        }
    }
};

int main() {
    MiClase obj1(10);
    MiClase obj2 = std::move(obj1);  // Move Constructor llamado
    obj2.mostrar();
    obj1.mostrar();  // No hay datos, ya que los datos fueron movidos

    MiClase obj3(20);
    obj3 = std::move(obj2);  // Move Assignment Operator llamado
    obj3.mostrar();
    obj2.mostrar();  // No hay datos, ya que los datos fueron movidos

    return 0;
}
<---Ejemplo con R-Value References Result--->
<---Ejemplo de R-Value References--->
```cpp
#include <iostream>

class MiClase {
public:
    int* data;

    // Constructor normal
    MiClase(int value) : data(new int(value)) {
        std::cout << "Constructor llamado para " << *data << std::endl;
    }

    // Destructor
    ~MiClase() {
        delete data;
        std::cout << "Destructor llamado" << std::endl;
    }

    // Move Constructor
    MiClase(MiClase&& other) noexcept : data(other.data) {
        other.data = nullptr;
        std::cout << "Move Constructor llamado" << std::endl;
    }

    // Move Assignment Operator
    MiClase& operator=(MiClase&& other) noexcept {
        if (this != &other) {
            delete data;
            data = other.data;
            other.data = nullptr;
            std::cout << "Move Assignment Operator llamado" << std::endl;
        }
        return *this;
    }

    void mostrar() const {
        if (data) {
            std::cout << "Valor: " << *data << std::endl;
        } else {
            std::cout << "No hay datos" << std::endl;
        }
    }
};

int main() {
    MiClase obj1(10);
    MiClase obj2 = std::move(obj1);  // Move Constructor llamado
    obj2.mostrar();
    obj1.mostrar();  // No hay datos, ya que los datos fueron movidos

    MiClase obj3(20);
    obj3 = std::move(obj2);  // Move Assignment Operator llamado
    obj3.mostrar();
    obj2.mostrar();  // No hay datos, ya que los datos fueron movidos

    return 0;
}
<---Ejemplo de R-Value References Result--->
<---Ejemplo de Sobrecarga de Funciones con L-Values y R-Values--->
```cpp
#include <iostream>

void procesar(int& x) {
    std::cout << "L-value reference: " << x << std::endl;
}

void procesar(int&& x) {
    std::cout << "R-value reference: " << x << std::endl;
}

int main() {
    int a = 5;
    procesar(a);        // Llama a la versión de L-value reference
    procesar(10);       // Llama a la versión de R-value reference
    procesar(a + 3);    // Llama a la versión de R-value reference

    return 0;
}
<---Ejemplo de Sobrecarga de Funciones con L-Values y R-Values Result--->
<---Asignación a una Variable--->
```cpp
int x = 5;         // '5' es un R-value asignado a 'x'
double y = 3.14;   // '3.14' es un R-value asignado a 'y'
<---Asignación a una Variable Result--->
<---Paso como Argumentos a Funciones--->
```cpp
#include <iostream>

// Función que toma un parámetro por valor
void procesar(int x) {
    std::cout << "Valor: " << x << std::endl;
}

int main() {
    procesar(10);   // '10' es un R-value pasado como argumento
    return 0;
}
<---Paso como Argumentos a Funciones Result--->
<---Inicialización de Variables--->
```cpp
int a = 5;         // '5' es un R-value usado para inicializar 'a'
double b = a + 3;  // 'a + 3' es un R-value usado para inicializar 'b'
<---Inicialización de Variables Result--->
<---Uso en Expresiones y Operadores--->
```cpp
#include <iostream>

int main() {
    int x = 5;
    int y = 10;
    int z = x + y;  // 'x + y' es un R-value usado en una expresión

    std::cout << "Resultado: " << z << std::endl;
    return 0;
}
<---Uso en Expresiones y Operadores Result--->
<---Uso con R-Value References--->
```cpp
#include <iostream>

class MiClase {
public:
    int* data;

    // Constructor normal
    MiClase(int value) : data(new int(value)) {
        std::cout << "Constructor llamado para " << *data << std::endl;
    }

    // Destructor
    ~MiClase() {
        delete data;
        std::cout << "Destructor llamado" << std::endl;
    }

    // Move Constructor
    MiClase(MiClase&& other) noexcept : data(other.data) {
        other.data = nullptr;
        std::cout << "Move Constructor llamado" << std::endl;
    }

    // Move Assignment Operator
    MiClase& operator=(MiClase&& other) noexcept {
        if (this != &other) {
            delete data;
            data = other.data;
            other.data = nullptr;
            std::cout << "Move Assignment Operator llamado" << std::endl;
        }
        return *this;
    }

    void mostrar() const {
        if (data) {
            std::cout << "Valor: " << *data << std::endl;
        } else {
            std::cout << "No hay datos" << std::endl;
        }
    }
};

int main() {
    MiClase obj1(10);
    MiClase obj2 = std::move(obj1);  // 'std::move(obj1)' convierte 'obj1' en un R-value
    obj2.mostrar();
    obj1.mostrar();  // No hay datos, ya que los datos fueron movidos

    MiClase obj3(20);
    obj3 = std::move(obj2);  // 'std::move(obj2)' convierte 'obj2' en un R-value
    obj3.mostrar();
    obj2.mostrar();  // No hay datos, ya que los datos fueron movidos

    return 0;
}
<---Uso con R-Value References Result--->
<---Características de L-Value--->
<---Características de L-Value Result--->
<---Ejemplos de L-Value--->
```cpp
int x = 5;         // 'x' es un L-value
int* p = &x;       // 'p' es un L-value que contiene la dirección de 'x'
x = 10;            // 'x' puede estar en el lado izquierdo de la asignación
*p = 20;           // '*p' es un L-value que puede estar en el lado izquierdo de la asignación

int& ref = x;      // 'ref' es un L-value reference a 'x'
ref = 30;          // 'ref' puede estar en el lado izquierdo de la asignación
<---Ejemplos de L-Value Result--->
<---R-Value--->
<---R-Value Result--->
<---Ejemplos de R-Value--->
```cpp
int y = 5;         // '5' es un R-value
int z = y + 3;     // 'y + 3' es un R-value
<---Ejemplos de R-Value Result--->
<---Move Constructor y Move Assignment Operator--->
<---Move Constructor y Move Assignment Operator Result--->
<---Move Constructor--->
```cpp
#include <iostream>
#include <utility>

class MiClase {
private:
    int* data;

public:
    // Constructor
    MiClase(int value) : data(new int(value)) {
        std::cout << "Constructor llamado para " << *data << std::endl;
    }

    // Destructor
    ~MiClase() {
        delete data;
        std::cout << "Destructor llamado" << std::endl;
    }

    // Move Constructor
    MiClase(MiClase&& other) noexcept : data(other.data) {
        other.data = nullptr;
        std::cout << "Move Constructor llamado" << std::endl;
    }

    // Move Assignment Operator
    MiClase& operator=(MiClase&& other) noexcept {
        if (this != &other) {
            delete data;
            data = other.data;
            other.data = nullptr;
            std::cout << "Move Assignment Operator llamado" << std::endl;
        }
        return *this;
    }

    void mostrar() const {
        if (data) {
            std::cout << "Valor: " << *data << std::endl;
        } else {
            std::cout << "No hay datos" << std::endl;
        }
    }
};

int main() {
    MiClase obj1(10);
    MiClase obj2 = std::move(obj1);  // Move Constructor llamado
    obj2.mostrar();
    obj1.mostrar();  // No hay datos, ya que los datos fueron movidos

    MiClase obj3(20);
    obj3 = std::move(obj2);  // Move Assignment Operator llamado
    obj3.mostrar();
    obj2.mostrar();  // No hay datos, ya que los datos fueron movidos

    return 0;
}
<---Move Constructor Result--->
<---Ejemplos Prácticos--->
```cpp
#include <iostream>

int main() {
    // Literales
    int x = 5;         // '5' es un R-value
    double y = 3.14;   // '3.14' es un R-value

    // Resultados de Expresiones
    int z = x + 2;     // 'x + 2' es un R-value

    // Llamadas a Funciones que Devuelven R-Values
    std::string s1 = "hello";          // "hello" es un R-value
    std::string s2 = s1 + " world";    // 's1 + " world"' es un R-value

    // Mostrando los valores
    std::cout << "x: " << x << std::endl;
    std::cout << "y: " << y << std::endl;
    std::cout << "z: " << z << std::endl;
    std::cout << "s1: " << s1 << std::endl;
    std::cout << "s2: " << s2 << std::endl;

    return 0;
}
<---Ejemplos Prácticos Result--->
<---Sintaxis--->
```cpp
#include <utility>

std::move(obj);  // Convierte 'obj' en un R-value
<---Sintaxis Result--->
<---Ejemplo con R-Value References--->
```cpp
#include <iostream>

class MiClase {
public:
    int* data;

    // Constructor normal
    MiClase(int value) : data(new int(value)) {
        std::cout << "Constructor llamado para " << *data << std::endl;
    }

    // Destructor
    ~MiClase() {
        delete data;
        std::cout << "Destructor llamado" << std::endl;
    }

    // Move Constructor
    MiClase(MiClase&& other) noexcept : data(other.data) {
        other.data = nullptr;
        std::cout << "Move Constructor llamado" << std::endl;
    }

    // Move Assignment Operator
    MiClase& operator=(MiClase&& other) noexcept {
        if (this != &other) {
            delete data;
            data = other.data;
            other.data = nullptr;
            std::cout << "Move Assignment Operator llamado" << std::endl;
        }
        return *this;
    }

    void mostrar() const {
        if (data) {
            std::cout << "Valor: " << *data << std::endl;
        } else {
            std::cout << "No hay datos" << std::endl;
        }
    }
};

int main() {
    MiClase obj1(10);
    MiClase obj2 = std::move(obj1);  // Move Constructor llamado
    obj2.mostrar();
    obj1.mostrar();  // No hay datos, ya que los datos fueron movidos

    MiClase obj3(20);
    obj3 = std::move(obj2);  // Move Assignment Operator llamado
    obj3.mostrar();
    obj2.mostrar();  // No hay datos, ya que los datos fueron movidos

    return 0;
}
<---Ejemplo con R-Value References Result--->
<---Ejemplo de R-Value References--->
```cpp
#include <iostream>

class MiClase {
public:
    int* data;

    // Constructor normal
    MiClase(int value) : data(new int(value)) {
        std::cout << "Constructor llamado para " << *data << std::endl;
    }

    // Destructor
    ~MiClase() {
        delete data;
        std::cout << "Destructor llamado" << std::endl;
    }

    // Move Constructor
    MiClase(MiClase&& other) noexcept : data(other.data) {
        other.data = nullptr;
        std::cout << "Move Constructor llamado" << std::endl;
    }

    // Move Assignment Operator
    MiClase& operator=(MiClase&& other) noexcept {
        if (this != &other) {
            delete data;
            data = other.data;
            other.data = nullptr;
            std::cout << "Move Assignment Operator llamado" << std::endl;
        }
        return *this;
    }

    void mostrar() const {
        if (data) {
            std::cout << "Valor: " << *data << std::endl;
        } else {
            std::cout << "No hay datos" << std::endl;
        }
    }
};

int main() {
    MiClase obj1(10);
    MiClase obj2 = std::move(obj1);  // Move Constructor llamado
    obj2.mostrar();
    obj1.mostrar();  // No hay datos, ya que los datos fueron movidos

    MiClase obj3(20);
    obj3 = std::move(obj2);  // Move Assignment Operator llamado
    obj3.mostrar();
    obj2.mostrar();  // No hay datos, ya que los datos fueron movidos

    return 0;
}
<---Ejemplo de R-Value References Result--->
<---Ejemplo de Sobrecarga de Funciones con L-Values y R-Values--->
```cpp
#include <iostream>

void procesar(int& x) {
    std::cout << "L-value reference: " << x << std::endl;
}

void procesar(int&& x) {
    std::cout << "R-value reference: " << x << std::endl;
}

int main() {
    int a = 5;
    procesar(a);        // Llama a la versión de L-value reference
    procesar(10);       // Llama a la versión de R-value reference
    procesar(a + 3);    // Llama a la versión de R-value reference

    return 0;
}
<---Ejemplo de Sobrecarga de Funciones con L-Values y R-Values Result--->
<---Asignación a una Variable--->
```cpp
int x = 5;         // '5' es un R-value asignado a 'x'
double y = 3.14;   // '3.14' es un R-value asignado a 'y'
<---Asignación a una Variable Result--->
<---Paso como Argumentos a Funciones--->
```cpp
#include <iostream>

// Función que toma un parámetro por valor
void procesar(int x) {
    std::cout << "Valor: " << x << std::endl;
}

int main() {
    procesar(10);   // '10' es un R-value pasado como argumento
    return 0;
}
<---Paso como Argumentos a Funciones Result--->
<---Inicialización de Variables--->
```cpp
int a = 5;         // '5' es un R-value usado para inicializar 'a'
double b = a + 3;  // 'a + 3' es un R-value usado para inicializar 'b'
<---Inicialización de Variables Result--->
<---Uso en Expresiones y Operadores--->
```cpp
#include <iostream>

int main() {
    int x = 5;
    int y = 10;
    int z = x + y;  // 'x + y' es un R-value usado en una expresión

    std::cout << "Resultado: " << z << std::endl;
    return 0;
}
<---Uso en Expresiones y Operadores Result--->
<---Uso con R-Value References--->
```cpp
#include <iostream>

class MiClase {
public:
    int* data;

    // Constructor normal
    MiClase(int value) : data(new int(value)) {
        std::cout << "Constructor llamado para " << *data << std::endl;
    }

    // Destructor
    ~MiClase() {
        delete data;
        std::cout << "Destructor llamado" << std::endl;
    }

    // Move Constructor
    MiClase(MiClase&& other) noexcept : data(other.data) {
        other.data = nullptr;
        std::cout << "Move Constructor llamado" << std::endl;
    }

    // Move Assignment Operator
    MiClase& operator=(MiClase&& other) noexcept {
        if (this != &other) {
            delete data;
            data = other.data;
            other.data = nullptr;
            std::cout << "Move Assignment Operator llamado" << std::endl;
        }
        return *this;
    }

    void mostrar() const {
        if (data) {
            std::cout << "Valor: " << *data << std::endl;
        } else {
            std::cout << "No hay datos" << std::endl;
        }
    }
};

int main() {
    MiClase obj1(10);
    MiClase obj2 = std::move(obj1);  // 'std::move(obj1)' convierte 'obj1' en un R-value
    obj2.mostrar();
    obj1.mostrar();  // No hay datos, ya que los datos fueron movidos

    MiClase obj3(20);
    obj3 = std::move(obj2);  // 'std::move(obj2)' convierte 'obj2' en un R-value
    obj3.mostrar();
    obj2.mostrar();  // No hay datos, ya que los datos fueron movidos

    return 0;
}
<---Uso con R-Value References Result--->
<---Definición de una Clase con Move Semantics--->
```cpp
#include <iostream>
#include <utility>  // Para std::move

class MiClase {
public:
    int* data;

    // Constructor normal
    MiClase(int value) : data(new int(value)) {
        std::cout << "Constructor llamado para " << *data << std::endl;
    }

    // Destructor
    ~MiClase() {
        delete data;
        std::cout << "Destructor llamado" << std::endl;
    }

    // Move Constructor
    MiClase(MiClase&& other) noexcept : data(other.data) {
        other.data = nullptr;
        std::cout << "Move Constructor llamado" << std::endl;
    }

    // Move Assignment Operator
    MiClase& operator=(MiClase&& other) noexcept {
        if (this != &other) {
            delete data;
            data = other.data;
            other.data = nullptr;
            std::cout << "Move Assignment Operator llamado" << std::endl;
        }
        return *this;
    }

    void mostrar() const {
        if (data) {
            std::cout << "Valor: " << *data << std::endl;
        } else {
            std::cout << "No hay datos" << std::endl;
        }
    }
};

int main() {
    MiClase obj1(10);
    MiClase obj2 = std::move(obj1);  // std::move convierte 'obj1' en un R-value
    obj2.mostrar();
    obj1.mostrar();  // No hay datos, ya que los datos fueron movidos

    MiClase obj3(20);
    obj3 = std::move(obj2);  // std::move convierte 'obj2' en un R-value
    obj3.mostrar();
    obj2.mostrar();  // No hay datos, ya que los datos fueron movidos

    return 0;
}
<---Definición de una Clase con Move Semantics Result--->
<---Implementación Simplificada de `std::move`--->
```cpp
namespace std {
    template <typename T>
    typename remove_reference<T>::type&& move(T&& arg) noexcept {
        return static_cast<typename remove_reference<T>::type&&>(arg);
    }
}
<---Implementación Simplificada de `std::move` Result--->
