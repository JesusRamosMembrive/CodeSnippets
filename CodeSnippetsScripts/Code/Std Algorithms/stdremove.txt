<---EXPLANATION--->
### Algoritmos de la Biblioteca Estándar: `std::all_of`

La función `std::all_of` es un algoritmo de la biblioteca estándar de C++ que se utiliza para verificar si todos los elementos en un rango satisfacen una determinada condición. Es parte del encabezado `<algorithm>` y es muy útil para realizar verificaciones globales sobre los elementos de contenedores como vectores, listas, arrays, etc.

#### Sintaxis de `std::all_of`

```cpp
#include <algorithm>

template <class InputIt, class UnaryPredicate>
bool all_of(InputIt first, InputIt last, UnaryPredicate p);
```

- **`InputIt first`**: Iterador al primer elemento del rango.
- **`InputIt last`**: Iterador al elemento después del último en el rango.
- **`UnaryPredicate p`**: Una función o función objeto que toma un elemento del rango y devuelve un valor convertible a `bool`.

#### Descripción

`std::all_of` aplica el predicado `p` a todos los elementos en el rango `[first, last)` y devuelve `true` si el predicado devuelve `true` para todos los elementos. De lo contrario, devuelve `false`.

#### Ejemplo de Uso de `std::all_of`

##### Ejemplo Básico

```cpp
#include <iostream>
#include <vector>
#include <algorithm>

bool esPositivo(int n) {
    return n > 0;
}

int main() {
    std::vector<int> vec = {1, 2, 3, 4, 5};

    // Verificar si todos los elementos son positivos
    bool todosPositivos = std::all_of(vec.begin(), vec.end(), esPositivo);

    if (todosPositivos) {
        std::cout << "Todos los elementos son positivos." << std::endl;
    } else {
        std::cout << "No todos los elementos son positivos." << std::endl;
    }

    return 0;
}
```

En este ejemplo:
- `esPositivo` es una función que verifica si un número es mayor que cero.
- `std::all_of(vec.begin(), vec.end(), esPositivo)` verifica si todos los elementos del vector son positivos.

##### Ejemplo con Lambda

```cpp
#include <iostream>
#include <vector>
#include <algorithm>

int main() {
    std::vector<int> vec = {1, 2, 3, 4, 5};

    // Usar una lambda para verificar si todos los elementos son positivos
    bool todosPositivos = std::all_of(vec.begin(), vec.end(), [](int n) {
        return n > 0;
    });

    if (todosPositivos) {
        std::cout << "Todos los elementos son positivos." << std::endl;
    } else {
        std::cout << "No todos los elementos son positivos." << std::endl;
    }

    return 0;
}
```

En este ejemplo:
- Se usa una expresión lambda para definir el predicado en línea.

### Más Ejemplos

#### Verificar si Todos los Elementos son Pares

```cpp
#include <iostream>
#include <vector>
#include <algorithm>

int main() {
    std::vector<int> vec = {2, 4, 6, 8, 10};

    // Usar una lambda para verificar si todos los elementos son pares
    bool todosPares = std::all_of(vec.begin(), vec.end(), [](int n) {
        return n % 2 == 0;
    });

    if (todosPares) {
        std::cout << "Todos los elementos son pares." << std::endl;
    } else {
        std::cout << "No todos los elementos son pares." << std::endl;
    }

    return 0;
}
```

#### Verificar si Todos los Elementos Están en un Rango

```cpp
#include <iostream>
#include <vector>
#include <algorithm>

int main() {
    std::vector<int> vec = {5, 6, 7, 8, 9};

    // Usar una lambda para verificar si todos los elementos están en el rango [5, 10]
    bool enRango = std::all_of(vec.begin(), vec.end(), [](int n) {
        return n >= 5 && n <= 10;
    });

    if (enRango) {
        std::cout << "Todos los elementos están en el rango [5, 10]." << std::endl;
    } else {
        std::cout << "No todos los elementos están en el rango [5, 10]." << std::endl;
    }

    return 0;
}
```

### Consideraciones

- **Rendimiento:** `std::all_of` detiene la evaluación tan pronto como encuentra el primer elemento que no satisface el predicado, lo que puede mejorar el rendimiento en comparación con un bucle que siempre recorre todos los elementos.
- **Uso con Diferentes Contenedores:** Funciona con cualquier contenedor que soporte iteradores, como `std::vector`, `std::list`, `std::array`, etc.

### Conclusión

`std::all_of` es una función útil y poderosa de la biblioteca estándar de C++ que permite verificar de manera eficiente si todos los elementos en un rango cumplen con una condición específica. Su uso con funciones, funtores y lambdas proporciona una gran flexibilidad y es esencial para escribir código conciso y claro en C++.
### Algoritmo de la Biblioteca Estándar: `std::for_each`

El algoritmo `std::for_each` de la biblioteca estándar de C++ se utiliza para aplicar una función a cada elemento de un rango. Es una herramienta útil para realizar operaciones repetitivas en cada elemento de un contenedor.

#### Sintaxis de `std::for_each`

```cpp
#include <algorithm>

template <class InputIt, class UnaryFunction>
UnaryFunction for_each(InputIt first, InputIt last, UnaryFunction f);
```

- **`InputIt first`**: Iterador al primer elemento del rango.
- **`InputIt last`**: Iterador al elemento después del último en el rango.
- **`UnaryFunction f`**: Una función o función objeto que se aplicará a cada elemento en el rango.

#### Descripción

`std::for_each` aplica la función `f` a cada elemento en el rango `[first, last)`. La función `f` puede ser una función regular, un objeto de función (functor) o una lambda.

#### Ejemplo de Uso de `std::for_each`

##### Ejemplo Básico

```cpp
#include <iostream>
#include <vector>
#include <algorithm>

void imprimir(int n) {
    std::cout << n << " ";
}

int main() {
    std::vector<int> vec = {1, 2, 3, 4, 5};

    // Usar std::for_each para imprimir cada elemento del vector
    std::for_each(vec.begin(), vec.end(), imprimir);
    std::cout << std::endl;

    return 0;
}
```

En este ejemplo:
- `imprimir` es una función que toma un entero y lo imprime.
- `std::for_each(vec.begin(), vec.end(), imprimir)` aplica la función `imprimir` a cada elemento del vector.

##### Ejemplo con Lambda

```cpp
#include <iostream>
#include <vector>
#include <algorithm>

int main() {
    std::vector<int> vec = {1, 2, 3, 4, 5};

    // Usar una lambda para imprimir cada elemento del vector
    std::for_each(vec.begin(), vec.end(), [](int n) {
        std::cout << n << " ";
    });
    std::cout << std::endl;

    return 0;
}
```

En este ejemplo:
- Se usa una expresión lambda para definir la operación de impresión en línea.

### Más Ejemplos

#### Incrementar Cada Elemento de un Contenedor

```cpp
#include <iostream>
#include <vector>
#include <algorithm>

int main() {
    std::vector<int> vec = {1, 2, 3, 4, 5};

    // Usar una lambda para incrementar cada elemento del vector
    std::for_each(vec.begin(), vec.end(), [](int& n) {
        n += 1;
    });

    // Imprimir los elementos incrementados
    std::for_each(vec.begin(), vec.end(), [](int n) {
        std::cout << n << " ";
    });
    std::cout << std::endl;

    return 0;
}
```

En este ejemplo:
- La lambda incrementa cada elemento del vector en 1.
- Luego, se imprime cada elemento del vector utilizando `std::for_each`.

#### Acumular Valores Usando un Functor

```cpp
#include <iostream>
#include <vector>
#include <algorithm>

struct Acumulador {
    int suma = 0;

    void operator()(int n) {
        suma += n;
    }
};

int main() {
    std::vector<int> vec = {1, 2, 3, 4, 5};

    Acumulador acumulador = std::for_each(vec.begin(), vec.end(), Acumulador());

    std::cout << "Suma de los elementos: " << acumulador.suma << std::endl;

    return 0;
}
```

En este ejemplo:
- `Acumulador` es un functor que acumula la suma de los elementos.
- `std::for_each` aplica el functor a cada elemento del vector y devuelve el functor actualizado.

### Consideraciones

- **Rendimiento:** `std::for_each` es eficiente y generalmente se compila a código similar al de un bucle `for` explícito.
- **Modificabilidad:** La función o lambda pasada a `std::for_each` puede modificar los elementos del contenedor si se pasan por referencia.

### Conclusión

`std::for_each` es un algoritmo de la biblioteca estándar de C++ que proporciona una forma conveniente y expresiva de aplicar una operación a cada elemento de un rango. Su uso con funciones, funtores y lambdas ofrece gran flexibilidad, y es una herramienta valiosa para escribir código conciso y claro en C++.
### Algoritmo de la Biblioteca Estándar: `std::accumulate`

La función `std::accumulate` es un algoritmo de la biblioteca estándar de C++ que se utiliza para sumar los elementos de un rango, acumulando un valor inicial con el resultado de aplicar una operación binaria a los elementos del rango. Es parte del encabezado `<numeric>`.

#### Sintaxis de `std::accumulate`

```cpp
#include <numeric>

template <class InputIt, class T>
T accumulate(InputIt first, InputIt last, T init);

template <class InputIt, class T, class BinaryOperation>
T accumulate(InputIt first, InputIt last, T init, BinaryOperation op);
```

- **`InputIt first`**: Iterador al primer elemento del rango.
- **`InputIt last`**: Iterador al elemento después del último en el rango.
- **`T init`**: Valor inicial de la acumulación.
- **`BinaryOperation op`** (opcional): Operación binaria que se aplicará a los elementos y al acumulador.

#### Descripción

`std::accumulate` aplica una operación binaria a un valor inicial y a cada uno de los elementos del rango, acumulando el resultado. Si no se proporciona una operación binaria, se utiliza la suma por defecto.

#### Ejemplo de Uso de `std::accumulate`

##### Ejemplo Básico (Suma)

```cpp
#include <iostream>
#include <vector>
#include <numeric>

int main() {
    std::vector<int> vec = {1, 2, 3, 4, 5};

    // Usar std::accumulate para sumar todos los elementos
    int suma = std::accumulate(vec.begin(), vec.end(), 0);

    std::cout << "La suma de los elementos es: " << suma << std::endl;

    return 0;
}
```

En este ejemplo:
- `std::accumulate(vec.begin(), vec.end(), 0)` suma todos los elementos del vector comenzando con un valor inicial de `0`.

##### Ejemplo con Operación Binaria Personalizada (Multiplicación)

```cpp
#include <iostream>
#include <vector>
#include <numeric>

int main() {
    std::vector<int> vec = {1, 2, 3, 4, 5};

    // Usar std::accumulate para multiplicar todos los elementos
    int producto = std::accumulate(vec.begin(), vec.end(), 1, std::multiplies<int>());

    std::cout << "El producto de los elementos es: " << producto << std::endl;

    return 0;
}
```

En este ejemplo:
- `std::accumulate(vec.begin(), vec.end(), 1, std::multiplies<int>())` multiplica todos los elementos del vector comenzando con un valor inicial de `1`.

### Más Ejemplos

#### Concatenar Cadenas de Texto

```cpp
#include <iostream>
#include <vector>
#include <numeric>
#include <string>

int main() {
    std::vector<std::string> vec = {"Hola", " ", "mundo", "!"};

    // Usar std::accumulate para concatenar todas las cadenas
    std::string resultado = std::accumulate(vec.begin(), vec.end(), std::string(""));

    std::cout << "Cadena concatenada: " << resultado << std::endl;

    return 0;
}
```

En este ejemplo:
- `std::accumulate(vec.begin(), vec.end(), std::string(""))` concatena todas las cadenas del vector comenzando con una cadena vacía.

#### Calcular la Media de los Elementos

```cpp
#include <iostream>
#include <vector>
#include <numeric>

int main() {
    std::vector<int> vec = {1, 2, 3, 4, 5};

    // Calcular la suma de los elementos
    int suma = std::accumulate(vec.begin(), vec.end(), 0);

    // Calcular la media
    double media = static_cast<double>(suma) / vec.size();

    std::cout << "La media de los elementos es: " << media << std::endl;

    return 0;
}
```

En este ejemplo:
- Se calcula la suma de los elementos del vector y luego se divide por el número de elementos para obtener la media.

### Consideraciones

- **Rendimiento:** `std::accumulate` es eficiente y su rendimiento es lineal en relación con el número de elementos del rango.
- **Flexibilidad:** Puede usarse con cualquier tipo de contenedor que soporte iteradores y con cualquier operación binaria que tome dos parámetros del tipo de los elementos del contenedor.

### Conclusión

`std::accumulate` es un algoritmo versátil y poderoso de la biblioteca estándar de C++ que permite acumular valores en un rango utilizando una operación binaria. Su uso con funciones, funtores y lambdas ofrece gran flexibilidad y es esencial para escribir código conciso y claro en C++. Comprender cómo utilizar `std::accumulate` puede simplificar muchas operaciones comunes de reducción y acumulación en C++.
### Algoritmos de la Biblioteca Estándar: `std::max` y `std::min`

Las funciones `std::max` y `std::min` son parte de la biblioteca estándar de C++ y se utilizan para encontrar el mayor y el menor de dos valores, respectivamente. También existen versiones de estas funciones que operan sobre rangos de elementos. Estas funciones son parte del encabezado `<algorithm>`.

#### Sintaxis de `std::max` y `std::min`

##### `std::max`

```cpp
#include <algorithm>

template <class T>
const T& max(const T& a, const T& b);

template <class T, class Compare>
const T& max(const T& a, const T& b, Compare comp);

template <class ForwardIt>
ForwardIt max_element(ForwardIt first, ForwardIt last);

template <class ForwardIt, class Compare>
ForwardIt max_element(ForwardIt first, ForwardIt last, Compare comp);
```

##### `std::min`

```cpp
#include <algorithm>

template <class T>
const T& min(const T& a, const T& b);

template <class T, class Compare>
const T& min(const T& a, const T& b, Compare comp);

template <class ForwardIt>
ForwardIt min_element(ForwardIt first, ForwardIt last);

template <class ForwardIt, class Compare>
ForwardIt min_element(ForwardIt first, ForwardIt last, Compare comp);
```

#### Descripción

- **`std::max` y `std::min`:** Devuelven el mayor y el menor de dos valores, respectivamente. Se puede proporcionar una función de comparación personalizada.
- **`std::max_element` y `std::min_element`:** Encuentran el mayor y el menor elemento en un rango de elementos, respectivamente. Se puede proporcionar una función de comparación personalizada.

#### Ejemplo de Uso de `std::max` y `std::min`

##### Ejemplo Básico con Dos Valores

```cpp
#include <iostream>
#include <algorithm>

int main() {
    int a = 10, b = 20;

    // Encontrar el valor máximo
    int maxVal = std::max(a, b);
    std::cout << "El mayor de " << a << " y " << b << " es " << maxVal << std::endl;

    // Encontrar el valor mínimo
    int minVal = std::min(a, b);
    std::cout << "El menor de " << a << " y " << b << " es " << minVal << std::endl;

    return 0;
}
```

En este ejemplo:
- `std::max(a, b)` devuelve el mayor de `a` y `b`.
- `std::min(a, b)` devuelve el menor de `a` y `b`.

##### Ejemplo con Comparación Personalizada

```cpp
#include <iostream>
#include <algorithm>
#include <string>

int main() {
    std::string s1 = "apple", s2 = "orange";

    // Comparar las cadenas por longitud
    auto maxLen = std::max(s1, s2, [](const std::string& lhs, const std::string& rhs) {
        return lhs.size() < rhs.size();
    });

    std::cout << "La cadena con mayor longitud es: " << maxLen << std::endl;

    return 0;
}
```

En este ejemplo:
- Se usa una lambda para comparar las cadenas por su longitud.

#### Uso de `std::max_element` y `std::min_element`

##### Ejemplo Básico con un Rango de Elementos

```cpp
#include <iostream>
#include <vector>
#include <algorithm>

int main() {
    std::vector<int> vec = {1, 2, 3, 4, 5};

    // Encontrar el elemento máximo
    auto maxIt = std::max_element(vec.begin(), vec.end());
    std::cout << "El elemento máximo es: " << *maxIt << std::endl;

    // Encontrar el elemento mínimo
    auto minIt = std::min_element(vec.begin(), vec.end());
    std::cout << "El elemento mínimo es: " << *minIt << std::endl;

    return 0;
}
```

En este ejemplo:
- `std::max_element(vec.begin(), vec.end())` devuelve un iterador al elemento máximo en el vector.
- `std::min_element(vec.begin(), vec.end())` devuelve un iterador al elemento mínimo en el vector.

##### Ejemplo con Comparación Personalizada

```cpp
#include <iostream>
#include <vector>
#include <algorithm>

struct Punto {
    int x, y;
};

bool compararPorDistancia(const Punto& p1, const Punto& p2) {
    return (p1.x * p1.x + p1.y * p1.y) < (p2.x * p2.x + p2.y * p2.y);
}

int main() {
    std::vector<Punto> puntos = {{1, 2}, {3, 4}, {0, 5}, {-1, -1}};

    // Encontrar el punto más lejano del origen
    auto maxIt = std::max_element(puntos.begin(), puntos.end(), compararPorDistancia);
    std::cout << "El punto más lejano es: (" << maxIt->x << ", " << maxIt->y << ")" << std::endl;

    // Encontrar el punto más cercano al origen
    auto minIt = std::min_element(puntos.begin(), puntos.end(), compararPorDistancia);
    std::cout << "El punto más cercano es: (" << minIt->x << ", " << minIt->y << ")" << std::endl;

    return 0;
}
```

En este ejemplo:
- `compararPorDistancia` es una función que compara dos puntos por su distancia al origen.
- `std::max_element` y `std::min_element` usan esta función para encontrar el punto más lejano y el más cercano, respectivamente.

### Consideraciones

- **Rendimiento:** `std::max` y `std::min` operan en tiempo constante, mientras que `std::max_element` y `std::min_element` tienen un rendimiento lineal respecto al número de elementos en el rango.
- **Flexibilidad:** Se pueden usar con cualquier tipo de datos que soporte las operaciones de comparación necesarias.

### Conclusión

`std::max` y `std::min` son funciones útiles de la biblioteca estándar de C++ para encontrar el mayor y el menor de dos valores, respectivamente. `std::max_element` y `std::min_element` extienden esta funcionalidad para operar sobre rangos de elementos. La capacidad de proporcionar funciones de comparación personalizadas hace que estos algoritmos sean extremadamente flexibles y poderosos, permitiendo su uso en una amplia variedad de escenarios de programación.
### Algoritmos de la Biblioteca Estándar: `std::find` y `std::find_if`

Los algoritmos `std::find` y `std::find_if` son parte de la biblioteca estándar de C++ y se utilizan para buscar elementos en un rango. Son funciones de búsqueda lineal que permiten encontrar el primer elemento que cumple con un criterio específico.

#### `std::find`

`std::find` busca el primer elemento en el rango `[first, last)` que es igual al valor especificado.

##### Sintaxis

```cpp
#include <algorithm>

template <class InputIt, class T>
InputIt find(InputIt first, InputIt last, const T& value);
```

- **`InputIt first`**: Iterador al primer elemento del rango.
- **`InputIt last`**: Iterador al elemento después del último en el rango.
- **`const T& value`**: Valor a buscar.

##### Ejemplo de Uso de `std::find`

```cpp
#include <iostream>
#include <vector>
#include <algorithm>

int main() {
    std::vector<int> vec = {1, 2, 3, 4, 5};

    // Buscar el valor 3
    auto it = std::find(vec.begin(), vec.end(), 3);

    if (it != vec.end()) {
        std::cout << "Elemento encontrado: " << *it << std::endl;
    } else {
        std::cout << "Elemento no encontrado" << std::endl;
    }

    return 0;
}
```

En este ejemplo:
- `std::find(vec.begin(), vec.end(), 3)` busca el valor `3` en el vector `vec`.

#### `std::find_if`

`std::find_if` busca el primer elemento en el rango `[first, last)` que satisface el predicado especificado.

##### Sintaxis

```cpp
#include <algorithm>

template <class InputIt, class UnaryPredicate>
InputIt find_if(InputIt first, InputIt last, UnaryPredicate p);
```

- **`InputIt first`**: Iterador al primer elemento del rango.
- **`InputIt last`**: Iterador al elemento después del último en el rango.
- **`UnaryPredicate p`**: Función o función objeto que toma un elemento y devuelve `true` o `false`.

##### Ejemplo de Uso de `std::find_if`

```cpp
#include <iostream>
#include <vector>
#include <algorithm>

bool esImpar(int n) {
    return n % 2 != 0;
}

int main() {
    std::vector<int> vec = {2, 4, 6, 7, 8};

    // Buscar el primer elemento impar
    auto it = std::find_if(vec.begin(), vec.end(), esImpar);

    if (it != vec.end()) {
        std::cout << "Primer elemento impar encontrado: " << *it << std::endl;
    } else {
        std::cout << "Elemento impar no encontrado" << std::endl;
    }

    return 0;
}
```

En este ejemplo:
- `std::find_if(vec.begin(), vec.end(), esImpar)` busca el primer número impar en el vector `vec`.

#### `std::find_if` con Lambda

Las lambdas ofrecen una forma concisa y poderosa de definir el predicado en línea.

##### Ejemplo de Uso de `std::find_if` con Lambda

```cpp
#include <iostream>
#include <vector>
#include <algorithm>

int main() {
    std::vector<int> vec = {2, 4, 6, 7, 8};

    // Usar una lambda para buscar el primer elemento impar
    auto it = std::find_if(vec.begin(), vec.end(), [](int n) {
        return n % 2 != 0;
    });

    if (it != vec.end()) {
        std::cout << "Primer elemento impar encontrado: " << *it << std::endl;
    } else {
        std::cout << "Elemento impar no encontrado" << std::endl;
    }

    return 0;
}
```

### Más Ejemplos

#### Buscar un Punto en un Vector de Puntos

```cpp
#include <iostream>
#include <vector>
#include <algorithm>

struct Punto {
    int x, y;

    bool operator==(const Punto& otro) const {
        return x == otro.x && y == otro.y;
    }
};

int main() {
    std::vector<Punto> puntos = {{1, 2}, {3, 4}, {5, 6}, {7, 8}};
    Punto puntoABuscar = {5, 6};

    // Buscar el punto {5, 6}
    auto it = std::find(puntos.begin(), puntos.end(), puntoABuscar);

    if (it != puntos.end()) {
        std::cout << "Punto encontrado: (" << it->x << ", " << it->y << ")" << std::endl;
    } else {
        std::cout << "Punto no encontrado" << std::endl;
    }

    return 0;
}
```

#### Buscar un Número en un Vector que Sea Mayor que un Valor Específico

```cpp
#include <iostream>
#include <vector>
#include <algorithm>

int main() {
    std::vector<int> vec = {2, 4, 6, 7, 8};

    // Usar una lambda para buscar el primer elemento mayor que 5
    auto it = std::find_if(vec.begin(), vec.end(), [](int n) {
        return n > 5;
    });

    if (it != vec.end()) {
        std::cout << "Primer elemento mayor que 5 encontrado: " << *it << std::endl;
    } else {
        std::cout << "Elemento mayor que 5 no encontrado" << std::endl;
    }

    return 0;
}
```

### Consideraciones

- **Rendimiento:** Tanto `std::find` como `std::find_if` tienen un rendimiento lineal (`O(n)`), ya que pueden necesitar recorrer todo el rango de elementos en el peor de los casos.
- **Flexibilidad:** `std::find` es útil para buscar un valor específico, mientras que `std::find_if` proporciona una mayor flexibilidad al permitir la búsqueda basada en un predicado.

### Conclusión

`std::find` y `std::find_if` son algoritmos esenciales de la biblioteca estándar de C++ para realizar búsquedas lineales en rangos de elementos. `std::find` se utiliza para buscar un valor específico, mientras que `std::find_if` permite buscar con base en un predicado, proporcionando una gran flexibilidad. Estos algoritmos son fundamentales para escribir código C++ claro y eficiente, y son ampliamente utilizados en la programación diaria.
### Algoritmo de la Biblioteca Estándar: `std::copy`

La función `std::copy` es un algoritmo de la biblioteca estándar de C++ que se utiliza para copiar elementos de un rango a otro. Es parte del encabezado `<algorithm>` y es muy útil para duplicar o trasladar datos entre contenedores.

#### Sintaxis de `std::copy`

```cpp
#include <algorithm>

template <class InputIt, class OutputIt>
OutputIt copy(InputIt first, InputIt last, OutputIt d_first);
```

- **`InputIt first`**: Iterador al primer elemento del rango de entrada.
- **`InputIt last`**: Iterador al elemento después del último en el rango de entrada.
- **`OutputIt d_first`**: Iterador al primer elemento del rango de destino.

#### Descripción

`std::copy` copia los elementos del rango `[first, last)` al rango que comienza en `d_first`. El rango de destino debe ser lo suficientemente grande para contener todos los elementos copiados.

#### Ejemplo de Uso de `std::copy`

##### Ejemplo Básico

```cpp
#include <iostream>
#include <vector>
#include <algorithm>

int main() {
    std::vector<int> origen = {1, 2, 3, 4, 5};
    std::vector<int> destino(origen.size());

    // Usar std::copy para copiar los elementos
    std::copy(origen.begin(), origen.end(), destino.begin());

    // Mostrar los elementos copiados
    std::cout << "Elementos copiados al vector destino: ";
    for (int elem : destino) {
        std::cout << elem << " ";
    }
    std::cout << std::endl;

    return 0;
}
```

En este ejemplo:
- `std::copy(origen.begin(), origen.end(), destino.begin())` copia todos los elementos del vector `origen` al vector `destino`.

### Uso con Diferentes Tipos de Contenedores

`std::copy` se puede usar con cualquier contenedor que soporte iteradores, como `std::vector`, `std::list`, `std::array`, etc.

##### Copiar Elementos entre Diferentes Contenedores

```cpp
#include <iostream>
#include <vector>
#include <list>
#include <algorithm>

int main() {
    std::vector<int> origen = {1, 2, 3, 4, 5};
    std::list<int> destino(origen.size());

    // Usar std::copy para copiar los elementos
    std::copy(origen.begin(), origen.end(), destino.begin());

    // Mostrar los elementos copiados
    std::cout << "Elementos copiados a la lista destino: ";
    for (int elem : destino) {
        std::cout << elem << " ";
    }
    std::cout << std::endl;

    return 0;
}
```

En este ejemplo:
- `std::copy` se usa para copiar elementos de un `std::vector` a un `std::list`.

### Ejemplos Adicionales

#### Copiar un Rango Parcial de Elementos

```cpp
#include <iostream>
#include <vector>
#include <algorithm>

int main() {
    std::vector<int> origen = {1, 2, 3, 4, 5};
    std::vector<int> destino(3);

    // Usar std::copy para copiar los primeros 3 elementos
    std::copy(origen.begin(), origen.begin() + 3, destino.begin());

    // Mostrar los elementos copiados
    std::cout << "Primeros 3 elementos copiados al vector destino: ";
    for (int elem : destino) {
        std::cout << elem << " ";
    }
    std::cout << std::endl;

    return 0;
}
```

En este ejemplo:
- `std::copy(origen.begin(), origen.begin() + 3, destino.begin())` copia los primeros tres elementos del vector `origen` al vector `destino`.

#### Copiar con `std::back_inserter`

Si el contenedor de destino no tiene suficiente espacio reservado, se puede utilizar un `std::back_inserter` para que el contenedor crezca automáticamente.

```cpp
#include <iostream>
#include <vector>
#include <algorithm>
#include <iterator>

int main() {
    std::vector<int> origen = {1, 2, 3, 4, 5};
    std::vector<int> destino;

    // Usar std::copy con std::back_inserter
    std::copy(origen.begin(), origen.end(), std::back_inserter(destino));

    // Mostrar los elementos copiados
    std::cout << "Elementos copiados al vector destino con back_inserter: ";
    for (int elem : destino) {
        std::cout << elem << " ";
    }
    std::cout << std::endl;

    return 0;
}
```

En este ejemplo:
- `std::back_inserter(destino)` se utiliza para insertar elementos al final del vector `destino`, expandiendo automáticamente su tamaño según sea necesario.

### Consideraciones

- **Rendimiento:** `std::copy` es muy eficiente y generalmente se compila a un bucle simple que copia elementos.
- **Seguridad:** Asegúrese de que el rango de destino sea lo suficientemente grande para contener todos los elementos del rango de origen para evitar accesos fuera de los límites.

### Conclusión

`std::copy` es un algoritmo fundamental de la biblioteca estándar de C++ que proporciona una forma eficiente y flexible de copiar elementos entre contenedores. Su uso con iteradores y adaptadores de inserción como `std::back_inserter` permite una gran variedad de operaciones de copia, adecuándose a las necesidades de diferentes tipos de contenedores. Comprender y utilizar `std::copy` es esencial para escribir código C++ robusto y eficiente.
### Algoritmo de la Biblioteca Estándar: `std::sort`

La función `std::sort` es un algoritmo de la biblioteca estándar de C++ que se utiliza para ordenar los elementos de un rango. Es parte del encabezado `<algorithm>` y es ampliamente utilizada debido a su eficiencia y flexibilidad.

#### Sintaxis de `std::sort`

```cpp
#include <algorithm>

template <class RandomIt>
void sort(RandomIt first, RandomIt last);

template <class RandomIt, class Compare>
void sort(RandomIt first, RandomIt last, Compare comp);
```

- **`RandomIt first`**: Iterador al primer elemento del rango.
- **`RandomIt last`**: Iterador al elemento después del último en el rango.
- **`Compare comp`**: (Opcional) Función o función objeto que define el criterio de comparación.

#### Descripción

`std::sort` ordena los elementos en el rango `[first, last)` en orden ascendente por defecto. Si se proporciona una función de comparación, se utiliza esa función para determinar el orden.

#### Ejemplo de Uso de `std::sort`

##### Ejemplo Básico (Orden Ascendente)

```cpp
#include <iostream>
#include <vector>
#include <algorithm>

int main() {
    std::vector<int> vec = {5, 2, 9, 1, 5, 6};

    // Usar std::sort para ordenar los elementos en orden ascendente
    std::sort(vec.begin(), vec.end());

    // Mostrar los elementos ordenados
    std::cout << "Elementos ordenados: ";
    for (int elem : vec) {
        std::cout << elem << " ";
    }
    std::cout << std::endl;

    return 0;
}
```

En este ejemplo:
- `std::sort(vec.begin(), vec.end())` ordena todos los elementos del vector `vec` en orden ascendente.

##### Ejemplo con Comparación Personalizada (Orden Descendente)

```cpp
#include <iostream>
#include <vector>
#include <algorithm>

int main() {
    std::vector<int> vec = {5, 2, 9, 1, 5, 6};

    // Usar std::sort con una función de comparación para ordenar en orden descendente
    std::sort(vec.begin(), vec.end(), std::greater<int>());

    // Mostrar los elementos ordenados
    std::cout << "Elementos ordenados en orden descendente: ";
    for (int elem : vec) {
        std::cout << elem << " ";
    }
    std::cout << std::endl;

    return 0;
}
```

En este ejemplo:
- `std::sort(vec.begin(), vec.end(), std::greater<int>())` ordena los elementos del vector `vec` en orden descendente usando `std::greater`.

### Uso con Diferentes Tipos de Contenedores

`std::sort` se puede usar con cualquier contenedor que soporte iteradores de acceso aleatorio, como `std::vector`, `std::array`, y `std::deque`.

##### Ordenar un `std::array`

```cpp
#include <iostream>
#include <array>
#include <algorithm>

int main() {
    std::array<int, 6> arr = {5, 2, 9, 1, 5, 6};

    // Usar std::sort para ordenar los elementos del array
    std::sort(arr.begin(), arr.end());

    // Mostrar los elementos ordenados
    std::cout << "Elementos del array ordenados: ";
    for (int elem : arr) {
        std::cout << elem << " ";
    }
    std::cout << std::endl;

    return 0;
}
```

En este ejemplo:
- `std::sort` se usa para ordenar los elementos de
### Algoritmo de la Biblioteca Estándar: `std::transform`

La función `std::transform` es un algoritmo de la biblioteca estándar de C++ que se utiliza para aplicar una operación a un rango de elementos y almacenar los resultados en otro rango (o el mismo). Es parte del encabezado `<algorithm>` y es muy útil para transformar elementos de contenedores mediante la aplicación de una función.

#### Sintaxis de `std::transform`

Hay dos variantes de `std::transform`:

1. Aplicar una función unaria a cada elemento de un rango:

```cpp
#include <algorithm>

template <class InputIt, class OutputIt, class UnaryOperation>
OutputIt transform(InputIt first, InputIt last, OutputIt d_first, UnaryOperation unary_op);
```

- **`InputIt first`**: Iterador al primer elemento del rango de entrada.
- **`InputIt last`**: Iterador al elemento después del último en el rango de entrada.
- **`OutputIt d_first`**: Iterador al primer elemento del rango de destino.
- **`UnaryOperation unary_op`**: Función o función objeto que se aplicará a cada elemento del rango de entrada.

2. Aplicar una función binaria a cada par de elementos de dos rangos:

```cpp
#include <algorithm>

template <class InputIt1, class InputIt2, class OutputIt, class BinaryOperation>
OutputIt transform(InputIt1 first1, InputIt1 last1, InputIt2 first2, OutputIt d_first, BinaryOperation binary_op);
```

- **`InputIt1 first1`**: Iterador al primer elemento del primer rango de entrada.
- **`InputIt1 last1`**: Iterador al elemento después del último en el primer rango de entrada.
- **`InputIt2 first2`**: Iterador al primer elemento del segundo rango de entrada.
- **`OutputIt d_first`**: Iterador al primer elemento del rango de destino.
- **`BinaryOperation binary_op`**: Función o función objeto que se aplicará a cada par de elementos de los dos rangos de entrada.

#### Ejemplo de Uso de `std::transform`

##### Ejemplo Básico (Función Unaria)

```cpp
#include <iostream>
#include <vector>
#include <algorithm>

int main() {
    std::vector<int> origen = {1, 2, 3, 4, 5};
    std::vector<int> destino(origen.size());

    // Usar std::transform para duplicar cada elemento
    std::transform(origen.begin(), origen.end(), destino.begin(), [](int x) {
        return x * 2;
    });

    // Mostrar los elementos transformados
    std::cout << "Elementos transformados (duplicados): ";
    for (int elem : destino) {
        std::cout << elem << " ";
    }
    std::cout << std::endl;

    return 0;
}
```

En este ejemplo:
- `std::transform(origen.begin(), origen.end(), destino.begin(), [](int x) { return x * 2; })` aplica una lambda que duplica cada elemento del vector `origen` y almacena los resultados en el vector `destino`.

##### Ejemplo con Función Binaria

```cpp
#include <iostream>
#include <vector>
#include <algorithm>

int main() {
    std::vector<int> vec1 = {1, 2, 3, 4, 5};
    std::vector<int> vec2 = {10, 20, 30, 40, 50};
    std::vector<int> resultado(vec1.size());

    // Usar std::transform para sumar elementos de dos vectores
    std::transform(vec1.begin(), vec1.end(), vec2.begin(), resultado.begin(), [](int x, int y) {
        return x + y;
    });

    // Mostrar los elementos transformados
    std::cout << "Elementos transformados (suma de vec1 y vec2): ";
    for (int elem : resultado) {
        std::cout << elem << " ";
    }
    std::cout << std::endl;

    return 0;
}
```

En este ejemplo:
- `std::transform(vec1.begin(), vec1.end(), vec2.begin(), resultado.begin(), [](int x, int y) { return x + y; })` aplica una lambda que suma los elementos correspondientes de `vec1` y `vec2`, almacenando los resultados en `resultado`.

### Uso con Diferentes Tipos de Contenedores

`std::transform` se puede usar con cualquier contenedor que soporte iteradores, como `std::vector`, `std::list`, `std::array`, etc.

##### Transformar una Lista

```cpp
#include <iostream>
#include <list>
#include <algorithm>

int main() {
    std::list<int> origen = {1, 2, 3, 4, 5};
    std::list<int> destino(origen.size());

    // Usar std::transform para incrementar cada elemento
    std::transform(origen.begin(), origen.end(), destino.begin(), [](int x) {
        return x + 1;
    });

    // Mostrar los elementos transformados
    std::cout << "Elementos transformados (incrementados): ";
    for (int elem : destino) {
        std::cout << elem << " ";
    }
    std::cout << std::endl;

    return 0;
}
```

En este ejemplo:
- `std::transform` se usa para incrementar cada elemento de una lista.

### Consideraciones

- **Rendimiento:** `std::transform` es muy eficiente y tiene un rendimiento lineal (`O(n)`) respecto al número de elementos.
- **Flexibilidad:** Puede usar funciones, funtores y lambdas para definir las transformaciones.
- **Requisito de Espacio:** El rango de destino debe ser lo suficientemente grande para contener todos los elementos transformados.

### Conclusión

`std::transform` es un algoritmo de la biblioteca estándar de C++ muy útil para aplicar operaciones a los elementos de un contenedor y almacenar los resultados en otro. Su uso con funciones, funtores y lambdas proporciona una gran flexibilidad y permite escribir código conciso y claro. Comprender y utilizar `std::transform` es esencial para realizar transformaciones eficientes en datos en C++.
### Algoritmo de la Biblioteca Estándar: `std::fill`

La función `std::fill` es un algoritmo de la biblioteca estándar de C++ que se utiliza para asignar un valor a todos los elementos en un rango. Es parte del encabezado `<algorithm>` y se utiliza comúnmente para inicializar o restablecer los elementos de un contenedor.

#### Sintaxis de `std::fill`

```cpp
#include <algorithm>

template <class ForwardIt, class T>
void fill(ForwardIt first, ForwardIt last, const T& value);
```

- **`ForwardIt first`**: Iterador al primer elemento del rango.
- **`ForwardIt last`**: Iterador al elemento después del último en el rango.
- **`const T& value`**: Valor a asignar a los elementos del rango.

#### Descripción

`std::fill` asigna el valor `value` a cada elemento en el rango `[first, last)`. El rango debe ser accesible mediante iteradores de avance (forward iterators).

#### Ejemplo de Uso de `std::fill`

##### Ejemplo Básico

```cpp
#include <iostream>
#include <vector>
#include <algorithm>

int main() {
    std::vector<int> vec(10);

    // Usar std::fill para asignar el valor 5 a todos los elementos del vector
    std::fill(vec.begin(), vec.end(), 5);

    // Mostrar los elementos del vector
    std::cout << "Elementos del vector después de std::fill: ";
    for (int elem : vec) {
        std::cout << elem << " ";
    }
    std::cout << std::endl;

    return 0;
}
```

En este ejemplo:
- `std::fill(vec.begin(), vec.end(), 5)` asigna el valor `5` a todos los elementos del vector `vec`.

### Uso con Diferentes Tipos de Contenedores

`std::fill` se puede usar con cualquier contenedor que soporte iteradores de avance, como `std::vector`, `std::list`, `std::array`, etc.

##### Ejemplo con `std::array`

```cpp
#include <iostream>
#include <array>
#include <algorithm>

int main() {
    std::array<int, 5> arr;

    // Usar std::fill para asignar el valor 10 a todos los elementos del array
    std::fill(arr.begin(), arr.end(), 10);

    // Mostrar los elementos del array
    std::cout << "Elementos del array después de std::fill: ";
    for (int elem : arr) {
        std::cout << elem << " ";
    }
    std::cout << std::endl;

    return 0;
}
```

En este ejemplo:
- `std::fill(arr.begin(), arr.end(), 10)` asigna el valor `10` a todos los elementos del array `arr`.

### Ejemplos Adicionales

#### Inicializar una Matriz

`std::fill` también puede ser utilizado para inicializar matrices u otras estructuras de datos.

##### Ejemplo con una Matriz

```cpp
#include <iostream>
#include <vector>
#include <algorithm>

int main() {
    std::vector<std::vector<int>> matrix(3, std::vector<int>(4));

    // Usar std::fill para asignar el valor 0 a todos los elementos de la matriz
    for (auto& row : matrix) {
        std::fill(row.begin(), row.end(), 0);
    }

    // Mostrar los elementos de la matriz
    std::cout << "Elementos de la matriz después de std::fill: " << std::endl;
    for (const auto& row : matrix) {
        for (int elem : row) {
            std::cout << elem << " ";
        }
        std::cout << std::endl;
    }

    return 0;
}
```

En este ejemplo:
- `std::fill` se utiliza en cada fila de la matriz para asignar el valor `0` a todos los elementos.

### Uso con Rangos Parciales

##### Ejemplo de Rango Parcial

```cpp
#include <iostream>
#include <vector>
#include <algorithm>

int main() {
    std::vector<int> vec(10);

    // Asignar el valor 1 a la primera mitad del vector
    std::fill(vec.begin(), vec.begin() + vec.size() / 2, 1);

    // Asignar el valor 2 a la segunda mitad del vector
    std::fill(vec.begin() + vec.size() / 2, vec.end(), 2);

    // Mostrar los elementos del vector
    std::cout << "Elementos del vector después de std::fill en rangos parciales: ";
    for (int elem : vec) {
        std::cout << elem << " ";
    }
    std::cout << std::endl;

    return 0;
}
```

En este ejemplo:
- `std::fill` se utiliza para asignar diferentes valores a distintas partes del vector.

### Consideraciones

- **Rendimiento:** `std::fill` es muy eficiente y generalmente se compila a un bucle simple que asigna el valor a cada elemento del rango.
- **Flexibilidad:** Puede usarse con cualquier tipo de contenedor que soporte iteradores de avance.
- **Seguridad:** Asegúrese de que el rango especificado esté dentro de los límites del contenedor para evitar accesos fuera de los límites.

### Conclusión

`std::fill` es un algoritmo simple pero poderoso de la biblioteca estándar de C++ que proporciona una forma eficiente y flexible de asignar valores a los elementos de un contenedor. Su uso es fundamental para inicializar o restablecer contenedores y es una herramienta esencial en el arsenal de cualquier programador de C++.
### Algoritmo de la Biblioteca Estándar: `std::replace`

La función `std::replace` es un algoritmo de la biblioteca estándar de C++ que se utiliza para reemplazar todos los elementos de un rango que son iguales a un valor específico por otro valor. Es parte del encabezado `<algorithm>` y es muy útil para modificar elementos de contenedores en base a una condición de igualdad.

#### Sintaxis de `std::replace`

```cpp
#include <algorithm>

template <class ForwardIt, class T>
void replace(ForwardIt first, ForwardIt last, const T& old_value, const T& new_value);
```

- **`ForwardIt first`**: Iterador al primer elemento del rango.
- **`ForwardIt last`**: Iterador al elemento después del último en el rango.
- **`const T& old_value`**: Valor que será reemplazado.
- **`const T& new_value`**: Valor que reemplazará a `old_value`.

#### Descripción

`std::replace` reemplaza cada elemento en el rango `[first, last)` que es igual a `old_value` por `new_value`.

#### Ejemplo de Uso de `std::replace`

##### Ejemplo Básico

```cpp
#include <iostream>
#include <vector>
#include <algorithm>

int main() {
    std::vector<int> vec = {1, 2, 3, 2, 5, 2};

    // Usar std::replace para reemplazar todos los 2 por 9
    std::replace(vec.begin(), vec.end(), 2, 9);

    // Mostrar los elementos modificados
    std::cout << "Elementos del vector después de std::replace: ";
    for (int elem : vec) {
        std::cout << elem << " ";
    }
    std::cout << std::endl;

    return 0;
}
```

En este ejemplo:
- `std::replace(vec.begin(), vec.end(), 2, 9)` reemplaza todas las ocurrencias del valor `2` en el vector `vec` con `9`.

### Uso con Diferentes Tipos de Contenedores

`std::replace` se puede usar con cualquier contenedor que soporte iteradores de avance, como `std::vector`, `std::list`, `std::array`, etc.

##### Ejemplo con `std::list`

```cpp
#include <iostream>
#include <list>
#include <algorithm>

int main() {
    std::list<int> lst = {1, 2, 3, 2, 5, 2};

    // Usar std::replace para reemplazar todos los 2 por 9
    std::replace(lst.begin(), lst.end(), 2, 9);

    // Mostrar los elementos modificados
    std::cout << "Elementos de la lista después de std::replace: ";
    for (int elem : lst) {
        std::cout << elem << " ";
    }
    std::cout << std::endl;

    return 0;
}
```

En este ejemplo:
- `std::replace` se utiliza para reemplazar todas las ocurrencias del valor `2` en la lista `lst` con `9`.

### Ejemplos Adicionales

#### Reemplazar un Rango Parcial de Elementos

```cpp
#include <iostream>
#include <vector>
#include <algorithm>

int main() {
    std::vector<int> vec = {1, 2, 3, 2, 5, 2};

    // Usar std::replace para reemplazar todos los 2 por 9 en la primera mitad del vector
    std::replace(vec.begin(), vec.begin() + vec.size() / 2, 2, 9);

    // Mostrar los elementos modificados
    std::cout << "Elementos del vector después de std::replace en la primera mitad: ";
    for (int elem : vec) {
        std::cout << elem << " ";
    }
    std::cout << std::endl;

    return 0;
}
```

En este ejemplo:
- `std::replace(vec.begin(), vec.begin() + vec.size() / 2, 2, 9)` reemplaza todas las ocurrencias del valor `2` en la primera mitad del vector `vec` con `9`.

### Variantes: `std::replace_if`

Además de `std::replace`, existe una variante llamada `std::replace_if` que reemplaza los elementos basados en un predicado.

#### Sintaxis de `std::replace_if`

```cpp
#include <algorithm>

template <class ForwardIt, class UnaryPredicate, class T>
void replace_if(ForwardIt first, ForwardIt last, UnaryPredicate p, const T& new_value);
```

- **`ForwardIt first`**: Iterador al primer elemento del rango.
- **`ForwardIt last`**: Iterador al elemento después del último en el rango.
- **`UnaryPredicate p`**: Predicado que define la condición de reemplazo.
- **`const T& new_value`**: Valor que reemplazará a los elementos que satisfacen el predicado.

#### Ejemplo de Uso de `std::replace_if`

##### Ejemplo Básico con `std::replace_if`

```cpp
#include <iostream>
#include <vector>
#include <algorithm>

bool esPar(int n) {
    return n % 2 == 0;
}

int main() {
    std::vector<int> vec = {1, 2, 3, 4, 5, 6};

    // Usar std::replace_if para reemplazar todos los números pares por 0
    std::replace_if(vec.begin(), vec.end(), esPar, 0);

    // Mostrar los elementos modificados
    std::cout << "Elementos del vector después de std::replace_if: ";
    for (int elem : vec) {
        std::cout << elem << " ";
    }
    std::cout << std::endl;

    return 0;
}
```

En este ejemplo:
- `std::replace_if(vec.begin(), vec.end(), esPar, 0)` reemplaza todos los números pares en el vector `vec` con `0`.

##### Ejemplo con Lambda

```cpp
#include <iostream>
#include <vector>
#include <algorithm>

int main() {
    std::vector<int> vec = {1, 2, 3, 4, 5, 6};

    // Usar std::replace_if con una lambda para reemplazar todos los números mayores que 3 por 99
    std::replace_if(vec.begin(), vec.end(), [](int n) { return n > 3; }, 99);

    // Mostrar los elementos modificados
    std::cout << "Elementos del vector después de std::replace_if: ";
    for (int elem : vec) {
        std::cout << elem << " ";
    }
    std::cout << std::endl;

    return 0;
}
```

En este ejemplo:
- `std::replace_if(vec.begin(), vec.end(), [](int n) { return n > 3; }, 99)` reemplaza todos los números mayores que `3` en el vector `vec` con `99`.

### Consideraciones

- **Rendimiento:** `std::replace` y `std::replace_if` tienen un rendimiento lineal (`O(n)`), ya que necesitan recorrer todo el rango de elementos.
- **Flexibilidad:** `std::replace` es útil para reemplazar valores específicos, mientras que `std::replace_if` proporciona mayor flexibilidad al permitir reemplazos basados en un predicado.
- **Uso de Predicados:** `std::replace_if` puede utilizar funciones, funtores y lambdas como predicados, lo que lo hace extremadamente versátil.

### Conclusión

`std::replace` y `std::replace_if` son algoritmos de la biblioteca estándar de C++ que proporcionan formas eficientes y flexibles de reemplazar elementos en contenedores. `std::replace` se usa para reemplazar valores específicos, mientras que `std::replace_if` permite realizar reemplazos basados en condiciones más complejas definidas por predicados. Comprender y utilizar estos algoritmos es esencial para escribir código C++ claro, eficiente y fácil de mantener.
### Algoritmo de la Biblioteca Estándar: `std::remove`

La función `std::remove` es un algoritmo de la biblioteca estándar de C++ que se utiliza para eliminar elementos de un contenedor que son iguales a un valor específico. Sin embargo, `std::remove` no elimina físicamente los elementos del contenedor, sino que los mueve al final del rango y devuelve un iterador al nuevo final lógico del rango sin los elementos eliminados. Es parte del encabezado `<algorithm>`.

#### Sintaxis de `std::remove`

```cpp
#include <algorithm>

template <class ForwardIt, class T>
ForwardIt remove(ForwardIt first, ForwardIt last, const T& value);
```

- **`ForwardIt first`**: Iterador al primer elemento del rango.
- **`ForwardIt last`**: Iterador al elemento después del último en el rango.
- **`const T& value`**: Valor de los elementos a eliminar.

#### Descripción

`std::remove` reordena los elementos del rango `[first, last)` de modo que todos los elementos que no son iguales a `value` se encuentran al principio del rango, y devuelve un iterador al nuevo final lógico del rango que no contiene los elementos eliminados.

#### Ejemplo de Uso de `std::remove`

##### Ejemplo Básico

```cpp
#include <iostream>
#include <vector>
#include <algorithm>

int main() {
    std::vector<int> vec = {1, 2, 3, 2, 5, 2};

    // Usar std::remove para mover los elementos que no son 2 al principio
    auto it = std::remove(vec.begin(), vec.end(), 2);

    // Eliminar físicamente los elementos después del nuevo final lógico
    vec.erase(it, vec.end());

    // Mostrar los elementos restantes
    std::cout << "Elementos del vector después de std::remove y erase: ";
    for (int elem : vec) {
        std::cout << elem << " ";
    }
    std::cout << std::endl;

    return 0;
}
```

En este ejemplo:
- `std::remove(vec.begin(), vec.end(), 2)` reordena los elementos del vector `vec` moviendo todos los `2` al final y devuelve un iterador al nuevo final lógico del vector.
- `vec.erase(it, vec.end())` elimina físicamente los elementos desde el nuevo final lógico hasta el final real del vector.

### Uso con Diferentes Tipos de Contenedores

`std::remove` se puede usar con cualquier contenedor que soporte iteradores de avance, como `std::vector`, `std::list`, `std::deque`, etc.

##### Ejemplo con `std::list`

```cpp
#include <iostream>
#include <list>
#include <algorithm>

int main() {
    std::list<int> lst = {1, 2, 3, 2, 5, 2};

    // Usar std::remove para mover los elementos que no son 2 al principio
    auto it = std::remove(lst.begin(), lst.end(), 2);

    // Eliminar físicamente los elementos después del nuevo final lógico
    lst.erase(it, lst.end());

    // Mostrar los elementos restantes
    std::cout << "Elementos de la lista después de std::remove y erase: ";
    for (int elem : lst) {
        std::cout << elem << " ";
    }
    std::cout << std::endl;

    return 0;
}
```

En este ejemplo:
- `std::remove` se utiliza para mover todas las ocurrencias del valor `2` al final de la lista `lst`.
- `lst.erase(it, lst.end())` elimina físicamente estos elementos.

### Variantes: `std::remove_if`

Además de `std::remove`, existe una variante llamada `std::remove_if` que elimina elementos basados en un predicado.

#### Sintaxis de `std::remove_if`

```cpp
#include <algorithm>

template <class ForwardIt, class UnaryPredicate>
ForwardIt remove_if(ForwardIt first, ForwardIt last, UnaryPredicate p);
```

- **`ForwardIt first`**: Iterador al primer elemento del rango.
- **`ForwardIt last`**: Iterador al elemento después del último en el rango.
- **`UnaryPredicate p`**: Predicado que define la condición de eliminación.

#### Ejemplo de Uso de `std::remove_if`

##### Ejemplo Básico con `std::remove_if`

```cpp
#include <iostream>
#include <vector>
#include <algorithm>

bool esPar(int n) {
    return n % 2 == 0;
}

int main() {
    std::vector<int> vec = {1, 2, 3, 4, 5, 6};

    // Usar std::remove_if para mover los números pares al final
    auto it = std::remove_if(vec.begin(), vec.end(), esPar);

    // Eliminar físicamente los elementos después del nuevo final lógico
    vec.erase(it, vec.end());

    // Mostrar los elementos restantes
    std::cout << "Elementos del vector después de std::remove_if y erase: ";
    for (int elem : vec) {
        std::cout << elem << " ";
    }
    std::cout << std::endl;

    return 0;
}
```

En este ejemplo:
- `std::remove_if(vec.begin(), vec.end(), esPar)` reordena los elementos del vector `vec` moviendo todos los números pares al final y devuelve un iterador al nuevo final lógico del vector.
- `vec.erase(it, vec.end())` elimina físicamente estos elementos.

##### Ejemplo con Lambda

```cpp
#include <iostream>
#include <vector>
#include <algorithm>

int main() {
    std::vector<int> vec = {1, 2, 3, 4, 5, 6};

    // Usar std::remove_if con una lambda para mover los números mayores que 3 al final
    auto it = std::remove_if(vec.begin(), vec.end(), [](int n) { return n > 3; });

    // Eliminar físicamente los elementos después del nuevo final lógico
    vec.erase(it, vec.end());

    // Mostrar los elementos restantes
    std::cout << "Elementos del vector después de std::remove_if y erase: ";
    for (int elem : vec) {
        std::cout << elem << " ";
    }
    std::cout << std::endl;

    return 0;
}
```

En este ejemplo:
- `std::remove_if(vec.begin(), vec.end(), [](int n) { return n > 3; })` mueve todos los números mayores que `3` al final del vector `vec`.
- `vec.erase(it, vec.end())` elimina físicamente estos elementos.

### Consideraciones

- **Rendimiento:** `std::remove` y `std::remove_if` tienen un rendimiento lineal (`O(n)`), ya que necesitan recorrer todo el rango de elementos.
- **Uso de Predicados:** `std::remove_if` puede utilizar funciones, funtores y lambdas como predicados, lo que lo hace extremadamente versátil.
- **Eliminar Físicamente:** Aunque `std::remove` y `std::remove_if` reorganizan los elementos para mover los que se van a eliminar al final del rango, es necesario utilizar `erase` para eliminar físicamente los elementos del contenedor.

### Conclusión

`std::remove` y `std::remove_if` son algoritmos de la biblioteca estándar de C++ que proporcionan una manera eficiente de eliminar elementos de un contenedor basados en un valor o una condición. Estos algoritmos reorganizan los elementos y devuelven un iterador al nuevo final lógico del rango, lo que permite una eliminación física posterior. Comprender y utilizar `std::remove` y `std::remove_if` es esencial para realizar operaciones de eliminación eficientes en contenedores en C++.
<---FILES--->
Ejemplo Básico
Ejemplo Básico Result
Ejemplo con Lambda
Ejemplo con Lambda Result
Ejemplo Básico
Ejemplo Básico Result
Ejemplo con Lambda
Ejemplo con Lambda Result
Ejemplo Básico
Ejemplo Básico Result
Ejemplo con Lambda
Ejemplo con Lambda Result
Ejemplo Básico (Suma)
Ejemplo Básico (Suma) Result
Ejemplo con Operación Binaria Personalizada (Multiplicación)
Ejemplo con Operación Binaria Personalizada (Multiplicación) Result
Ejemplo Básico
Ejemplo Básico Result
Ejemplo con Lambda
Ejemplo con Lambda Result
Ejemplo Básico (Suma)
Ejemplo Básico (Suma) Result
Ejemplo con Operación Binaria Personalizada (Multiplicación)
Ejemplo con Operación Binaria Personalizada (Multiplicación) Result
`std::max`
`std::max` Result
`std::min`
`std::min` Result
Ejemplo Básico con Dos Valores
Ejemplo Básico con Dos Valores Result
Ejemplo con Comparación Personalizada
Ejemplo con Comparación Personalizada Result
Ejemplo Básico con un Rango de Elementos
Ejemplo Básico con un Rango de Elementos Result
Ejemplo Básico
Ejemplo Básico Result
Ejemplo con Lambda
Ejemplo con Lambda Result
Ejemplo Básico (Suma)
Ejemplo Básico (Suma) Result
Ejemplo con Operación Binaria Personalizada (Multiplicación)
Ejemplo con Operación Binaria Personalizada (Multiplicación) Result
`std::max`
`std::max` Result
`std::min`
`std::min` Result
Ejemplo Básico con Dos Valores
Ejemplo Básico con Dos Valores Result
Ejemplo con Comparación Personalizada
Ejemplo con Comparación Personalizada Result
Ejemplo Básico con un Rango de Elementos
Ejemplo Básico con un Rango de Elementos Result
Sintaxis
Sintaxis Result
Ejemplo de Uso de `std::find`
Ejemplo de Uso de `std::find` Result
Ejemplo de Uso de `std::find_if`
Ejemplo de Uso de `std::find_if` Result
Ejemplo de Uso de `std::find_if` con Lambda
Ejemplo de Uso de `std::find_if` con Lambda Result
Ejemplo Básico
Ejemplo Básico Result
Ejemplo con Lambda
Ejemplo con Lambda Result
Ejemplo Básico (Suma)
Ejemplo Básico (Suma) Result
Ejemplo con Operación Binaria Personalizada (Multiplicación)
Ejemplo con Operación Binaria Personalizada (Multiplicación) Result
`std::max`
`std::max` Result
`std::min`
`std::min` Result
Ejemplo Básico con Dos Valores
Ejemplo Básico con Dos Valores Result
Ejemplo con Comparación Personalizada
Ejemplo con Comparación Personalizada Result
Ejemplo Básico con un Rango de Elementos
Ejemplo Básico con un Rango de Elementos Result
Sintaxis
Sintaxis Result
Ejemplo de Uso de `std::find`
Ejemplo de Uso de `std::find` Result
Ejemplo de Uso de `std::find_if`
Ejemplo de Uso de `std::find_if` Result
Ejemplo de Uso de `std::find_if` con Lambda
Ejemplo de Uso de `std::find_if` con Lambda Result
Copiar Elementos entre Diferentes Contenedores
Copiar Elementos entre Diferentes Contenedores Result
Ejemplo Básico
Ejemplo Básico Result
Ejemplo con Lambda
Ejemplo con Lambda Result
Ejemplo Básico (Suma)
Ejemplo Básico (Suma) Result
Ejemplo con Operación Binaria Personalizada (Multiplicación)
Ejemplo con Operación Binaria Personalizada (Multiplicación) Result
`std::max`
`std::max` Result
`std::min`
`std::min` Result
Ejemplo Básico con Dos Valores
Ejemplo Básico con Dos Valores Result
Ejemplo con Comparación Personalizada
Ejemplo con Comparación Personalizada Result
Ejemplo Básico con un Rango de Elementos
Ejemplo Básico con un Rango de Elementos Result
Sintaxis
Sintaxis Result
Ejemplo de Uso de `std::find`
Ejemplo de Uso de `std::find` Result
Ejemplo de Uso de `std::find_if`
Ejemplo de Uso de `std::find_if` Result
Ejemplo de Uso de `std::find_if` con Lambda
Ejemplo de Uso de `std::find_if` con Lambda Result
Copiar Elementos entre Diferentes Contenedores
Copiar Elementos entre Diferentes Contenedores Result
Ejemplo Básico (Orden Ascendente)
Ejemplo Básico (Orden Ascendente) Result
Ejemplo con Comparación Personalizada (Orden Descendente)
Ejemplo con Comparación Personalizada (Orden Descendente) Result
Ordenar un `std::array`
Ordenar un `std::array` Result
Ejemplo Básico
Ejemplo Básico Result
Ejemplo con Lambda
Ejemplo con Lambda Result
Ejemplo Básico (Suma)
Ejemplo Básico (Suma) Result
Ejemplo con Operación Binaria Personalizada (Multiplicación)
Ejemplo con Operación Binaria Personalizada (Multiplicación) Result
`std::max`
`std::max` Result
`std::min`
`std::min` Result
Ejemplo Básico con Dos Valores
Ejemplo Básico con Dos Valores Result
Ejemplo con Comparación Personalizada
Ejemplo con Comparación Personalizada Result
Ejemplo Básico con un Rango de Elementos
Ejemplo Básico con un Rango de Elementos Result
Sintaxis
Sintaxis Result
Ejemplo de Uso de `std::find`
Ejemplo de Uso de `std::find` Result
Ejemplo de Uso de `std::find_if`
Ejemplo de Uso de `std::find_if` Result
Ejemplo de Uso de `std::find_if` con Lambda
Ejemplo de Uso de `std::find_if` con Lambda Result
Copiar Elementos entre Diferentes Contenedores
Copiar Elementos entre Diferentes Contenedores Result
Ejemplo Básico (Orden Ascendente)
Ejemplo Básico (Orden Ascendente) Result
Ejemplo con Comparación Personalizada (Orden Descendente)
Ejemplo con Comparación Personalizada (Orden Descendente) Result
Ordenar un `std::array`
Ordenar un `std::array` Result
Ejemplo Básico (Función Unaria)
Ejemplo Básico (Función Unaria) Result
Ejemplo con Función Binaria
Ejemplo con Función Binaria Result
Transformar una Lista
Transformar una Lista Result
Ejemplo Básico
Ejemplo Básico Result
Ejemplo con Lambda
Ejemplo con Lambda Result
Ejemplo Básico (Suma)
Ejemplo Básico (Suma) Result
Ejemplo con Operación Binaria Personalizada (Multiplicación)
Ejemplo con Operación Binaria Personalizada (Multiplicación) Result
`std::max`
`std::max` Result
`std::min`
`std::min` Result
Ejemplo Básico con Dos Valores
Ejemplo Básico con Dos Valores Result
Ejemplo con Comparación Personalizada
Ejemplo con Comparación Personalizada Result
Ejemplo Básico con un Rango de Elementos
Ejemplo Básico con un Rango de Elementos Result
Sintaxis
Sintaxis Result
Ejemplo de Uso de `std::find`
Ejemplo de Uso de `std::find` Result
Ejemplo de Uso de `std::find_if`
Ejemplo de Uso de `std::find_if` Result
Ejemplo de Uso de `std::find_if` con Lambda
Ejemplo de Uso de `std::find_if` con Lambda Result
Copiar Elementos entre Diferentes Contenedores
Copiar Elementos entre Diferentes Contenedores Result
Ejemplo Básico (Orden Ascendente)
Ejemplo Básico (Orden Ascendente) Result
Ejemplo con Comparación Personalizada (Orden Descendente)
Ejemplo con Comparación Personalizada (Orden Descendente) Result
Ordenar un `std::array`
Ordenar un `std::array` Result
Ejemplo Básico (Función Unaria)
Ejemplo Básico (Función Unaria) Result
Ejemplo con Función Binaria
Ejemplo con Función Binaria Result
Transformar una Lista
Transformar una Lista Result
Ejemplo con `std::array`
Ejemplo con `std::array` Result
Ejemplo con una Matriz
Ejemplo con una Matriz Result
Ejemplo de Rango Parcial
Ejemplo de Rango Parcial Result
Ejemplo Básico
Ejemplo Básico Result
Ejemplo con Lambda
Ejemplo con Lambda Result
Ejemplo Básico (Suma)
Ejemplo Básico (Suma) Result
Ejemplo con Operación Binaria Personalizada (Multiplicación)
Ejemplo con Operación Binaria Personalizada (Multiplicación) Result
`std::max`
`std::max` Result
`std::min`
`std::min` Result
Ejemplo Básico con Dos Valores
Ejemplo Básico con Dos Valores Result
Ejemplo con Comparación Personalizada
Ejemplo con Comparación Personalizada Result
Ejemplo Básico con un Rango de Elementos
Ejemplo Básico con un Rango de Elementos Result
Sintaxis
Sintaxis Result
Ejemplo de Uso de `std::find`
Ejemplo de Uso de `std::find` Result
Ejemplo de Uso de `std::find_if`
Ejemplo de Uso de `std::find_if` Result
Ejemplo de Uso de `std::find_if` con Lambda
Ejemplo de Uso de `std::find_if` con Lambda Result
Copiar Elementos entre Diferentes Contenedores
Copiar Elementos entre Diferentes Contenedores Result
Ejemplo Básico (Orden Ascendente)
Ejemplo Básico (Orden Ascendente) Result
Ejemplo con Comparación Personalizada (Orden Descendente)
Ejemplo con Comparación Personalizada (Orden Descendente) Result
Ordenar un `std::array`
Ordenar un `std::array` Result
Ejemplo Básico (Función Unaria)
Ejemplo Básico (Función Unaria) Result
Ejemplo con Función Binaria
Ejemplo con Función Binaria Result
Transformar una Lista
Transformar una Lista Result
Ejemplo con `std::array`
Ejemplo con `std::array` Result
Ejemplo con una Matriz
Ejemplo con una Matriz Result
Ejemplo de Rango Parcial
Ejemplo de Rango Parcial Result
Ejemplo con `std::list`
Ejemplo con `std::list` Result
Ejemplo Básico con `std::replace_if`
Ejemplo Básico con `std::replace_if` Result
Ejemplo Básico
Ejemplo Básico Result
Ejemplo con Lambda
Ejemplo con Lambda Result
Ejemplo Básico (Suma)
Ejemplo Básico (Suma) Result
Ejemplo con Operación Binaria Personalizada (Multiplicación)
Ejemplo con Operación Binaria Personalizada (Multiplicación) Result
`std::max`
`std::max` Result
`std::min`
`std::min` Result
Ejemplo Básico con Dos Valores
Ejemplo Básico con Dos Valores Result
Ejemplo con Comparación Personalizada
Ejemplo con Comparación Personalizada Result
Ejemplo Básico con un Rango de Elementos
Ejemplo Básico con un Rango de Elementos Result
Sintaxis
Sintaxis Result
Ejemplo de Uso de `std::find`
Ejemplo de Uso de `std::find` Result
Ejemplo de Uso de `std::find_if`
Ejemplo de Uso de `std::find_if` Result
Ejemplo de Uso de `std::find_if` con Lambda
Ejemplo de Uso de `std::find_if` con Lambda Result
Copiar Elementos entre Diferentes Contenedores
Copiar Elementos entre Diferentes Contenedores Result
Ejemplo Básico (Orden Ascendente)
Ejemplo Básico (Orden Ascendente) Result
Ejemplo con Comparación Personalizada (Orden Descendente)
Ejemplo con Comparación Personalizada (Orden Descendente) Result
Ordenar un `std::array`
Ordenar un `std::array` Result
Ejemplo Básico (Función Unaria)
Ejemplo Básico (Función Unaria) Result
Ejemplo con Función Binaria
Ejemplo con Función Binaria Result
Transformar una Lista
Transformar una Lista Result
Ejemplo con `std::array`
Ejemplo con `std::array` Result
Ejemplo con una Matriz
Ejemplo con una Matriz Result
Ejemplo de Rango Parcial
Ejemplo de Rango Parcial Result
Ejemplo con `std::list`
Ejemplo con `std::list` Result
Ejemplo Básico con `std::replace_if`
Ejemplo Básico con `std::replace_if` Result
Ejemplo Básico con `std::remove_if`
Ejemplo Básico con `std::remove_if` Result
<---Ejemplo Básico--->
```cpp
#include <iostream>
#include <vector>
#include <algorithm>

bool esPositivo(int n) {
    return n > 0;
}

int main() {
    std::vector<int> vec = {1, 2, 3, 4, 5};

    // Verificar si todos los elementos son positivos
    bool todosPositivos = std::all_of(vec.begin(), vec.end(), esPositivo);

    if (todosPositivos) {
        std::cout << "Todos los elementos son positivos." << std::endl;
    } else {
        std::cout << "No todos los elementos son positivos." << std::endl;
    }

    return 0;
}
<---Ejemplo Básico Result--->
<---Ejemplo con Lambda--->
```cpp
#include <iostream>
#include <vector>
#include <algorithm>

int main() {
    std::vector<int> vec = {1, 2, 3, 4, 5};

    // Usar una lambda para verificar si todos los elementos son positivos
    bool todosPositivos = std::all_of(vec.begin(), vec.end(), [](int n) {
        return n > 0;
    });

    if (todosPositivos) {
        std::cout << "Todos los elementos son positivos." << std::endl;
    } else {
        std::cout << "No todos los elementos son positivos." << std::endl;
    }

    return 0;
}
```cpp
#include <iostream>
#include <vector>
#include <algorithm>

int main() {
    std::vector<int> vec = {2, 4, 6, 8, 10};

    // Usar una lambda para verificar si todos los elementos son pares
    bool todosPares = std::all_of(vec.begin(), vec.end(), [](int n) {
        return n % 2 == 0;
    });

    if (todosPares) {
        std::cout << "Todos los elementos son pares." << std::endl;
    } else {
        std::cout << "No todos los elementos son pares." << std::endl;
    }

    return 0;
}
```cpp
#include <iostream>
#include <vector>
#include <algorithm>

int main() {
    std::vector<int> vec = {5, 6, 7, 8, 9};

    // Usar una lambda para verificar si todos los elementos están en el rango [5, 10]
    bool enRango = std::all_of(vec.begin(), vec.end(), [](int n) {
        return n >= 5 && n <= 10;
    });

    if (enRango) {
        std::cout << "Todos los elementos están en el rango [5, 10]." << std::endl;
    } else {
        std::cout << "No todos los elementos están en el rango [5, 10]." << std::endl;
    }

    return 0;
}
<---Ejemplo con Lambda Result--->
<---Ejemplo Básico--->
```cpp
#include <iostream>
#include <vector>
#include <algorithm>

void imprimir(int n) {
    std::cout << n << " ";
}

int main() {
    std::vector<int> vec = {1, 2, 3, 4, 5};

    // Usar std::for_each para imprimir cada elemento del vector
    std::for_each(vec.begin(), vec.end(), imprimir);
    std::cout << std::endl;

    return 0;
}
<---Ejemplo Básico Result--->
<---Ejemplo con Lambda--->
```cpp
#include <iostream>
#include <vector>
#include <algorithm>

int main() {
    std::vector<int> vec = {1, 2, 3, 4, 5};

    // Usar una lambda para imprimir cada elemento del vector
    std::for_each(vec.begin(), vec.end(), [](int n) {
        std::cout << n << " ";
    });
    std::cout << std::endl;

    return 0;
}
```cpp
#include <iostream>
#include <vector>
#include <algorithm>

int main() {
    std::vector<int> vec = {1, 2, 3, 4, 5};

    // Usar una lambda para incrementar cada elemento del vector
    std::for_each(vec.begin(), vec.end(), [](int& n) {
        n += 1;
    });

    // Imprimir los elementos incrementados
    std::for_each(vec.begin(), vec.end(), [](int n) {
        std::cout << n << " ";
    });
    std::cout << std::endl;

    return 0;
}
```cpp
#include <iostream>
#include <vector>
#include <algorithm>

struct Acumulador {
    int suma = 0;

    void operator()(int n) {
        suma += n;
    }
};

int main() {
    std::vector<int> vec = {1, 2, 3, 4, 5};

    Acumulador acumulador = std::for_each(vec.begin(), vec.end(), Acumulador());

    std::cout << "Suma de los elementos: " << acumulador.suma << std::endl;

    return 0;
}
<---Ejemplo con Lambda Result--->
<---Ejemplo Básico--->
```cpp
#include <iostream>
#include <vector>
#include <algorithm>

void imprimir(int n) {
    std::cout << n << " ";
}

int main() {
    std::vector<int> vec = {1, 2, 3, 4, 5};

    // Usar std::for_each para imprimir cada elemento del vector
    std::for_each(vec.begin(), vec.end(), imprimir);
    std::cout << std::endl;

    return 0;
}
<---Ejemplo Básico Result--->
<---Ejemplo con Lambda--->
```cpp
#include <iostream>
#include <vector>
#include <algorithm>

int main() {
    std::vector<int> vec = {1, 2, 3, 4, 5};

    // Usar una lambda para imprimir cada elemento del vector
    std::for_each(vec.begin(), vec.end(), [](int n) {
        std::cout << n << " ";
    });
    std::cout << std::endl;

    return 0;
}
```cpp
#include <iostream>
#include <vector>
#include <algorithm>

int main() {
    std::vector<int> vec = {1, 2, 3, 4, 5};

    // Usar una lambda para incrementar cada elemento del vector
    std::for_each(vec.begin(), vec.end(), [](int& n) {
        n += 1;
    });

    // Imprimir los elementos incrementados
    std::for_each(vec.begin(), vec.end(), [](int n) {
        std::cout << n << " ";
    });
    std::cout << std::endl;

    return 0;
}
```cpp
#include <iostream>
#include <vector>
#include <algorithm>

struct Acumulador {
    int suma = 0;

    void operator()(int n) {
        suma += n;
    }
};

int main() {
    std::vector<int> vec = {1, 2, 3, 4, 5};

    Acumulador acumulador = std::for_each(vec.begin(), vec.end(), Acumulador());

    std::cout << "Suma de los elementos: " << acumulador.suma << std::endl;

    return 0;
}
<---Ejemplo con Lambda Result--->
<---Ejemplo Básico (Suma)--->
```cpp
#include <iostream>
#include <vector>
#include <numeric>

int main() {
    std::vector<int> vec = {1, 2, 3, 4, 5};

    // Usar std::accumulate para sumar todos los elementos
    int suma = std::accumulate(vec.begin(), vec.end(), 0);

    std::cout << "La suma de los elementos es: " << suma << std::endl;

    return 0;
}
<---Ejemplo Básico (Suma) Result--->
<---Ejemplo con Operación Binaria Personalizada (Multiplicación)--->
```cpp
#include <iostream>
#include <vector>
#include <numeric>

int main() {
    std::vector<int> vec = {1, 2, 3, 4, 5};

    // Usar std::accumulate para multiplicar todos los elementos
    int producto = std::accumulate(vec.begin(), vec.end(), 1, std::multiplies<int>());

    std::cout << "El producto de los elementos es: " << producto << std::endl;

    return 0;
}
```cpp
#include <iostream>
#include <vector>
#include <numeric>
#include <string>

int main() {
    std::vector<std::string> vec = {"Hola", " ", "mundo", "!"};

    // Usar std::accumulate para concatenar todas las cadenas
    std::string resultado = std::accumulate(vec.begin(), vec.end(), std::string(""));

    std::cout << "Cadena concatenada: " << resultado << std::endl;

    return 0;
}
```cpp
#include <iostream>
#include <vector>
#include <numeric>

int main() {
    std::vector<int> vec = {1, 2, 3, 4, 5};

    // Calcular la suma de los elementos
    int suma = std::accumulate(vec.begin(), vec.end(), 0);

    // Calcular la media
    double media = static_cast<double>(suma) / vec.size();

    std::cout << "La media de los elementos es: " << media << std::endl;

    return 0;
}
<---Ejemplo con Operación Binaria Personalizada (Multiplicación) Result--->
<---Ejemplo Básico--->
```cpp
#include <iostream>
#include <vector>
#include <algorithm>

void imprimir(int n) {
    std::cout << n << " ";
}

int main() {
    std::vector<int> vec = {1, 2, 3, 4, 5};

    // Usar std::for_each para imprimir cada elemento del vector
    std::for_each(vec.begin(), vec.end(), imprimir);
    std::cout << std::endl;

    return 0;
}
<---Ejemplo Básico Result--->
<---Ejemplo con Lambda--->
```cpp
#include <iostream>
#include <vector>
#include <algorithm>

int main() {
    std::vector<int> vec = {1, 2, 3, 4, 5};

    // Usar una lambda para imprimir cada elemento del vector
    std::for_each(vec.begin(), vec.end(), [](int n) {
        std::cout << n << " ";
    });
    std::cout << std::endl;

    return 0;
}
```cpp
#include <iostream>
#include <vector>
#include <algorithm>

int main() {
    std::vector<int> vec = {1, 2, 3, 4, 5};

    // Usar una lambda para incrementar cada elemento del vector
    std::for_each(vec.begin(), vec.end(), [](int& n) {
        n += 1;
    });

    // Imprimir los elementos incrementados
    std::for_each(vec.begin(), vec.end(), [](int n) {
        std::cout << n << " ";
    });
    std::cout << std::endl;

    return 0;
}
```cpp
#include <iostream>
#include <vector>
#include <algorithm>

struct Acumulador {
    int suma = 0;

    void operator()(int n) {
        suma += n;
    }
};

int main() {
    std::vector<int> vec = {1, 2, 3, 4, 5};

    Acumulador acumulador = std::for_each(vec.begin(), vec.end(), Acumulador());

    std::cout << "Suma de los elementos: " << acumulador.suma << std::endl;

    return 0;
}
<---Ejemplo con Lambda Result--->
<---Ejemplo Básico (Suma)--->
```cpp
#include <iostream>
#include <vector>
#include <numeric>

int main() {
    std::vector<int> vec = {1, 2, 3, 4, 5};

    // Usar std::accumulate para sumar todos los elementos
    int suma = std::accumulate(vec.begin(), vec.end(), 0);

    std::cout << "La suma de los elementos es: " << suma << std::endl;

    return 0;
}
<---Ejemplo Básico (Suma) Result--->
<---Ejemplo con Operación Binaria Personalizada (Multiplicación)--->
```cpp
#include <iostream>
#include <vector>
#include <numeric>

int main() {
    std::vector<int> vec = {1, 2, 3, 4, 5};

    // Usar std::accumulate para multiplicar todos los elementos
    int producto = std::accumulate(vec.begin(), vec.end(), 1, std::multiplies<int>());

    std::cout << "El producto de los elementos es: " << producto << std::endl;

    return 0;
}
```cpp
#include <iostream>
#include <vector>
#include <numeric>
#include <string>

int main() {
    std::vector<std::string> vec = {"Hola", " ", "mundo", "!"};

    // Usar std::accumulate para concatenar todas las cadenas
    std::string resultado = std::accumulate(vec.begin(), vec.end(), std::string(""));

    std::cout << "Cadena concatenada: " << resultado << std::endl;

    return 0;
}
```cpp
#include <iostream>
#include <vector>
#include <numeric>

int main() {
    std::vector<int> vec = {1, 2, 3, 4, 5};

    // Calcular la suma de los elementos
    int suma = std::accumulate(vec.begin(), vec.end(), 0);

    // Calcular la media
    double media = static_cast<double>(suma) / vec.size();

    std::cout << "La media de los elementos es: " << media << std::endl;

    return 0;
}
<---Ejemplo con Operación Binaria Personalizada (Multiplicación) Result--->
<---`std::max`--->
```cpp
#include <algorithm>

template <class T>
const T& max(const T& a, const T& b);

template <class T, class Compare>
const T& max(const T& a, const T& b, Compare comp);

template <class ForwardIt>
ForwardIt max_element(ForwardIt first, ForwardIt last);

template <class ForwardIt, class Compare>
ForwardIt max_element(ForwardIt first, ForwardIt last, Compare comp);
<---`std::max` Result--->
<---`std::min`--->
```cpp
#include <algorithm>

template <class T>
const T& min(const T& a, const T& b);

template <class T, class Compare>
const T& min(const T& a, const T& b, Compare comp);

template <class ForwardIt>
ForwardIt min_element(ForwardIt first, ForwardIt last);

template <class ForwardIt, class Compare>
ForwardIt min_element(ForwardIt first, ForwardIt last, Compare comp);
<---`std::min` Result--->
<---Ejemplo Básico con Dos Valores--->
```cpp
#include <iostream>
#include <algorithm>

int main() {
    int a = 10, b = 20;

    // Encontrar el valor máximo
    int maxVal = std::max(a, b);
    std::cout << "El mayor de " << a << " y " << b << " es " << maxVal << std::endl;

    // Encontrar el valor mínimo
    int minVal = std::min(a, b);
    std::cout << "El menor de " << a << " y " << b << " es " << minVal << std::endl;

    return 0;
}
<---Ejemplo Básico con Dos Valores Result--->
<---Ejemplo con Comparación Personalizada--->
```cpp
#include <iostream>
#include <vector>
#include <algorithm>

struct Punto {
    int x, y;
};

bool compararPorDistancia(const Punto& p1, const Punto& p2) {
    return (p1.x * p1.x + p1.y * p1.y) < (p2.x * p2.x + p2.y * p2.y);
}

int main() {
    std::vector<Punto> puntos = {{1, 2}, {3, 4}, {0, 5}, {-1, -1}};

    // Encontrar el punto más lejano del origen
    auto maxIt = std::max_element(puntos.begin(), puntos.end(), compararPorDistancia);
    std::cout << "El punto más lejano es: (" << maxIt->x << ", " << maxIt->y << ")" << std::endl;

    // Encontrar el punto más cercano al origen
    auto minIt = std::min_element(puntos.begin(), puntos.end(), compararPorDistancia);
    std::cout << "El punto más cercano es: (" << minIt->x << ", " << minIt->y << ")" << std::endl;

    return 0;
}
<---Ejemplo con Comparación Personalizada Result--->
<---Ejemplo Básico con un Rango de Elementos--->
```cpp
#include <iostream>
#include <vector>
#include <algorithm>

int main() {
    std::vector<int> vec = {1, 2, 3, 4, 5};

    // Encontrar el elemento máximo
    auto maxIt = std::max_element(vec.begin(), vec.end());
    std::cout << "El elemento máximo es: " << *maxIt << std::endl;

    // Encontrar el elemento mínimo
    auto minIt = std::min_element(vec.begin(), vec.end());
    std::cout << "El elemento mínimo es: " << *minIt << std::endl;

    return 0;
}
<---Ejemplo Básico con un Rango de Elementos Result--->
<---Ejemplo Básico--->
```cpp
#include <iostream>
#include <vector>
#include <algorithm>

void imprimir(int n) {
    std::cout << n << " ";
}

int main() {
    std::vector<int> vec = {1, 2, 3, 4, 5};

    // Usar std::for_each para imprimir cada elemento del vector
    std::for_each(vec.begin(), vec.end(), imprimir);
    std::cout << std::endl;

    return 0;
}
<---Ejemplo Básico Result--->
<---Ejemplo con Lambda--->
```cpp
#include <iostream>
#include <vector>
#include <algorithm>

int main() {
    std::vector<int> vec = {1, 2, 3, 4, 5};

    // Usar una lambda para imprimir cada elemento del vector
    std::for_each(vec.begin(), vec.end(), [](int n) {
        std::cout << n << " ";
    });
    std::cout << std::endl;

    return 0;
}
```cpp
#include <iostream>
#include <vector>
#include <algorithm>

int main() {
    std::vector<int> vec = {1, 2, 3, 4, 5};

    // Usar una lambda para incrementar cada elemento del vector
    std::for_each(vec.begin(), vec.end(), [](int& n) {
        n += 1;
    });

    // Imprimir los elementos incrementados
    std::for_each(vec.begin(), vec.end(), [](int n) {
        std::cout << n << " ";
    });
    std::cout << std::endl;

    return 0;
}
```cpp
#include <iostream>
#include <vector>
#include <algorithm>

struct Acumulador {
    int suma = 0;

    void operator()(int n) {
        suma += n;
    }
};

int main() {
    std::vector<int> vec = {1, 2, 3, 4, 5};

    Acumulador acumulador = std::for_each(vec.begin(), vec.end(), Acumulador());

    std::cout << "Suma de los elementos: " << acumulador.suma << std::endl;

    return 0;
}
<---Ejemplo con Lambda Result--->
<---Ejemplo Básico (Suma)--->
```cpp
#include <iostream>
#include <vector>
#include <numeric>

int main() {
    std::vector<int> vec = {1, 2, 3, 4, 5};

    // Usar std::accumulate para sumar todos los elementos
    int suma = std::accumulate(vec.begin(), vec.end(), 0);

    std::cout << "La suma de los elementos es: " << suma << std::endl;

    return 0;
}
<---Ejemplo Básico (Suma) Result--->
<---Ejemplo con Operación Binaria Personalizada (Multiplicación)--->
```cpp
#include <iostream>
#include <vector>
#include <numeric>

int main() {
    std::vector<int> vec = {1, 2, 3, 4, 5};

    // Usar std::accumulate para multiplicar todos los elementos
    int producto = std::accumulate(vec.begin(), vec.end(), 1, std::multiplies<int>());

    std::cout << "El producto de los elementos es: " << producto << std::endl;

    return 0;
}
```cpp
#include <iostream>
#include <vector>
#include <numeric>
#include <string>

int main() {
    std::vector<std::string> vec = {"Hola", " ", "mundo", "!"};

    // Usar std::accumulate para concatenar todas las cadenas
    std::string resultado = std::accumulate(vec.begin(), vec.end(), std::string(""));

    std::cout << "Cadena concatenada: " << resultado << std::endl;

    return 0;
}
```cpp
#include <iostream>
#include <vector>
#include <numeric>

int main() {
    std::vector<int> vec = {1, 2, 3, 4, 5};

    // Calcular la suma de los elementos
    int suma = std::accumulate(vec.begin(), vec.end(), 0);

    // Calcular la media
    double media = static_cast<double>(suma) / vec.size();

    std::cout << "La media de los elementos es: " << media << std::endl;

    return 0;
}
<---Ejemplo con Operación Binaria Personalizada (Multiplicación) Result--->
<---`std::max`--->
```cpp
#include <algorithm>

template <class T>
const T& max(const T& a, const T& b);

template <class T, class Compare>
const T& max(const T& a, const T& b, Compare comp);

template <class ForwardIt>
ForwardIt max_element(ForwardIt first, ForwardIt last);

template <class ForwardIt, class Compare>
ForwardIt max_element(ForwardIt first, ForwardIt last, Compare comp);
<---`std::max` Result--->
<---`std::min`--->
```cpp
#include <algorithm>

template <class T>
const T& min(const T& a, const T& b);

template <class T, class Compare>
const T& min(const T& a, const T& b, Compare comp);

template <class ForwardIt>
ForwardIt min_element(ForwardIt first, ForwardIt last);

template <class ForwardIt, class Compare>
ForwardIt min_element(ForwardIt first, ForwardIt last, Compare comp);
<---`std::min` Result--->
<---Ejemplo Básico con Dos Valores--->
```cpp
#include <iostream>
#include <algorithm>

int main() {
    int a = 10, b = 20;

    // Encontrar el valor máximo
    int maxVal = std::max(a, b);
    std::cout << "El mayor de " << a << " y " << b << " es " << maxVal << std::endl;

    // Encontrar el valor mínimo
    int minVal = std::min(a, b);
    std::cout << "El menor de " << a << " y " << b << " es " << minVal << std::endl;

    return 0;
}
<---Ejemplo Básico con Dos Valores Result--->
<---Ejemplo con Comparación Personalizada--->
```cpp
#include <iostream>
#include <vector>
#include <algorithm>

struct Punto {
    int x, y;
};

bool compararPorDistancia(const Punto& p1, const Punto& p2) {
    return (p1.x * p1.x + p1.y * p1.y) < (p2.x * p2.x + p2.y * p2.y);
}

int main() {
    std::vector<Punto> puntos = {{1, 2}, {3, 4}, {0, 5}, {-1, -1}};

    // Encontrar el punto más lejano del origen
    auto maxIt = std::max_element(puntos.begin(), puntos.end(), compararPorDistancia);
    std::cout << "El punto más lejano es: (" << maxIt->x << ", " << maxIt->y << ")" << std::endl;

    // Encontrar el punto más cercano al origen
    auto minIt = std::min_element(puntos.begin(), puntos.end(), compararPorDistancia);
    std::cout << "El punto más cercano es: (" << minIt->x << ", " << minIt->y << ")" << std::endl;

    return 0;
}
<---Ejemplo con Comparación Personalizada Result--->
<---Ejemplo Básico con un Rango de Elementos--->
```cpp
#include <iostream>
#include <vector>
#include <algorithm>

int main() {
    std::vector<int> vec = {1, 2, 3, 4, 5};

    // Encontrar el elemento máximo
    auto maxIt = std::max_element(vec.begin(), vec.end());
    std::cout << "El elemento máximo es: " << *maxIt << std::endl;

    // Encontrar el elemento mínimo
    auto minIt = std::min_element(vec.begin(), vec.end());
    std::cout << "El elemento mínimo es: " << *minIt << std::endl;

    return 0;
}
<---Ejemplo Básico con un Rango de Elementos Result--->
<---Sintaxis--->
```cpp
#include <algorithm>

template <class InputIt, class UnaryPredicate>
InputIt find_if(InputIt first, InputIt last, UnaryPredicate p);
<---Sintaxis Result--->
<---Ejemplo de Uso de `std::find`--->
```cpp
#include <iostream>
#include <vector>
#include <algorithm>

int main() {
    std::vector<int> vec = {1, 2, 3, 4, 5};

    // Buscar el valor 3
    auto it = std::find(vec.begin(), vec.end(), 3);

    if (it != vec.end()) {
        std::cout << "Elemento encontrado: " << *it << std::endl;
    } else {
        std::cout << "Elemento no encontrado" << std::endl;
    }

    return 0;
}
<---Ejemplo de Uso de `std::find` Result--->
<---Ejemplo de Uso de `std::find_if`--->
```cpp
#include <iostream>
#include <vector>
#include <algorithm>

bool esImpar(int n) {
    return n % 2 != 0;
}

int main() {
    std::vector<int> vec = {2, 4, 6, 7, 8};

    // Buscar el primer elemento impar
    auto it = std::find_if(vec.begin(), vec.end(), esImpar);

    if (it != vec.end()) {
        std::cout << "Primer elemento impar encontrado: " << *it << std::endl;
    } else {
        std::cout << "Elemento impar no encontrado" << std::endl;
    }

    return 0;
}
<---Ejemplo de Uso de `std::find_if` Result--->
<---Ejemplo de Uso de `std::find_if` con Lambda--->
```cpp
#include <iostream>
#include <vector>
#include <algorithm>

int main() {
    std::vector<int> vec = {2, 4, 6, 7, 8};

    // Usar una lambda para buscar el primer elemento impar
    auto it = std::find_if(vec.begin(), vec.end(), [](int n) {
        return n % 2 != 0;
    });

    if (it != vec.end()) {
        std::cout << "Primer elemento impar encontrado: " << *it << std::endl;
    } else {
        std::cout << "Elemento impar no encontrado" << std::endl;
    }

    return 0;
}
```cpp
#include <iostream>
#include <vector>
#include <algorithm>

struct Punto {
    int x, y;

    bool operator==(const Punto& otro) const {
        return x == otro.x && y == otro.y;
    }
};

int main() {
    std::vector<Punto> puntos = {{1, 2}, {3, 4}, {5, 6}, {7, 8}};
    Punto puntoABuscar = {5, 6};

    // Buscar el punto {5, 6}
    auto it = std::find(puntos.begin(), puntos.end(), puntoABuscar);

    if (it != puntos.end()) {
        std::cout << "Punto encontrado: (" << it->x << ", " << it->y << ")" << std::endl;
    } else {
        std::cout << "Punto no encontrado" << std::endl;
    }

    return 0;
}
```cpp
#include <iostream>
#include <vector>
#include <algorithm>

int main() {
    std::vector<int> vec = {2, 4, 6, 7, 8};

    // Usar una lambda para buscar el primer elemento mayor que 5
    auto it = std::find_if(vec.begin(), vec.end(), [](int n) {
        return n > 5;
    });

    if (it != vec.end()) {
        std::cout << "Primer elemento mayor que 5 encontrado: " << *it << std::endl;
    } else {
        std::cout << "Elemento mayor que 5 no encontrado" << std::endl;
    }

    return 0;
}
<---Ejemplo de Uso de `std::find_if` con Lambda Result--->
<---Ejemplo Básico--->
```cpp
#include <iostream>
#include <vector>
#include <algorithm>

int main() {
    std::vector<int> origen = {1, 2, 3, 4, 5};
    std::vector<int> destino(origen.size());

    // Usar std::copy para copiar los elementos
    std::copy(origen.begin(), origen.end(), destino.begin());

    // Mostrar los elementos copiados
    std::cout << "Elementos copiados al vector destino: ";
    for (int elem : destino) {
        std::cout << elem << " ";
    }
    std::cout << std::endl;

    return 0;
}
<---Ejemplo Básico Result--->
<---Ejemplo con Lambda--->
```cpp
#include <iostream>
#include <vector>
#include <algorithm>

int main() {
    std::vector<int> vec = {1, 2, 3, 4, 5};

    // Usar una lambda para imprimir cada elemento del vector
    std::for_each(vec.begin(), vec.end(), [](int n) {
        std::cout << n << " ";
    });
    std::cout << std::endl;

    return 0;
}
```cpp
#include <iostream>
#include <vector>
#include <algorithm>

int main() {
    std::vector<int> vec = {1, 2, 3, 4, 5};

    // Usar una lambda para incrementar cada elemento del vector
    std::for_each(vec.begin(), vec.end(), [](int& n) {
        n += 1;
    });

    // Imprimir los elementos incrementados
    std::for_each(vec.begin(), vec.end(), [](int n) {
        std::cout << n << " ";
    });
    std::cout << std::endl;

    return 0;
}
```cpp
#include <iostream>
#include <vector>
#include <algorithm>

struct Acumulador {
    int suma = 0;

    void operator()(int n) {
        suma += n;
    }
};

int main() {
    std::vector<int> vec = {1, 2, 3, 4, 5};

    Acumulador acumulador = std::for_each(vec.begin(), vec.end(), Acumulador());

    std::cout << "Suma de los elementos: " << acumulador.suma << std::endl;

    return 0;
}
<---Ejemplo con Lambda Result--->
<---Ejemplo Básico (Suma)--->
```cpp
#include <iostream>
#include <vector>
#include <numeric>

int main() {
    std::vector<int> vec = {1, 2, 3, 4, 5};

    // Usar std::accumulate para sumar todos los elementos
    int suma = std::accumulate(vec.begin(), vec.end(), 0);

    std::cout << "La suma de los elementos es: " << suma << std::endl;

    return 0;
}
<---Ejemplo Básico (Suma) Result--->
<---Ejemplo con Operación Binaria Personalizada (Multiplicación)--->
```cpp
#include <iostream>
#include <vector>
#include <numeric>

int main() {
    std::vector<int> vec = {1, 2, 3, 4, 5};

    // Usar std::accumulate para multiplicar todos los elementos
    int producto = std::accumulate(vec.begin(), vec.end(), 1, std::multiplies<int>());

    std::cout << "El producto de los elementos es: " << producto << std::endl;

    return 0;
}
```cpp
#include <iostream>
#include <vector>
#include <numeric>
#include <string>

int main() {
    std::vector<std::string> vec = {"Hola", " ", "mundo", "!"};

    // Usar std::accumulate para concatenar todas las cadenas
    std::string resultado = std::accumulate(vec.begin(), vec.end(), std::string(""));

    std::cout << "Cadena concatenada: " << resultado << std::endl;

    return 0;
}
```cpp
#include <iostream>
#include <vector>
#include <numeric>

int main() {
    std::vector<int> vec = {1, 2, 3, 4, 5};

    // Calcular la suma de los elementos
    int suma = std::accumulate(vec.begin(), vec.end(), 0);

    // Calcular la media
    double media = static_cast<double>(suma) / vec.size();

    std::cout << "La media de los elementos es: " << media << std::endl;

    return 0;
}
<---Ejemplo con Operación Binaria Personalizada (Multiplicación) Result--->
<---`std::max`--->
```cpp
#include <algorithm>

template <class T>
const T& max(const T& a, const T& b);

template <class T, class Compare>
const T& max(const T& a, const T& b, Compare comp);

template <class ForwardIt>
ForwardIt max_element(ForwardIt first, ForwardIt last);

template <class ForwardIt, class Compare>
ForwardIt max_element(ForwardIt first, ForwardIt last, Compare comp);
<---`std::max` Result--->
<---`std::min`--->
```cpp
#include <algorithm>

template <class T>
const T& min(const T& a, const T& b);

template <class T, class Compare>
const T& min(const T& a, const T& b, Compare comp);

template <class ForwardIt>
ForwardIt min_element(ForwardIt first, ForwardIt last);

template <class ForwardIt, class Compare>
ForwardIt min_element(ForwardIt first, ForwardIt last, Compare comp);
<---`std::min` Result--->
<---Ejemplo Básico con Dos Valores--->
```cpp
#include <iostream>
#include <algorithm>

int main() {
    int a = 10, b = 20;

    // Encontrar el valor máximo
    int maxVal = std::max(a, b);
    std::cout << "El mayor de " << a << " y " << b << " es " << maxVal << std::endl;

    // Encontrar el valor mínimo
    int minVal = std::min(a, b);
    std::cout << "El menor de " << a << " y " << b << " es " << minVal << std::endl;

    return 0;
}
<---Ejemplo Básico con Dos Valores Result--->
<---Ejemplo con Comparación Personalizada--->
```cpp
#include <iostream>
#include <vector>
#include <algorithm>

struct Punto {
    int x, y;
};

bool compararPorDistancia(const Punto& p1, const Punto& p2) {
    return (p1.x * p1.x + p1.y * p1.y) < (p2.x * p2.x + p2.y * p2.y);
}

int main() {
    std::vector<Punto> puntos = {{1, 2}, {3, 4}, {0, 5}, {-1, -1}};

    // Encontrar el punto más lejano del origen
    auto maxIt = std::max_element(puntos.begin(), puntos.end(), compararPorDistancia);
    std::cout << "El punto más lejano es: (" << maxIt->x << ", " << maxIt->y << ")" << std::endl;

    // Encontrar el punto más cercano al origen
    auto minIt = std::min_element(puntos.begin(), puntos.end(), compararPorDistancia);
    std::cout << "El punto más cercano es: (" << minIt->x << ", " << minIt->y << ")" << std::endl;

    return 0;
}
<---Ejemplo con Comparación Personalizada Result--->
<---Ejemplo Básico con un Rango de Elementos--->
```cpp
#include <iostream>
#include <vector>
#include <algorithm>

int main() {
    std::vector<int> vec = {1, 2, 3, 4, 5};

    // Encontrar el elemento máximo
    auto maxIt = std::max_element(vec.begin(), vec.end());
    std::cout << "El elemento máximo es: " << *maxIt << std::endl;

    // Encontrar el elemento mínimo
    auto minIt = std::min_element(vec.begin(), vec.end());
    std::cout << "El elemento mínimo es: " << *minIt << std::endl;

    return 0;
}
<---Ejemplo Básico con un Rango de Elementos Result--->
<---Sintaxis--->
```cpp
#include <algorithm>

template <class InputIt, class UnaryPredicate>
InputIt find_if(InputIt first, InputIt last, UnaryPredicate p);
<---Sintaxis Result--->
<---Ejemplo de Uso de `std::find`--->
```cpp
#include <iostream>
#include <vector>
#include <algorithm>

int main() {
    std::vector<int> vec = {1, 2, 3, 4, 5};

    // Buscar el valor 3
    auto it = std::find(vec.begin(), vec.end(), 3);

    if (it != vec.end()) {
        std::cout << "Elemento encontrado: " << *it << std::endl;
    } else {
        std::cout << "Elemento no encontrado" << std::endl;
    }

    return 0;
}
<---Ejemplo de Uso de `std::find` Result--->
<---Ejemplo de Uso de `std::find_if`--->
```cpp
#include <iostream>
#include <vector>
#include <algorithm>

bool esImpar(int n) {
    return n % 2 != 0;
}

int main() {
    std::vector<int> vec = {2, 4, 6, 7, 8};

    // Buscar el primer elemento impar
    auto it = std::find_if(vec.begin(), vec.end(), esImpar);

    if (it != vec.end()) {
        std::cout << "Primer elemento impar encontrado: " << *it << std::endl;
    } else {
        std::cout << "Elemento impar no encontrado" << std::endl;
    }

    return 0;
}
<---Ejemplo de Uso de `std::find_if` Result--->
<---Ejemplo de Uso de `std::find_if` con Lambda--->
```cpp
#include <iostream>
#include <vector>
#include <algorithm>

int main() {
    std::vector<int> vec = {2, 4, 6, 7, 8};

    // Usar una lambda para buscar el primer elemento impar
    auto it = std::find_if(vec.begin(), vec.end(), [](int n) {
        return n % 2 != 0;
    });

    if (it != vec.end()) {
        std::cout << "Primer elemento impar encontrado: " << *it << std::endl;
    } else {
        std::cout << "Elemento impar no encontrado" << std::endl;
    }

    return 0;
}
```cpp
#include <iostream>
#include <vector>
#include <algorithm>

struct Punto {
    int x, y;

    bool operator==(const Punto& otro) const {
        return x == otro.x && y == otro.y;
    }
};

int main() {
    std::vector<Punto> puntos = {{1, 2}, {3, 4}, {5, 6}, {7, 8}};
    Punto puntoABuscar = {5, 6};

    // Buscar el punto {5, 6}
    auto it = std::find(puntos.begin(), puntos.end(), puntoABuscar);

    if (it != puntos.end()) {
        std::cout << "Punto encontrado: (" << it->x << ", " << it->y << ")" << std::endl;
    } else {
        std::cout << "Punto no encontrado" << std::endl;
    }

    return 0;
}
```cpp
#include <iostream>
#include <vector>
#include <algorithm>

int main() {
    std::vector<int> vec = {2, 4, 6, 7, 8};

    // Usar una lambda para buscar el primer elemento mayor que 5
    auto it = std::find_if(vec.begin(), vec.end(), [](int n) {
        return n > 5;
    });

    if (it != vec.end()) {
        std::cout << "Primer elemento mayor que 5 encontrado: " << *it << std::endl;
    } else {
        std::cout << "Elemento mayor que 5 no encontrado" << std::endl;
    }

    return 0;
}
<---Ejemplo de Uso de `std::find_if` con Lambda Result--->
<---Copiar Elementos entre Diferentes Contenedores--->
```cpp
#include <iostream>
#include <vector>
#include <list>
#include <algorithm>

int main() {
    std::vector<int> origen = {1, 2, 3, 4, 5};
    std::list<int> destino(origen.size());

    // Usar std::copy para copiar los elementos
    std::copy(origen.begin(), origen.end(), destino.begin());

    // Mostrar los elementos copiados
    std::cout << "Elementos copiados a la lista destino: ";
    for (int elem : destino) {
        std::cout << elem << " ";
    }
    std::cout << std::endl;

    return 0;
}
```cpp
#include <iostream>
#include <vector>
#include <algorithm>

int main() {
    std::vector<int> origen = {1, 2, 3, 4, 5};
    std::vector<int> destino(3);

    // Usar std::copy para copiar los primeros 3 elementos
    std::copy(origen.begin(), origen.begin() + 3, destino.begin());

    // Mostrar los elementos copiados
    std::cout << "Primeros 3 elementos copiados al vector destino: ";
    for (int elem : destino) {
        std::cout << elem << " ";
    }
    std::cout << std::endl;

    return 0;
}
```cpp
#include <iostream>
#include <vector>
#include <algorithm>
#include <iterator>

int main() {
    std::vector<int> origen = {1, 2, 3, 4, 5};
    std::vector<int> destino;

    // Usar std::copy con std::back_inserter
    std::copy(origen.begin(), origen.end(), std::back_inserter(destino));

    // Mostrar los elementos copiados
    std::cout << "Elementos copiados al vector destino con back_inserter: ";
    for (int elem : destino) {
        std::cout << elem << " ";
    }
    std::cout << std::endl;

    return 0;
}
<---Copiar Elementos entre Diferentes Contenedores Result--->
<---Ejemplo Básico--->
```cpp
#include <iostream>
#include <vector>
#include <algorithm>

int main() {
    std::vector<int> origen = {1, 2, 3, 4, 5};
    std::vector<int> destino(origen.size());

    // Usar std::copy para copiar los elementos
    std::copy(origen.begin(), origen.end(), destino.begin());

    // Mostrar los elementos copiados
    std::cout << "Elementos copiados al vector destino: ";
    for (int elem : destino) {
        std::cout << elem << " ";
    }
    std::cout << std::endl;

    return 0;
}
<---Ejemplo Básico Result--->
<---Ejemplo con Lambda--->
```cpp
#include <iostream>
#include <vector>
#include <algorithm>

int main() {
    std::vector<int> vec = {1, 2, 3, 4, 5};

    // Usar una lambda para imprimir cada elemento del vector
    std::for_each(vec.begin(), vec.end(), [](int n) {
        std::cout << n << " ";
    });
    std::cout << std::endl;

    return 0;
}
```cpp
#include <iostream>
#include <vector>
#include <algorithm>

int main() {
    std::vector<int> vec = {1, 2, 3, 4, 5};

    // Usar una lambda para incrementar cada elemento del vector
    std::for_each(vec.begin(), vec.end(), [](int& n) {
        n += 1;
    });

    // Imprimir los elementos incrementados
    std::for_each(vec.begin(), vec.end(), [](int n) {
        std::cout << n << " ";
    });
    std::cout << std::endl;

    return 0;
}
```cpp
#include <iostream>
#include <vector>
#include <algorithm>

struct Acumulador {
    int suma = 0;

    void operator()(int n) {
        suma += n;
    }
};

int main() {
    std::vector<int> vec = {1, 2, 3, 4, 5};

    Acumulador acumulador = std::for_each(vec.begin(), vec.end(), Acumulador());

    std::cout << "Suma de los elementos: " << acumulador.suma << std::endl;

    return 0;
}
<---Ejemplo con Lambda Result--->
<---Ejemplo Básico (Suma)--->
```cpp
#include <iostream>
#include <vector>
#include <numeric>

int main() {
    std::vector<int> vec = {1, 2, 3, 4, 5};

    // Usar std::accumulate para sumar todos los elementos
    int suma = std::accumulate(vec.begin(), vec.end(), 0);

    std::cout << "La suma de los elementos es: " << suma << std::endl;

    return 0;
}
<---Ejemplo Básico (Suma) Result--->
<---Ejemplo con Operación Binaria Personalizada (Multiplicación)--->
```cpp
#include <iostream>
#include <vector>
#include <numeric>

int main() {
    std::vector<int> vec = {1, 2, 3, 4, 5};

    // Usar std::accumulate para multiplicar todos los elementos
    int producto = std::accumulate(vec.begin(), vec.end(), 1, std::multiplies<int>());

    std::cout << "El producto de los elementos es: " << producto << std::endl;

    return 0;
}
```cpp
#include <iostream>
#include <vector>
#include <numeric>
#include <string>

int main() {
    std::vector<std::string> vec = {"Hola", " ", "mundo", "!"};

    // Usar std::accumulate para concatenar todas las cadenas
    std::string resultado = std::accumulate(vec.begin(), vec.end(), std::string(""));

    std::cout << "Cadena concatenada: " << resultado << std::endl;

    return 0;
}
```cpp
#include <iostream>
#include <vector>
#include <numeric>

int main() {
    std::vector<int> vec = {1, 2, 3, 4, 5};

    // Calcular la suma de los elementos
    int suma = std::accumulate(vec.begin(), vec.end(), 0);

    // Calcular la media
    double media = static_cast<double>(suma) / vec.size();

    std::cout << "La media de los elementos es: " << media << std::endl;

    return 0;
}
<---Ejemplo con Operación Binaria Personalizada (Multiplicación) Result--->
<---`std::max`--->
```cpp
#include <algorithm>

template <class T>
const T& max(const T& a, const T& b);

template <class T, class Compare>
const T& max(const T& a, const T& b, Compare comp);

template <class ForwardIt>
ForwardIt max_element(ForwardIt first, ForwardIt last);

template <class ForwardIt, class Compare>
ForwardIt max_element(ForwardIt first, ForwardIt last, Compare comp);
<---`std::max` Result--->
<---`std::min`--->
```cpp
#include <algorithm>

template <class T>
const T& min(const T& a, const T& b);

template <class T, class Compare>
const T& min(const T& a, const T& b, Compare comp);

template <class ForwardIt>
ForwardIt min_element(ForwardIt first, ForwardIt last);

template <class ForwardIt, class Compare>
ForwardIt min_element(ForwardIt first, ForwardIt last, Compare comp);
<---`std::min` Result--->
<---Ejemplo Básico con Dos Valores--->
```cpp
#include <iostream>
#include <algorithm>

int main() {
    int a = 10, b = 20;

    // Encontrar el valor máximo
    int maxVal = std::max(a, b);
    std::cout << "El mayor de " << a << " y " << b << " es " << maxVal << std::endl;

    // Encontrar el valor mínimo
    int minVal = std::min(a, b);
    std::cout << "El menor de " << a << " y " << b << " es " << minVal << std::endl;

    return 0;
}
<---Ejemplo Básico con Dos Valores Result--->
<---Ejemplo con Comparación Personalizada--->
```cpp
#include <iostream>
#include <vector>
#include <algorithm>

struct Punto {
    int x, y;
};

bool compararPorDistancia(const Punto& p1, const Punto& p2) {
    return (p1.x * p1.x + p1.y * p1.y) < (p2.x * p2.x + p2.y * p2.y);
}

int main() {
    std::vector<Punto> puntos = {{1, 2}, {3, 4}, {0, 5}, {-1, -1}};

    // Encontrar el punto más lejano del origen
    auto maxIt = std::max_element(puntos.begin(), puntos.end(), compararPorDistancia);
    std::cout << "El punto más lejano es: (" << maxIt->x << ", " << maxIt->y << ")" << std::endl;

    // Encontrar el punto más cercano al origen
    auto minIt = std::min_element(puntos.begin(), puntos.end(), compararPorDistancia);
    std::cout << "El punto más cercano es: (" << minIt->x << ", " << minIt->y << ")" << std::endl;

    return 0;
}
<---Ejemplo con Comparación Personalizada Result--->
<---Ejemplo Básico con un Rango de Elementos--->
```cpp
#include <iostream>
#include <vector>
#include <algorithm>

int main() {
    std::vector<int> vec = {1, 2, 3, 4, 5};

    // Encontrar el elemento máximo
    auto maxIt = std::max_element(vec.begin(), vec.end());
    std::cout << "El elemento máximo es: " << *maxIt << std::endl;

    // Encontrar el elemento mínimo
    auto minIt = std::min_element(vec.begin(), vec.end());
    std::cout << "El elemento mínimo es: " << *minIt << std::endl;

    return 0;
}
<---Ejemplo Básico con un Rango de Elementos Result--->
<---Sintaxis--->
```cpp
#include <algorithm>

template <class InputIt, class UnaryPredicate>
InputIt find_if(InputIt first, InputIt last, UnaryPredicate p);
<---Sintaxis Result--->
<---Ejemplo de Uso de `std::find`--->
```cpp
#include <iostream>
#include <vector>
#include <algorithm>

int main() {
    std::vector<int> vec = {1, 2, 3, 4, 5};

    // Buscar el valor 3
    auto it = std::find(vec.begin(), vec.end(), 3);

    if (it != vec.end()) {
        std::cout << "Elemento encontrado: " << *it << std::endl;
    } else {
        std::cout << "Elemento no encontrado" << std::endl;
    }

    return 0;
}
<---Ejemplo de Uso de `std::find` Result--->
<---Ejemplo de Uso de `std::find_if`--->
```cpp
#include <iostream>
#include <vector>
#include <algorithm>

bool esImpar(int n) {
    return n % 2 != 0;
}

int main() {
    std::vector<int> vec = {2, 4, 6, 7, 8};

    // Buscar el primer elemento impar
    auto it = std::find_if(vec.begin(), vec.end(), esImpar);

    if (it != vec.end()) {
        std::cout << "Primer elemento impar encontrado: " << *it << std::endl;
    } else {
        std::cout << "Elemento impar no encontrado" << std::endl;
    }

    return 0;
}
<---Ejemplo de Uso de `std::find_if` Result--->
<---Ejemplo de Uso de `std::find_if` con Lambda--->
```cpp
#include <iostream>
#include <vector>
#include <algorithm>

int main() {
    std::vector<int> vec = {2, 4, 6, 7, 8};

    // Usar una lambda para buscar el primer elemento impar
    auto it = std::find_if(vec.begin(), vec.end(), [](int n) {
        return n % 2 != 0;
    });

    if (it != vec.end()) {
        std::cout << "Primer elemento impar encontrado: " << *it << std::endl;
    } else {
        std::cout << "Elemento impar no encontrado" << std::endl;
    }

    return 0;
}
```cpp
#include <iostream>
#include <vector>
#include <algorithm>

struct Punto {
    int x, y;

    bool operator==(const Punto& otro) const {
        return x == otro.x && y == otro.y;
    }
};

int main() {
    std::vector<Punto> puntos = {{1, 2}, {3, 4}, {5, 6}, {7, 8}};
    Punto puntoABuscar = {5, 6};

    // Buscar el punto {5, 6}
    auto it = std::find(puntos.begin(), puntos.end(), puntoABuscar);

    if (it != puntos.end()) {
        std::cout << "Punto encontrado: (" << it->x << ", " << it->y << ")" << std::endl;
    } else {
        std::cout << "Punto no encontrado" << std::endl;
    }

    return 0;
}
```cpp
#include <iostream>
#include <vector>
#include <algorithm>

int main() {
    std::vector<int> vec = {2, 4, 6, 7, 8};

    // Usar una lambda para buscar el primer elemento mayor que 5
    auto it = std::find_if(vec.begin(), vec.end(), [](int n) {
        return n > 5;
    });

    if (it != vec.end()) {
        std::cout << "Primer elemento mayor que 5 encontrado: " << *it << std::endl;
    } else {
        std::cout << "Elemento mayor que 5 no encontrado" << std::endl;
    }

    return 0;
}
<---Ejemplo de Uso de `std::find_if` con Lambda Result--->
<---Copiar Elementos entre Diferentes Contenedores--->
```cpp
#include <iostream>
#include <vector>
#include <list>
#include <algorithm>

int main() {
    std::vector<int> origen = {1, 2, 3, 4, 5};
    std::list<int> destino(origen.size());

    // Usar std::copy para copiar los elementos
    std::copy(origen.begin(), origen.end(), destino.begin());

    // Mostrar los elementos copiados
    std::cout << "Elementos copiados a la lista destino: ";
    for (int elem : destino) {
        std::cout << elem << " ";
    }
    std::cout << std::endl;

    return 0;
}
```cpp
#include <iostream>
#include <vector>
#include <algorithm>

int main() {
    std::vector<int> origen = {1, 2, 3, 4, 5};
    std::vector<int> destino(3);

    // Usar std::copy para copiar los primeros 3 elementos
    std::copy(origen.begin(), origen.begin() + 3, destino.begin());

    // Mostrar los elementos copiados
    std::cout << "Primeros 3 elementos copiados al vector destino: ";
    for (int elem : destino) {
        std::cout << elem << " ";
    }
    std::cout << std::endl;

    return 0;
}
```cpp
#include <iostream>
#include <vector>
#include <algorithm>
#include <iterator>

int main() {
    std::vector<int> origen = {1, 2, 3, 4, 5};
    std::vector<int> destino;

    // Usar std::copy con std::back_inserter
    std::copy(origen.begin(), origen.end(), std::back_inserter(destino));

    // Mostrar los elementos copiados
    std::cout << "Elementos copiados al vector destino con back_inserter: ";
    for (int elem : destino) {
        std::cout << elem << " ";
    }
    std::cout << std::endl;

    return 0;
}
<---Copiar Elementos entre Diferentes Contenedores Result--->
<---Ejemplo Básico (Orden Ascendente)--->
```cpp
#include <iostream>
#include <vector>
#include <algorithm>

int main() {
    std::vector<int> vec = {5, 2, 9, 1, 5, 6};

    // Usar std::sort para ordenar los elementos en orden ascendente
    std::sort(vec.begin(), vec.end());

    // Mostrar los elementos ordenados
    std::cout << "Elementos ordenados: ";
    for (int elem : vec) {
        std::cout << elem << " ";
    }
    std::cout << std::endl;

    return 0;
}
<---Ejemplo Básico (Orden Ascendente) Result--->
<---Ejemplo con Comparación Personalizada (Orden Descendente)--->
```cpp
#include <iostream>
#include <vector>
#include <algorithm>

int main() {
    std::vector<int> vec = {5, 2, 9, 1, 5, 6};

    // Usar std::sort con una función de comparación para ordenar en orden descendente
    std::sort(vec.begin(), vec.end(), std::greater<int>());

    // Mostrar los elementos ordenados
    std::cout << "Elementos ordenados en orden descendente: ";
    for (int elem : vec) {
        std::cout << elem << " ";
    }
    std::cout << std::endl;

    return 0;
}
<---Ejemplo con Comparación Personalizada (Orden Descendente) Result--->
<---Ordenar un `std::array`--->
```cpp
#include <iostream>
#include <array>
#include <algorithm>

int main() {
    std::array<int, 6> arr = {5, 2, 9, 1, 5, 6};

    // Usar std::sort para ordenar los elementos del array
    std::sort(arr.begin(), arr.end());

    // Mostrar los elementos ordenados
    std::cout << "Elementos del array ordenados: ";
    for (int elem : arr) {
        std::cout << elem << " ";
    }
    std::cout << std::endl;

    return 0;
}
<---Ordenar un `std::array` Result--->
<---Ejemplo Básico--->
```cpp
#include <iostream>
#include <vector>
#include <algorithm>

int main() {
    std::vector<int> origen = {1, 2, 3, 4, 5};
    std::vector<int> destino(origen.size());

    // Usar std::copy para copiar los elementos
    std::copy(origen.begin(), origen.end(), destino.begin());

    // Mostrar los elementos copiados
    std::cout << "Elementos copiados al vector destino: ";
    for (int elem : destino) {
        std::cout << elem << " ";
    }
    std::cout << std::endl;

    return 0;
}
<---Ejemplo Básico Result--->
<---Ejemplo con Lambda--->
```cpp
#include <iostream>
#include <vector>
#include <algorithm>

int main() {
    std::vector<int> vec = {1, 2, 3, 4, 5};

    // Usar una lambda para imprimir cada elemento del vector
    std::for_each(vec.begin(), vec.end(), [](int n) {
        std::cout << n << " ";
    });
    std::cout << std::endl;

    return 0;
}
```cpp
#include <iostream>
#include <vector>
#include <algorithm>

int main() {
    std::vector<int> vec = {1, 2, 3, 4, 5};

    // Usar una lambda para incrementar cada elemento del vector
    std::for_each(vec.begin(), vec.end(), [](int& n) {
        n += 1;
    });

    // Imprimir los elementos incrementados
    std::for_each(vec.begin(), vec.end(), [](int n) {
        std::cout << n << " ";
    });
    std::cout << std::endl;

    return 0;
}
```cpp
#include <iostream>
#include <vector>
#include <algorithm>

struct Acumulador {
    int suma = 0;

    void operator()(int n) {
        suma += n;
    }
};

int main() {
    std::vector<int> vec = {1, 2, 3, 4, 5};

    Acumulador acumulador = std::for_each(vec.begin(), vec.end(), Acumulador());

    std::cout << "Suma de los elementos: " << acumulador.suma << std::endl;

    return 0;
}
<---Ejemplo con Lambda Result--->
<---Ejemplo Básico (Suma)--->
```cpp
#include <iostream>
#include <vector>
#include <numeric>

int main() {
    std::vector<int> vec = {1, 2, 3, 4, 5};

    // Usar std::accumulate para sumar todos los elementos
    int suma = std::accumulate(vec.begin(), vec.end(), 0);

    std::cout << "La suma de los elementos es: " << suma << std::endl;

    return 0;
}
<---Ejemplo Básico (Suma) Result--->
<---Ejemplo con Operación Binaria Personalizada (Multiplicación)--->
```cpp
#include <iostream>
#include <vector>
#include <numeric>

int main() {
    std::vector<int> vec = {1, 2, 3, 4, 5};

    // Usar std::accumulate para multiplicar todos los elementos
    int producto = std::accumulate(vec.begin(), vec.end(), 1, std::multiplies<int>());

    std::cout << "El producto de los elementos es: " << producto << std::endl;

    return 0;
}
```cpp
#include <iostream>
#include <vector>
#include <numeric>
#include <string>

int main() {
    std::vector<std::string> vec = {"Hola", " ", "mundo", "!"};

    // Usar std::accumulate para concatenar todas las cadenas
    std::string resultado = std::accumulate(vec.begin(), vec.end(), std::string(""));

    std::cout << "Cadena concatenada: " << resultado << std::endl;

    return 0;
}
```cpp
#include <iostream>
#include <vector>
#include <numeric>

int main() {
    std::vector<int> vec = {1, 2, 3, 4, 5};

    // Calcular la suma de los elementos
    int suma = std::accumulate(vec.begin(), vec.end(), 0);

    // Calcular la media
    double media = static_cast<double>(suma) / vec.size();

    std::cout << "La media de los elementos es: " << media << std::endl;

    return 0;
}
<---Ejemplo con Operación Binaria Personalizada (Multiplicación) Result--->
<---`std::max`--->
```cpp
#include <algorithm>

template <class T>
const T& max(const T& a, const T& b);

template <class T, class Compare>
const T& max(const T& a, const T& b, Compare comp);

template <class ForwardIt>
ForwardIt max_element(ForwardIt first, ForwardIt last);

template <class ForwardIt, class Compare>
ForwardIt max_element(ForwardIt first, ForwardIt last, Compare comp);
<---`std::max` Result--->
<---`std::min`--->
```cpp
#include <algorithm>

template <class T>
const T& min(const T& a, const T& b);

template <class T, class Compare>
const T& min(const T& a, const T& b, Compare comp);

template <class ForwardIt>
ForwardIt min_element(ForwardIt first, ForwardIt last);

template <class ForwardIt, class Compare>
ForwardIt min_element(ForwardIt first, ForwardIt last, Compare comp);
<---`std::min` Result--->
<---Ejemplo Básico con Dos Valores--->
```cpp
#include <iostream>
#include <algorithm>

int main() {
    int a = 10, b = 20;

    // Encontrar el valor máximo
    int maxVal = std::max(a, b);
    std::cout << "El mayor de " << a << " y " << b << " es " << maxVal << std::endl;

    // Encontrar el valor mínimo
    int minVal = std::min(a, b);
    std::cout << "El menor de " << a << " y " << b << " es " << minVal << std::endl;

    return 0;
}
<---Ejemplo Básico con Dos Valores Result--->
<---Ejemplo con Comparación Personalizada--->
```cpp
#include <iostream>
#include <vector>
#include <algorithm>

struct Punto {
    int x, y;
};

bool compararPorDistancia(const Punto& p1, const Punto& p2) {
    return (p1.x * p1.x + p1.y * p1.y) < (p2.x * p2.x + p2.y * p2.y);
}

int main() {
    std::vector<Punto> puntos = {{1, 2}, {3, 4}, {0, 5}, {-1, -1}};

    // Encontrar el punto más lejano del origen
    auto maxIt = std::max_element(puntos.begin(), puntos.end(), compararPorDistancia);
    std::cout << "El punto más lejano es: (" << maxIt->x << ", " << maxIt->y << ")" << std::endl;

    // Encontrar el punto más cercano al origen
    auto minIt = std::min_element(puntos.begin(), puntos.end(), compararPorDistancia);
    std::cout << "El punto más cercano es: (" << minIt->x << ", " << minIt->y << ")" << std::endl;

    return 0;
}
<---Ejemplo con Comparación Personalizada Result--->
<---Ejemplo Básico con un Rango de Elementos--->
```cpp
#include <iostream>
#include <vector>
#include <algorithm>

int main() {
    std::vector<int> vec = {1, 2, 3, 4, 5};

    // Encontrar el elemento máximo
    auto maxIt = std::max_element(vec.begin(), vec.end());
    std::cout << "El elemento máximo es: " << *maxIt << std::endl;

    // Encontrar el elemento mínimo
    auto minIt = std::min_element(vec.begin(), vec.end());
    std::cout << "El elemento mínimo es: " << *minIt << std::endl;

    return 0;
}
<---Ejemplo Básico con un Rango de Elementos Result--->
<---Sintaxis--->
```cpp
#include <algorithm>

template <class InputIt, class UnaryPredicate>
InputIt find_if(InputIt first, InputIt last, UnaryPredicate p);
<---Sintaxis Result--->
<---Ejemplo de Uso de `std::find`--->
```cpp
#include <iostream>
#include <vector>
#include <algorithm>

int main() {
    std::vector<int> vec = {1, 2, 3, 4, 5};

    // Buscar el valor 3
    auto it = std::find(vec.begin(), vec.end(), 3);

    if (it != vec.end()) {
        std::cout << "Elemento encontrado: " << *it << std::endl;
    } else {
        std::cout << "Elemento no encontrado" << std::endl;
    }

    return 0;
}
<---Ejemplo de Uso de `std::find` Result--->
<---Ejemplo de Uso de `std::find_if`--->
```cpp
#include <iostream>
#include <vector>
#include <algorithm>

bool esImpar(int n) {
    return n % 2 != 0;
}

int main() {
    std::vector<int> vec = {2, 4, 6, 7, 8};

    // Buscar el primer elemento impar
    auto it = std::find_if(vec.begin(), vec.end(), esImpar);

    if (it != vec.end()) {
        std::cout << "Primer elemento impar encontrado: " << *it << std::endl;
    } else {
        std::cout << "Elemento impar no encontrado" << std::endl;
    }

    return 0;
}
<---Ejemplo de Uso de `std::find_if` Result--->
<---Ejemplo de Uso de `std::find_if` con Lambda--->
```cpp
#include <iostream>
#include <vector>
#include <algorithm>

int main() {
    std::vector<int> vec = {2, 4, 6, 7, 8};

    // Usar una lambda para buscar el primer elemento impar
    auto it = std::find_if(vec.begin(), vec.end(), [](int n) {
        return n % 2 != 0;
    });

    if (it != vec.end()) {
        std::cout << "Primer elemento impar encontrado: " << *it << std::endl;
    } else {
        std::cout << "Elemento impar no encontrado" << std::endl;
    }

    return 0;
}
```cpp
#include <iostream>
#include <vector>
#include <algorithm>

struct Punto {
    int x, y;

    bool operator==(const Punto& otro) const {
        return x == otro.x && y == otro.y;
    }
};

int main() {
    std::vector<Punto> puntos = {{1, 2}, {3, 4}, {5, 6}, {7, 8}};
    Punto puntoABuscar = {5, 6};

    // Buscar el punto {5, 6}
    auto it = std::find(puntos.begin(), puntos.end(), puntoABuscar);

    if (it != puntos.end()) {
        std::cout << "Punto encontrado: (" << it->x << ", " << it->y << ")" << std::endl;
    } else {
        std::cout << "Punto no encontrado" << std::endl;
    }

    return 0;
}
```cpp
#include <iostream>
#include <vector>
#include <algorithm>

int main() {
    std::vector<int> vec = {2, 4, 6, 7, 8};

    // Usar una lambda para buscar el primer elemento mayor que 5
    auto it = std::find_if(vec.begin(), vec.end(), [](int n) {
        return n > 5;
    });

    if (it != vec.end()) {
        std::cout << "Primer elemento mayor que 5 encontrado: " << *it << std::endl;
    } else {
        std::cout << "Elemento mayor que 5 no encontrado" << std::endl;
    }

    return 0;
}
<---Ejemplo de Uso de `std::find_if` con Lambda Result--->
<---Copiar Elementos entre Diferentes Contenedores--->
```cpp
#include <iostream>
#include <vector>
#include <list>
#include <algorithm>

int main() {
    std::vector<int> origen = {1, 2, 3, 4, 5};
    std::list<int> destino(origen.size());

    // Usar std::copy para copiar los elementos
    std::copy(origen.begin(), origen.end(), destino.begin());

    // Mostrar los elementos copiados
    std::cout << "Elementos copiados a la lista destino: ";
    for (int elem : destino) {
        std::cout << elem << " ";
    }
    std::cout << std::endl;

    return 0;
}
```cpp
#include <iostream>
#include <vector>
#include <algorithm>

int main() {
    std::vector<int> origen = {1, 2, 3, 4, 5};
    std::vector<int> destino(3);

    // Usar std::copy para copiar los primeros 3 elementos
    std::copy(origen.begin(), origen.begin() + 3, destino.begin());

    // Mostrar los elementos copiados
    std::cout << "Primeros 3 elementos copiados al vector destino: ";
    for (int elem : destino) {
        std::cout << elem << " ";
    }
    std::cout << std::endl;

    return 0;
}
```cpp
#include <iostream>
#include <vector>
#include <algorithm>
#include <iterator>

int main() {
    std::vector<int> origen = {1, 2, 3, 4, 5};
    std::vector<int> destino;

    // Usar std::copy con std::back_inserter
    std::copy(origen.begin(), origen.end(), std::back_inserter(destino));

    // Mostrar los elementos copiados
    std::cout << "Elementos copiados al vector destino con back_inserter: ";
    for (int elem : destino) {
        std::cout << elem << " ";
    }
    std::cout << std::endl;

    return 0;
}
<---Copiar Elementos entre Diferentes Contenedores Result--->
<---Ejemplo Básico (Orden Ascendente)--->
```cpp
#include <iostream>
#include <vector>
#include <algorithm>

int main() {
    std::vector<int> vec = {5, 2, 9, 1, 5, 6};

    // Usar std::sort para ordenar los elementos en orden ascendente
    std::sort(vec.begin(), vec.end());

    // Mostrar los elementos ordenados
    std::cout << "Elementos ordenados: ";
    for (int elem : vec) {
        std::cout << elem << " ";
    }
    std::cout << std::endl;

    return 0;
}
<---Ejemplo Básico (Orden Ascendente) Result--->
<---Ejemplo con Comparación Personalizada (Orden Descendente)--->
```cpp
#include <iostream>
#include <vector>
#include <algorithm>

int main() {
    std::vector<int> vec = {5, 2, 9, 1, 5, 6};

    // Usar std::sort con una función de comparación para ordenar en orden descendente
    std::sort(vec.begin(), vec.end(), std::greater<int>());

    // Mostrar los elementos ordenados
    std::cout << "Elementos ordenados en orden descendente: ";
    for (int elem : vec) {
        std::cout << elem << " ";
    }
    std::cout << std::endl;

    return 0;
}
<---Ejemplo con Comparación Personalizada (Orden Descendente) Result--->
<---Ordenar un `std::array`--->
```cpp
#include <iostream>
#include <array>
#include <algorithm>

int main() {
    std::array<int, 6> arr = {5, 2, 9, 1, 5, 6};

    // Usar std::sort para ordenar los elementos del array
    std::sort(arr.begin(), arr.end());

    // Mostrar los elementos ordenados
    std::cout << "Elementos del array ordenados: ";
    for (int elem : arr) {
        std::cout << elem << " ";
    }
    std::cout << std::endl;

    return 0;
}
<---Ordenar un `std::array` Result--->
<---Ejemplo Básico (Función Unaria)--->
```cpp
#include <iostream>
#include <vector>
#include <algorithm>

int main() {
    std::vector<int> origen = {1, 2, 3, 4, 5};
    std::vector<int> destino(origen.size());

    // Usar std::transform para duplicar cada elemento
    std::transform(origen.begin(), origen.end(), destino.begin(), [](int x) {
        return x * 2;
    });

    // Mostrar los elementos transformados
    std::cout << "Elementos transformados (duplicados): ";
    for (int elem : destino) {
        std::cout << elem << " ";
    }
    std::cout << std::endl;

    return 0;
}
<---Ejemplo Básico (Función Unaria) Result--->
<---Ejemplo con Función Binaria--->
```cpp
#include <iostream>
#include <vector>
#include <algorithm>

int main() {
    std::vector<int> vec1 = {1, 2, 3, 4, 5};
    std::vector<int> vec2 = {10, 20, 30, 40, 50};
    std::vector<int> resultado(vec1.size());

    // Usar std::transform para sumar elementos de dos vectores
    std::transform(vec1.begin(), vec1.end(), vec2.begin(), resultado.begin(), [](int x, int y) {
        return x + y;
    });

    // Mostrar los elementos transformados
    std::cout << "Elementos transformados (suma de vec1 y vec2): ";
    for (int elem : resultado) {
        std::cout << elem << " ";
    }
    std::cout << std::endl;

    return 0;
}
<---Ejemplo con Función Binaria Result--->
<---Transformar una Lista--->
```cpp
#include <iostream>
#include <list>
#include <algorithm>

int main() {
    std::list<int> origen = {1, 2, 3, 4, 5};
    std::list<int> destino(origen.size());

    // Usar std::transform para incrementar cada elemento
    std::transform(origen.begin(), origen.end(), destino.begin(), [](int x) {
        return x + 1;
    });

    // Mostrar los elementos transformados
    std::cout << "Elementos transformados (incrementados): ";
    for (int elem : destino) {
        std::cout << elem << " ";
    }
    std::cout << std::endl;

    return 0;
}
<---Transformar una Lista Result--->
<---Ejemplo Básico--->
```cpp
#include <iostream>
#include <vector>
#include <algorithm>

int main() {
    std::vector<int> vec(10);

    // Usar std::fill para asignar el valor 5 a todos los elementos del vector
    std::fill(vec.begin(), vec.end(), 5);

    // Mostrar los elementos del vector
    std::cout << "Elementos del vector después de std::fill: ";
    for (int elem : vec) {
        std::cout << elem << " ";
    }
    std::cout << std::endl;

    return 0;
}
<---Ejemplo Básico Result--->
<---Ejemplo con Lambda--->
```cpp
#include <iostream>
#include <vector>
#include <algorithm>

int main() {
    std::vector<int> vec = {1, 2, 3, 4, 5};

    // Usar una lambda para imprimir cada elemento del vector
    std::for_each(vec.begin(), vec.end(), [](int n) {
        std::cout << n << " ";
    });
    std::cout << std::endl;

    return 0;
}
```cpp
#include <iostream>
#include <vector>
#include <algorithm>

int main() {
    std::vector<int> vec = {1, 2, 3, 4, 5};

    // Usar una lambda para incrementar cada elemento del vector
    std::for_each(vec.begin(), vec.end(), [](int& n) {
        n += 1;
    });

    // Imprimir los elementos incrementados
    std::for_each(vec.begin(), vec.end(), [](int n) {
        std::cout << n << " ";
    });
    std::cout << std::endl;

    return 0;
}
```cpp
#include <iostream>
#include <vector>
#include <algorithm>

struct Acumulador {
    int suma = 0;

    void operator()(int n) {
        suma += n;
    }
};

int main() {
    std::vector<int> vec = {1, 2, 3, 4, 5};

    Acumulador acumulador = std::for_each(vec.begin(), vec.end(), Acumulador());

    std::cout << "Suma de los elementos: " << acumulador.suma << std::endl;

    return 0;
}
<---Ejemplo con Lambda Result--->
<---Ejemplo Básico (Suma)--->
```cpp
#include <iostream>
#include <vector>
#include <numeric>

int main() {
    std::vector<int> vec = {1, 2, 3, 4, 5};

    // Usar std::accumulate para sumar todos los elementos
    int suma = std::accumulate(vec.begin(), vec.end(), 0);

    std::cout << "La suma de los elementos es: " << suma << std::endl;

    return 0;
}
<---Ejemplo Básico (Suma) Result--->
<---Ejemplo con Operación Binaria Personalizada (Multiplicación)--->
```cpp
#include <iostream>
#include <vector>
#include <numeric>

int main() {
    std::vector<int> vec = {1, 2, 3, 4, 5};

    // Usar std::accumulate para multiplicar todos los elementos
    int producto = std::accumulate(vec.begin(), vec.end(), 1, std::multiplies<int>());

    std::cout << "El producto de los elementos es: " << producto << std::endl;

    return 0;
}
```cpp
#include <iostream>
#include <vector>
#include <numeric>
#include <string>

int main() {
    std::vector<std::string> vec = {"Hola", " ", "mundo", "!"};

    // Usar std::accumulate para concatenar todas las cadenas
    std::string resultado = std::accumulate(vec.begin(), vec.end(), std::string(""));

    std::cout << "Cadena concatenada: " << resultado << std::endl;

    return 0;
}
```cpp
#include <iostream>
#include <vector>
#include <numeric>

int main() {
    std::vector<int> vec = {1, 2, 3, 4, 5};

    // Calcular la suma de los elementos
    int suma = std::accumulate(vec.begin(), vec.end(), 0);

    // Calcular la media
    double media = static_cast<double>(suma) / vec.size();

    std::cout << "La media de los elementos es: " << media << std::endl;

    return 0;
}
<---Ejemplo con Operación Binaria Personalizada (Multiplicación) Result--->
<---`std::max`--->
```cpp
#include <algorithm>

template <class T>
const T& max(const T& a, const T& b);

template <class T, class Compare>
const T& max(const T& a, const T& b, Compare comp);

template <class ForwardIt>
ForwardIt max_element(ForwardIt first, ForwardIt last);

template <class ForwardIt, class Compare>
ForwardIt max_element(ForwardIt first, ForwardIt last, Compare comp);
<---`std::max` Result--->
<---`std::min`--->
```cpp
#include <algorithm>

template <class T>
const T& min(const T& a, const T& b);

template <class T, class Compare>
const T& min(const T& a, const T& b, Compare comp);

template <class ForwardIt>
ForwardIt min_element(ForwardIt first, ForwardIt last);

template <class ForwardIt, class Compare>
ForwardIt min_element(ForwardIt first, ForwardIt last, Compare comp);
<---`std::min` Result--->
<---Ejemplo Básico con Dos Valores--->
```cpp
#include <iostream>
#include <algorithm>

int main() {
    int a = 10, b = 20;

    // Encontrar el valor máximo
    int maxVal = std::max(a, b);
    std::cout << "El mayor de " << a << " y " << b << " es " << maxVal << std::endl;

    // Encontrar el valor mínimo
    int minVal = std::min(a, b);
    std::cout << "El menor de " << a << " y " << b << " es " << minVal << std::endl;

    return 0;
}
<---Ejemplo Básico con Dos Valores Result--->
<---Ejemplo con Comparación Personalizada--->
```cpp
#include <iostream>
#include <vector>
#include <algorithm>

struct Punto {
    int x, y;
};

bool compararPorDistancia(const Punto& p1, const Punto& p2) {
    return (p1.x * p1.x + p1.y * p1.y) < (p2.x * p2.x + p2.y * p2.y);
}

int main() {
    std::vector<Punto> puntos = {{1, 2}, {3, 4}, {0, 5}, {-1, -1}};

    // Encontrar el punto más lejano del origen
    auto maxIt = std::max_element(puntos.begin(), puntos.end(), compararPorDistancia);
    std::cout << "El punto más lejano es: (" << maxIt->x << ", " << maxIt->y << ")" << std::endl;

    // Encontrar el punto más cercano al origen
    auto minIt = std::min_element(puntos.begin(), puntos.end(), compararPorDistancia);
    std::cout << "El punto más cercano es: (" << minIt->x << ", " << minIt->y << ")" << std::endl;

    return 0;
}
<---Ejemplo con Comparación Personalizada Result--->
<---Ejemplo Básico con un Rango de Elementos--->
```cpp
#include <iostream>
#include <vector>
#include <algorithm>

int main() {
    std::vector<int> vec = {1, 2, 3, 4, 5};

    // Encontrar el elemento máximo
    auto maxIt = std::max_element(vec.begin(), vec.end());
    std::cout << "El elemento máximo es: " << *maxIt << std::endl;

    // Encontrar el elemento mínimo
    auto minIt = std::min_element(vec.begin(), vec.end());
    std::cout << "El elemento mínimo es: " << *minIt << std::endl;

    return 0;
}
<---Ejemplo Básico con un Rango de Elementos Result--->
<---Sintaxis--->
```cpp
#include <algorithm>

template <class InputIt, class UnaryPredicate>
InputIt find_if(InputIt first, InputIt last, UnaryPredicate p);
<---Sintaxis Result--->
<---Ejemplo de Uso de `std::find`--->
```cpp
#include <iostream>
#include <vector>
#include <algorithm>

int main() {
    std::vector<int> vec = {1, 2, 3, 4, 5};

    // Buscar el valor 3
    auto it = std::find(vec.begin(), vec.end(), 3);

    if (it != vec.end()) {
        std::cout << "Elemento encontrado: " << *it << std::endl;
    } else {
        std::cout << "Elemento no encontrado" << std::endl;
    }

    return 0;
}
<---Ejemplo de Uso de `std::find` Result--->
<---Ejemplo de Uso de `std::find_if`--->
```cpp
#include <iostream>
#include <vector>
#include <algorithm>

bool esImpar(int n) {
    return n % 2 != 0;
}

int main() {
    std::vector<int> vec = {2, 4, 6, 7, 8};

    // Buscar el primer elemento impar
    auto it = std::find_if(vec.begin(), vec.end(), esImpar);

    if (it != vec.end()) {
        std::cout << "Primer elemento impar encontrado: " << *it << std::endl;
    } else {
        std::cout << "Elemento impar no encontrado" << std::endl;
    }

    return 0;
}
<---Ejemplo de Uso de `std::find_if` Result--->
<---Ejemplo de Uso de `std::find_if` con Lambda--->
```cpp
#include <iostream>
#include <vector>
#include <algorithm>

int main() {
    std::vector<int> vec = {2, 4, 6, 7, 8};

    // Usar una lambda para buscar el primer elemento impar
    auto it = std::find_if(vec.begin(), vec.end(), [](int n) {
        return n % 2 != 0;
    });

    if (it != vec.end()) {
        std::cout << "Primer elemento impar encontrado: " << *it << std::endl;
    } else {
        std::cout << "Elemento impar no encontrado" << std::endl;
    }

    return 0;
}
```cpp
#include <iostream>
#include <vector>
#include <algorithm>

struct Punto {
    int x, y;

    bool operator==(const Punto& otro) const {
        return x == otro.x && y == otro.y;
    }
};

int main() {
    std::vector<Punto> puntos = {{1, 2}, {3, 4}, {5, 6}, {7, 8}};
    Punto puntoABuscar = {5, 6};

    // Buscar el punto {5, 6}
    auto it = std::find(puntos.begin(), puntos.end(), puntoABuscar);

    if (it != puntos.end()) {
        std::cout << "Punto encontrado: (" << it->x << ", " << it->y << ")" << std::endl;
    } else {
        std::cout << "Punto no encontrado" << std::endl;
    }

    return 0;
}
```cpp
#include <iostream>
#include <vector>
#include <algorithm>

int main() {
    std::vector<int> vec = {2, 4, 6, 7, 8};

    // Usar una lambda para buscar el primer elemento mayor que 5
    auto it = std::find_if(vec.begin(), vec.end(), [](int n) {
        return n > 5;
    });

    if (it != vec.end()) {
        std::cout << "Primer elemento mayor que 5 encontrado: " << *it << std::endl;
    } else {
        std::cout << "Elemento mayor que 5 no encontrado" << std::endl;
    }

    return 0;
}
<---Ejemplo de Uso de `std::find_if` con Lambda Result--->
<---Copiar Elementos entre Diferentes Contenedores--->
```cpp
#include <iostream>
#include <vector>
#include <list>
#include <algorithm>

int main() {
    std::vector<int> origen = {1, 2, 3, 4, 5};
    std::list<int> destino(origen.size());

    // Usar std::copy para copiar los elementos
    std::copy(origen.begin(), origen.end(), destino.begin());

    // Mostrar los elementos copiados
    std::cout << "Elementos copiados a la lista destino: ";
    for (int elem : destino) {
        std::cout << elem << " ";
    }
    std::cout << std::endl;

    return 0;
}
```cpp
#include <iostream>
#include <vector>
#include <algorithm>

int main() {
    std::vector<int> origen = {1, 2, 3, 4, 5};
    std::vector<int> destino(3);

    // Usar std::copy para copiar los primeros 3 elementos
    std::copy(origen.begin(), origen.begin() + 3, destino.begin());

    // Mostrar los elementos copiados
    std::cout << "Primeros 3 elementos copiados al vector destino: ";
    for (int elem : destino) {
        std::cout << elem << " ";
    }
    std::cout << std::endl;

    return 0;
}
```cpp
#include <iostream>
#include <vector>
#include <algorithm>
#include <iterator>

int main() {
    std::vector<int> origen = {1, 2, 3, 4, 5};
    std::vector<int> destino;

    // Usar std::copy con std::back_inserter
    std::copy(origen.begin(), origen.end(), std::back_inserter(destino));

    // Mostrar los elementos copiados
    std::cout << "Elementos copiados al vector destino con back_inserter: ";
    for (int elem : destino) {
        std::cout << elem << " ";
    }
    std::cout << std::endl;

    return 0;
}
<---Copiar Elementos entre Diferentes Contenedores Result--->
<---Ejemplo Básico (Orden Ascendente)--->
```cpp
#include <iostream>
#include <vector>
#include <algorithm>

int main() {
    std::vector<int> vec = {5, 2, 9, 1, 5, 6};

    // Usar std::sort para ordenar los elementos en orden ascendente
    std::sort(vec.begin(), vec.end());

    // Mostrar los elementos ordenados
    std::cout << "Elementos ordenados: ";
    for (int elem : vec) {
        std::cout << elem << " ";
    }
    std::cout << std::endl;

    return 0;
}
<---Ejemplo Básico (Orden Ascendente) Result--->
<---Ejemplo con Comparación Personalizada (Orden Descendente)--->
```cpp
#include <iostream>
#include <vector>
#include <algorithm>

int main() {
    std::vector<int> vec = {5, 2, 9, 1, 5, 6};

    // Usar std::sort con una función de comparación para ordenar en orden descendente
    std::sort(vec.begin(), vec.end(), std::greater<int>());

    // Mostrar los elementos ordenados
    std::cout << "Elementos ordenados en orden descendente: ";
    for (int elem : vec) {
        std::cout << elem << " ";
    }
    std::cout << std::endl;

    return 0;
}
<---Ejemplo con Comparación Personalizada (Orden Descendente) Result--->
<---Ordenar un `std::array`--->
```cpp
#include <iostream>
#include <array>
#include <algorithm>

int main() {
    std::array<int, 6> arr = {5, 2, 9, 1, 5, 6};

    // Usar std::sort para ordenar los elementos del array
    std::sort(arr.begin(), arr.end());

    // Mostrar los elementos ordenados
    std::cout << "Elementos del array ordenados: ";
    for (int elem : arr) {
        std::cout << elem << " ";
    }
    std::cout << std::endl;

    return 0;
}
<---Ordenar un `std::array` Result--->
<---Ejemplo Básico (Función Unaria)--->
```cpp
#include <iostream>
#include <vector>
#include <algorithm>

int main() {
    std::vector<int> origen = {1, 2, 3, 4, 5};
    std::vector<int> destino(origen.size());

    // Usar std::transform para duplicar cada elemento
    std::transform(origen.begin(), origen.end(), destino.begin(), [](int x) {
        return x * 2;
    });

    // Mostrar los elementos transformados
    std::cout << "Elementos transformados (duplicados): ";
    for (int elem : destino) {
        std::cout << elem << " ";
    }
    std::cout << std::endl;

    return 0;
}
<---Ejemplo Básico (Función Unaria) Result--->
<---Ejemplo con Función Binaria--->
```cpp
#include <iostream>
#include <vector>
#include <algorithm>

int main() {
    std::vector<int> vec1 = {1, 2, 3, 4, 5};
    std::vector<int> vec2 = {10, 20, 30, 40, 50};
    std::vector<int> resultado(vec1.size());

    // Usar std::transform para sumar elementos de dos vectores
    std::transform(vec1.begin(), vec1.end(), vec2.begin(), resultado.begin(), [](int x, int y) {
        return x + y;
    });

    // Mostrar los elementos transformados
    std::cout << "Elementos transformados (suma de vec1 y vec2): ";
    for (int elem : resultado) {
        std::cout << elem << " ";
    }
    std::cout << std::endl;

    return 0;
}
<---Ejemplo con Función Binaria Result--->
<---Transformar una Lista--->
```cpp
#include <iostream>
#include <list>
#include <algorithm>

int main() {
    std::list<int> origen = {1, 2, 3, 4, 5};
    std::list<int> destino(origen.size());

    // Usar std::transform para incrementar cada elemento
    std::transform(origen.begin(), origen.end(), destino.begin(), [](int x) {
        return x + 1;
    });

    // Mostrar los elementos transformados
    std::cout << "Elementos transformados (incrementados): ";
    for (int elem : destino) {
        std::cout << elem << " ";
    }
    std::cout << std::endl;

    return 0;
}
<---Transformar una Lista Result--->
<---Ejemplo con `std::array`--->
```cpp
#include <iostream>
#include <array>
#include <algorithm>

int main() {
    std::array<int, 5> arr;

    // Usar std::fill para asignar el valor 10 a todos los elementos del array
    std::fill(arr.begin(), arr.end(), 10);

    // Mostrar los elementos del array
    std::cout << "Elementos del array después de std::fill: ";
    for (int elem : arr) {
        std::cout << elem << " ";
    }
    std::cout << std::endl;

    return 0;
}
<---Ejemplo con `std::array` Result--->
<---Ejemplo con una Matriz--->
```cpp
#include <iostream>
#include <vector>
#include <algorithm>

int main() {
    std::vector<std::vector<int>> matrix(3, std::vector<int>(4));

    // Usar std::fill para asignar el valor 0 a todos los elementos de la matriz
    for (auto& row : matrix) {
        std::fill(row.begin(), row.end(), 0);
    }

    // Mostrar los elementos de la matriz
    std::cout << "Elementos de la matriz después de std::fill: " << std::endl;
    for (const auto& row : matrix) {
        for (int elem : row) {
            std::cout << elem << " ";
        }
        std::cout << std::endl;
    }

    return 0;
}
<---Ejemplo con una Matriz Result--->
<---Ejemplo de Rango Parcial--->
```cpp
#include <iostream>
#include <vector>
#include <algorithm>

int main() {
    std::vector<int> vec(10);

    // Asignar el valor 1 a la primera mitad del vector
    std::fill(vec.begin(), vec.begin() + vec.size() / 2, 1);

    // Asignar el valor 2 a la segunda mitad del vector
    std::fill(vec.begin() + vec.size() / 2, vec.end(), 2);

    // Mostrar los elementos del vector
    std::cout << "Elementos del vector después de std::fill en rangos parciales: ";
    for (int elem : vec) {
        std::cout << elem << " ";
    }
    std::cout << std::endl;

    return 0;
}
<---Ejemplo de Rango Parcial Result--->
<---Ejemplo Básico--->
```cpp
#include <iostream>
#include <vector>
#include <algorithm>

int main() {
    std::vector<int> vec = {1, 2, 3, 2, 5, 2};

    // Usar std::replace para reemplazar todos los 2 por 9
    std::replace(vec.begin(), vec.end(), 2, 9);

    // Mostrar los elementos modificados
    std::cout << "Elementos del vector después de std::replace: ";
    for (int elem : vec) {
        std::cout << elem << " ";
    }
    std::cout << std::endl;

    return 0;
}
<---Ejemplo Básico Result--->
<---Ejemplo con Lambda--->
```cpp
#include <iostream>
#include <vector>
#include <algorithm>

int main() {
    std::vector<int> vec = {1, 2, 3, 4, 5, 6};

    // Usar std::replace_if con una lambda para reemplazar todos los números mayores que 3 por 99
    std::replace_if(vec.begin(), vec.end(), [](int n) { return n > 3; }, 99);

    // Mostrar los elementos modificados
    std::cout << "Elementos del vector después de std::replace_if: ";
    for (int elem : vec) {
        std::cout << elem << " ";
    }
    std::cout << std::endl;

    return 0;
}
<---Ejemplo con Lambda Result--->
<---Ejemplo Básico (Suma)--->
```cpp
#include <iostream>
#include <vector>
#include <numeric>

int main() {
    std::vector<int> vec = {1, 2, 3, 4, 5};

    // Usar std::accumulate para sumar todos los elementos
    int suma = std::accumulate(vec.begin(), vec.end(), 0);

    std::cout << "La suma de los elementos es: " << suma << std::endl;

    return 0;
}
<---Ejemplo Básico (Suma) Result--->
<---Ejemplo con Operación Binaria Personalizada (Multiplicación)--->
```cpp
#include <iostream>
#include <vector>
#include <numeric>

int main() {
    std::vector<int> vec = {1, 2, 3, 4, 5};

    // Usar std::accumulate para multiplicar todos los elementos
    int producto = std::accumulate(vec.begin(), vec.end(), 1, std::multiplies<int>());

    std::cout << "El producto de los elementos es: " << producto << std::endl;

    return 0;
}
```cpp
#include <iostream>
#include <vector>
#include <numeric>
#include <string>

int main() {
    std::vector<std::string> vec = {"Hola", " ", "mundo", "!"};

    // Usar std::accumulate para concatenar todas las cadenas
    std::string resultado = std::accumulate(vec.begin(), vec.end(), std::string(""));

    std::cout << "Cadena concatenada: " << resultado << std::endl;

    return 0;
}
```cpp
#include <iostream>
#include <vector>
#include <numeric>

int main() {
    std::vector<int> vec = {1, 2, 3, 4, 5};

    // Calcular la suma de los elementos
    int suma = std::accumulate(vec.begin(), vec.end(), 0);

    // Calcular la media
    double media = static_cast<double>(suma) / vec.size();

    std::cout << "La media de los elementos es: " << media << std::endl;

    return 0;
}
<---Ejemplo con Operación Binaria Personalizada (Multiplicación) Result--->
<---`std::max`--->
```cpp
#include <algorithm>

template <class T>
const T& max(const T& a, const T& b);

template <class T, class Compare>
const T& max(const T& a, const T& b, Compare comp);

template <class ForwardIt>
ForwardIt max_element(ForwardIt first, ForwardIt last);

template <class ForwardIt, class Compare>
ForwardIt max_element(ForwardIt first, ForwardIt last, Compare comp);
<---`std::max` Result--->
<---`std::min`--->
```cpp
#include <algorithm>

template <class T>
const T& min(const T& a, const T& b);

template <class T, class Compare>
const T& min(const T& a, const T& b, Compare comp);

template <class ForwardIt>
ForwardIt min_element(ForwardIt first, ForwardIt last);

template <class ForwardIt, class Compare>
ForwardIt min_element(ForwardIt first, ForwardIt last, Compare comp);
<---`std::min` Result--->
<---Ejemplo Básico con Dos Valores--->
```cpp
#include <iostream>
#include <algorithm>

int main() {
    int a = 10, b = 20;

    // Encontrar el valor máximo
    int maxVal = std::max(a, b);
    std::cout << "El mayor de " << a << " y " << b << " es " << maxVal << std::endl;

    // Encontrar el valor mínimo
    int minVal = std::min(a, b);
    std::cout << "El menor de " << a << " y " << b << " es " << minVal << std::endl;

    return 0;
}
<---Ejemplo Básico con Dos Valores Result--->
<---Ejemplo con Comparación Personalizada--->
```cpp
#include <iostream>
#include <vector>
#include <algorithm>

struct Punto {
    int x, y;
};

bool compararPorDistancia(const Punto& p1, const Punto& p2) {
    return (p1.x * p1.x + p1.y * p1.y) < (p2.x * p2.x + p2.y * p2.y);
}

int main() {
    std::vector<Punto> puntos = {{1, 2}, {3, 4}, {0, 5}, {-1, -1}};

    // Encontrar el punto más lejano del origen
    auto maxIt = std::max_element(puntos.begin(), puntos.end(), compararPorDistancia);
    std::cout << "El punto más lejano es: (" << maxIt->x << ", " << maxIt->y << ")" << std::endl;

    // Encontrar el punto más cercano al origen
    auto minIt = std::min_element(puntos.begin(), puntos.end(), compararPorDistancia);
    std::cout << "El punto más cercano es: (" << minIt->x << ", " << minIt->y << ")" << std::endl;

    return 0;
}
<---Ejemplo con Comparación Personalizada Result--->
<---Ejemplo Básico con un Rango de Elementos--->
```cpp
#include <iostream>
#include <vector>
#include <algorithm>

int main() {
    std::vector<int> vec = {1, 2, 3, 4, 5};

    // Encontrar el elemento máximo
    auto maxIt = std::max_element(vec.begin(), vec.end());
    std::cout << "El elemento máximo es: " << *maxIt << std::endl;

    // Encontrar el elemento mínimo
    auto minIt = std::min_element(vec.begin(), vec.end());
    std::cout << "El elemento mínimo es: " << *minIt << std::endl;

    return 0;
}
<---Ejemplo Básico con un Rango de Elementos Result--->
<---Sintaxis--->
```cpp
#include <algorithm>

template <class InputIt, class UnaryPredicate>
InputIt find_if(InputIt first, InputIt last, UnaryPredicate p);
<---Sintaxis Result--->
<---Ejemplo de Uso de `std::find`--->
```cpp
#include <iostream>
#include <vector>
#include <algorithm>

int main() {
    std::vector<int> vec = {1, 2, 3, 4, 5};

    // Buscar el valor 3
    auto it = std::find(vec.begin(), vec.end(), 3);

    if (it != vec.end()) {
        std::cout << "Elemento encontrado: " << *it << std::endl;
    } else {
        std::cout << "Elemento no encontrado" << std::endl;
    }

    return 0;
}
<---Ejemplo de Uso de `std::find` Result--->
<---Ejemplo de Uso de `std::find_if`--->
```cpp
#include <iostream>
#include <vector>
#include <algorithm>

bool esImpar(int n) {
    return n % 2 != 0;
}

int main() {
    std::vector<int> vec = {2, 4, 6, 7, 8};

    // Buscar el primer elemento impar
    auto it = std::find_if(vec.begin(), vec.end(), esImpar);

    if (it != vec.end()) {
        std::cout << "Primer elemento impar encontrado: " << *it << std::endl;
    } else {
        std::cout << "Elemento impar no encontrado" << std::endl;
    }

    return 0;
}
<---Ejemplo de Uso de `std::find_if` Result--->
<---Ejemplo de Uso de `std::find_if` con Lambda--->
```cpp
#include <iostream>
#include <vector>
#include <algorithm>

int main() {
    std::vector<int> vec = {2, 4, 6, 7, 8};

    // Usar una lambda para buscar el primer elemento impar
    auto it = std::find_if(vec.begin(), vec.end(), [](int n) {
        return n % 2 != 0;
    });

    if (it != vec.end()) {
        std::cout << "Primer elemento impar encontrado: " << *it << std::endl;
    } else {
        std::cout << "Elemento impar no encontrado" << std::endl;
    }

    return 0;
}
```cpp
#include <iostream>
#include <vector>
#include <algorithm>

struct Punto {
    int x, y;

    bool operator==(const Punto& otro) const {
        return x == otro.x && y == otro.y;
    }
};

int main() {
    std::vector<Punto> puntos = {{1, 2}, {3, 4}, {5, 6}, {7, 8}};
    Punto puntoABuscar = {5, 6};

    // Buscar el punto {5, 6}
    auto it = std::find(puntos.begin(), puntos.end(), puntoABuscar);

    if (it != puntos.end()) {
        std::cout << "Punto encontrado: (" << it->x << ", " << it->y << ")" << std::endl;
    } else {
        std::cout << "Punto no encontrado" << std::endl;
    }

    return 0;
}
```cpp
#include <iostream>
#include <vector>
#include <algorithm>

int main() {
    std::vector<int> vec = {2, 4, 6, 7, 8};

    // Usar una lambda para buscar el primer elemento mayor que 5
    auto it = std::find_if(vec.begin(), vec.end(), [](int n) {
        return n > 5;
    });

    if (it != vec.end()) {
        std::cout << "Primer elemento mayor que 5 encontrado: " << *it << std::endl;
    } else {
        std::cout << "Elemento mayor que 5 no encontrado" << std::endl;
    }

    return 0;
}
<---Ejemplo de Uso de `std::find_if` con Lambda Result--->
<---Copiar Elementos entre Diferentes Contenedores--->
```cpp
#include <iostream>
#include <vector>
#include <list>
#include <algorithm>

int main() {
    std::vector<int> origen = {1, 2, 3, 4, 5};
    std::list<int> destino(origen.size());

    // Usar std::copy para copiar los elementos
    std::copy(origen.begin(), origen.end(), destino.begin());

    // Mostrar los elementos copiados
    std::cout << "Elementos copiados a la lista destino: ";
    for (int elem : destino) {
        std::cout << elem << " ";
    }
    std::cout << std::endl;

    return 0;
}
```cpp
#include <iostream>
#include <vector>
#include <algorithm>

int main() {
    std::vector<int> origen = {1, 2, 3, 4, 5};
    std::vector<int> destino(3);

    // Usar std::copy para copiar los primeros 3 elementos
    std::copy(origen.begin(), origen.begin() + 3, destino.begin());

    // Mostrar los elementos copiados
    std::cout << "Primeros 3 elementos copiados al vector destino: ";
    for (int elem : destino) {
        std::cout << elem << " ";
    }
    std::cout << std::endl;

    return 0;
}
```cpp
#include <iostream>
#include <vector>
#include <algorithm>
#include <iterator>

int main() {
    std::vector<int> origen = {1, 2, 3, 4, 5};
    std::vector<int> destino;

    // Usar std::copy con std::back_inserter
    std::copy(origen.begin(), origen.end(), std::back_inserter(destino));

    // Mostrar los elementos copiados
    std::cout << "Elementos copiados al vector destino con back_inserter: ";
    for (int elem : destino) {
        std::cout << elem << " ";
    }
    std::cout << std::endl;

    return 0;
}
<---Copiar Elementos entre Diferentes Contenedores Result--->
<---Ejemplo Básico (Orden Ascendente)--->
```cpp
#include <iostream>
#include <vector>
#include <algorithm>

int main() {
    std::vector<int> vec = {5, 2, 9, 1, 5, 6};

    // Usar std::sort para ordenar los elementos en orden ascendente
    std::sort(vec.begin(), vec.end());

    // Mostrar los elementos ordenados
    std::cout << "Elementos ordenados: ";
    for (int elem : vec) {
        std::cout << elem << " ";
    }
    std::cout << std::endl;

    return 0;
}
<---Ejemplo Básico (Orden Ascendente) Result--->
<---Ejemplo con Comparación Personalizada (Orden Descendente)--->
```cpp
#include <iostream>
#include <vector>
#include <algorithm>

int main() {
    std::vector<int> vec = {5, 2, 9, 1, 5, 6};

    // Usar std::sort con una función de comparación para ordenar en orden descendente
    std::sort(vec.begin(), vec.end(), std::greater<int>());

    // Mostrar los elementos ordenados
    std::cout << "Elementos ordenados en orden descendente: ";
    for (int elem : vec) {
        std::cout << elem << " ";
    }
    std::cout << std::endl;

    return 0;
}
<---Ejemplo con Comparación Personalizada (Orden Descendente) Result--->
<---Ordenar un `std::array`--->
```cpp
#include <iostream>
#include <array>
#include <algorithm>

int main() {
    std::array<int, 6> arr = {5, 2, 9, 1, 5, 6};

    // Usar std::sort para ordenar los elementos del array
    std::sort(arr.begin(), arr.end());

    // Mostrar los elementos ordenados
    std::cout << "Elementos del array ordenados: ";
    for (int elem : arr) {
        std::cout << elem << " ";
    }
    std::cout << std::endl;

    return 0;
}
<---Ordenar un `std::array` Result--->
<---Ejemplo Básico (Función Unaria)--->
```cpp
#include <iostream>
#include <vector>
#include <algorithm>

int main() {
    std::vector<int> origen = {1, 2, 3, 4, 5};
    std::vector<int> destino(origen.size());

    // Usar std::transform para duplicar cada elemento
    std::transform(origen.begin(), origen.end(), destino.begin(), [](int x) {
        return x * 2;
    });

    // Mostrar los elementos transformados
    std::cout << "Elementos transformados (duplicados): ";
    for (int elem : destino) {
        std::cout << elem << " ";
    }
    std::cout << std::endl;

    return 0;
}
<---Ejemplo Básico (Función Unaria) Result--->
<---Ejemplo con Función Binaria--->
```cpp
#include <iostream>
#include <vector>
#include <algorithm>

int main() {
    std::vector<int> vec1 = {1, 2, 3, 4, 5};
    std::vector<int> vec2 = {10, 20, 30, 40, 50};
    std::vector<int> resultado(vec1.size());

    // Usar std::transform para sumar elementos de dos vectores
    std::transform(vec1.begin(), vec1.end(), vec2.begin(), resultado.begin(), [](int x, int y) {
        return x + y;
    });

    // Mostrar los elementos transformados
    std::cout << "Elementos transformados (suma de vec1 y vec2): ";
    for (int elem : resultado) {
        std::cout << elem << " ";
    }
    std::cout << std::endl;

    return 0;
}
<---Ejemplo con Función Binaria Result--->
<---Transformar una Lista--->
```cpp
#include <iostream>
#include <list>
#include <algorithm>

int main() {
    std::list<int> origen = {1, 2, 3, 4, 5};
    std::list<int> destino(origen.size());

    // Usar std::transform para incrementar cada elemento
    std::transform(origen.begin(), origen.end(), destino.begin(), [](int x) {
        return x + 1;
    });

    // Mostrar los elementos transformados
    std::cout << "Elementos transformados (incrementados): ";
    for (int elem : destino) {
        std::cout << elem << " ";
    }
    std::cout << std::endl;

    return 0;
}
<---Transformar una Lista Result--->
<---Ejemplo con `std::array`--->
```cpp
#include <iostream>
#include <array>
#include <algorithm>

int main() {
    std::array<int, 5> arr;

    // Usar std::fill para asignar el valor 10 a todos los elementos del array
    std::fill(arr.begin(), arr.end(), 10);

    // Mostrar los elementos del array
    std::cout << "Elementos del array después de std::fill: ";
    for (int elem : arr) {
        std::cout << elem << " ";
    }
    std::cout << std::endl;

    return 0;
}
<---Ejemplo con `std::array` Result--->
<---Ejemplo con una Matriz--->
```cpp
#include <iostream>
#include <vector>
#include <algorithm>

int main() {
    std::vector<std::vector<int>> matrix(3, std::vector<int>(4));

    // Usar std::fill para asignar el valor 0 a todos los elementos de la matriz
    for (auto& row : matrix) {
        std::fill(row.begin(), row.end(), 0);
    }

    // Mostrar los elementos de la matriz
    std::cout << "Elementos de la matriz después de std::fill: " << std::endl;
    for (const auto& row : matrix) {
        for (int elem : row) {
            std::cout << elem << " ";
        }
        std::cout << std::endl;
    }

    return 0;
}
<---Ejemplo con una Matriz Result--->
<---Ejemplo de Rango Parcial--->
```cpp
#include <iostream>
#include <vector>
#include <algorithm>

int main() {
    std::vector<int> vec(10);

    // Asignar el valor 1 a la primera mitad del vector
    std::fill(vec.begin(), vec.begin() + vec.size() / 2, 1);

    // Asignar el valor 2 a la segunda mitad del vector
    std::fill(vec.begin() + vec.size() / 2, vec.end(), 2);

    // Mostrar los elementos del vector
    std::cout << "Elementos del vector después de std::fill en rangos parciales: ";
    for (int elem : vec) {
        std::cout << elem << " ";
    }
    std::cout << std::endl;

    return 0;
}
<---Ejemplo de Rango Parcial Result--->
<---Ejemplo con `std::list`--->
```cpp
#include <iostream>
#include <list>
#include <algorithm>

int main() {
    std::list<int> lst = {1, 2, 3, 2, 5, 2};

    // Usar std::replace para reemplazar todos los 2 por 9
    std::replace(lst.begin(), lst.end(), 2, 9);

    // Mostrar los elementos modificados
    std::cout << "Elementos de la lista después de std::replace: ";
    for (int elem : lst) {
        std::cout << elem << " ";
    }
    std::cout << std::endl;

    return 0;
}
```cpp
#include <iostream>
#include <vector>
#include <algorithm>

int main() {
    std::vector<int> vec = {1, 2, 3, 2, 5, 2};

    // Usar std::replace para reemplazar todos los 2 por 9 en la primera mitad del vector
    std::replace(vec.begin(), vec.begin() + vec.size() / 2, 2, 9);

    // Mostrar los elementos modificados
    std::cout << "Elementos del vector después de std::replace en la primera mitad: ";
    for (int elem : vec) {
        std::cout << elem << " ";
    }
    std::cout << std::endl;

    return 0;
}
```cpp
#include <algorithm>

template <class ForwardIt, class UnaryPredicate, class T>
void replace_if(ForwardIt first, ForwardIt last, UnaryPredicate p, const T& new_value);
<---Ejemplo con `std::list` Result--->
<---Ejemplo Básico con `std::replace_if`--->
```cpp
#include <iostream>
#include <vector>
#include <algorithm>

bool esPar(int n) {
    return n % 2 == 0;
}

int main() {
    std::vector<int> vec = {1, 2, 3, 4, 5, 6};

    // Usar std::replace_if para reemplazar todos los números pares por 0
    std::replace_if(vec.begin(), vec.end(), esPar, 0);

    // Mostrar los elementos modificados
    std::cout << "Elementos del vector después de std::replace_if: ";
    for (int elem : vec) {
        std::cout << elem << " ";
    }
    std::cout << std::endl;

    return 0;
}
<---Ejemplo Básico con `std::replace_if` Result--->
<---Ejemplo Básico--->
```cpp
#include <iostream>
#include <vector>
#include <algorithm>

int main() {
    std::vector<int> vec = {1, 2, 3, 2, 5, 2};

    // Usar std::remove para mover los elementos que no son 2 al principio
    auto it = std::remove(vec.begin(), vec.end(), 2);

    // Eliminar físicamente los elementos después del nuevo final lógico
    vec.erase(it, vec.end());

    // Mostrar los elementos restantes
    std::cout << "Elementos del vector después de std::remove y erase: ";
    for (int elem : vec) {
        std::cout << elem << " ";
    }
    std::cout << std::endl;

    return 0;
}
<---Ejemplo Básico Result--->
<---Ejemplo con Lambda--->
```cpp
#include <iostream>
#include <vector>
#include <algorithm>

int main() {
    std::vector<int> vec = {1, 2, 3, 4, 5, 6};

    // Usar std::remove_if con una lambda para mover los números mayores que 3 al final
    auto it = std::remove_if(vec.begin(), vec.end(), [](int n) { return n > 3; });

    // Eliminar físicamente los elementos después del nuevo final lógico
    vec.erase(it, vec.end());

    // Mostrar los elementos restantes
    std::cout << "Elementos del vector después de std::remove_if y erase: ";
    for (int elem : vec) {
        std::cout << elem << " ";
    }
    std::cout << std::endl;

    return 0;
}
<---Ejemplo con Lambda Result--->
<---Ejemplo Básico (Suma)--->
```cpp
#include <iostream>
#include <vector>
#include <numeric>

int main() {
    std::vector<int> vec = {1, 2, 3, 4, 5};

    // Usar std::accumulate para sumar todos los elementos
    int suma = std::accumulate(vec.begin(), vec.end(), 0);

    std::cout << "La suma de los elementos es: " << suma << std::endl;

    return 0;
}
<---Ejemplo Básico (Suma) Result--->
<---Ejemplo con Operación Binaria Personalizada (Multiplicación)--->
```cpp
#include <iostream>
#include <vector>
#include <numeric>

int main() {
    std::vector<int> vec = {1, 2, 3, 4, 5};

    // Usar std::accumulate para multiplicar todos los elementos
    int producto = std::accumulate(vec.begin(), vec.end(), 1, std::multiplies<int>());

    std::cout << "El producto de los elementos es: " << producto << std::endl;

    return 0;
}
```cpp
#include <iostream>
#include <vector>
#include <numeric>
#include <string>

int main() {
    std::vector<std::string> vec = {"Hola", " ", "mundo", "!"};

    // Usar std::accumulate para concatenar todas las cadenas
    std::string resultado = std::accumulate(vec.begin(), vec.end(), std::string(""));

    std::cout << "Cadena concatenada: " << resultado << std::endl;

    return 0;
}
```cpp
#include <iostream>
#include <vector>
#include <numeric>

int main() {
    std::vector<int> vec = {1, 2, 3, 4, 5};

    // Calcular la suma de los elementos
    int suma = std::accumulate(vec.begin(), vec.end(), 0);

    // Calcular la media
    double media = static_cast<double>(suma) / vec.size();

    std::cout << "La media de los elementos es: " << media << std::endl;

    return 0;
}
<---Ejemplo con Operación Binaria Personalizada (Multiplicación) Result--->
<---`std::max`--->
```cpp
#include <algorithm>

template <class T>
const T& max(const T& a, const T& b);

template <class T, class Compare>
const T& max(const T& a, const T& b, Compare comp);

template <class ForwardIt>
ForwardIt max_element(ForwardIt first, ForwardIt last);

template <class ForwardIt, class Compare>
ForwardIt max_element(ForwardIt first, ForwardIt last, Compare comp);
<---`std::max` Result--->
<---`std::min`--->
```cpp
#include <algorithm>

template <class T>
const T& min(const T& a, const T& b);

template <class T, class Compare>
const T& min(const T& a, const T& b, Compare comp);

template <class ForwardIt>
ForwardIt min_element(ForwardIt first, ForwardIt last);

template <class ForwardIt, class Compare>
ForwardIt min_element(ForwardIt first, ForwardIt last, Compare comp);
<---`std::min` Result--->
<---Ejemplo Básico con Dos Valores--->
```cpp
#include <iostream>
#include <algorithm>

int main() {
    int a = 10, b = 20;

    // Encontrar el valor máximo
    int maxVal = std::max(a, b);
    std::cout << "El mayor de " << a << " y " << b << " es " << maxVal << std::endl;

    // Encontrar el valor mínimo
    int minVal = std::min(a, b);
    std::cout << "El menor de " << a << " y " << b << " es " << minVal << std::endl;

    return 0;
}
<---Ejemplo Básico con Dos Valores Result--->
<---Ejemplo con Comparación Personalizada--->
```cpp
#include <iostream>
#include <vector>
#include <algorithm>

struct Punto {
    int x, y;
};

bool compararPorDistancia(const Punto& p1, const Punto& p2) {
    return (p1.x * p1.x + p1.y * p1.y) < (p2.x * p2.x + p2.y * p2.y);
}

int main() {
    std::vector<Punto> puntos = {{1, 2}, {3, 4}, {0, 5}, {-1, -1}};

    // Encontrar el punto más lejano del origen
    auto maxIt = std::max_element(puntos.begin(), puntos.end(), compararPorDistancia);
    std::cout << "El punto más lejano es: (" << maxIt->x << ", " << maxIt->y << ")" << std::endl;

    // Encontrar el punto más cercano al origen
    auto minIt = std::min_element(puntos.begin(), puntos.end(), compararPorDistancia);
    std::cout << "El punto más cercano es: (" << minIt->x << ", " << minIt->y << ")" << std::endl;

    return 0;
}
<---Ejemplo con Comparación Personalizada Result--->
<---Ejemplo Básico con un Rango de Elementos--->
```cpp
#include <iostream>
#include <vector>
#include <algorithm>

int main() {
    std::vector<int> vec = {1, 2, 3, 4, 5};

    // Encontrar el elemento máximo
    auto maxIt = std::max_element(vec.begin(), vec.end());
    std::cout << "El elemento máximo es: " << *maxIt << std::endl;

    // Encontrar el elemento mínimo
    auto minIt = std::min_element(vec.begin(), vec.end());
    std::cout << "El elemento mínimo es: " << *minIt << std::endl;

    return 0;
}
<---Ejemplo Básico con un Rango de Elementos Result--->
<---Sintaxis--->
```cpp
#include <algorithm>

template <class InputIt, class UnaryPredicate>
InputIt find_if(InputIt first, InputIt last, UnaryPredicate p);
<---Sintaxis Result--->
<---Ejemplo de Uso de `std::find`--->
```cpp
#include <iostream>
#include <vector>
#include <algorithm>

int main() {
    std::vector<int> vec = {1, 2, 3, 4, 5};

    // Buscar el valor 3
    auto it = std::find(vec.begin(), vec.end(), 3);

    if (it != vec.end()) {
        std::cout << "Elemento encontrado: " << *it << std::endl;
    } else {
        std::cout << "Elemento no encontrado" << std::endl;
    }

    return 0;
}
<---Ejemplo de Uso de `std::find` Result--->
<---Ejemplo de Uso de `std::find_if`--->
```cpp
#include <iostream>
#include <vector>
#include <algorithm>

bool esImpar(int n) {
    return n % 2 != 0;
}

int main() {
    std::vector<int> vec = {2, 4, 6, 7, 8};

    // Buscar el primer elemento impar
    auto it = std::find_if(vec.begin(), vec.end(), esImpar);

    if (it != vec.end()) {
        std::cout << "Primer elemento impar encontrado: " << *it << std::endl;
    } else {
        std::cout << "Elemento impar no encontrado" << std::endl;
    }

    return 0;
}
<---Ejemplo de Uso de `std::find_if` Result--->
<---Ejemplo de Uso de `std::find_if` con Lambda--->
```cpp
#include <iostream>
#include <vector>
#include <algorithm>

int main() {
    std::vector<int> vec = {2, 4, 6, 7, 8};

    // Usar una lambda para buscar el primer elemento impar
    auto it = std::find_if(vec.begin(), vec.end(), [](int n) {
        return n % 2 != 0;
    });

    if (it != vec.end()) {
        std::cout << "Primer elemento impar encontrado: " << *it << std::endl;
    } else {
        std::cout << "Elemento impar no encontrado" << std::endl;
    }

    return 0;
}
```cpp
#include <iostream>
#include <vector>
#include <algorithm>

struct Punto {
    int x, y;

    bool operator==(const Punto& otro) const {
        return x == otro.x && y == otro.y;
    }
};

int main() {
    std::vector<Punto> puntos = {{1, 2}, {3, 4}, {5, 6}, {7, 8}};
    Punto puntoABuscar = {5, 6};

    // Buscar el punto {5, 6}
    auto it = std::find(puntos.begin(), puntos.end(), puntoABuscar);

    if (it != puntos.end()) {
        std::cout << "Punto encontrado: (" << it->x << ", " << it->y << ")" << std::endl;
    } else {
        std::cout << "Punto no encontrado" << std::endl;
    }

    return 0;
}
```cpp
#include <iostream>
#include <vector>
#include <algorithm>

int main() {
    std::vector<int> vec = {2, 4, 6, 7, 8};

    // Usar una lambda para buscar el primer elemento mayor que 5
    auto it = std::find_if(vec.begin(), vec.end(), [](int n) {
        return n > 5;
    });

    if (it != vec.end()) {
        std::cout << "Primer elemento mayor que 5 encontrado: " << *it << std::endl;
    } else {
        std::cout << "Elemento mayor que 5 no encontrado" << std::endl;
    }

    return 0;
}
<---Ejemplo de Uso de `std::find_if` con Lambda Result--->
<---Copiar Elementos entre Diferentes Contenedores--->
```cpp
#include <iostream>
#include <vector>
#include <list>
#include <algorithm>

int main() {
    std::vector<int> origen = {1, 2, 3, 4, 5};
    std::list<int> destino(origen.size());

    // Usar std::copy para copiar los elementos
    std::copy(origen.begin(), origen.end(), destino.begin());

    // Mostrar los elementos copiados
    std::cout << "Elementos copiados a la lista destino: ";
    for (int elem : destino) {
        std::cout << elem << " ";
    }
    std::cout << std::endl;

    return 0;
}
```cpp
#include <iostream>
#include <vector>
#include <algorithm>

int main() {
    std::vector<int> origen = {1, 2, 3, 4, 5};
    std::vector<int> destino(3);

    // Usar std::copy para copiar los primeros 3 elementos
    std::copy(origen.begin(), origen.begin() + 3, destino.begin());

    // Mostrar los elementos copiados
    std::cout << "Primeros 3 elementos copiados al vector destino: ";
    for (int elem : destino) {
        std::cout << elem << " ";
    }
    std::cout << std::endl;

    return 0;
}
```cpp
#include <iostream>
#include <vector>
#include <algorithm>
#include <iterator>

int main() {
    std::vector<int> origen = {1, 2, 3, 4, 5};
    std::vector<int> destino;

    // Usar std::copy con std::back_inserter
    std::copy(origen.begin(), origen.end(), std::back_inserter(destino));

    // Mostrar los elementos copiados
    std::cout << "Elementos copiados al vector destino con back_inserter: ";
    for (int elem : destino) {
        std::cout << elem << " ";
    }
    std::cout << std::endl;

    return 0;
}
<---Copiar Elementos entre Diferentes Contenedores Result--->
<---Ejemplo Básico (Orden Ascendente)--->
```cpp
#include <iostream>
#include <vector>
#include <algorithm>

int main() {
    std::vector<int> vec = {5, 2, 9, 1, 5, 6};

    // Usar std::sort para ordenar los elementos en orden ascendente
    std::sort(vec.begin(), vec.end());

    // Mostrar los elementos ordenados
    std::cout << "Elementos ordenados: ";
    for (int elem : vec) {
        std::cout << elem << " ";
    }
    std::cout << std::endl;

    return 0;
}
<---Ejemplo Básico (Orden Ascendente) Result--->
<---Ejemplo con Comparación Personalizada (Orden Descendente)--->
```cpp
#include <iostream>
#include <vector>
#include <algorithm>

int main() {
    std::vector<int> vec = {5, 2, 9, 1, 5, 6};

    // Usar std::sort con una función de comparación para ordenar en orden descendente
    std::sort(vec.begin(), vec.end(), std::greater<int>());

    // Mostrar los elementos ordenados
    std::cout << "Elementos ordenados en orden descendente: ";
    for (int elem : vec) {
        std::cout << elem << " ";
    }
    std::cout << std::endl;

    return 0;
}
<---Ejemplo con Comparación Personalizada (Orden Descendente) Result--->
<---Ordenar un `std::array`--->
```cpp
#include <iostream>
#include <array>
#include <algorithm>

int main() {
    std::array<int, 6> arr = {5, 2, 9, 1, 5, 6};

    // Usar std::sort para ordenar los elementos del array
    std::sort(arr.begin(), arr.end());

    // Mostrar los elementos ordenados
    std::cout << "Elementos del array ordenados: ";
    for (int elem : arr) {
        std::cout << elem << " ";
    }
    std::cout << std::endl;

    return 0;
}
<---Ordenar un `std::array` Result--->
<---Ejemplo Básico (Función Unaria)--->
```cpp
#include <iostream>
#include <vector>
#include <algorithm>

int main() {
    std::vector<int> origen = {1, 2, 3, 4, 5};
    std::vector<int> destino(origen.size());

    // Usar std::transform para duplicar cada elemento
    std::transform(origen.begin(), origen.end(), destino.begin(), [](int x) {
        return x * 2;
    });

    // Mostrar los elementos transformados
    std::cout << "Elementos transformados (duplicados): ";
    for (int elem : destino) {
        std::cout << elem << " ";
    }
    std::cout << std::endl;

    return 0;
}
<---Ejemplo Básico (Función Unaria) Result--->
<---Ejemplo con Función Binaria--->
```cpp
#include <iostream>
#include <vector>
#include <algorithm>

int main() {
    std::vector<int> vec1 = {1, 2, 3, 4, 5};
    std::vector<int> vec2 = {10, 20, 30, 40, 50};
    std::vector<int> resultado(vec1.size());

    // Usar std::transform para sumar elementos de dos vectores
    std::transform(vec1.begin(), vec1.end(), vec2.begin(), resultado.begin(), [](int x, int y) {
        return x + y;
    });

    // Mostrar los elementos transformados
    std::cout << "Elementos transformados (suma de vec1 y vec2): ";
    for (int elem : resultado) {
        std::cout << elem << " ";
    }
    std::cout << std::endl;

    return 0;
}
<---Ejemplo con Función Binaria Result--->
<---Transformar una Lista--->
```cpp
#include <iostream>
#include <list>
#include <algorithm>

int main() {
    std::list<int> origen = {1, 2, 3, 4, 5};
    std::list<int> destino(origen.size());

    // Usar std::transform para incrementar cada elemento
    std::transform(origen.begin(), origen.end(), destino.begin(), [](int x) {
        return x + 1;
    });

    // Mostrar los elementos transformados
    std::cout << "Elementos transformados (incrementados): ";
    for (int elem : destino) {
        std::cout << elem << " ";
    }
    std::cout << std::endl;

    return 0;
}
<---Transformar una Lista Result--->
<---Ejemplo con `std::array`--->
```cpp
#include <iostream>
#include <array>
#include <algorithm>

int main() {
    std::array<int, 5> arr;

    // Usar std::fill para asignar el valor 10 a todos los elementos del array
    std::fill(arr.begin(), arr.end(), 10);

    // Mostrar los elementos del array
    std::cout << "Elementos del array después de std::fill: ";
    for (int elem : arr) {
        std::cout << elem << " ";
    }
    std::cout << std::endl;

    return 0;
}
<---Ejemplo con `std::array` Result--->
<---Ejemplo con una Matriz--->
```cpp
#include <iostream>
#include <vector>
#include <algorithm>

int main() {
    std::vector<std::vector<int>> matrix(3, std::vector<int>(4));

    // Usar std::fill para asignar el valor 0 a todos los elementos de la matriz
    for (auto& row : matrix) {
        std::fill(row.begin(), row.end(), 0);
    }

    // Mostrar los elementos de la matriz
    std::cout << "Elementos de la matriz después de std::fill: " << std::endl;
    for (const auto& row : matrix) {
        for (int elem : row) {
            std::cout << elem << " ";
        }
        std::cout << std::endl;
    }

    return 0;
}
<---Ejemplo con una Matriz Result--->
<---Ejemplo de Rango Parcial--->
```cpp
#include <iostream>
#include <vector>
#include <algorithm>

int main() {
    std::vector<int> vec(10);

    // Asignar el valor 1 a la primera mitad del vector
    std::fill(vec.begin(), vec.begin() + vec.size() / 2, 1);

    // Asignar el valor 2 a la segunda mitad del vector
    std::fill(vec.begin() + vec.size() / 2, vec.end(), 2);

    // Mostrar los elementos del vector
    std::cout << "Elementos del vector después de std::fill en rangos parciales: ";
    for (int elem : vec) {
        std::cout << elem << " ";
    }
    std::cout << std::endl;

    return 0;
}
<---Ejemplo de Rango Parcial Result--->
<---Ejemplo con `std::list`--->
```cpp
#include <iostream>
#include <list>
#include <algorithm>

int main() {
    std::list<int> lst = {1, 2, 3, 2, 5, 2};

    // Usar std::remove para mover los elementos que no son 2 al principio
    auto it = std::remove(lst.begin(), lst.end(), 2);

    // Eliminar físicamente los elementos después del nuevo final lógico
    lst.erase(it, lst.end());

    // Mostrar los elementos restantes
    std::cout << "Elementos de la lista después de std::remove y erase: ";
    for (int elem : lst) {
        std::cout << elem << " ";
    }
    std::cout << std::endl;

    return 0;
}
```cpp
#include <algorithm>

template <class ForwardIt, class UnaryPredicate>
ForwardIt remove_if(ForwardIt first, ForwardIt last, UnaryPredicate p);
<---Ejemplo con `std::list` Result--->
<---Ejemplo Básico con `std::replace_if`--->
```cpp
#include <iostream>
#include <vector>
#include <algorithm>

bool esPar(int n) {
    return n % 2 == 0;
}

int main() {
    std::vector<int> vec = {1, 2, 3, 4, 5, 6};

    // Usar std::replace_if para reemplazar todos los números pares por 0
    std::replace_if(vec.begin(), vec.end(), esPar, 0);

    // Mostrar los elementos modificados
    std::cout << "Elementos del vector después de std::replace_if: ";
    for (int elem : vec) {
        std::cout << elem << " ";
    }
    std::cout << std::endl;

    return 0;
}
<---Ejemplo Básico con `std::replace_if` Result--->
<---Ejemplo Básico con `std::remove_if`--->
```cpp
#include <iostream>
#include <vector>
#include <algorithm>

bool esPar(int n) {
    return n % 2 == 0;
}

int main() {
    std::vector<int> vec = {1, 2, 3, 4, 5, 6};

    // Usar std::remove_if para mover los números pares al final
    auto it = std::remove_if(vec.begin(), vec.end(), esPar);

    // Eliminar físicamente los elementos después del nuevo final lógico
    vec.erase(it, vec.end());

    // Mostrar los elementos restantes
    std::cout << "Elementos del vector después de std::remove_if y erase: ";
    for (int elem : vec) {
        std::cout << elem << " ";
    }
    std::cout << std::endl;

    return 0;
}
<---Ejemplo Básico con `std::remove_if` Result--->
