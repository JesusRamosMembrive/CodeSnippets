<---EXPLANATION--->
### Algoritmos de la Biblioteca Estándar: `std::all_of`

La función `std::all_of` es un algoritmo de la biblioteca estándar de C++ que se utiliza para verificar si todos los elementos en un rango satisfacen una determinada condición. Es parte del encabezado `<algorithm>` y es muy útil para realizar verificaciones globales sobre los elementos de contenedores como vectores, listas, arrays, etc.

#### Sintaxis de `std::all_of`

```cpp
#include <algorithm>

template <class InputIt, class UnaryPredicate>
bool all_of(InputIt first, InputIt last, UnaryPredicate p);
```

- **`InputIt first`**: Iterador al primer elemento del rango.
- **`InputIt last`**: Iterador al elemento después del último en el rango.
- **`UnaryPredicate p`**: Una función o función objeto que toma un elemento del rango y devuelve un valor convertible a `bool`.

#### Descripción

`std::all_of` aplica el predicado `p` a todos los elementos en el rango `[first, last)` y devuelve `true` si el predicado devuelve `true` para todos los elementos. De lo contrario, devuelve `false`.

#### Ejemplo de Uso de `std::all_of`

##### Ejemplo Básico

```cpp
#include <iostream>
#include <vector>
#include <algorithm>

bool esPositivo(int n) {
    return n > 0;
}

int main() {
    std::vector<int> vec = {1, 2, 3, 4, 5};

    // Verificar si todos los elementos son positivos
    bool todosPositivos = std::all_of(vec.begin(), vec.end(), esPositivo);

    if (todosPositivos) {
        std::cout << "Todos los elementos son positivos." << std::endl;
    } else {
        std::cout << "No todos los elementos son positivos." << std::endl;
    }

    return 0;
}
```

En este ejemplo:
- `esPositivo` es una función que verifica si un número es mayor que cero.
- `std::all_of(vec.begin(), vec.end(), esPositivo)` verifica si todos los elementos del vector son positivos.

##### Ejemplo con Lambda

```cpp
#include <iostream>
#include <vector>
#include <algorithm>

int main() {
    std::vector<int> vec = {1, 2, 3, 4, 5};

    // Usar una lambda para verificar si todos los elementos son positivos
    bool todosPositivos = std::all_of(vec.begin(), vec.end(), [](int n) {
        return n > 0;
    });

    if (todosPositivos) {
        std::cout << "Todos los elementos son positivos." << std::endl;
    } else {
        std::cout << "No todos los elementos son positivos." << std::endl;
    }

    return 0;
}
```

En este ejemplo:
- Se usa una expresión lambda para definir el predicado en línea.

### Más Ejemplos

#### Verificar si Todos los Elementos son Pares

```cpp
#include <iostream>
#include <vector>
#include <algorithm>

int main() {
    std::vector<int> vec = {2, 4, 6, 8, 10};

    // Usar una lambda para verificar si todos los elementos son pares
    bool todosPares = std::all_of(vec.begin(), vec.end(), [](int n) {
        return n % 2 == 0;
    });

    if (todosPares) {
        std::cout << "Todos los elementos son pares." << std::endl;
    } else {
        std::cout << "No todos los elementos son pares." << std::endl;
    }

    return 0;
}
```

#### Verificar si Todos los Elementos Están en un Rango

```cpp
#include <iostream>
#include <vector>
#include <algorithm>

int main() {
    std::vector<int> vec = {5, 6, 7, 8, 9};

    // Usar una lambda para verificar si todos los elementos están en el rango [5, 10]
    bool enRango = std::all_of(vec.begin(), vec.end(), [](int n) {
        return n >= 5 && n <= 10;
    });

    if (enRango) {
        std::cout << "Todos los elementos están en el rango [5, 10]." << std::endl;
    } else {
        std::cout << "No todos los elementos están en el rango [5, 10]." << std::endl;
    }

    return 0;
}
```

### Consideraciones

- **Rendimiento:** `std::all_of` detiene la evaluación tan pronto como encuentra el primer elemento que no satisface el predicado, lo que puede mejorar el rendimiento en comparación con un bucle que siempre recorre todos los elementos.
- **Uso con Diferentes Contenedores:** Funciona con cualquier contenedor que soporte iteradores, como `std::vector`, `std::list`, `std::array`, etc.

### Conclusión

`std::all_of` es una función útil y poderosa de la biblioteca estándar de C++ que permite verificar de manera eficiente si todos los elementos en un rango cumplen con una condición específica. Su uso con funciones, funtores y lambdas proporciona una gran flexibilidad y es esencial para escribir código conciso y claro en C++.
### Algoritmo de la Biblioteca Estándar: `std::for_each`

El algoritmo `std::for_each` de la biblioteca estándar de C++ se utiliza para aplicar una función a cada elemento de un rango. Es una herramienta útil para realizar operaciones repetitivas en cada elemento de un contenedor.

#### Sintaxis de `std::for_each`

```cpp
#include <algorithm>

template <class InputIt, class UnaryFunction>
UnaryFunction for_each(InputIt first, InputIt last, UnaryFunction f);
```

- **`InputIt first`**: Iterador al primer elemento del rango.
- **`InputIt last`**: Iterador al elemento después del último en el rango.
- **`UnaryFunction f`**: Una función o función objeto que se aplicará a cada elemento en el rango.

#### Descripción

`std::for_each` aplica la función `f` a cada elemento en el rango `[first, last)`. La función `f` puede ser una función regular, un objeto de función (functor) o una lambda.

#### Ejemplo de Uso de `std::for_each`

##### Ejemplo Básico

```cpp
#include <iostream>
#include <vector>
#include <algorithm>

void imprimir(int n) {
    std::cout << n << " ";
}

int main() {
    std::vector<int> vec = {1, 2, 3, 4, 5};

    // Usar std::for_each para imprimir cada elemento del vector
    std::for_each(vec.begin(), vec.end(), imprimir);
    std::cout << std::endl;

    return 0;
}
```

En este ejemplo:
- `imprimir` es una función que toma un entero y lo imprime.
- `std::for_each(vec.begin(), vec.end(), imprimir)` aplica la función `imprimir` a cada elemento del vector.

##### Ejemplo con Lambda

```cpp
#include <iostream>
#include <vector>
#include <algorithm>

int main() {
    std::vector<int> vec = {1, 2, 3, 4, 5};

    // Usar una lambda para imprimir cada elemento del vector
    std::for_each(vec.begin(), vec.end(), [](int n) {
        std::cout << n << " ";
    });
    std::cout << std::endl;

    return 0;
}
```

En este ejemplo:
- Se usa una expresión lambda para definir la operación de impresión en línea.

### Más Ejemplos

#### Incrementar Cada Elemento de un Contenedor

```cpp
#include <iostream>
#include <vector>
#include <algorithm>

int main() {
    std::vector<int> vec = {1, 2, 3, 4, 5};

    // Usar una lambda para incrementar cada elemento del vector
    std::for_each(vec.begin(), vec.end(), [](int& n) {
        n += 1;
    });

    // Imprimir los elementos incrementados
    std::for_each(vec.begin(), vec.end(), [](int n) {
        std::cout << n << " ";
    });
    std::cout << std::endl;

    return 0;
}
```

En este ejemplo:
- La lambda incrementa cada elemento del vector en 1.
- Luego, se imprime cada elemento del vector utilizando `std::for_each`.

#### Acumular Valores Usando un Functor

```cpp
#include <iostream>
#include <vector>
#include <algorithm>

struct Acumulador {
    int suma = 0;

    void operator()(int n) {
        suma += n;
    }
};

int main() {
    std::vector<int> vec = {1, 2, 3, 4, 5};

    Acumulador acumulador = std::for_each(vec.begin(), vec.end(), Acumulador());

    std::cout << "Suma de los elementos: " << acumulador.suma << std::endl;

    return 0;
}
```

En este ejemplo:
- `Acumulador` es un functor que acumula la suma de los elementos.
- `std::for_each` aplica el functor a cada elemento del vector y devuelve el functor actualizado.

### Consideraciones

- **Rendimiento:** `std::for_each` es eficiente y generalmente se compila a código similar al de un bucle `for` explícito.
- **Modificabilidad:** La función o lambda pasada a `std::for_each` puede modificar los elementos del contenedor si se pasan por referencia.

### Conclusión

`std::for_each` es un algoritmo de la biblioteca estándar de C++ que proporciona una forma conveniente y expresiva de aplicar una operación a cada elemento de un rango. Su uso con funciones, funtores y lambdas ofrece gran flexibilidad, y es una herramienta valiosa para escribir código conciso y claro en C++.
<---FILES--->
Ejemplo Básico
Ejemplo Básico Result
Ejemplo con Lambda
Ejemplo con Lambda Result
Ejemplo Básico
Ejemplo Básico Result
Ejemplo con Lambda
Ejemplo con Lambda Result
<---Ejemplo Básico--->
```cpp
#include <iostream>
#include <vector>
#include <algorithm>

bool esPositivo(int n) {
    return n > 0;
}

int main() {
    std::vector<int> vec = {1, 2, 3, 4, 5};

    // Verificar si todos los elementos son positivos
    bool todosPositivos = std::all_of(vec.begin(), vec.end(), esPositivo);

    if (todosPositivos) {
        std::cout << "Todos los elementos son positivos." << std::endl;
    } else {
        std::cout << "No todos los elementos son positivos." << std::endl;
    }

    return 0;
}
<---Ejemplo Básico Result--->
<---Ejemplo con Lambda--->
```cpp
#include <iostream>
#include <vector>
#include <algorithm>

int main() {
    std::vector<int> vec = {1, 2, 3, 4, 5};

    // Usar una lambda para verificar si todos los elementos son positivos
    bool todosPositivos = std::all_of(vec.begin(), vec.end(), [](int n) {
        return n > 0;
    });

    if (todosPositivos) {
        std::cout << "Todos los elementos son positivos." << std::endl;
    } else {
        std::cout << "No todos los elementos son positivos." << std::endl;
    }

    return 0;
}
```cpp
#include <iostream>
#include <vector>
#include <algorithm>

int main() {
    std::vector<int> vec = {2, 4, 6, 8, 10};

    // Usar una lambda para verificar si todos los elementos son pares
    bool todosPares = std::all_of(vec.begin(), vec.end(), [](int n) {
        return n % 2 == 0;
    });

    if (todosPares) {
        std::cout << "Todos los elementos son pares." << std::endl;
    } else {
        std::cout << "No todos los elementos son pares." << std::endl;
    }

    return 0;
}
```cpp
#include <iostream>
#include <vector>
#include <algorithm>

int main() {
    std::vector<int> vec = {5, 6, 7, 8, 9};

    // Usar una lambda para verificar si todos los elementos están en el rango [5, 10]
    bool enRango = std::all_of(vec.begin(), vec.end(), [](int n) {
        return n >= 5 && n <= 10;
    });

    if (enRango) {
        std::cout << "Todos los elementos están en el rango [5, 10]." << std::endl;
    } else {
        std::cout << "No todos los elementos están en el rango [5, 10]." << std::endl;
    }

    return 0;
}
<---Ejemplo con Lambda Result--->
<---Ejemplo Básico--->
```cpp
#include <iostream>
#include <vector>
#include <algorithm>

void imprimir(int n) {
    std::cout << n << " ";
}

int main() {
    std::vector<int> vec = {1, 2, 3, 4, 5};

    // Usar std::for_each para imprimir cada elemento del vector
    std::for_each(vec.begin(), vec.end(), imprimir);
    std::cout << std::endl;

    return 0;
}
<---Ejemplo Básico Result--->
<---Ejemplo con Lambda--->
```cpp
#include <iostream>
#include <vector>
#include <algorithm>

int main() {
    std::vector<int> vec = {1, 2, 3, 4, 5};

    // Usar una lambda para imprimir cada elemento del vector
    std::for_each(vec.begin(), vec.end(), [](int n) {
        std::cout << n << " ";
    });
    std::cout << std::endl;

    return 0;
}
```cpp
#include <iostream>
#include <vector>
#include <algorithm>

int main() {
    std::vector<int> vec = {1, 2, 3, 4, 5};

    // Usar una lambda para incrementar cada elemento del vector
    std::for_each(vec.begin(), vec.end(), [](int& n) {
        n += 1;
    });

    // Imprimir los elementos incrementados
    std::for_each(vec.begin(), vec.end(), [](int n) {
        std::cout << n << " ";
    });
    std::cout << std::endl;

    return 0;
}
```cpp
#include <iostream>
#include <vector>
#include <algorithm>

struct Acumulador {
    int suma = 0;

    void operator()(int n) {
        suma += n;
    }
};

int main() {
    std::vector<int> vec = {1, 2, 3, 4, 5};

    Acumulador acumulador = std::for_each(vec.begin(), vec.end(), Acumulador());

    std::cout << "Suma de los elementos: " << acumulador.suma << std::endl;

    return 0;
}
<---Ejemplo con Lambda Result--->
