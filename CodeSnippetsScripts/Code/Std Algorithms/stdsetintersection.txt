<---EXPLANATION--->
### Algoritmos de la Biblioteca Estándar: `std::all_of`

La función `std::all_of` es un algoritmo de la biblioteca estándar de C++ que se utiliza para verificar si todos los elementos en un rango satisfacen una determinada condición. Es parte del encabezado `<algorithm>` y es muy útil para realizar verificaciones globales sobre los elementos de contenedores como vectores, listas, arrays, etc.

#### Sintaxis de `std::all_of`

```cpp
#include <algorithm>

template <class InputIt, class UnaryPredicate>
bool all_of(InputIt first, InputIt last, UnaryPredicate p);
```

- **`InputIt first`**: Iterador al primer elemento del rango.
- **`InputIt last`**: Iterador al elemento después del último en el rango.
- **`UnaryPredicate p`**: Una función o función objeto que toma un elemento del rango y devuelve un valor convertible a `bool`.

#### Descripción

`std::all_of` aplica el predicado `p` a todos los elementos en el rango `[first, last)` y devuelve `true` si el predicado devuelve `true` para todos los elementos. De lo contrario, devuelve `false`.

#### Ejemplo de Uso de `std::all_of`

##### Ejemplo Básico

```cpp
#include <iostream>
#include <vector>
#include <algorithm>

bool esPositivo(int n) {
    return n > 0;
}

int main() {
    std::vector<int> vec = {1, 2, 3, 4, 5};

    // Verificar si todos los elementos son positivos
    bool todosPositivos = std::all_of(vec.begin(), vec.end(), esPositivo);

    if (todosPositivos) {
        std::cout << "Todos los elementos son positivos." << std::endl;
    } else {
        std::cout << "No todos los elementos son positivos." << std::endl;
    }

    return 0;
}
```

En este ejemplo:
- `esPositivo` es una función que verifica si un número es mayor que cero.
- `std::all_of(vec.begin(), vec.end(), esPositivo)` verifica si todos los elementos del vector son positivos.

##### Ejemplo con Lambda

```cpp
#include <iostream>
#include <vector>
#include <algorithm>

int main() {
    std::vector<int> vec = {1, 2, 3, 4, 5};

    // Usar una lambda para verificar si todos los elementos son positivos
    bool todosPositivos = std::all_of(vec.begin(), vec.end(), [](int n) {
        return n > 0;
    });

    if (todosPositivos) {
        std::cout << "Todos los elementos son positivos." << std::endl;
    } else {
        std::cout << "No todos los elementos son positivos." << std::endl;
    }

    return 0;
}
```

En este ejemplo:
- Se usa una expresión lambda para definir el predicado en línea.

### Más Ejemplos

#### Verificar si Todos los Elementos son Pares

```cpp
#include <iostream>
#include <vector>
#include <algorithm>

int main() {
    std::vector<int> vec = {2, 4, 6, 8, 10};

    // Usar una lambda para verificar si todos los elementos son pares
    bool todosPares = std::all_of(vec.begin(), vec.end(), [](int n) {
        return n % 2 == 0;
    });

    if (todosPares) {
        std::cout << "Todos los elementos son pares." << std::endl;
    } else {
        std::cout << "No todos los elementos son pares." << std::endl;
    }

    return 0;
}
```

#### Verificar si Todos los Elementos Están en un Rango

```cpp
#include <iostream>
#include <vector>
#include <algorithm>

int main() {
    std::vector<int> vec = {5, 6, 7, 8, 9};

    // Usar una lambda para verificar si todos los elementos están en el rango [5, 10]
    bool enRango = std::all_of(vec.begin(), vec.end(), [](int n) {
        return n >= 5 && n <= 10;
    });

    if (enRango) {
        std::cout << "Todos los elementos están en el rango [5, 10]." << std::endl;
    } else {
        std::cout << "No todos los elementos están en el rango [5, 10]." << std::endl;
    }

    return 0;
}
```

### Consideraciones

- **Rendimiento:** `std::all_of` detiene la evaluación tan pronto como encuentra el primer elemento que no satisface el predicado, lo que puede mejorar el rendimiento en comparación con un bucle que siempre recorre todos los elementos.
- **Uso con Diferentes Contenedores:** Funciona con cualquier contenedor que soporte iteradores, como `std::vector`, `std::list`, `std::array`, etc.

### Conclusión

`std::all_of` es una función útil y poderosa de la biblioteca estándar de C++ que permite verificar de manera eficiente si todos los elementos en un rango cumplen con una condición específica. Su uso con funciones, funtores y lambdas proporciona una gran flexibilidad y es esencial para escribir código conciso y claro en C++.
### Algoritmo de la Biblioteca Estándar: `std::for_each`

El algoritmo `std::for_each` de la biblioteca estándar de C++ se utiliza para aplicar una función a cada elemento de un rango. Es una herramienta útil para realizar operaciones repetitivas en cada elemento de un contenedor.

#### Sintaxis de `std::for_each`

```cpp
#include <algorithm>

template <class InputIt, class UnaryFunction>
UnaryFunction for_each(InputIt first, InputIt last, UnaryFunction f);
```

- **`InputIt first`**: Iterador al primer elemento del rango.
- **`InputIt last`**: Iterador al elemento después del último en el rango.
- **`UnaryFunction f`**: Una función o función objeto que se aplicará a cada elemento en el rango.

#### Descripción

`std::for_each` aplica la función `f` a cada elemento en el rango `[first, last)`. La función `f` puede ser una función regular, un objeto de función (functor) o una lambda.

#### Ejemplo de Uso de `std::for_each`

##### Ejemplo Básico

```cpp
#include <iostream>
#include <vector>
#include <algorithm>

void imprimir(int n) {
    std::cout << n << " ";
}

int main() {
    std::vector<int> vec = {1, 2, 3, 4, 5};

    // Usar std::for_each para imprimir cada elemento del vector
    std::for_each(vec.begin(), vec.end(), imprimir);
    std::cout << std::endl;

    return 0;
}
```

En este ejemplo:
- `imprimir` es una función que toma un entero y lo imprime.
- `std::for_each(vec.begin(), vec.end(), imprimir)` aplica la función `imprimir` a cada elemento del vector.

##### Ejemplo con Lambda

```cpp
#include <iostream>
#include <vector>
#include <algorithm>

int main() {
    std::vector<int> vec = {1, 2, 3, 4, 5};

    // Usar una lambda para imprimir cada elemento del vector
    std::for_each(vec.begin(), vec.end(), [](int n) {
        std::cout << n << " ";
    });
    std::cout << std::endl;

    return 0;
}
```

En este ejemplo:
- Se usa una expresión lambda para definir la operación de impresión en línea.

### Más Ejemplos

#### Incrementar Cada Elemento de un Contenedor

```cpp
#include <iostream>
#include <vector>
#include <algorithm>

int main() {
    std::vector<int> vec = {1, 2, 3, 4, 5};

    // Usar una lambda para incrementar cada elemento del vector
    std::for_each(vec.begin(), vec.end(), [](int& n) {
        n += 1;
    });

    // Imprimir los elementos incrementados
    std::for_each(vec.begin(), vec.end(), [](int n) {
        std::cout << n << " ";
    });
    std::cout << std::endl;

    return 0;
}
```

En este ejemplo:
- La lambda incrementa cada elemento del vector en 1.
- Luego, se imprime cada elemento del vector utilizando `std::for_each`.

#### Acumular Valores Usando un Functor

```cpp
#include <iostream>
#include <vector>
#include <algorithm>

struct Acumulador {
    int suma = 0;

    void operator()(int n) {
        suma += n;
    }
};

int main() {
    std::vector<int> vec = {1, 2, 3, 4, 5};

    Acumulador acumulador = std::for_each(vec.begin(), vec.end(), Acumulador());

    std::cout << "Suma de los elementos: " << acumulador.suma << std::endl;

    return 0;
}
```

En este ejemplo:
- `Acumulador` es un functor que acumula la suma de los elementos.
- `std::for_each` aplica el functor a cada elemento del vector y devuelve el functor actualizado.

### Consideraciones

- **Rendimiento:** `std::for_each` es eficiente y generalmente se compila a código similar al de un bucle `for` explícito.
- **Modificabilidad:** La función o lambda pasada a `std::for_each` puede modificar los elementos del contenedor si se pasan por referencia.

### Conclusión

`std::for_each` es un algoritmo de la biblioteca estándar de C++ que proporciona una forma conveniente y expresiva de aplicar una operación a cada elemento de un rango. Su uso con funciones, funtores y lambdas ofrece gran flexibilidad, y es una herramienta valiosa para escribir código conciso y claro en C++.
### Algoritmo de la Biblioteca Estándar: `std::accumulate`

La función `std::accumulate` es un algoritmo de la biblioteca estándar de C++ que se utiliza para sumar los elementos de un rango, acumulando un valor inicial con el resultado de aplicar una operación binaria a los elementos del rango. Es parte del encabezado `<numeric>`.

#### Sintaxis de `std::accumulate`

```cpp
#include <numeric>

template <class InputIt, class T>
T accumulate(InputIt first, InputIt last, T init);

template <class InputIt, class T, class BinaryOperation>
T accumulate(InputIt first, InputIt last, T init, BinaryOperation op);
```

- **`InputIt first`**: Iterador al primer elemento del rango.
- **`InputIt last`**: Iterador al elemento después del último en el rango.
- **`T init`**: Valor inicial de la acumulación.
- **`BinaryOperation op`** (opcional): Operación binaria que se aplicará a los elementos y al acumulador.

#### Descripción

`std::accumulate` aplica una operación binaria a un valor inicial y a cada uno de los elementos del rango, acumulando el resultado. Si no se proporciona una operación binaria, se utiliza la suma por defecto.

#### Ejemplo de Uso de `std::accumulate`

##### Ejemplo Básico (Suma)

```cpp
#include <iostream>
#include <vector>
#include <numeric>

int main() {
    std::vector<int> vec = {1, 2, 3, 4, 5};

    // Usar std::accumulate para sumar todos los elementos
    int suma = std::accumulate(vec.begin(), vec.end(), 0);

    std::cout << "La suma de los elementos es: " << suma << std::endl;

    return 0;
}
```

En este ejemplo:
- `std::accumulate(vec.begin(), vec.end(), 0)` suma todos los elementos del vector comenzando con un valor inicial de `0`.

##### Ejemplo con Operación Binaria Personalizada (Multiplicación)

```cpp
#include <iostream>
#include <vector>
#include <numeric>

int main() {
    std::vector<int> vec = {1, 2, 3, 4, 5};

    // Usar std::accumulate para multiplicar todos los elementos
    int producto = std::accumulate(vec.begin(), vec.end(), 1, std::multiplies<int>());

    std::cout << "El producto de los elementos es: " << producto << std::endl;

    return 0;
}
```

En este ejemplo:
- `std::accumulate(vec.begin(), vec.end(), 1, std::multiplies<int>())` multiplica todos los elementos del vector comenzando con un valor inicial de `1`.

### Más Ejemplos

#### Concatenar Cadenas de Texto

```cpp
#include <iostream>
#include <vector>
#include <numeric>
#include <string>

int main() {
    std::vector<std::string> vec = {"Hola", " ", "mundo", "!"};

    // Usar std::accumulate para concatenar todas las cadenas
    std::string resultado = std::accumulate(vec.begin(), vec.end(), std::string(""));

    std::cout << "Cadena concatenada: " << resultado << std::endl;

    return 0;
}
```

En este ejemplo:
- `std::accumulate(vec.begin(), vec.end(), std::string(""))` concatena todas las cadenas del vector comenzando con una cadena vacía.

#### Calcular la Media de los Elementos

```cpp
#include <iostream>
#include <vector>
#include <numeric>

int main() {
    std::vector<int> vec = {1, 2, 3, 4, 5};

    // Calcular la suma de los elementos
    int suma = std::accumulate(vec.begin(), vec.end(), 0);

    // Calcular la media
    double media = static_cast<double>(suma) / vec.size();

    std::cout << "La media de los elementos es: " << media << std::endl;

    return 0;
}
```

En este ejemplo:
- Se calcula la suma de los elementos del vector y luego se divide por el número de elementos para obtener la media.

### Consideraciones

- **Rendimiento:** `std::accumulate` es eficiente y su rendimiento es lineal en relación con el número de elementos del rango.
- **Flexibilidad:** Puede usarse con cualquier tipo de contenedor que soporte iteradores y con cualquier operación binaria que tome dos parámetros del tipo de los elementos del contenedor.

### Conclusión

`std::accumulate` es un algoritmo versátil y poderoso de la biblioteca estándar de C++ que permite acumular valores en un rango utilizando una operación binaria. Su uso con funciones, funtores y lambdas ofrece gran flexibilidad y es esencial para escribir código conciso y claro en C++. Comprender cómo utilizar `std::accumulate` puede simplificar muchas operaciones comunes de reducción y acumulación en C++.
### Algoritmos de la Biblioteca Estándar: `std::max` y `std::min`

Las funciones `std::max` y `std::min` son parte de la biblioteca estándar de C++ y se utilizan para encontrar el mayor y el menor de dos valores, respectivamente. También existen versiones de estas funciones que operan sobre rangos de elementos. Estas funciones son parte del encabezado `<algorithm>`.

#### Sintaxis de `std::max` y `std::min`

##### `std::max`

```cpp
#include <algorithm>

template <class T>
const T& max(const T& a, const T& b);

template <class T, class Compare>
const T& max(const T& a, const T& b, Compare comp);

template <class ForwardIt>
ForwardIt max_element(ForwardIt first, ForwardIt last);

template <class ForwardIt, class Compare>
ForwardIt max_element(ForwardIt first, ForwardIt last, Compare comp);
```

##### `std::min`

```cpp
#include <algorithm>

template <class T>
const T& min(const T& a, const T& b);

template <class T, class Compare>
const T& min(const T& a, const T& b, Compare comp);

template <class ForwardIt>
ForwardIt min_element(ForwardIt first, ForwardIt last);

template <class ForwardIt, class Compare>
ForwardIt min_element(ForwardIt first, ForwardIt last, Compare comp);
```

#### Descripción

- **`std::max` y `std::min`:** Devuelven el mayor y el menor de dos valores, respectivamente. Se puede proporcionar una función de comparación personalizada.
- **`std::max_element` y `std::min_element`:** Encuentran el mayor y el menor elemento en un rango de elementos, respectivamente. Se puede proporcionar una función de comparación personalizada.

#### Ejemplo de Uso de `std::max` y `std::min`

##### Ejemplo Básico con Dos Valores

```cpp
#include <iostream>
#include <algorithm>

int main() {
    int a = 10, b = 20;

    // Encontrar el valor máximo
    int maxVal = std::max(a, b);
    std::cout << "El mayor de " << a << " y " << b << " es " << maxVal << std::endl;

    // Encontrar el valor mínimo
    int minVal = std::min(a, b);
    std::cout << "El menor de " << a << " y " << b << " es " << minVal << std::endl;

    return 0;
}
```

En este ejemplo:
- `std::max(a, b)` devuelve el mayor de `a` y `b`.
- `std::min(a, b)` devuelve el menor de `a` y `b`.

##### Ejemplo con Comparación Personalizada

```cpp
#include <iostream>
#include <algorithm>
#include <string>

int main() {
    std::string s1 = "apple", s2 = "orange";

    // Comparar las cadenas por longitud
    auto maxLen = std::max(s1, s2, [](const std::string& lhs, const std::string& rhs) {
        return lhs.size() < rhs.size();
    });

    std::cout << "La cadena con mayor longitud es: " << maxLen << std::endl;

    return 0;
}
```

En este ejemplo:
- Se usa una lambda para comparar las cadenas por su longitud.

#### Uso de `std::max_element` y `std::min_element`

##### Ejemplo Básico con un Rango de Elementos

```cpp
#include <iostream>
#include <vector>
#include <algorithm>

int main() {
    std::vector<int> vec = {1, 2, 3, 4, 5};

    // Encontrar el elemento máximo
    auto maxIt = std::max_element(vec.begin(), vec.end());
    std::cout << "El elemento máximo es: " << *maxIt << std::endl;

    // Encontrar el elemento mínimo
    auto minIt = std::min_element(vec.begin(), vec.end());
    std::cout << "El elemento mínimo es: " << *minIt << std::endl;

    return 0;
}
```

En este ejemplo:
- `std::max_element(vec.begin(), vec.end())` devuelve un iterador al elemento máximo en el vector.
- `std::min_element(vec.begin(), vec.end())` devuelve un iterador al elemento mínimo en el vector.

##### Ejemplo con Comparación Personalizada

```cpp
#include <iostream>
#include <vector>
#include <algorithm>

struct Punto {
    int x, y;
};

bool compararPorDistancia(const Punto& p1, const Punto& p2) {
    return (p1.x * p1.x + p1.y * p1.y) < (p2.x * p2.x + p2.y * p2.y);
}

int main() {
    std::vector<Punto> puntos = {{1, 2}, {3, 4}, {0, 5}, {-1, -1}};

    // Encontrar el punto más lejano del origen
    auto maxIt = std::max_element(puntos.begin(), puntos.end(), compararPorDistancia);
    std::cout << "El punto más lejano es: (" << maxIt->x << ", " << maxIt->y << ")" << std::endl;

    // Encontrar el punto más cercano al origen
    auto minIt = std::min_element(puntos.begin(), puntos.end(), compararPorDistancia);
    std::cout << "El punto más cercano es: (" << minIt->x << ", " << minIt->y << ")" << std::endl;

    return 0;
}
```

En este ejemplo:
- `compararPorDistancia` es una función que compara dos puntos por su distancia al origen.
- `std::max_element` y `std::min_element` usan esta función para encontrar el punto más lejano y el más cercano, respectivamente.

### Consideraciones

- **Rendimiento:** `std::max` y `std::min` operan en tiempo constante, mientras que `std::max_element` y `std::min_element` tienen un rendimiento lineal respecto al número de elementos en el rango.
- **Flexibilidad:** Se pueden usar con cualquier tipo de datos que soporte las operaciones de comparación necesarias.

### Conclusión

`std::max` y `std::min` son funciones útiles de la biblioteca estándar de C++ para encontrar el mayor y el menor de dos valores, respectivamente. `std::max_element` y `std::min_element` extienden esta funcionalidad para operar sobre rangos de elementos. La capacidad de proporcionar funciones de comparación personalizadas hace que estos algoritmos sean extremadamente flexibles y poderosos, permitiendo su uso en una amplia variedad de escenarios de programación.
### Algoritmos de la Biblioteca Estándar: `std::find` y `std::find_if`

Los algoritmos `std::find` y `std::find_if` son parte de la biblioteca estándar de C++ y se utilizan para buscar elementos en un rango. Son funciones de búsqueda lineal que permiten encontrar el primer elemento que cumple con un criterio específico.

#### `std::find`

`std::find` busca el primer elemento en el rango `[first, last)` que es igual al valor especificado.

##### Sintaxis

```cpp
#include <algorithm>

template <class InputIt, class T>
InputIt find(InputIt first, InputIt last, const T& value);
```

- **`InputIt first`**: Iterador al primer elemento del rango.
- **`InputIt last`**: Iterador al elemento después del último en el rango.
- **`const T& value`**: Valor a buscar.

##### Ejemplo de Uso de `std::find`

```cpp
#include <iostream>
#include <vector>
#include <algorithm>

int main() {
    std::vector<int> vec = {1, 2, 3, 4, 5};

    // Buscar el valor 3
    auto it = std::find(vec.begin(), vec.end(), 3);

    if (it != vec.end()) {
        std::cout << "Elemento encontrado: " << *it << std::endl;
    } else {
        std::cout << "Elemento no encontrado" << std::endl;
    }

    return 0;
}
```

En este ejemplo:
- `std::find(vec.begin(), vec.end(), 3)` busca el valor `3` en el vector `vec`.

#### `std::find_if`

`std::find_if` busca el primer elemento en el rango `[first, last)` que satisface el predicado especificado.

##### Sintaxis

```cpp
#include <algorithm>

template <class InputIt, class UnaryPredicate>
InputIt find_if(InputIt first, InputIt last, UnaryPredicate p);
```

- **`InputIt first`**: Iterador al primer elemento del rango.
- **`InputIt last`**: Iterador al elemento después del último en el rango.
- **`UnaryPredicate p`**: Función o función objeto que toma un elemento y devuelve `true` o `false`.

##### Ejemplo de Uso de `std::find_if`

```cpp
#include <iostream>
#include <vector>
#include <algorithm>

bool esImpar(int n) {
    return n % 2 != 0;
}

int main() {
    std::vector<int> vec = {2, 4, 6, 7, 8};

    // Buscar el primer elemento impar
    auto it = std::find_if(vec.begin(), vec.end(), esImpar);

    if (it != vec.end()) {
        std::cout << "Primer elemento impar encontrado: " << *it << std::endl;
    } else {
        std::cout << "Elemento impar no encontrado" << std::endl;
    }

    return 0;
}
```

En este ejemplo:
- `std::find_if(vec.begin(), vec.end(), esImpar)` busca el primer número impar en el vector `vec`.

#### `std::find_if` con Lambda

Las lambdas ofrecen una forma concisa y poderosa de definir el predicado en línea.

##### Ejemplo de Uso de `std::find_if` con Lambda

```cpp
#include <iostream>
#include <vector>
#include <algorithm>

int main() {
    std::vector<int> vec = {2, 4, 6, 7, 8};

    // Usar una lambda para buscar el primer elemento impar
    auto it = std::find_if(vec.begin(), vec.end(), [](int n) {
        return n % 2 != 0;
    });

    if (it != vec.end()) {
        std::cout << "Primer elemento impar encontrado: " << *it << std::endl;
    } else {
        std::cout << "Elemento impar no encontrado" << std::endl;
    }

    return 0;
}
```

### Más Ejemplos

#### Buscar un Punto en un Vector de Puntos

```cpp
#include <iostream>
#include <vector>
#include <algorithm>

struct Punto {
    int x, y;

    bool operator==(const Punto& otro) const {
        return x == otro.x && y == otro.y;
    }
};

int main() {
    std::vector<Punto> puntos = {{1, 2}, {3, 4}, {5, 6}, {7, 8}};
    Punto puntoABuscar = {5, 6};

    // Buscar el punto {5, 6}
    auto it = std::find(puntos.begin(), puntos.end(), puntoABuscar);

    if (it != puntos.end()) {
        std::cout << "Punto encontrado: (" << it->x << ", " << it->y << ")" << std::endl;
    } else {
        std::cout << "Punto no encontrado" << std::endl;
    }

    return 0;
}
```

#### Buscar un Número en un Vector que Sea Mayor que un Valor Específico

```cpp
#include <iostream>
#include <vector>
#include <algorithm>

int main() {
    std::vector<int> vec = {2, 4, 6, 7, 8};

    // Usar una lambda para buscar el primer elemento mayor que 5
    auto it = std::find_if(vec.begin(), vec.end(), [](int n) {
        return n > 5;
    });

    if (it != vec.end()) {
        std::cout << "Primer elemento mayor que 5 encontrado: " << *it << std::endl;
    } else {
        std::cout << "Elemento mayor que 5 no encontrado" << std::endl;
    }

    return 0;
}
```

### Consideraciones

- **Rendimiento:** Tanto `std::find` como `std::find_if` tienen un rendimiento lineal (`O(n)`), ya que pueden necesitar recorrer todo el rango de elementos en el peor de los casos.
- **Flexibilidad:** `std::find` es útil para buscar un valor específico, mientras que `std::find_if` proporciona una mayor flexibilidad al permitir la búsqueda basada en un predicado.

### Conclusión

`std::find` y `std::find_if` son algoritmos esenciales de la biblioteca estándar de C++ para realizar búsquedas lineales en rangos de elementos. `std::find` se utiliza para buscar un valor específico, mientras que `std::find_if` permite buscar con base en un predicado, proporcionando una gran flexibilidad. Estos algoritmos son fundamentales para escribir código C++ claro y eficiente, y son ampliamente utilizados en la programación diaria.
### Algoritmo de la Biblioteca Estándar: `std::copy`

La función `std::copy` es un algoritmo de la biblioteca estándar de C++ que se utiliza para copiar elementos de un rango a otro. Es parte del encabezado `<algorithm>` y es muy útil para duplicar o trasladar datos entre contenedores.

#### Sintaxis de `std::copy`

```cpp
#include <algorithm>

template <class InputIt, class OutputIt>
OutputIt copy(InputIt first, InputIt last, OutputIt d_first);
```

- **`InputIt first`**: Iterador al primer elemento del rango de entrada.
- **`InputIt last`**: Iterador al elemento después del último en el rango de entrada.
- **`OutputIt d_first`**: Iterador al primer elemento del rango de destino.

#### Descripción

`std::copy` copia los elementos del rango `[first, last)` al rango que comienza en `d_first`. El rango de destino debe ser lo suficientemente grande para contener todos los elementos copiados.

#### Ejemplo de Uso de `std::copy`

##### Ejemplo Básico

```cpp
#include <iostream>
#include <vector>
#include <algorithm>

int main() {
    std::vector<int> origen = {1, 2, 3, 4, 5};
    std::vector<int> destino(origen.size());

    // Usar std::copy para copiar los elementos
    std::copy(origen.begin(), origen.end(), destino.begin());

    // Mostrar los elementos copiados
    std::cout << "Elementos copiados al vector destino: ";
    for (int elem : destino) {
        std::cout << elem << " ";
    }
    std::cout << std::endl;

    return 0;
}
```

En este ejemplo:
- `std::copy(origen.begin(), origen.end(), destino.begin())` copia todos los elementos del vector `origen` al vector `destino`.

### Uso con Diferentes Tipos de Contenedores

`std::copy` se puede usar con cualquier contenedor que soporte iteradores, como `std::vector`, `std::list`, `std::array`, etc.

##### Copiar Elementos entre Diferentes Contenedores

```cpp
#include <iostream>
#include <vector>
#include <list>
#include <algorithm>

int main() {
    std::vector<int> origen = {1, 2, 3, 4, 5};
    std::list<int> destino(origen.size());

    // Usar std::copy para copiar los elementos
    std::copy(origen.begin(), origen.end(), destino.begin());

    // Mostrar los elementos copiados
    std::cout << "Elementos copiados a la lista destino: ";
    for (int elem : destino) {
        std::cout << elem << " ";
    }
    std::cout << std::endl;

    return 0;
}
```

En este ejemplo:
- `std::copy` se usa para copiar elementos de un `std::vector` a un `std::list`.

### Ejemplos Adicionales

#### Copiar un Rango Parcial de Elementos

```cpp
#include <iostream>
#include <vector>
#include <algorithm>

int main() {
    std::vector<int> origen = {1, 2, 3, 4, 5};
    std::vector<int> destino(3);

    // Usar std::copy para copiar los primeros 3 elementos
    std::copy(origen.begin(), origen.begin() + 3, destino.begin());

    // Mostrar los elementos copiados
    std::cout << "Primeros 3 elementos copiados al vector destino: ";
    for (int elem : destino) {
        std::cout << elem << " ";
    }
    std::cout << std::endl;

    return 0;
}
```

En este ejemplo:
- `std::copy(origen.begin(), origen.begin() + 3, destino.begin())` copia los primeros tres elementos del vector `origen` al vector `destino`.

#### Copiar con `std::back_inserter`

Si el contenedor de destino no tiene suficiente espacio reservado, se puede utilizar un `std::back_inserter` para que el contenedor crezca automáticamente.

```cpp
#include <iostream>
#include <vector>
#include <algorithm>
#include <iterator>

int main() {
    std::vector<int> origen = {1, 2, 3, 4, 5};
    std::vector<int> destino;

    // Usar std::copy con std::back_inserter
    std::copy(origen.begin(), origen.end(), std::back_inserter(destino));

    // Mostrar los elementos copiados
    std::cout << "Elementos copiados al vector destino con back_inserter: ";
    for (int elem : destino) {
        std::cout << elem << " ";
    }
    std::cout << std::endl;

    return 0;
}
```

En este ejemplo:
- `std::back_inserter(destino)` se utiliza para insertar elementos al final del vector `destino`, expandiendo automáticamente su tamaño según sea necesario.

### Consideraciones

- **Rendimiento:** `std::copy` es muy eficiente y generalmente se compila a un bucle simple que copia elementos.
- **Seguridad:** Asegúrese de que el rango de destino sea lo suficientemente grande para contener todos los elementos del rango de origen para evitar accesos fuera de los límites.

### Conclusión

`std::copy` es un algoritmo fundamental de la biblioteca estándar de C++ que proporciona una forma eficiente y flexible de copiar elementos entre contenedores. Su uso con iteradores y adaptadores de inserción como `std::back_inserter` permite una gran variedad de operaciones de copia, adecuándose a las necesidades de diferentes tipos de contenedores. Comprender y utilizar `std::copy` es esencial para escribir código C++ robusto y eficiente.
### Algoritmo de la Biblioteca Estándar: `std::sort`

La función `std::sort` es un algoritmo de la biblioteca estándar de C++ que se utiliza para ordenar los elementos de un rango. Es parte del encabezado `<algorithm>` y es ampliamente utilizada debido a su eficiencia y flexibilidad.

#### Sintaxis de `std::sort`

```cpp
#include <algorithm>

template <class RandomIt>
void sort(RandomIt first, RandomIt last);

template <class RandomIt, class Compare>
void sort(RandomIt first, RandomIt last, Compare comp);
```

- **`RandomIt first`**: Iterador al primer elemento del rango.
- **`RandomIt last`**: Iterador al elemento después del último en el rango.
- **`Compare comp`**: (Opcional) Función o función objeto que define el criterio de comparación.

#### Descripción

`std::sort` ordena los elementos en el rango `[first, last)` en orden ascendente por defecto. Si se proporciona una función de comparación, se utiliza esa función para determinar el orden.

#### Ejemplo de Uso de `std::sort`

##### Ejemplo Básico (Orden Ascendente)

```cpp
#include <iostream>
#include <vector>
#include <algorithm>

int main() {
    std::vector<int> vec = {5, 2, 9, 1, 5, 6};

    // Usar std::sort para ordenar los elementos en orden ascendente
    std::sort(vec.begin(), vec.end());

    // Mostrar los elementos ordenados
    std::cout << "Elementos ordenados: ";
    for (int elem : vec) {
        std::cout << elem << " ";
    }
    std::cout << std::endl;

    return 0;
}
```

En este ejemplo:
- `std::sort(vec.begin(), vec.end())` ordena todos los elementos del vector `vec` en orden ascendente.

##### Ejemplo con Comparación Personalizada (Orden Descendente)

```cpp
#include <iostream>
#include <vector>
#include <algorithm>

int main() {
    std::vector<int> vec = {5, 2, 9, 1, 5, 6};

    // Usar std::sort con una función de comparación para ordenar en orden descendente
    std::sort(vec.begin(), vec.end(), std::greater<int>());

    // Mostrar los elementos ordenados
    std::cout << "Elementos ordenados en orden descendente: ";
    for (int elem : vec) {
        std::cout << elem << " ";
    }
    std::cout << std::endl;

    return 0;
}
```

En este ejemplo:
- `std::sort(vec.begin(), vec.end(), std::greater<int>())` ordena los elementos del vector `vec` en orden descendente usando `std::greater`.

### Uso con Diferentes Tipos de Contenedores

`std::sort` se puede usar con cualquier contenedor que soporte iteradores de acceso aleatorio, como `std::vector`, `std::array`, y `std::deque`.

##### Ordenar un `std::array`

```cpp
#include <iostream>
#include <array>
#include <algorithm>

int main() {
    std::array<int, 6> arr = {5, 2, 9, 1, 5, 6};

    // Usar std::sort para ordenar los elementos del array
    std::sort(arr.begin(), arr.end());

    // Mostrar los elementos ordenados
    std::cout << "Elementos del array ordenados: ";
    for (int elem : arr) {
        std::cout << elem << " ";
    }
    std::cout << std::endl;

    return 0;
}
```

En este ejemplo:
- `std::sort` se usa para ordenar los elementos de
### Algoritmo de la Biblioteca Estándar: `std::transform`

La función `std::transform` es un algoritmo de la biblioteca estándar de C++ que se utiliza para aplicar una operación a un rango de elementos y almacenar los resultados en otro rango (o el mismo). Es parte del encabezado `<algorithm>` y es muy útil para transformar elementos de contenedores mediante la aplicación de una función.

#### Sintaxis de `std::transform`

Hay dos variantes de `std::transform`:

1. Aplicar una función unaria a cada elemento de un rango:

```cpp
#include <algorithm>

template <class InputIt, class OutputIt, class UnaryOperation>
OutputIt transform(InputIt first, InputIt last, OutputIt d_first, UnaryOperation unary_op);
```

- **`InputIt first`**: Iterador al primer elemento del rango de entrada.
- **`InputIt last`**: Iterador al elemento después del último en el rango de entrada.
- **`OutputIt d_first`**: Iterador al primer elemento del rango de destino.
- **`UnaryOperation unary_op`**: Función o función objeto que se aplicará a cada elemento del rango de entrada.

2. Aplicar una función binaria a cada par de elementos de dos rangos:

```cpp
#include <algorithm>

template <class InputIt1, class InputIt2, class OutputIt, class BinaryOperation>
OutputIt transform(InputIt1 first1, InputIt1 last1, InputIt2 first2, OutputIt d_first, BinaryOperation binary_op);
```

- **`InputIt1 first1`**: Iterador al primer elemento del primer rango de entrada.
- **`InputIt1 last1`**: Iterador al elemento después del último en el primer rango de entrada.
- **`InputIt2 first2`**: Iterador al primer elemento del segundo rango de entrada.
- **`OutputIt d_first`**: Iterador al primer elemento del rango de destino.
- **`BinaryOperation binary_op`**: Función o función objeto que se aplicará a cada par de elementos de los dos rangos de entrada.

#### Ejemplo de Uso de `std::transform`

##### Ejemplo Básico (Función Unaria)

```cpp
#include <iostream>
#include <vector>
#include <algorithm>

int main() {
    std::vector<int> origen = {1, 2, 3, 4, 5};
    std::vector<int> destino(origen.size());

    // Usar std::transform para duplicar cada elemento
    std::transform(origen.begin(), origen.end(), destino.begin(), [](int x) {
        return x * 2;
    });

    // Mostrar los elementos transformados
    std::cout << "Elementos transformados (duplicados): ";
    for (int elem : destino) {
        std::cout << elem << " ";
    }
    std::cout << std::endl;

    return 0;
}
```

En este ejemplo:
- `std::transform(origen.begin(), origen.end(), destino.begin(), [](int x) { return x * 2; })` aplica una lambda que duplica cada elemento del vector `origen` y almacena los resultados en el vector `destino`.

##### Ejemplo con Función Binaria

```cpp
#include <iostream>
#include <vector>
#include <algorithm>

int main() {
    std::vector<int> vec1 = {1, 2, 3, 4, 5};
    std::vector<int> vec2 = {10, 20, 30, 40, 50};
    std::vector<int> resultado(vec1.size());

    // Usar std::transform para sumar elementos de dos vectores
    std::transform(vec1.begin(), vec1.end(), vec2.begin(), resultado.begin(), [](int x, int y) {
        return x + y;
    });

    // Mostrar los elementos transformados
    std::cout << "Elementos transformados (suma de vec1 y vec2): ";
    for (int elem : resultado) {
        std::cout << elem << " ";
    }
    std::cout << std::endl;

    return 0;
}
```

En este ejemplo:
- `std::transform(vec1.begin(), vec1.end(), vec2.begin(), resultado.begin(), [](int x, int y) { return x + y; })` aplica una lambda que suma los elementos correspondientes de `vec1` y `vec2`, almacenando los resultados en `resultado`.

### Uso con Diferentes Tipos de Contenedores

`std::transform` se puede usar con cualquier contenedor que soporte iteradores, como `std::vector`, `std::list`, `std::array`, etc.

##### Transformar una Lista

```cpp
#include <iostream>
#include <list>
#include <algorithm>

int main() {
    std::list<int> origen = {1, 2, 3, 4, 5};
    std::list<int> destino(origen.size());

    // Usar std::transform para incrementar cada elemento
    std::transform(origen.begin(), origen.end(), destino.begin(), [](int x) {
        return x + 1;
    });

    // Mostrar los elementos transformados
    std::cout << "Elementos transformados (incrementados): ";
    for (int elem : destino) {
        std::cout << elem << " ";
    }
    std::cout << std::endl;

    return 0;
}
```

En este ejemplo:
- `std::transform` se usa para incrementar cada elemento de una lista.

### Consideraciones

- **Rendimiento:** `std::transform` es muy eficiente y tiene un rendimiento lineal (`O(n)`) respecto al número de elementos.
- **Flexibilidad:** Puede usar funciones, funtores y lambdas para definir las transformaciones.
- **Requisito de Espacio:** El rango de destino debe ser lo suficientemente grande para contener todos los elementos transformados.

### Conclusión

`std::transform` es un algoritmo de la biblioteca estándar de C++ muy útil para aplicar operaciones a los elementos de un contenedor y almacenar los resultados en otro. Su uso con funciones, funtores y lambdas proporciona una gran flexibilidad y permite escribir código conciso y claro. Comprender y utilizar `std::transform` es esencial para realizar transformaciones eficientes en datos en C++.
### Algoritmo de la Biblioteca Estándar: `std::fill`

La función `std::fill` es un algoritmo de la biblioteca estándar de C++ que se utiliza para asignar un valor a todos los elementos en un rango. Es parte del encabezado `<algorithm>` y se utiliza comúnmente para inicializar o restablecer los elementos de un contenedor.

#### Sintaxis de `std::fill`

```cpp
#include <algorithm>

template <class ForwardIt, class T>
void fill(ForwardIt first, ForwardIt last, const T& value);
```

- **`ForwardIt first`**: Iterador al primer elemento del rango.
- **`ForwardIt last`**: Iterador al elemento después del último en el rango.
- **`const T& value`**: Valor a asignar a los elementos del rango.

#### Descripción

`std::fill` asigna el valor `value` a cada elemento en el rango `[first, last)`. El rango debe ser accesible mediante iteradores de avance (forward iterators).

#### Ejemplo de Uso de `std::fill`

##### Ejemplo Básico

```cpp
#include <iostream>
#include <vector>
#include <algorithm>

int main() {
    std::vector<int> vec(10);

    // Usar std::fill para asignar el valor 5 a todos los elementos del vector
    std::fill(vec.begin(), vec.end(), 5);

    // Mostrar los elementos del vector
    std::cout << "Elementos del vector después de std::fill: ";
    for (int elem : vec) {
        std::cout << elem << " ";
    }
    std::cout << std::endl;

    return 0;
}
```

En este ejemplo:
- `std::fill(vec.begin(), vec.end(), 5)` asigna el valor `5` a todos los elementos del vector `vec`.

### Uso con Diferentes Tipos de Contenedores

`std::fill` se puede usar con cualquier contenedor que soporte iteradores de avance, como `std::vector`, `std::list`, `std::array`, etc.

##### Ejemplo con `std::array`

```cpp
#include <iostream>
#include <array>
#include <algorithm>

int main() {
    std::array<int, 5> arr;

    // Usar std::fill para asignar el valor 10 a todos los elementos del array
    std::fill(arr.begin(), arr.end(), 10);

    // Mostrar los elementos del array
    std::cout << "Elementos del array después de std::fill: ";
    for (int elem : arr) {
        std::cout << elem << " ";
    }
    std::cout << std::endl;

    return 0;
}
```

En este ejemplo:
- `std::fill(arr.begin(), arr.end(), 10)` asigna el valor `10` a todos los elementos del array `arr`.

### Ejemplos Adicionales

#### Inicializar una Matriz

`std::fill` también puede ser utilizado para inicializar matrices u otras estructuras de datos.

##### Ejemplo con una Matriz

```cpp
#include <iostream>
#include <vector>
#include <algorithm>

int main() {
    std::vector<std::vector<int>> matrix(3, std::vector<int>(4));

    // Usar std::fill para asignar el valor 0 a todos los elementos de la matriz
    for (auto& row : matrix) {
        std::fill(row.begin(), row.end(), 0);
    }

    // Mostrar los elementos de la matriz
    std::cout << "Elementos de la matriz después de std::fill: " << std::endl;
    for (const auto& row : matrix) {
        for (int elem : row) {
            std::cout << elem << " ";
        }
        std::cout << std::endl;
    }

    return 0;
}
```

En este ejemplo:
- `std::fill` se utiliza en cada fila de la matriz para asignar el valor `0` a todos los elementos.

### Uso con Rangos Parciales

##### Ejemplo de Rango Parcial

```cpp
#include <iostream>
#include <vector>
#include <algorithm>

int main() {
    std::vector<int> vec(10);

    // Asignar el valor 1 a la primera mitad del vector
    std::fill(vec.begin(), vec.begin() + vec.size() / 2, 1);

    // Asignar el valor 2 a la segunda mitad del vector
    std::fill(vec.begin() + vec.size() / 2, vec.end(), 2);

    // Mostrar los elementos del vector
    std::cout << "Elementos del vector después de std::fill en rangos parciales: ";
    for (int elem : vec) {
        std::cout << elem << " ";
    }
    std::cout << std::endl;

    return 0;
}
```

En este ejemplo:
- `std::fill` se utiliza para asignar diferentes valores a distintas partes del vector.

### Consideraciones

- **Rendimiento:** `std::fill` es muy eficiente y generalmente se compila a un bucle simple que asigna el valor a cada elemento del rango.
- **Flexibilidad:** Puede usarse con cualquier tipo de contenedor que soporte iteradores de avance.
- **Seguridad:** Asegúrese de que el rango especificado esté dentro de los límites del contenedor para evitar accesos fuera de los límites.

### Conclusión

`std::fill` es un algoritmo simple pero poderoso de la biblioteca estándar de C++ que proporciona una forma eficiente y flexible de asignar valores a los elementos de un contenedor. Su uso es fundamental para inicializar o restablecer contenedores y es una herramienta esencial en el arsenal de cualquier programador de C++.
### Algoritmo de la Biblioteca Estándar: `std::replace`

La función `std::replace` es un algoritmo de la biblioteca estándar de C++ que se utiliza para reemplazar todos los elementos de un rango que son iguales a un valor específico por otro valor. Es parte del encabezado `<algorithm>` y es muy útil para modificar elementos de contenedores en base a una condición de igualdad.

#### Sintaxis de `std::replace`

```cpp
#include <algorithm>

template <class ForwardIt, class T>
void replace(ForwardIt first, ForwardIt last, const T& old_value, const T& new_value);
```

- **`ForwardIt first`**: Iterador al primer elemento del rango.
- **`ForwardIt last`**: Iterador al elemento después del último en el rango.
- **`const T& old_value`**: Valor que será reemplazado.
- **`const T& new_value`**: Valor que reemplazará a `old_value`.

#### Descripción

`std::replace` reemplaza cada elemento en el rango `[first, last)` que es igual a `old_value` por `new_value`.

#### Ejemplo de Uso de `std::replace`

##### Ejemplo Básico

```cpp
#include <iostream>
#include <vector>
#include <algorithm>

int main() {
    std::vector<int> vec = {1, 2, 3, 2, 5, 2};

    // Usar std::replace para reemplazar todos los 2 por 9
    std::replace(vec.begin(), vec.end(), 2, 9);

    // Mostrar los elementos modificados
    std::cout << "Elementos del vector después de std::replace: ";
    for (int elem : vec) {
        std::cout << elem << " ";
    }
    std::cout << std::endl;

    return 0;
}
```

En este ejemplo:
- `std::replace(vec.begin(), vec.end(), 2, 9)` reemplaza todas las ocurrencias del valor `2` en el vector `vec` con `9`.

### Uso con Diferentes Tipos de Contenedores

`std::replace` se puede usar con cualquier contenedor que soporte iteradores de avance, como `std::vector`, `std::list`, `std::array`, etc.

##### Ejemplo con `std::list`

```cpp
#include <iostream>
#include <list>
#include <algorithm>

int main() {
    std::list<int> lst = {1, 2, 3, 2, 5, 2};

    // Usar std::replace para reemplazar todos los 2 por 9
    std::replace(lst.begin(), lst.end(), 2, 9);

    // Mostrar los elementos modificados
    std::cout << "Elementos de la lista después de std::replace: ";
    for (int elem : lst) {
        std::cout << elem << " ";
    }
    std::cout << std::endl;

    return 0;
}
```

En este ejemplo:
- `std::replace` se utiliza para reemplazar todas las ocurrencias del valor `2` en la lista `lst` con `9`.

### Ejemplos Adicionales

#### Reemplazar un Rango Parcial de Elementos

```cpp
#include <iostream>
#include <vector>
#include <algorithm>

int main() {
    std::vector<int> vec = {1, 2, 3, 2, 5, 2};

    // Usar std::replace para reemplazar todos los 2 por 9 en la primera mitad del vector
    std::replace(vec.begin(), vec.begin() + vec.size() / 2, 2, 9);

    // Mostrar los elementos modificados
    std::cout << "Elementos del vector después de std::replace en la primera mitad: ";
    for (int elem : vec) {
        std::cout << elem << " ";
    }
    std::cout << std::endl;

    return 0;
}
```

En este ejemplo:
- `std::replace(vec.begin(), vec.begin() + vec.size() / 2, 2, 9)` reemplaza todas las ocurrencias del valor `2` en la primera mitad del vector `vec` con `9`.

### Variantes: `std::replace_if`

Además de `std::replace`, existe una variante llamada `std::replace_if` que reemplaza los elementos basados en un predicado.

#### Sintaxis de `std::replace_if`

```cpp
#include <algorithm>

template <class ForwardIt, class UnaryPredicate, class T>
void replace_if(ForwardIt first, ForwardIt last, UnaryPredicate p, const T& new_value);
```

- **`ForwardIt first`**: Iterador al primer elemento del rango.
- **`ForwardIt last`**: Iterador al elemento después del último en el rango.
- **`UnaryPredicate p`**: Predicado que define la condición de reemplazo.
- **`const T& new_value`**: Valor que reemplazará a los elementos que satisfacen el predicado.

#### Ejemplo de Uso de `std::replace_if`

##### Ejemplo Básico con `std::replace_if`

```cpp
#include <iostream>
#include <vector>
#include <algorithm>

bool esPar(int n) {
    return n % 2 == 0;
}

int main() {
    std::vector<int> vec = {1, 2, 3, 4, 5, 6};

    // Usar std::replace_if para reemplazar todos los números pares por 0
    std::replace_if(vec.begin(), vec.end(), esPar, 0);

    // Mostrar los elementos modificados
    std::cout << "Elementos del vector después de std::replace_if: ";
    for (int elem : vec) {
        std::cout << elem << " ";
    }
    std::cout << std::endl;

    return 0;
}
```

En este ejemplo:
- `std::replace_if(vec.begin(), vec.end(), esPar, 0)` reemplaza todos los números pares en el vector `vec` con `0`.

##### Ejemplo con Lambda

```cpp
#include <iostream>
#include <vector>
#include <algorithm>

int main() {
    std::vector<int> vec = {1, 2, 3, 4, 5, 6};

    // Usar std::replace_if con una lambda para reemplazar todos los números mayores que 3 por 99
    std::replace_if(vec.begin(), vec.end(), [](int n) { return n > 3; }, 99);

    // Mostrar los elementos modificados
    std::cout << "Elementos del vector después de std::replace_if: ";
    for (int elem : vec) {
        std::cout << elem << " ";
    }
    std::cout << std::endl;

    return 0;
}
```

En este ejemplo:
- `std::replace_if(vec.begin(), vec.end(), [](int n) { return n > 3; }, 99)` reemplaza todos los números mayores que `3` en el vector `vec` con `99`.

### Consideraciones

- **Rendimiento:** `std::replace` y `std::replace_if` tienen un rendimiento lineal (`O(n)`), ya que necesitan recorrer todo el rango de elementos.
- **Flexibilidad:** `std::replace` es útil para reemplazar valores específicos, mientras que `std::replace_if` proporciona mayor flexibilidad al permitir reemplazos basados en un predicado.
- **Uso de Predicados:** `std::replace_if` puede utilizar funciones, funtores y lambdas como predicados, lo que lo hace extremadamente versátil.

### Conclusión

`std::replace` y `std::replace_if` son algoritmos de la biblioteca estándar de C++ que proporcionan formas eficientes y flexibles de reemplazar elementos en contenedores. `std::replace` se usa para reemplazar valores específicos, mientras que `std::replace_if` permite realizar reemplazos basados en condiciones más complejas definidas por predicados. Comprender y utilizar estos algoritmos es esencial para escribir código C++ claro, eficiente y fácil de mantener.
### Algoritmo de la Biblioteca Estándar: `std::remove`

La función `std::remove` es un algoritmo de la biblioteca estándar de C++ que se utiliza para eliminar elementos de un contenedor que son iguales a un valor específico. Sin embargo, `std::remove` no elimina físicamente los elementos del contenedor, sino que los mueve al final del rango y devuelve un iterador al nuevo final lógico del rango sin los elementos eliminados. Es parte del encabezado `<algorithm>`.

#### Sintaxis de `std::remove`

```cpp
#include <algorithm>

template <class ForwardIt, class T>
ForwardIt remove(ForwardIt first, ForwardIt last, const T& value);
```

- **`ForwardIt first`**: Iterador al primer elemento del rango.
- **`ForwardIt last`**: Iterador al elemento después del último en el rango.
- **`const T& value`**: Valor de los elementos a eliminar.

#### Descripción

`std::remove` reordena los elementos del rango `[first, last)` de modo que todos los elementos que no son iguales a `value` se encuentran al principio del rango, y devuelve un iterador al nuevo final lógico del rango que no contiene los elementos eliminados.

#### Ejemplo de Uso de `std::remove`

##### Ejemplo Básico

```cpp
#include <iostream>
#include <vector>
#include <algorithm>

int main() {
    std::vector<int> vec = {1, 2, 3, 2, 5, 2};

    // Usar std::remove para mover los elementos que no son 2 al principio
    auto it = std::remove(vec.begin(), vec.end(), 2);

    // Eliminar físicamente los elementos después del nuevo final lógico
    vec.erase(it, vec.end());

    // Mostrar los elementos restantes
    std::cout << "Elementos del vector después de std::remove y erase: ";
    for (int elem : vec) {
        std::cout << elem << " ";
    }
    std::cout << std::endl;

    return 0;
}
```

En este ejemplo:
- `std::remove(vec.begin(), vec.end(), 2)` reordena los elementos del vector `vec` moviendo todos los `2` al final y devuelve un iterador al nuevo final lógico del vector.
- `vec.erase(it, vec.end())` elimina físicamente los elementos desde el nuevo final lógico hasta el final real del vector.

### Uso con Diferentes Tipos de Contenedores

`std::remove` se puede usar con cualquier contenedor que soporte iteradores de avance, como `std::vector`, `std::list`, `std::deque`, etc.

##### Ejemplo con `std::list`

```cpp
#include <iostream>
#include <list>
#include <algorithm>

int main() {
    std::list<int> lst = {1, 2, 3, 2, 5, 2};

    // Usar std::remove para mover los elementos que no son 2 al principio
    auto it = std::remove(lst.begin(), lst.end(), 2);

    // Eliminar físicamente los elementos después del nuevo final lógico
    lst.erase(it, lst.end());

    // Mostrar los elementos restantes
    std::cout << "Elementos de la lista después de std::remove y erase: ";
    for (int elem : lst) {
        std::cout << elem << " ";
    }
    std::cout << std::endl;

    return 0;
}
```

En este ejemplo:
- `std::remove` se utiliza para mover todas las ocurrencias del valor `2` al final de la lista `lst`.
- `lst.erase(it, lst.end())` elimina físicamente estos elementos.

### Variantes: `std::remove_if`

Además de `std::remove`, existe una variante llamada `std::remove_if` que elimina elementos basados en un predicado.

#### Sintaxis de `std::remove_if`

```cpp
#include <algorithm>

template <class ForwardIt, class UnaryPredicate>
ForwardIt remove_if(ForwardIt first, ForwardIt last, UnaryPredicate p);
```

- **`ForwardIt first`**: Iterador al primer elemento del rango.
- **`ForwardIt last`**: Iterador al elemento después del último en el rango.
- **`UnaryPredicate p`**: Predicado que define la condición de eliminación.

#### Ejemplo de Uso de `std::remove_if`

##### Ejemplo Básico con `std::remove_if`

```cpp
#include <iostream>
#include <vector>
#include <algorithm>

bool esPar(int n) {
    return n % 2 == 0;
}

int main() {
    std::vector<int> vec = {1, 2, 3, 4, 5, 6};

    // Usar std::remove_if para mover los números pares al final
    auto it = std::remove_if(vec.begin(), vec.end(), esPar);

    // Eliminar físicamente los elementos después del nuevo final lógico
    vec.erase(it, vec.end());

    // Mostrar los elementos restantes
    std::cout << "Elementos del vector después de std::remove_if y erase: ";
    for (int elem : vec) {
        std::cout << elem << " ";
    }
    std::cout << std::endl;

    return 0;
}
```

En este ejemplo:
- `std::remove_if(vec.begin(), vec.end(), esPar)` reordena los elementos del vector `vec` moviendo todos los números pares al final y devuelve un iterador al nuevo final lógico del vector.
- `vec.erase(it, vec.end())` elimina físicamente estos elementos.

##### Ejemplo con Lambda

```cpp
#include <iostream>
#include <vector>
#include <algorithm>

int main() {
    std::vector<int> vec = {1, 2, 3, 4, 5, 6};

    // Usar std::remove_if con una lambda para mover los números mayores que 3 al final
    auto it = std::remove_if(vec.begin(), vec.end(), [](int n) { return n > 3; });

    // Eliminar físicamente los elementos después del nuevo final lógico
    vec.erase(it, vec.end());

    // Mostrar los elementos restantes
    std::cout << "Elementos del vector después de std::remove_if y erase: ";
    for (int elem : vec) {
        std::cout << elem << " ";
    }
    std::cout << std::endl;

    return 0;
}
```

En este ejemplo:
- `std::remove_if(vec.begin(), vec.end(), [](int n) { return n > 3; })` mueve todos los números mayores que `3` al final del vector `vec`.
- `vec.erase(it, vec.end())` elimina físicamente estos elementos.

### Consideraciones

- **Rendimiento:** `std::remove` y `std::remove_if` tienen un rendimiento lineal (`O(n)`), ya que necesitan recorrer todo el rango de elementos.
- **Uso de Predicados:** `std::remove_if` puede utilizar funciones, funtores y lambdas como predicados, lo que lo hace extremadamente versátil.
- **Eliminar Físicamente:** Aunque `std::remove` y `std::remove_if` reorganizan los elementos para mover los que se van a eliminar al final del rango, es necesario utilizar `erase` para eliminar físicamente los elementos del contenedor.

### Conclusión

`std::remove` y `std::remove_if` son algoritmos de la biblioteca estándar de C++ que proporcionan una manera eficiente de eliminar elementos de un contenedor basados en un valor o una condición. Estos algoritmos reorganizan los elementos y devuelven un iterador al nuevo final lógico del rango, lo que permite una eliminación física posterior. Comprender y utilizar `std::remove` y `std::remove_if` es esencial para realizar operaciones de eliminación eficientes en contenedores en C++.
### Algoritmo de la Biblioteca Estándar: `std::reverse`

La función `std::reverse` es un algoritmo de la biblioteca estándar de C++ que se utiliza para invertir el orden de los elementos en un rango. Es parte del encabezado `<algorithm>` y se utiliza comúnmente para revertir el orden de los elementos de contenedores como vectores, listas, arrays, etc.

#### Sintaxis de `std::reverse`

```cpp
#include <algorithm>

template <class BidirectionalIt>
void reverse(BidirectionalIt first, BidirectionalIt last);
```

- **`BidirectionalIt first`**: Iterador al primer elemento del rango.
- **`BidirectionalIt last`**: Iterador al elemento después del último en el rango.

#### Descripción

`std::reverse` invierte el orden de los elementos en el rango `[first, last)`. Este algoritmo requiere que los iteradores proporcionados sean bidireccionales, lo que significa que se debe poder avanzar y retroceder a través del rango.

#### Ejemplo de Uso de `std::reverse`

##### Ejemplo Básico

```cpp
#include <iostream>
#include <vector>
#include <algorithm>

int main() {
    std::vector<int> vec = {1, 2, 3, 4, 5};

    // Usar std::reverse para invertir el orden de los elementos
    std::reverse(vec.begin(), vec.end());

    // Mostrar los elementos invertidos
    std::cout << "Elementos del vector después de std::reverse: ";
    for (int elem : vec) {
        std::cout << elem << " ";
    }
    std::cout << std::endl;

    return 0;
}
```

En este ejemplo:
- `std::reverse(vec.begin(), vec.end())` invierte el orden de todos los elementos del vector `vec`.

### Uso con Diferentes Tipos de Contenedores

`std::reverse` se puede usar con cualquier contenedor que soporte iteradores bidireccionales, como `std::vector`, `std::list`, `std::deque`, etc.

##### Ejemplo con `std::list`

```cpp
#include <iostream>
#include <list>
#include <algorithm>

int main() {
    std::list<int> lst = {1, 2, 3, 4, 5};

    // Usar std::reverse para invertir el orden de los elementos
    std::reverse(lst.begin(), lst.end());

    // Mostrar los elementos invertidos
    std::cout << "Elementos de la lista después de std::reverse: ";
    for (int elem : lst) {
        std::cout << elem << " ";
    }
    std::cout << std::endl;

    return 0;
}
```

En este ejemplo:
- `std::reverse` se utiliza para invertir el orden de los elementos en la lista `lst`.

### Ejemplos Adicionales

#### Invertir una Subsección de un Contenedor

##### Ejemplo de Subsección

```cpp
#include <iostream>
#include <vector>
#include <algorithm>

int main() {
    std::vector<int> vec = {1, 2, 3, 4, 5, 6, 7, 8};

    // Usar std::reverse para invertir el orden de los elementos en una subsección del vector
    std::reverse(vec.begin() + 2, vec.begin() + 6);

    // Mostrar los elementos del vector después de invertir la subsección
    std::cout << "Elementos del vector después de invertir una subsección: ";
    for (int elem : vec) {
        std::cout << elem << " ";
    }
    std::cout << std::endl;

    return 0;
}
```

En este ejemplo:
- `std::reverse(vec.begin() + 2, vec.begin() + 6)` invierte el orden de los elementos en la subsección `[3, 4, 5, 6]` del vector `vec`.

#### Invertir una Cadena de Texto

##### Ejemplo con `std::string`

```cpp
#include <iostream>
#include <string>
#include <algorithm>

int main() {
    std::string str = "Hello, World!";

    // Usar std::reverse para invertir el orden de los caracteres en la cadena
    std::reverse(str.begin(), str.end());

    // Mostrar la cadena invertida
    std::cout << "Cadena después de std::reverse: " << str << std::endl;

    return 0;
}
```

En este ejemplo:
- `std::reverse` se utiliza para invertir el orden de los caracteres en la cadena `str`.

### Consideraciones

- **Rendimiento:** `std::reverse` es muy eficiente y tiene un rendimiento lineal (`O(n)`), ya que necesita recorrer todo el rango de elementos para invertirlos.
- **Requisitos de Iteradores:** `std::reverse` requiere iteradores bidireccionales, lo que significa que no puede utilizarse con contenedores que solo proporcionan iteradores de avance, como `std::forward_list`.
- **Inversión In-Situ:** `std::reverse` invierte los elementos en su lugar, lo que significa que no requiere espacio adicional significativo.

### Conclusión

`std::reverse` es un algoritmo de la biblioteca estándar de C++ que proporciona una manera eficiente y directa de invertir el orden de los elementos en un rango. Su uso es fundamental para tareas que requieren la manipulación de la ordenación de elementos en contenedores. Comprender y utilizar `std::reverse` es esencial para escribir código C++ claro y eficiente cuando se necesita invertir el orden de los elementos en contenedores.
### Algoritmo de la Biblioteca Estándar: `std::partition`

La función `std::partition` es un algoritmo de la biblioteca estándar de C++ que se utiliza para reorganizar los elementos de un rango de modo que todos los elementos que satisfacen un predicado dado precedan a todos los que no lo satisfacen. Es parte del encabezado `<algorithm>` y es útil para particionar contenedores en base a una condición específica.

#### Sintaxis de `std::partition`

```cpp
#include <algorithm>

template <class ForwardIt, class UnaryPredicate>
ForwardIt partition(ForwardIt first, ForwardIt last, UnaryPredicate p);
```

- **`ForwardIt first`**: Iterador al primer elemento del rango.
- **`ForwardIt last`**: Iterador al elemento después del último en el rango.
- **`UnaryPredicate p`**: Predicado que define la condición de partición. Debe devolver `true` para elementos que deben estar en la primera parte del rango y `false` para los demás.

#### Descripción

`std::partition` reorganiza los elementos en el rango `[first, last)` de modo que todos los elementos que satisfacen el predicado `p` estén antes que los elementos que no lo satisfacen. Devuelve un iterador al primer elemento de la segunda parte del rango (donde los elementos no satisfacen el predicado).

#### Ejemplo de Uso de `std::partition`

##### Ejemplo Básico

```cpp
#include <iostream>
#include <vector>
#include <algorithm>

bool esPar(int n) {
    return n % 2 == 0;
}

int main() {
    std::vector<int> vec = {1, 2, 3, 4, 5, 6};

    // Usar std::partition para particionar los elementos
    auto it = std::partition(vec.begin(), vec.end(), esPar);

    // Mostrar los elementos particionados
    std::cout << "Elementos después de std::partition: ";
    for (int elem : vec) {
        std::cout << elem << " ";
    }
    std::cout << std::endl;

    // Mostrar el punto de partición
    std::cout << "Punto de partición: " << *it << std::endl;

    return 0;
}
```

En este ejemplo:
- `std::partition(vec.begin(), vec.end(), esPar)` reorganiza los elementos de `vec` para que todos los números pares estén antes de los impares. Devuelve un iterador al primer elemento que no satisface el predicado `esPar`.

### Uso con Diferentes Tipos de Contenedores

`std::partition` se puede usar con cualquier contenedor que soporte iteradores de avance, como `std::vector`, `std::list`, `std::deque`, etc.

##### Ejemplo con `std::list`

```cpp
#include <iostream>
#include <list>
#include <algorithm>

bool esPositivo(int n) {
    return n > 0;
}

int main() {
    std::list<int> lst = {-1, 2, -3, 4, -5, 6};

    // Usar std::partition para particionar los elementos
    auto it = std::partition(lst.begin(), lst.end(), esPositivo);

    // Mostrar los elementos particionados
    std::cout << "Elementos de la lista después de std::partition: ";
    for (int elem : lst) {
        std::cout << elem << " ";
    }
    std::cout << std::endl;

    // Mostrar el punto de partición
    std::cout << "Punto de partición: " << *it << std::endl;

    return 0;
}
```

En este ejemplo:
- `std::partition` se utiliza para reorganizar los elementos de la lista `lst` de modo que todos los números positivos estén antes de los negativos.

### Variantes: `std::stable_partition`

`std::stable_partition` es una variante de `std::partition` que preserva el orden relativo de los elementos que satisfacen el predicado y los que no lo satisfacen.

#### Sintaxis de `std::stable_partition`

```cpp
#include <algorithm>

template <class ForwardIt, class UnaryPredicate>
ForwardIt stable_partition(ForwardIt first, ForwardIt last, UnaryPredicate p);
```

- **`ForwardIt first`**: Iterador al primer elemento del rango.
- **`ForwardIt last`**: Iterador al elemento después del último en el rango.
- **`UnaryPredicate p`**: Predicado que define la condición de partición.

#### Ejemplo de Uso de `std::stable_partition`

##### Ejemplo Básico con `std::stable_partition`

```cpp
#include <iostream>
#include <vector>
#include <algorithm>

bool esPar(int n) {
    return n % 2 == 0;
}

int main() {
    std::vector<int> vec = {1, 2, 3, 4, 5, 6};

    // Usar std::stable_partition para particionar los elementos
    auto it = std::stable_partition(vec.begin(), vec.end(), esPar);

    // Mostrar los elementos particionados
    std::cout << "Elementos después de std::stable_partition: ";
    for (int elem : vec) {
        std::cout << elem << " ";
    }
    std::cout << std::endl;

    // Mostrar el punto de partición
    std::cout << "Punto de partición: " << *it << std::endl;

    return 0;
}
```

En este ejemplo:
- `std::stable_partition(vec.begin(), vec.end(), esPar)` reorganiza los elementos de `vec` para que todos los números pares estén antes de los impares, preservando el orden relativo de los elementos.

### Consideraciones

- **Rendimiento:** `std::partition` y `std::stable_partition` tienen un rendimiento lineal (`O(n)`), ya que necesitan recorrer todo el rango de elementos. `std::stable_partition` es generalmente más lento debido a que preserva el orden relativo de los elementos.
- **Requisitos de Iteradores:** `std::partition` y `std::stable_partition` requieren iteradores de avance. Para contenedores que solo proporcionan iteradores de una sola dirección, se debe usar una alternativa.
- **Uso de Predicados:** Ambos algoritmos pueden utilizar funciones, funtores y lambdas como predicados, proporcionando una gran flexibilidad.

### Conclusión

`std::partition` y `std::stable_partition` son algoritmos útiles de la biblioteca estándar de C++ que permiten reorganizar elementos de un contenedor en base a una condición específica. `std::partition` proporciona una partición eficiente, mientras que `std::stable_partition` preserva el orden relativo de los elementos. Comprender y utilizar estos algoritmos es esencial para realizar particiones eficientes y flexibles en contenedores en C++.
### Algoritmos de la Biblioteca Estándar: `std::lower_bound` y `std::upper_bound`

Los algoritmos `std::lower_bound` y `std::upper_bound` son parte de la biblioteca estándar de C++ y se utilizan para realizar búsquedas en contenedores ordenados. Estas funciones permiten encontrar posiciones específicas de elementos en rangos ordenados de manera eficiente utilizando la búsqueda binaria. Son parte del encabezado `<algorithm>`.

#### `std::lower_bound`

`std::lower_bound` encuentra el primer elemento en un rango ordenado que no es menor que un valor especificado.

##### Sintaxis

```cpp
#include <algorithm>

template <class ForwardIt, class T>
ForwardIt lower_bound(ForwardIt first, ForwardIt last, const T& value);

template <class ForwardIt, class T, class Compare>
ForwardIt lower_bound(ForwardIt first, ForwardIt last, const T& value, Compare comp);
```

- **`ForwardIt first`**: Iterador al primer elemento del rango.
- **`ForwardIt last`**: Iterador al elemento después del último en el rango.
- **`const T& value`**: Valor que se busca.
- **`Compare comp`**: (Opcional) Función de comparación que toma dos argumentos.

##### Descripción

`std::lower_bound` realiza una búsqueda binaria en el rango `[first, last)` para encontrar el primer elemento que no es menor que `value`. Si `comp` se proporciona, se utiliza como función de comparación en lugar del operador `<`.

#### Ejemplo de Uso de `std::lower_bound`

```cpp
#include <iostream>
#include <vector>
#include <algorithm>

int main() {
    std::vector<int> vec = {1, 2, 3, 4, 5, 6, 7, 8, 9};

    // Usar std::lower_bound para encontrar el primer elemento no menor que 5
    auto it = std::lower_bound(vec.begin(), vec.end(), 5);

    // Mostrar el resultado
    if (it != vec.end()) {
        std::cout << "El primer elemento no menor que 5 es: " << *it << std::endl;
    } else {
        std::cout << "No se encontró un elemento no menor que 5" << std::endl;
    }

    return 0;
}
```

En este ejemplo:
- `std::lower_bound(vec.begin(), vec.end(), 5)` devuelve un iterador al primer elemento en `vec` que no es menor que `5`.

### `std::upper_bound`

`std::upper_bound` encuentra el primer elemento en un rango ordenado que es mayor que un valor especificado.

##### Sintaxis

```cpp
#include <algorithm>

template <class ForwardIt, class T>
ForwardIt upper_bound(ForwardIt first, ForwardIt last, const T& value);

template <class ForwardIt, class T, class Compare>
ForwardIt upper_bound(ForwardIt first, ForwardIt last, const T& value, Compare comp);
```

- **`ForwardIt first`**: Iterador al primer elemento del rango.
- **`ForwardIt last`**: Iterador al elemento después del último en el rango.
- **`const T& value`**: Valor que se busca.
- **`Compare comp`**: (Opcional) Función de comparación que toma dos argumentos.

##### Descripción

`std::upper_bound` realiza una búsqueda binaria en el rango `[first, last)` para encontrar el primer elemento que es mayor que `value`. Si `comp` se proporciona, se utiliza como función de comparación en lugar del operador `<`.

#### Ejemplo de Uso de `std::upper_bound`

```cpp
#include <iostream>
#include <vector>
#include <algorithm>

int main() {
    std::vector<int> vec = {1, 2, 3, 4, 5, 6, 7, 8, 9};

    // Usar std::upper_bound para encontrar el primer elemento mayor que 5
    auto it = std::upper_bound(vec.begin(), vec.end(), 5);

    // Mostrar el resultado
    if (it != vec.end()) {
        std::cout << "El primer elemento mayor que 5 es: " << *it << std::endl;
    } else {
        std::cout << "No se encontró un elemento mayor que 5" << std::endl;
    }

    return 0;
}
```

En este ejemplo:
- `std::upper_bound(vec.begin(), vec.end(), 5)` devuelve un iterador al primer elemento en `vec` que es mayor que `5`.

### Uso con Comparaciones Personalizadas

Tanto `std::lower_bound` como `std::upper_bound` pueden utilizar una función de comparación personalizada para realizar búsquedas en rangos ordenados según un criterio específico.

##### Ejemplo con Comparación Personalizada

```cpp
#include <iostream>
#include <vector>
#include <algorithm>

struct Persona {
    std::string nombre;
    int edad;
};

bool compararPorEdad(const Persona& a, const Persona& b) {
    return a.edad < b.edad;
}

int main() {
    std::vector<Persona> personas = {{"Ana", 25}, {"Luis", 30}, {"Carlos", 22}, {"Maria", 28}};

    // Ordenar las personas por edad
    std::sort(personas.begin(), personas.end(), compararPorEdad);

    Persona p = {"", 28}; // Solo la edad importa para la búsqueda

    // Usar std::lower_bound con comparación personalizada
    auto it = std::lower_bound(personas.begin(), personas.end(), p, compararPorEdad);

    // Mostrar el resultado
    if (it != personas.end()) {
        std::cout << "Primera persona con edad no menor que 28: " << it->nombre << " (" << it->edad << ")" << std::endl;
    } else {
        std::cout << "No se encontró una persona con edad no menor que 28" << std::endl;
    }

    return 0;
}
```

En este ejemplo:
- `std::lower_bound(personas.begin(), personas.end(), p, compararPorEdad)` utiliza una función de comparación personalizada para encontrar la primera persona cuya edad no es menor que `28`.

### Consideraciones

- **Rendimiento:** Tanto `std::lower_bound` como `std::upper_bound` tienen un rendimiento logarítmico (`O(log n)`) debido a la búsqueda binaria.
- **Orden:** Los rangos de entrada deben estar ordenados según el criterio de comparación utilizado (ya sea por el operador `<` o una función de comparación personalizada).
- **Iteradores:** Estos algoritmos requieren iteradores de avance o mejor, ya que utilizan operaciones de búsqueda binaria.

### Conclusión

`std::lower_bound` y `std::upper_bound` son algoritmos de búsqueda binaria eficientes de la biblioteca estándar de C++ que permiten encontrar posiciones específicas de elementos en rangos ordenados. Son fundamentales para trabajar con contenedores ordenados y pueden utilizar comparaciones personalizadas para realizar búsquedas según criterios específicos. Comprender y utilizar estos algoritmos es esencial para realizar búsquedas rápidas y eficientes en contenedores en C++.
### Algoritmo de la Biblioteca Estándar: `std::nth_element`

La función `std::nth_element` es un algoritmo de la biblioteca estándar de C++ que se utiliza para reorganizar los elementos de un rango de manera que el elemento en la posición n (índice) sea el que estaría en esa posición si el rango estuviera completamente ordenado. Todos los elementos precedentes al n-ésimo son menores o iguales, y todos los elementos posteriores son mayores o iguales. Es parte del encabezado `<algorithm>`.

#### Sintaxis de `std::nth_element`

```cpp
#include <algorithm>

template <class RandomIt>
void nth_element(RandomIt first, RandomIt nth, RandomIt last);

template <class RandomIt, class Compare>
void nth_element(RandomIt first, RandomIt nth, RandomIt last, Compare comp);
```

- **`RandomIt first`**: Iterador al primer elemento del rango.
- **`RandomIt nth`**: Iterador al elemento que será el n-ésimo en el rango ordenado.
- **`RandomIt last`**: Iterador al elemento después del último en el rango.
- **`Compare comp`**: (Opcional) Función de comparación que toma dos argumentos.

#### Descripción

`std::nth_element` reorganiza los elementos en el rango `[first, last)` de manera que el elemento en la posición `nth` sea el mismo que estaría en esa posición si el rango estuviera ordenado. Todos los elementos precedentes a `nth` serán menores o iguales que el elemento en `nth`, y todos los elementos posteriores serán mayores o iguales.

#### Ejemplo de Uso de `std::nth_element`

##### Ejemplo Básico

```cpp
#include <iostream>
#include <vector>
#include <algorithm>

int main() {
    std::vector<int> vec = {10, 4, 5, 8, 6, 11, 26};

    // Encontrar el tercer elemento más pequeño (índice 2)
    std::nth_element(vec.begin(), vec.begin() + 2, vec.end());

    // Mostrar el tercer elemento más pequeño
    std::cout << "El tercer elemento más pequeño es: " << vec[2] << std::endl;

    // Mostrar todos los elementos
    std::cout << "Elementos del vector después de std::nth_element: ";
    for (int elem : vec) {
        std::cout << elem << " ";
    }
    std::cout << std::endl;

    return 0;
}
```

En este ejemplo:
- `std::nth_element(vec.begin(), vec.begin() + 2, vec.end())` coloca el tercer elemento más pequeño en la posición `vec[2]`.

### Uso con Comparación Personalizada

Puedes utilizar `std::nth_element` con una función de comparación personalizada para ordenar según un criterio específico.

##### Ejemplo con Comparación Personalizada

```cpp
#include <iostream>
#include <vector>
#include <algorithm>

struct Persona {
    std::string nombre;
    int edad;
};

bool compararPorEdad(const Persona& a, const Persona& b) {
    return a.edad < b.edad;
}

int main() {
    std::vector<Persona> personas = {{"Ana", 25}, {"Luis", 30}, {"Carlos", 22}, {"Maria", 28}, {"Jose", 24}};

    // Encontrar la tercera persona más joven
    std::nth_element(personas.begin(), personas.begin() + 2, personas.end(), compararPorEdad);

    // Mostrar la tercera persona más joven
    std::cout << "La tercera persona más joven es: " << personas[2].nombre << " (" << personas[2].edad << ")" << std::endl;

    // Mostrar todas las personas
    std::cout << "Personas después de std::nth_element: ";
    for (const auto& persona : personas) {
        std::cout << persona.nombre << " (" << persona.edad << "), ";
    }
    std::cout << std::endl;

    return 0;
}
```

En este ejemplo:
- `std::nth_element(personas.begin(), personas.begin() + 2, personas.end(), compararPorEdad)` coloca la tercera persona más joven en la posición `personas[2]`.

### Consideraciones

- **Rendimiento:** `std::nth_element` tiene una complejidad promedio de `O(n)`, pero en el peor de los casos puede ser `O(n log n)`.
- **Uso de Comparadores:** Se puede utilizar una función de comparación personalizada para ordenar según criterios específicos.
- **Requisitos de Iteradores:** `std::nth_element` requiere iteradores de acceso aleatorio, por lo que no puede utilizarse con contenedores que solo proporcionan iteradores de una sola dirección o bidireccionales, como `std::list`.

### Conclusión

`std::nth_element` es un algoritmo eficiente de la biblioteca estándar de C++ que permite encontrar y colocar el n-ésimo elemento en su posición correspondiente en un rango ordenado, asegurando que todos los elementos anteriores sean menores o iguales y todos los posteriores sean mayores o iguales. Su uso con comparaciones personalizadas proporciona flexibilidad para ordenar según criterios específicos. Comprender y utilizar `std::nth_element` es esencial para realizar operaciones de selección eficientes en contenedores en C++.
### Algoritmo de la Biblioteca Estándar: `std::merge`

La función `std::merge` es un algoritmo de la biblioteca estándar de C++ que se utiliza para fusionar dos rangos ordenados en un solo rango ordenado. Es parte del encabezado `<algorithm>` y es útil para combinar datos de manera eficiente mientras se mantiene el orden.

#### Sintaxis de `std::merge`

```cpp
#include <algorithm>

template <class InputIt1, class InputIt2, class OutputIt>
OutputIt merge(InputIt1 first1, InputIt1 last1, InputIt2 first2, InputIt2 last2, OutputIt d_first);

template <class InputIt1, class InputIt2, class OutputIt, class Compare>
OutputIt merge(InputIt1 first1, InputIt1 last1, InputIt2 first2, InputIt2 last2, OutputIt d_first, Compare comp);
```

- **`InputIt1 first1`**: Iterador al primer elemento del primer rango.
- **`InputIt1 last1`**: Iterador al elemento después del último en el primer rango.
- **`InputIt2 first2`**: Iterador al primer elemento del segundo rango.
- **`InputIt2 last2`**: Iterador al elemento después del último en el segundo rango.
- **`OutputIt d_first`**: Iterador al primer elemento del rango de destino.
- **`Compare comp`**: (Opcional) Función de comparación que toma dos argumentos.

#### Descripción

`std::merge` fusiona dos rangos ordenados `[first1, last1)` y `[first2, last2)` en un solo rango ordenado comenzando en `d_first`. El rango de salida debe ser lo suficientemente grande para contener todos los elementos fusionados. Si se proporciona una función de comparación `comp`, se utiliza para ordenar los elementos en lugar del operador `<`.

#### Ejemplo de Uso de `std::merge`

##### Ejemplo Básico

```cpp
#include <iostream>
#include <vector>
#include <algorithm>

int main() {
    std::vector<int> vec1 = {1, 3, 5, 7};
    std::vector<int> vec2 = {2, 4, 6, 8};
    std::vector<int> result(vec1.size() + vec2.size());

    // Usar std::merge para fusionar los dos vectores ordenados
    std::merge(vec1.begin(), vec1.end(), vec2.begin(), vec2.end(), result.begin());

    // Mostrar los elementos fusionados
    std::cout << "Elementos fusionados: ";
    for (int elem : result) {
        std::cout << elem << " ";
    }
    std::cout << std::endl;

    return 0;
}
```

En este ejemplo:
- `std::merge(vec1.begin(), vec1.end(), vec2.begin(), vec2.end(), result.begin())` fusiona los elementos de `vec1` y `vec2` en `result`.

### Uso con Comparación Personalizada

`std::merge` puede utilizar una función de comparación personalizada para ordenar según un criterio específico.

##### Ejemplo con Comparación Personalizada

```cpp
#include <iostream>
#include <vector>
#include <algorithm>

struct Persona {
    std::string nombre;
    int edad;
};

bool compararPorEdad(const Persona& a, const Persona& b) {
    return a.edad < b.edad;
}

int main() {
    std::vector<Persona> grupo1 = {{"Ana", 25}, {"Carlos", 30}};
    std::vector<Persona> grupo2 = {{"Luis", 22}, {"Maria", 28}};
    std::vector<Persona> resultado(grupo1.size() + grupo2.size());

    // Usar std::merge con comparación personalizada para fusionar los dos vectores ordenados
    std::merge(grupo1.begin(), grupo1.end(), grupo2.begin(), grupo2.end(), resultado.begin(), compararPorEdad);

    // Mostrar las personas fusionadas
    std::cout << "Personas fusionadas: ";
    for (const auto& persona : resultado) {
        std::cout << persona.nombre << " (" << persona.edad << "), ";
    }
    std::cout << std::endl;

    return 0;
}
```

En este ejemplo:
- `std::merge(grupo1.begin(), grupo1.end(), grupo2.begin(), grupo2.end(), resultado.begin(), compararPorEdad)` fusiona los elementos de `grupo1` y `grupo2` en `resultado` utilizando la función de comparación `compararPorEdad`.

### Consideraciones

- **Rendimiento:** `std::merge` tiene una complejidad lineal (`O(N)`) respecto a la suma de los tamaños de los dos rangos de entrada.
- **Orden:** Los rangos de entrada deben estar ordenados de acuerdo con el mismo criterio de comparación (ya sea el operador `<` o una función de comparación personalizada).
- **Tamaño del Rango de Salida:** El rango de salida debe ser lo suficientemente grande para contener todos los elementos fusionados. Asegúrate de reservar el espacio necesario antes de llamar a `std::merge`.

### Variantes: `std::inplace_merge`

`std::inplace_merge` es una variante que fusiona dos rangos adyacentes dentro de un mismo contenedor.

#### Sintaxis de `std::inplace_merge`

```cpp
#include <algorithm>

template <class BidirIt>
void inplace_merge(BidirIt first, BidirIt middle, BidirIt last);

template <class BidirIt, class Compare>
void inplace_merge(BidirIt first, BidirIt middle, BidirIt last, Compare comp);
```

- **`BidirIt first`**: Iterador al primer elemento del primer rango.
- **`BidirIt middle`**: Iterador al primer elemento del segundo rango.
- **`BidirIt last`**: Iterador al elemento después del último en el segundo rango.
- **`Compare comp`**: (Opcional) Función de comparación que toma dos argumentos.

#### Ejemplo de Uso de `std::inplace_merge`

```cpp
#include <iostream>
#include <vector>
#include <algorithm>

int main() {
    std::vector<int> vec = {1, 3, 5, 7, 2, 4, 6, 8};

    // Usar std::inplace_merge para fusionar los dos rangos adyacentes
    std::inplace_merge(vec.begin(), vec.begin() + 4, vec.end());

    // Mostrar los elementos fusionados
    std::cout << "Elementos después de std::inplace_merge: ";
    for (int elem : vec) {
        std::cout << elem << " ";
    }
    std::cout << std::endl;

    return 0;
}
```

En este ejemplo:
- `std::inplace_merge(vec.begin(), vec.begin() + 4, vec.end())` fusiona los dos rangos adyacentes `{1, 3, 5, 7}` y `{2, 4, 6, 8}` dentro del mismo contenedor `vec`.

### Conclusión

`std::merge` y `std::inplace_merge` son algoritmos de la biblioteca estándar de C++ que proporcionan formas eficientes de fusionar rangos ordenados en un solo rango ordenado. `std::merge` es útil cuando se trabaja con rangos de entrada separados y un rango de salida distinto, mientras que `std::inplace_merge` permite fusionar rangos adyacentes dentro de un mismo contenedor. Comprender y utilizar estos algoritmos es esencial para realizar fusiones eficientes y mantener el orden en contenedores en C++.
### Algoritmos de la Biblioteca Estándar: `std::set_intersection`

El algoritmo `std::set_intersection` es parte de la biblioteca estándar de C++ y se utiliza para encontrar la intersección de dos rangos ordenados, es decir, los elementos que están presentes en ambos rangos. Es parte del encabezado `<algorithm>`.

#### Sintaxis de `std::set_intersection`

```cpp
#include <algorithm>

template <class InputIt1, class InputIt2, class OutputIt>
OutputIt set_intersection(InputIt1 first1, InputIt1 last1, InputIt2 first2, InputIt2 last2, OutputIt d_first);

template <class InputIt1, class InputIt2, class OutputIt, class Compare>
OutputIt set_intersection(InputIt1 first1, InputIt1 last1, InputIt2 first2, InputIt2 last2, OutputIt d_first, Compare comp);
```

- **`InputIt1 first1`**: Iterador al primer elemento del primer rango.
- **`InputIt1 last1`**: Iterador al elemento después del último en el primer rango.
- **`InputIt2 first2`**: Iterador al primer elemento del segundo rango.
- **`InputIt2 last2`**: Iterador al elemento después del último en el segundo rango.
- **`OutputIt d_first`**: Iterador al primer elemento del rango de destino.
- **`Compare comp`**: (Opcional) Función de comparación que toma dos argumentos.

#### Descripción

`std::set_intersection` copia los elementos que están presentes en ambos rangos ordenados `[first1, last1)` y `[first2, last2)` en el rango comenzando en `d_first`. Si se proporciona una función de comparación `comp`, se utiliza para comparar los elementos en lugar del operador `<`.

#### Ejemplo de Uso de `std::set_intersection`

##### Ejemplo Básico

```cpp
#include <iostream>
#include <vector>
#include <algorithm>

int main() {
    std::vector<int> vec1 = {1, 2, 3, 4, 5};
    std::vector<int> vec2 = {3, 4, 5, 6, 7};
    std::vector<int> result;

    // Reservar espacio suficiente para el resultado
    result.reserve(std::min(vec1.size(), vec2.size()));

    // Usar std::set_intersection para encontrar la intersección de los dos vectores
    auto it = std::set_intersection(vec1.begin(), vec1.end(), vec2.begin(), vec2.end(), std::back_inserter(result));

    // Mostrar los elementos de la intersección
    std::cout << "Elementos de la intersección: ";
    for (int elem : result) {
        std::cout << elem << " ";
    }
    std::cout << std::endl;

    return 0;
}
```

En este ejemplo:
- `std::set_intersection(vec1.begin(), vec1.end(), vec2.begin(), vec2.end(), std::back_inserter(result))` encuentra los elementos que están presentes en ambos vectores `vec1` y `vec2` y los copia en `result`.

### Uso con Comparación Personalizada

`std::set_intersection` puede utilizar una función de comparación personalizada para comparar elementos según un criterio específico.

##### Ejemplo con Comparación Personalizada

```cpp
#include <iostream>
#include <vector>
#include <algorithm>

struct Persona {
    std::string nombre;
    int edad;
};

bool compararPorEdad(const Persona& a, const Persona& b) {
    return a.edad < b.edad;
}

bool igualEdad(const Persona& a, const Persona& b) {
    return a.edad == b.edad;
}

int main() {
    std::vector<Persona> grupo1 = {{"Ana", 25}, {"Carlos", 30}, {"Jose", 28}};
    std::vector<Persona> grupo2 = {{"Luis", 22}, {"Maria", 28}, {"Pedro", 30}};
    std::vector<Persona> resultado;

    // Ordenar los vectores por edad
    std::sort(grupo1.begin(), grupo1.end(), compararPorEdad);
    std::sort(grupo2.begin(), grupo2.end(), compararPorEdad);

    // Usar std::set_intersection con comparación personalizada para encontrar la intersección
    std::set_intersection(grupo1.begin(), grupo1.end(), grupo2.begin(), grupo2.end(), std::back_inserter(resultado), compararPorEdad);

    // Mostrar las personas en la intersección
    std::cout << "Personas en la intersección: ";
    for (const auto& persona : resultado) {
        std::cout << persona.nombre << " (" << persona.edad << "), ";
    }
    std::cout << std::endl;

    return 0;
}
```

En este ejemplo:
- `std::set_intersection(grupo1.begin(), grupo1.end(), grupo2.begin(), grupo2.end(), std::back_inserter(resultado), compararPorEdad)` encuentra las personas con la misma edad en ambos vectores `grupo1` y `grupo2` y las copia en `resultado`.

### Consideraciones

- **Rendimiento:** `std::set_intersection` tiene una complejidad lineal (`O(N + M)`), donde `N` y `M` son los tamaños de los dos rangos de entrada.
- **Orden:** Los rangos de entrada deben estar ordenados según el mismo criterio de comparación (ya sea por el operador `<` o una función de comparación personalizada).
- **Tamaño del Rango de Salida:** El rango de salida debe ser lo suficientemente grande para contener todos los elementos de la intersección. Utilizar `std::back_inserter` puede ser conveniente para manejar esto automáticamente.

### Variantes Relacionadas

Existen otros algoritmos similares que trabajan con conjuntos ordenados, como `std::set_union`, `std::set_difference` y `std::set_symmetric_difference`, cada uno de los cuales realiza una operación específica sobre dos conjuntos ordenados.

#### `std::set_union`

Copia los elementos presentes en al menos uno de los dos rangos ordenados.

##### Sintaxis

```cpp
template <class InputIt1, class InputIt2, class OutputIt>
OutputIt set_union(InputIt1 first1, InputIt1 last1, InputIt2 first2, InputIt2 last2, OutputIt d_first);

template <class InputIt1, class InputIt2, class OutputIt, class Compare>
OutputIt set_union(InputIt1 first1, InputIt1 last1, InputIt2 first2, InputIt2 last2, OutputIt d_first, Compare comp);
```

#### `std::set_difference`

Copia los elementos presentes en el primer rango pero no en el segundo.

##### Sintaxis

```cpp
template <class InputIt1, class InputIt2, class OutputIt>
OutputIt set_difference(InputIt1 first1, InputIt1 last1, InputIt2 first2, InputIt2 last2, OutputIt d_first);

template <class InputIt1, class InputIt2, class OutputIt, class Compare>
OutputIt set_difference(InputIt1 first1, InputIt1 last1, InputIt2 first2, InputIt2 last2, OutputIt d_first, Compare comp);
```

#### `std::set_symmetric_difference`

Copia los elementos presentes en exactamente uno de los dos rangos ordenados.

##### Sintaxis

```cpp
template <class InputIt1, class InputIt2, class OutputIt>
OutputIt set_symmetric_difference(InputIt1 first1, InputIt1 last1, InputIt2 first2, InputIt2 last2, OutputIt d_first);

template <class InputIt1, class InputIt2, class OutputIt, class Compare>
OutputIt set_symmetric_difference(InputIt1 first1, InputIt1 last1, InputIt2 first2, InputIt2 last2, OutputIt d_first, Compare comp);
```

### Conclusión

`std::set_intersection` es un algoritmo eficiente de la biblioteca estándar de C++ que permite encontrar la intersección de dos rangos ordenados. Es fundamental para trabajar con conjuntos de datos ordenados y puede utilizar comparaciones personalizadas para manejar criterios específicos. Comprender y utilizar `std::set_intersection`, junto con otros algoritmos relacionados como `std::set_union`, `std::set_difference` y `std::set_symmetric_difference`, es esencial para realizar operaciones de conjuntos eficientes en C++.
<---FILES--->
Ejemplo Básico
Ejemplo Básico Result
Ejemplo con Lambda
Ejemplo con Lambda Result
Ejemplo Básico
Ejemplo Básico Result
Ejemplo con Lambda
Ejemplo con Lambda Result
Ejemplo Básico
Ejemplo Básico Result
Ejemplo con Lambda
Ejemplo con Lambda Result
Ejemplo Básico (Suma)
Ejemplo Básico (Suma) Result
Ejemplo con Operación Binaria Personalizada (Multiplicación)
Ejemplo con Operación Binaria Personalizada (Multiplicación) Result
Ejemplo Básico
Ejemplo Básico Result
Ejemplo con Lambda
Ejemplo con Lambda Result
Ejemplo Básico (Suma)
Ejemplo Básico (Suma) Result
Ejemplo con Operación Binaria Personalizada (Multiplicación)
Ejemplo con Operación Binaria Personalizada (Multiplicación) Result
`std::max`
`std::max` Result
`std::min`
`std::min` Result
Ejemplo Básico con Dos Valores
Ejemplo Básico con Dos Valores Result
Ejemplo con Comparación Personalizada
Ejemplo con Comparación Personalizada Result
Ejemplo Básico con un Rango de Elementos
Ejemplo Básico con un Rango de Elementos Result
Ejemplo Básico
Ejemplo Básico Result
Ejemplo con Lambda
Ejemplo con Lambda Result
Ejemplo Básico (Suma)
Ejemplo Básico (Suma) Result
Ejemplo con Operación Binaria Personalizada (Multiplicación)
Ejemplo con Operación Binaria Personalizada (Multiplicación) Result
`std::max`
`std::max` Result
`std::min`
`std::min` Result
Ejemplo Básico con Dos Valores
Ejemplo Básico con Dos Valores Result
Ejemplo con Comparación Personalizada
Ejemplo con Comparación Personalizada Result
Ejemplo Básico con un Rango de Elementos
Ejemplo Básico con un Rango de Elementos Result
Sintaxis
Sintaxis Result
Ejemplo de Uso de `std::find`
Ejemplo de Uso de `std::find` Result
Ejemplo de Uso de `std::find_if`
Ejemplo de Uso de `std::find_if` Result
Ejemplo de Uso de `std::find_if` con Lambda
Ejemplo de Uso de `std::find_if` con Lambda Result
Ejemplo Básico
Ejemplo Básico Result
Ejemplo con Lambda
Ejemplo con Lambda Result
Ejemplo Básico (Suma)
Ejemplo Básico (Suma) Result
Ejemplo con Operación Binaria Personalizada (Multiplicación)
Ejemplo con Operación Binaria Personalizada (Multiplicación) Result
`std::max`
`std::max` Result
`std::min`
`std::min` Result
Ejemplo Básico con Dos Valores
Ejemplo Básico con Dos Valores Result
Ejemplo con Comparación Personalizada
Ejemplo con Comparación Personalizada Result
Ejemplo Básico con un Rango de Elementos
Ejemplo Básico con un Rango de Elementos Result
Sintaxis
Sintaxis Result
Ejemplo de Uso de `std::find`
Ejemplo de Uso de `std::find` Result
Ejemplo de Uso de `std::find_if`
Ejemplo de Uso de `std::find_if` Result
Ejemplo de Uso de `std::find_if` con Lambda
Ejemplo de Uso de `std::find_if` con Lambda Result
Copiar Elementos entre Diferentes Contenedores
Copiar Elementos entre Diferentes Contenedores Result
Ejemplo Básico
Ejemplo Básico Result
Ejemplo con Lambda
Ejemplo con Lambda Result
Ejemplo Básico (Suma)
Ejemplo Básico (Suma) Result
Ejemplo con Operación Binaria Personalizada (Multiplicación)
Ejemplo con Operación Binaria Personalizada (Multiplicación) Result
`std::max`
`std::max` Result
`std::min`
`std::min` Result
Ejemplo Básico con Dos Valores
Ejemplo Básico con Dos Valores Result
Ejemplo con Comparación Personalizada
Ejemplo con Comparación Personalizada Result
Ejemplo Básico con un Rango de Elementos
Ejemplo Básico con un Rango de Elementos Result
Sintaxis
Sintaxis Result
Ejemplo de Uso de `std::find`
Ejemplo de Uso de `std::find` Result
Ejemplo de Uso de `std::find_if`
Ejemplo de Uso de `std::find_if` Result
Ejemplo de Uso de `std::find_if` con Lambda
Ejemplo de Uso de `std::find_if` con Lambda Result
Copiar Elementos entre Diferentes Contenedores
Copiar Elementos entre Diferentes Contenedores Result
Ejemplo Básico (Orden Ascendente)
Ejemplo Básico (Orden Ascendente) Result
Ejemplo con Comparación Personalizada (Orden Descendente)
Ejemplo con Comparación Personalizada (Orden Descendente) Result
Ordenar un `std::array`
Ordenar un `std::array` Result
Ejemplo Básico
Ejemplo Básico Result
Ejemplo con Lambda
Ejemplo con Lambda Result
Ejemplo Básico (Suma)
Ejemplo Básico (Suma) Result
Ejemplo con Operación Binaria Personalizada (Multiplicación)
Ejemplo con Operación Binaria Personalizada (Multiplicación) Result
`std::max`
`std::max` Result
`std::min`
`std::min` Result
Ejemplo Básico con Dos Valores
Ejemplo Básico con Dos Valores Result
Ejemplo con Comparación Personalizada
Ejemplo con Comparación Personalizada Result
Ejemplo Básico con un Rango de Elementos
Ejemplo Básico con un Rango de Elementos Result
Sintaxis
Sintaxis Result
Ejemplo de Uso de `std::find`
Ejemplo de Uso de `std::find` Result
Ejemplo de Uso de `std::find_if`
Ejemplo de Uso de `std::find_if` Result
Ejemplo de Uso de `std::find_if` con Lambda
Ejemplo de Uso de `std::find_if` con Lambda Result
Copiar Elementos entre Diferentes Contenedores
Copiar Elementos entre Diferentes Contenedores Result
Ejemplo Básico (Orden Ascendente)
Ejemplo Básico (Orden Ascendente) Result
Ejemplo con Comparación Personalizada (Orden Descendente)
Ejemplo con Comparación Personalizada (Orden Descendente) Result
Ordenar un `std::array`
Ordenar un `std::array` Result
Ejemplo Básico (Función Unaria)
Ejemplo Básico (Función Unaria) Result
Ejemplo con Función Binaria
Ejemplo con Función Binaria Result
Transformar una Lista
Transformar una Lista Result
Ejemplo Básico
Ejemplo Básico Result
Ejemplo con Lambda
Ejemplo con Lambda Result
Ejemplo Básico (Suma)
Ejemplo Básico (Suma) Result
Ejemplo con Operación Binaria Personalizada (Multiplicación)
Ejemplo con Operación Binaria Personalizada (Multiplicación) Result
`std::max`
`std::max` Result
`std::min`
`std::min` Result
Ejemplo Básico con Dos Valores
Ejemplo Básico con Dos Valores Result
Ejemplo con Comparación Personalizada
Ejemplo con Comparación Personalizada Result
Ejemplo Básico con un Rango de Elementos
Ejemplo Básico con un Rango de Elementos Result
Sintaxis
Sintaxis Result
Ejemplo de Uso de `std::find`
Ejemplo de Uso de `std::find` Result
Ejemplo de Uso de `std::find_if`
Ejemplo de Uso de `std::find_if` Result
Ejemplo de Uso de `std::find_if` con Lambda
Ejemplo de Uso de `std::find_if` con Lambda Result
Copiar Elementos entre Diferentes Contenedores
Copiar Elementos entre Diferentes Contenedores Result
Ejemplo Básico (Orden Ascendente)
Ejemplo Básico (Orden Ascendente) Result
Ejemplo con Comparación Personalizada (Orden Descendente)
Ejemplo con Comparación Personalizada (Orden Descendente) Result
Ordenar un `std::array`
Ordenar un `std::array` Result
Ejemplo Básico (Función Unaria)
Ejemplo Básico (Función Unaria) Result
Ejemplo con Función Binaria
Ejemplo con Función Binaria Result
Transformar una Lista
Transformar una Lista Result
Ejemplo con `std::array`
Ejemplo con `std::array` Result
Ejemplo con una Matriz
Ejemplo con una Matriz Result
Ejemplo de Rango Parcial
Ejemplo de Rango Parcial Result
Ejemplo Básico
Ejemplo Básico Result
Ejemplo con Lambda
Ejemplo con Lambda Result
Ejemplo Básico (Suma)
Ejemplo Básico (Suma) Result
Ejemplo con Operación Binaria Personalizada (Multiplicación)
Ejemplo con Operación Binaria Personalizada (Multiplicación) Result
`std::max`
`std::max` Result
`std::min`
`std::min` Result
Ejemplo Básico con Dos Valores
Ejemplo Básico con Dos Valores Result
Ejemplo con Comparación Personalizada
Ejemplo con Comparación Personalizada Result
Ejemplo Básico con un Rango de Elementos
Ejemplo Básico con un Rango de Elementos Result
Sintaxis
Sintaxis Result
Ejemplo de Uso de `std::find`
Ejemplo de Uso de `std::find` Result
Ejemplo de Uso de `std::find_if`
Ejemplo de Uso de `std::find_if` Result
Ejemplo de Uso de `std::find_if` con Lambda
Ejemplo de Uso de `std::find_if` con Lambda Result
Copiar Elementos entre Diferentes Contenedores
Copiar Elementos entre Diferentes Contenedores Result
Ejemplo Básico (Orden Ascendente)
Ejemplo Básico (Orden Ascendente) Result
Ejemplo con Comparación Personalizada (Orden Descendente)
Ejemplo con Comparación Personalizada (Orden Descendente) Result
Ordenar un `std::array`
Ordenar un `std::array` Result
Ejemplo Básico (Función Unaria)
Ejemplo Básico (Función Unaria) Result
Ejemplo con Función Binaria
Ejemplo con Función Binaria Result
Transformar una Lista
Transformar una Lista Result
Ejemplo con `std::array`
Ejemplo con `std::array` Result
Ejemplo con una Matriz
Ejemplo con una Matriz Result
Ejemplo de Rango Parcial
Ejemplo de Rango Parcial Result
Ejemplo con `std::list`
Ejemplo con `std::list` Result
Ejemplo Básico con `std::replace_if`
Ejemplo Básico con `std::replace_if` Result
Ejemplo Básico
Ejemplo Básico Result
Ejemplo con Lambda
Ejemplo con Lambda Result
Ejemplo Básico (Suma)
Ejemplo Básico (Suma) Result
Ejemplo con Operación Binaria Personalizada (Multiplicación)
Ejemplo con Operación Binaria Personalizada (Multiplicación) Result
`std::max`
`std::max` Result
`std::min`
`std::min` Result
Ejemplo Básico con Dos Valores
Ejemplo Básico con Dos Valores Result
Ejemplo con Comparación Personalizada
Ejemplo con Comparación Personalizada Result
Ejemplo Básico con un Rango de Elementos
Ejemplo Básico con un Rango de Elementos Result
Sintaxis
Sintaxis Result
Ejemplo de Uso de `std::find`
Ejemplo de Uso de `std::find` Result
Ejemplo de Uso de `std::find_if`
Ejemplo de Uso de `std::find_if` Result
Ejemplo de Uso de `std::find_if` con Lambda
Ejemplo de Uso de `std::find_if` con Lambda Result
Copiar Elementos entre Diferentes Contenedores
Copiar Elementos entre Diferentes Contenedores Result
Ejemplo Básico (Orden Ascendente)
Ejemplo Básico (Orden Ascendente) Result
Ejemplo con Comparación Personalizada (Orden Descendente)
Ejemplo con Comparación Personalizada (Orden Descendente) Result
Ordenar un `std::array`
Ordenar un `std::array` Result
Ejemplo Básico (Función Unaria)
Ejemplo Básico (Función Unaria) Result
Ejemplo con Función Binaria
Ejemplo con Función Binaria Result
Transformar una Lista
Transformar una Lista Result
Ejemplo con `std::array`
Ejemplo con `std::array` Result
Ejemplo con una Matriz
Ejemplo con una Matriz Result
Ejemplo de Rango Parcial
Ejemplo de Rango Parcial Result
Ejemplo con `std::list`
Ejemplo con `std::list` Result
Ejemplo Básico con `std::replace_if`
Ejemplo Básico con `std::replace_if` Result
Ejemplo Básico con `std::remove_if`
Ejemplo Básico con `std::remove_if` Result
Ejemplo Básico
Ejemplo Básico Result
Ejemplo con Lambda
Ejemplo con Lambda Result
Ejemplo Básico (Suma)
Ejemplo Básico (Suma) Result
Ejemplo con Operación Binaria Personalizada (Multiplicación)
Ejemplo con Operación Binaria Personalizada (Multiplicación) Result
`std::max`
`std::max` Result
`std::min`
`std::min` Result
Ejemplo Básico con Dos Valores
Ejemplo Básico con Dos Valores Result
Ejemplo con Comparación Personalizada
Ejemplo con Comparación Personalizada Result
Ejemplo Básico con un Rango de Elementos
Ejemplo Básico con un Rango de Elementos Result
Sintaxis
Sintaxis Result
Ejemplo de Uso de `std::find`
Ejemplo de Uso de `std::find` Result
Ejemplo de Uso de `std::find_if`
Ejemplo de Uso de `std::find_if` Result
Ejemplo de Uso de `std::find_if` con Lambda
Ejemplo de Uso de `std::find_if` con Lambda Result
Copiar Elementos entre Diferentes Contenedores
Copiar Elementos entre Diferentes Contenedores Result
Ejemplo Básico (Orden Ascendente)
Ejemplo Básico (Orden Ascendente) Result
Ejemplo con Comparación Personalizada (Orden Descendente)
Ejemplo con Comparación Personalizada (Orden Descendente) Result
Ordenar un `std::array`
Ordenar un `std::array` Result
Ejemplo Básico (Función Unaria)
Ejemplo Básico (Función Unaria) Result
Ejemplo con Función Binaria
Ejemplo con Función Binaria Result
Transformar una Lista
Transformar una Lista Result
Ejemplo con `std::array`
Ejemplo con `std::array` Result
Ejemplo con una Matriz
Ejemplo con una Matriz Result
Ejemplo de Rango Parcial
Ejemplo de Rango Parcial Result
Ejemplo con `std::list`
Ejemplo con `std::list` Result
Ejemplo Básico con `std::replace_if`
Ejemplo Básico con `std::replace_if` Result
Ejemplo Básico con `std::remove_if`
Ejemplo Básico con `std::remove_if` Result
Ejemplo de Subsección
Ejemplo de Subsección Result
Ejemplo con `std::string`
Ejemplo con `std::string` Result
Ejemplo Básico
Ejemplo Básico Result
Ejemplo con Lambda
Ejemplo con Lambda Result
Ejemplo Básico (Suma)
Ejemplo Básico (Suma) Result
Ejemplo con Operación Binaria Personalizada (Multiplicación)
Ejemplo con Operación Binaria Personalizada (Multiplicación) Result
`std::max`
`std::max` Result
`std::min`
`std::min` Result
Ejemplo Básico con Dos Valores
Ejemplo Básico con Dos Valores Result
Ejemplo con Comparación Personalizada
Ejemplo con Comparación Personalizada Result
Ejemplo Básico con un Rango de Elementos
Ejemplo Básico con un Rango de Elementos Result
Sintaxis
Sintaxis Result
Ejemplo de Uso de `std::find`
Ejemplo de Uso de `std::find` Result
Ejemplo de Uso de `std::find_if`
Ejemplo de Uso de `std::find_if` Result
Ejemplo de Uso de `std::find_if` con Lambda
Ejemplo de Uso de `std::find_if` con Lambda Result
Copiar Elementos entre Diferentes Contenedores
Copiar Elementos entre Diferentes Contenedores Result
Ejemplo Básico (Orden Ascendente)
Ejemplo Básico (Orden Ascendente) Result
Ejemplo con Comparación Personalizada (Orden Descendente)
Ejemplo con Comparación Personalizada (Orden Descendente) Result
Ordenar un `std::array`
Ordenar un `std::array` Result
Ejemplo Básico (Función Unaria)
Ejemplo Básico (Función Unaria) Result
Ejemplo con Función Binaria
Ejemplo con Función Binaria Result
Transformar una Lista
Transformar una Lista Result
Ejemplo con `std::array`
Ejemplo con `std::array` Result
Ejemplo con una Matriz
Ejemplo con una Matriz Result
Ejemplo de Rango Parcial
Ejemplo de Rango Parcial Result
Ejemplo con `std::list`
Ejemplo con `std::list` Result
Ejemplo Básico con `std::replace_if`
Ejemplo Básico con `std::replace_if` Result
Ejemplo Básico con `std::remove_if`
Ejemplo Básico con `std::remove_if` Result
Ejemplo de Subsección
Ejemplo de Subsección Result
Ejemplo con `std::string`
Ejemplo con `std::string` Result
Ejemplo Básico con `std::stable_partition`
Ejemplo Básico con `std::stable_partition` Result
Ejemplo Básico
Ejemplo Básico Result
Ejemplo con Lambda
Ejemplo con Lambda Result
Ejemplo Básico (Suma)
Ejemplo Básico (Suma) Result
Ejemplo con Operación Binaria Personalizada (Multiplicación)
Ejemplo con Operación Binaria Personalizada (Multiplicación) Result
`std::max`
`std::max` Result
`std::min`
`std::min` Result
Ejemplo Básico con Dos Valores
Ejemplo Básico con Dos Valores Result
Ejemplo con Comparación Personalizada
Ejemplo con Comparación Personalizada Result
Ejemplo Básico con un Rango de Elementos
Ejemplo Básico con un Rango de Elementos Result
Sintaxis
Sintaxis Result
Ejemplo de Uso de `std::find`
Ejemplo de Uso de `std::find` Result
Ejemplo de Uso de `std::find_if`
Ejemplo de Uso de `std::find_if` Result
Ejemplo de Uso de `std::find_if` con Lambda
Ejemplo de Uso de `std::find_if` con Lambda Result
Copiar Elementos entre Diferentes Contenedores
Copiar Elementos entre Diferentes Contenedores Result
Ejemplo Básico (Orden Ascendente)
Ejemplo Básico (Orden Ascendente) Result
Ejemplo con Comparación Personalizada (Orden Descendente)
Ejemplo con Comparación Personalizada (Orden Descendente) Result
Ordenar un `std::array`
Ordenar un `std::array` Result
Ejemplo Básico (Función Unaria)
Ejemplo Básico (Función Unaria) Result
Ejemplo con Función Binaria
Ejemplo con Función Binaria Result
Transformar una Lista
Transformar una Lista Result
Ejemplo con `std::array`
Ejemplo con `std::array` Result
Ejemplo con una Matriz
Ejemplo con una Matriz Result
Ejemplo de Rango Parcial
Ejemplo de Rango Parcial Result
Ejemplo con `std::list`
Ejemplo con `std::list` Result
Ejemplo Básico con `std::replace_if`
Ejemplo Básico con `std::replace_if` Result
Ejemplo Básico con `std::remove_if`
Ejemplo Básico con `std::remove_if` Result
Ejemplo de Subsección
Ejemplo de Subsección Result
Ejemplo con `std::string`
Ejemplo con `std::string` Result
Ejemplo Básico con `std::stable_partition`
Ejemplo Básico con `std::stable_partition` Result
Descripción
Descripción Result
Ejemplo Básico
Ejemplo Básico Result
Ejemplo con Lambda
Ejemplo con Lambda Result
Ejemplo Básico (Suma)
Ejemplo Básico (Suma) Result
Ejemplo con Operación Binaria Personalizada (Multiplicación)
Ejemplo con Operación Binaria Personalizada (Multiplicación) Result
`std::max`
`std::max` Result
`std::min`
`std::min` Result
Ejemplo Básico con Dos Valores
Ejemplo Básico con Dos Valores Result
Ejemplo con Comparación Personalizada
Ejemplo con Comparación Personalizada Result
Ejemplo Básico con un Rango de Elementos
Ejemplo Básico con un Rango de Elementos Result
Sintaxis
Sintaxis Result
Ejemplo de Uso de `std::find`
Ejemplo de Uso de `std::find` Result
Ejemplo de Uso de `std::find_if`
Ejemplo de Uso de `std::find_if` Result
Ejemplo de Uso de `std::find_if` con Lambda
Ejemplo de Uso de `std::find_if` con Lambda Result
Copiar Elementos entre Diferentes Contenedores
Copiar Elementos entre Diferentes Contenedores Result
Ejemplo Básico (Orden Ascendente)
Ejemplo Básico (Orden Ascendente) Result
Ejemplo con Comparación Personalizada (Orden Descendente)
Ejemplo con Comparación Personalizada (Orden Descendente) Result
Ordenar un `std::array`
Ordenar un `std::array` Result
Ejemplo Básico (Función Unaria)
Ejemplo Básico (Función Unaria) Result
Ejemplo con Función Binaria
Ejemplo con Función Binaria Result
Transformar una Lista
Transformar una Lista Result
Ejemplo con `std::array`
Ejemplo con `std::array` Result
Ejemplo con una Matriz
Ejemplo con una Matriz Result
Ejemplo de Rango Parcial
Ejemplo de Rango Parcial Result
Ejemplo con `std::list`
Ejemplo con `std::list` Result
Ejemplo Básico con `std::replace_if`
Ejemplo Básico con `std::replace_if` Result
Ejemplo Básico con `std::remove_if`
Ejemplo Básico con `std::remove_if` Result
Ejemplo de Subsección
Ejemplo de Subsección Result
Ejemplo con `std::string`
Ejemplo con `std::string` Result
Ejemplo Básico con `std::stable_partition`
Ejemplo Básico con `std::stable_partition` Result
Descripción
Descripción Result
Ejemplo Básico
Ejemplo Básico Result
Ejemplo con Lambda
Ejemplo con Lambda Result
Ejemplo Básico (Suma)
Ejemplo Básico (Suma) Result
Ejemplo con Operación Binaria Personalizada (Multiplicación)
Ejemplo con Operación Binaria Personalizada (Multiplicación) Result
`std::max`
`std::max` Result
`std::min`
`std::min` Result
Ejemplo Básico con Dos Valores
Ejemplo Básico con Dos Valores Result
Ejemplo con Comparación Personalizada
Ejemplo con Comparación Personalizada Result
Ejemplo Básico con un Rango de Elementos
Ejemplo Básico con un Rango de Elementos Result
Sintaxis
Sintaxis Result
Ejemplo de Uso de `std::find`
Ejemplo de Uso de `std::find` Result
Ejemplo de Uso de `std::find_if`
Ejemplo de Uso de `std::find_if` Result
Ejemplo de Uso de `std::find_if` con Lambda
Ejemplo de Uso de `std::find_if` con Lambda Result
Copiar Elementos entre Diferentes Contenedores
Copiar Elementos entre Diferentes Contenedores Result
Ejemplo Básico (Orden Ascendente)
Ejemplo Básico (Orden Ascendente) Result
Ejemplo con Comparación Personalizada (Orden Descendente)
Ejemplo con Comparación Personalizada (Orden Descendente) Result
Ordenar un `std::array`
Ordenar un `std::array` Result
Ejemplo Básico (Función Unaria)
Ejemplo Básico (Función Unaria) Result
Ejemplo con Función Binaria
Ejemplo con Función Binaria Result
Transformar una Lista
Transformar una Lista Result
Ejemplo con `std::array`
Ejemplo con `std::array` Result
Ejemplo con una Matriz
Ejemplo con una Matriz Result
Ejemplo de Rango Parcial
Ejemplo de Rango Parcial Result
Ejemplo con `std::list`
Ejemplo con `std::list` Result
Ejemplo Básico con `std::replace_if`
Ejemplo Básico con `std::replace_if` Result
Ejemplo Básico con `std::remove_if`
Ejemplo Básico con `std::remove_if` Result
Ejemplo de Subsección
Ejemplo de Subsección Result
Ejemplo con `std::string`
Ejemplo con `std::string` Result
Ejemplo Básico con `std::stable_partition`
Ejemplo Básico con `std::stable_partition` Result
Descripción
Descripción Result
Ejemplo Básico
Ejemplo Básico Result
Ejemplo con Lambda
Ejemplo con Lambda Result
Ejemplo Básico (Suma)
Ejemplo Básico (Suma) Result
Ejemplo con Operación Binaria Personalizada (Multiplicación)
Ejemplo con Operación Binaria Personalizada (Multiplicación) Result
`std::max`
`std::max` Result
`std::min`
`std::min` Result
Ejemplo Básico con Dos Valores
Ejemplo Básico con Dos Valores Result
Ejemplo con Comparación Personalizada
Ejemplo con Comparación Personalizada Result
Ejemplo Básico con un Rango de Elementos
Ejemplo Básico con un Rango de Elementos Result
Sintaxis
Sintaxis Result
Ejemplo de Uso de `std::find`
Ejemplo de Uso de `std::find` Result
Ejemplo de Uso de `std::find_if`
Ejemplo de Uso de `std::find_if` Result
Ejemplo de Uso de `std::find_if` con Lambda
Ejemplo de Uso de `std::find_if` con Lambda Result
Copiar Elementos entre Diferentes Contenedores
Copiar Elementos entre Diferentes Contenedores Result
Ejemplo Básico (Orden Ascendente)
Ejemplo Básico (Orden Ascendente) Result
Ejemplo con Comparación Personalizada (Orden Descendente)
Ejemplo con Comparación Personalizada (Orden Descendente) Result
Ordenar un `std::array`
Ordenar un `std::array` Result
Ejemplo Básico (Función Unaria)
Ejemplo Básico (Función Unaria) Result
Ejemplo con Función Binaria
Ejemplo con Función Binaria Result
Transformar una Lista
Transformar una Lista Result
Ejemplo con `std::array`
Ejemplo con `std::array` Result
Ejemplo con una Matriz
Ejemplo con una Matriz Result
Ejemplo de Rango Parcial
Ejemplo de Rango Parcial Result
Ejemplo con `std::list`
Ejemplo con `std::list` Result
Ejemplo Básico con `std::replace_if`
Ejemplo Básico con `std::replace_if` Result
Ejemplo Básico con `std::remove_if`
Ejemplo Básico con `std::remove_if` Result
Ejemplo de Subsección
Ejemplo de Subsección Result
Ejemplo con `std::string`
Ejemplo con `std::string` Result
Ejemplo Básico con `std::stable_partition`
Ejemplo Básico con `std::stable_partition` Result
Descripción
Descripción Result
<---Ejemplo Básico--->
```cpp
#include <iostream>
#include <vector>
#include <algorithm>

bool esPositivo(int n) {
    return n > 0;
}

int main() {
    std::vector<int> vec = {1, 2, 3, 4, 5};

    // Verificar si todos los elementos son positivos
    bool todosPositivos = std::all_of(vec.begin(), vec.end(), esPositivo);

    if (todosPositivos) {
        std::cout << "Todos los elementos son positivos." << std::endl;
    } else {
        std::cout << "No todos los elementos son positivos." << std::endl;
    }

    return 0;
}
<---Ejemplo Básico Result--->
<---Ejemplo con Lambda--->
```cpp
#include <iostream>
#include <vector>
#include <algorithm>

int main() {
    std::vector<int> vec = {1, 2, 3, 4, 5};

    // Usar una lambda para verificar si todos los elementos son positivos
    bool todosPositivos = std::all_of(vec.begin(), vec.end(), [](int n) {
        return n > 0;
    });

    if (todosPositivos) {
        std::cout << "Todos los elementos son positivos." << std::endl;
    } else {
        std::cout << "No todos los elementos son positivos." << std::endl;
    }

    return 0;
}
```cpp
#include <iostream>
#include <vector>
#include <algorithm>

int main() {
    std::vector<int> vec = {2, 4, 6, 8, 10};

    // Usar una lambda para verificar si todos los elementos son pares
    bool todosPares = std::all_of(vec.begin(), vec.end(), [](int n) {
        return n % 2 == 0;
    });

    if (todosPares) {
        std::cout << "Todos los elementos son pares." << std::endl;
    } else {
        std::cout << "No todos los elementos son pares." << std::endl;
    }

    return 0;
}
```cpp
#include <iostream>
#include <vector>
#include <algorithm>

int main() {
    std::vector<int> vec = {5, 6, 7, 8, 9};

    // Usar una lambda para verificar si todos los elementos están en el rango [5, 10]
    bool enRango = std::all_of(vec.begin(), vec.end(), [](int n) {
        return n >= 5 && n <= 10;
    });

    if (enRango) {
        std::cout << "Todos los elementos están en el rango [5, 10]." << std::endl;
    } else {
        std::cout << "No todos los elementos están en el rango [5, 10]." << std::endl;
    }

    return 0;
}
<---Ejemplo con Lambda Result--->
<---Ejemplo Básico--->
```cpp
#include <iostream>
#include <vector>
#include <algorithm>

void imprimir(int n) {
    std::cout << n << " ";
}

int main() {
    std::vector<int> vec = {1, 2, 3, 4, 5};

    // Usar std::for_each para imprimir cada elemento del vector
    std::for_each(vec.begin(), vec.end(), imprimir);
    std::cout << std::endl;

    return 0;
}
<---Ejemplo Básico Result--->
<---Ejemplo con Lambda--->
```cpp
#include <iostream>
#include <vector>
#include <algorithm>

int main() {
    std::vector<int> vec = {1, 2, 3, 4, 5};

    // Usar una lambda para imprimir cada elemento del vector
    std::for_each(vec.begin(), vec.end(), [](int n) {
        std::cout << n << " ";
    });
    std::cout << std::endl;

    return 0;
}
```cpp
#include <iostream>
#include <vector>
#include <algorithm>

int main() {
    std::vector<int> vec = {1, 2, 3, 4, 5};

    // Usar una lambda para incrementar cada elemento del vector
    std::for_each(vec.begin(), vec.end(), [](int& n) {
        n += 1;
    });

    // Imprimir los elementos incrementados
    std::for_each(vec.begin(), vec.end(), [](int n) {
        std::cout << n << " ";
    });
    std::cout << std::endl;

    return 0;
}
```cpp
#include <iostream>
#include <vector>
#include <algorithm>

struct Acumulador {
    int suma = 0;

    void operator()(int n) {
        suma += n;
    }
};

int main() {
    std::vector<int> vec = {1, 2, 3, 4, 5};

    Acumulador acumulador = std::for_each(vec.begin(), vec.end(), Acumulador());

    std::cout << "Suma de los elementos: " << acumulador.suma << std::endl;

    return 0;
}
<---Ejemplo con Lambda Result--->
<---Ejemplo Básico--->
```cpp
#include <iostream>
#include <vector>
#include <algorithm>

void imprimir(int n) {
    std::cout << n << " ";
}

int main() {
    std::vector<int> vec = {1, 2, 3, 4, 5};

    // Usar std::for_each para imprimir cada elemento del vector
    std::for_each(vec.begin(), vec.end(), imprimir);
    std::cout << std::endl;

    return 0;
}
<---Ejemplo Básico Result--->
<---Ejemplo con Lambda--->
```cpp
#include <iostream>
#include <vector>
#include <algorithm>

int main() {
    std::vector<int> vec = {1, 2, 3, 4, 5};

    // Usar una lambda para imprimir cada elemento del vector
    std::for_each(vec.begin(), vec.end(), [](int n) {
        std::cout << n << " ";
    });
    std::cout << std::endl;

    return 0;
}
```cpp
#include <iostream>
#include <vector>
#include <algorithm>

int main() {
    std::vector<int> vec = {1, 2, 3, 4, 5};

    // Usar una lambda para incrementar cada elemento del vector
    std::for_each(vec.begin(), vec.end(), [](int& n) {
        n += 1;
    });

    // Imprimir los elementos incrementados
    std::for_each(vec.begin(), vec.end(), [](int n) {
        std::cout << n << " ";
    });
    std::cout << std::endl;

    return 0;
}
```cpp
#include <iostream>
#include <vector>
#include <algorithm>

struct Acumulador {
    int suma = 0;

    void operator()(int n) {
        suma += n;
    }
};

int main() {
    std::vector<int> vec = {1, 2, 3, 4, 5};

    Acumulador acumulador = std::for_each(vec.begin(), vec.end(), Acumulador());

    std::cout << "Suma de los elementos: " << acumulador.suma << std::endl;

    return 0;
}
<---Ejemplo con Lambda Result--->
<---Ejemplo Básico (Suma)--->
```cpp
#include <iostream>
#include <vector>
#include <numeric>

int main() {
    std::vector<int> vec = {1, 2, 3, 4, 5};

    // Usar std::accumulate para sumar todos los elementos
    int suma = std::accumulate(vec.begin(), vec.end(), 0);

    std::cout << "La suma de los elementos es: " << suma << std::endl;

    return 0;
}
<---Ejemplo Básico (Suma) Result--->
<---Ejemplo con Operación Binaria Personalizada (Multiplicación)--->
```cpp
#include <iostream>
#include <vector>
#include <numeric>

int main() {
    std::vector<int> vec = {1, 2, 3, 4, 5};

    // Usar std::accumulate para multiplicar todos los elementos
    int producto = std::accumulate(vec.begin(), vec.end(), 1, std::multiplies<int>());

    std::cout << "El producto de los elementos es: " << producto << std::endl;

    return 0;
}
```cpp
#include <iostream>
#include <vector>
#include <numeric>
#include <string>

int main() {
    std::vector<std::string> vec = {"Hola", " ", "mundo", "!"};

    // Usar std::accumulate para concatenar todas las cadenas
    std::string resultado = std::accumulate(vec.begin(), vec.end(), std::string(""));

    std::cout << "Cadena concatenada: " << resultado << std::endl;

    return 0;
}
```cpp
#include <iostream>
#include <vector>
#include <numeric>

int main() {
    std::vector<int> vec = {1, 2, 3, 4, 5};

    // Calcular la suma de los elementos
    int suma = std::accumulate(vec.begin(), vec.end(), 0);

    // Calcular la media
    double media = static_cast<double>(suma) / vec.size();

    std::cout << "La media de los elementos es: " << media << std::endl;

    return 0;
}
<---Ejemplo con Operación Binaria Personalizada (Multiplicación) Result--->
<---Ejemplo Básico--->
```cpp
#include <iostream>
#include <vector>
#include <algorithm>

void imprimir(int n) {
    std::cout << n << " ";
}

int main() {
    std::vector<int> vec = {1, 2, 3, 4, 5};

    // Usar std::for_each para imprimir cada elemento del vector
    std::for_each(vec.begin(), vec.end(), imprimir);
    std::cout << std::endl;

    return 0;
}
<---Ejemplo Básico Result--->
<---Ejemplo con Lambda--->
```cpp
#include <iostream>
#include <vector>
#include <algorithm>

int main() {
    std::vector<int> vec = {1, 2, 3, 4, 5};

    // Usar una lambda para imprimir cada elemento del vector
    std::for_each(vec.begin(), vec.end(), [](int n) {
        std::cout << n << " ";
    });
    std::cout << std::endl;

    return 0;
}
```cpp
#include <iostream>
#include <vector>
#include <algorithm>

int main() {
    std::vector<int> vec = {1, 2, 3, 4, 5};

    // Usar una lambda para incrementar cada elemento del vector
    std::for_each(vec.begin(), vec.end(), [](int& n) {
        n += 1;
    });

    // Imprimir los elementos incrementados
    std::for_each(vec.begin(), vec.end(), [](int n) {
        std::cout << n << " ";
    });
    std::cout << std::endl;

    return 0;
}
```cpp
#include <iostream>
#include <vector>
#include <algorithm>

struct Acumulador {
    int suma = 0;

    void operator()(int n) {
        suma += n;
    }
};

int main() {
    std::vector<int> vec = {1, 2, 3, 4, 5};

    Acumulador acumulador = std::for_each(vec.begin(), vec.end(), Acumulador());

    std::cout << "Suma de los elementos: " << acumulador.suma << std::endl;

    return 0;
}
<---Ejemplo con Lambda Result--->
<---Ejemplo Básico (Suma)--->
```cpp
#include <iostream>
#include <vector>
#include <numeric>

int main() {
    std::vector<int> vec = {1, 2, 3, 4, 5};

    // Usar std::accumulate para sumar todos los elementos
    int suma = std::accumulate(vec.begin(), vec.end(), 0);

    std::cout << "La suma de los elementos es: " << suma << std::endl;

    return 0;
}
<---Ejemplo Básico (Suma) Result--->
<---Ejemplo con Operación Binaria Personalizada (Multiplicación)--->
```cpp
#include <iostream>
#include <vector>
#include <numeric>

int main() {
    std::vector<int> vec = {1, 2, 3, 4, 5};

    // Usar std::accumulate para multiplicar todos los elementos
    int producto = std::accumulate(vec.begin(), vec.end(), 1, std::multiplies<int>());

    std::cout << "El producto de los elementos es: " << producto << std::endl;

    return 0;
}
```cpp
#include <iostream>
#include <vector>
#include <numeric>
#include <string>

int main() {
    std::vector<std::string> vec = {"Hola", " ", "mundo", "!"};

    // Usar std::accumulate para concatenar todas las cadenas
    std::string resultado = std::accumulate(vec.begin(), vec.end(), std::string(""));

    std::cout << "Cadena concatenada: " << resultado << std::endl;

    return 0;
}
```cpp
#include <iostream>
#include <vector>
#include <numeric>

int main() {
    std::vector<int> vec = {1, 2, 3, 4, 5};

    // Calcular la suma de los elementos
    int suma = std::accumulate(vec.begin(), vec.end(), 0);

    // Calcular la media
    double media = static_cast<double>(suma) / vec.size();

    std::cout << "La media de los elementos es: " << media << std::endl;

    return 0;
}
<---Ejemplo con Operación Binaria Personalizada (Multiplicación) Result--->
<---`std::max`--->
```cpp
#include <algorithm>

template <class T>
const T& max(const T& a, const T& b);

template <class T, class Compare>
const T& max(const T& a, const T& b, Compare comp);

template <class ForwardIt>
ForwardIt max_element(ForwardIt first, ForwardIt last);

template <class ForwardIt, class Compare>
ForwardIt max_element(ForwardIt first, ForwardIt last, Compare comp);
<---`std::max` Result--->
<---`std::min`--->
```cpp
#include <algorithm>

template <class T>
const T& min(const T& a, const T& b);

template <class T, class Compare>
const T& min(const T& a, const T& b, Compare comp);

template <class ForwardIt>
ForwardIt min_element(ForwardIt first, ForwardIt last);

template <class ForwardIt, class Compare>
ForwardIt min_element(ForwardIt first, ForwardIt last, Compare comp);
<---`std::min` Result--->
<---Ejemplo Básico con Dos Valores--->
```cpp
#include <iostream>
#include <algorithm>

int main() {
    int a = 10, b = 20;

    // Encontrar el valor máximo
    int maxVal = std::max(a, b);
    std::cout << "El mayor de " << a << " y " << b << " es " << maxVal << std::endl;

    // Encontrar el valor mínimo
    int minVal = std::min(a, b);
    std::cout << "El menor de " << a << " y " << b << " es " << minVal << std::endl;

    return 0;
}
<---Ejemplo Básico con Dos Valores Result--->
<---Ejemplo con Comparación Personalizada--->
```cpp
#include <iostream>
#include <vector>
#include <algorithm>

struct Punto {
    int x, y;
};

bool compararPorDistancia(const Punto& p1, const Punto& p2) {
    return (p1.x * p1.x + p1.y * p1.y) < (p2.x * p2.x + p2.y * p2.y);
}

int main() {
    std::vector<Punto> puntos = {{1, 2}, {3, 4}, {0, 5}, {-1, -1}};

    // Encontrar el punto más lejano del origen
    auto maxIt = std::max_element(puntos.begin(), puntos.end(), compararPorDistancia);
    std::cout << "El punto más lejano es: (" << maxIt->x << ", " << maxIt->y << ")" << std::endl;

    // Encontrar el punto más cercano al origen
    auto minIt = std::min_element(puntos.begin(), puntos.end(), compararPorDistancia);
    std::cout << "El punto más cercano es: (" << minIt->x << ", " << minIt->y << ")" << std::endl;

    return 0;
}
<---Ejemplo con Comparación Personalizada Result--->
<---Ejemplo Básico con un Rango de Elementos--->
```cpp
#include <iostream>
#include <vector>
#include <algorithm>

int main() {
    std::vector<int> vec = {1, 2, 3, 4, 5};

    // Encontrar el elemento máximo
    auto maxIt = std::max_element(vec.begin(), vec.end());
    std::cout << "El elemento máximo es: " << *maxIt << std::endl;

    // Encontrar el elemento mínimo
    auto minIt = std::min_element(vec.begin(), vec.end());
    std::cout << "El elemento mínimo es: " << *minIt << std::endl;

    return 0;
}
<---Ejemplo Básico con un Rango de Elementos Result--->
<---Ejemplo Básico--->
```cpp
#include <iostream>
#include <vector>
#include <algorithm>

void imprimir(int n) {
    std::cout << n << " ";
}

int main() {
    std::vector<int> vec = {1, 2, 3, 4, 5};

    // Usar std::for_each para imprimir cada elemento del vector
    std::for_each(vec.begin(), vec.end(), imprimir);
    std::cout << std::endl;

    return 0;
}
<---Ejemplo Básico Result--->
<---Ejemplo con Lambda--->
```cpp
#include <iostream>
#include <vector>
#include <algorithm>

int main() {
    std::vector<int> vec = {1, 2, 3, 4, 5};

    // Usar una lambda para imprimir cada elemento del vector
    std::for_each(vec.begin(), vec.end(), [](int n) {
        std::cout << n << " ";
    });
    std::cout << std::endl;

    return 0;
}
```cpp
#include <iostream>
#include <vector>
#include <algorithm>

int main() {
    std::vector<int> vec = {1, 2, 3, 4, 5};

    // Usar una lambda para incrementar cada elemento del vector
    std::for_each(vec.begin(), vec.end(), [](int& n) {
        n += 1;
    });

    // Imprimir los elementos incrementados
    std::for_each(vec.begin(), vec.end(), [](int n) {
        std::cout << n << " ";
    });
    std::cout << std::endl;

    return 0;
}
```cpp
#include <iostream>
#include <vector>
#include <algorithm>

struct Acumulador {
    int suma = 0;

    void operator()(int n) {
        suma += n;
    }
};

int main() {
    std::vector<int> vec = {1, 2, 3, 4, 5};

    Acumulador acumulador = std::for_each(vec.begin(), vec.end(), Acumulador());

    std::cout << "Suma de los elementos: " << acumulador.suma << std::endl;

    return 0;
}
<---Ejemplo con Lambda Result--->
<---Ejemplo Básico (Suma)--->
```cpp
#include <iostream>
#include <vector>
#include <numeric>

int main() {
    std::vector<int> vec = {1, 2, 3, 4, 5};

    // Usar std::accumulate para sumar todos los elementos
    int suma = std::accumulate(vec.begin(), vec.end(), 0);

    std::cout << "La suma de los elementos es: " << suma << std::endl;

    return 0;
}
<---Ejemplo Básico (Suma) Result--->
<---Ejemplo con Operación Binaria Personalizada (Multiplicación)--->
```cpp
#include <iostream>
#include <vector>
#include <numeric>

int main() {
    std::vector<int> vec = {1, 2, 3, 4, 5};

    // Usar std::accumulate para multiplicar todos los elementos
    int producto = std::accumulate(vec.begin(), vec.end(), 1, std::multiplies<int>());

    std::cout << "El producto de los elementos es: " << producto << std::endl;

    return 0;
}
```cpp
#include <iostream>
#include <vector>
#include <numeric>
#include <string>

int main() {
    std::vector<std::string> vec = {"Hola", " ", "mundo", "!"};

    // Usar std::accumulate para concatenar todas las cadenas
    std::string resultado = std::accumulate(vec.begin(), vec.end(), std::string(""));

    std::cout << "Cadena concatenada: " << resultado << std::endl;

    return 0;
}
```cpp
#include <iostream>
#include <vector>
#include <numeric>

int main() {
    std::vector<int> vec = {1, 2, 3, 4, 5};

    // Calcular la suma de los elementos
    int suma = std::accumulate(vec.begin(), vec.end(), 0);

    // Calcular la media
    double media = static_cast<double>(suma) / vec.size();

    std::cout << "La media de los elementos es: " << media << std::endl;

    return 0;
}
<---Ejemplo con Operación Binaria Personalizada (Multiplicación) Result--->
<---`std::max`--->
```cpp
#include <algorithm>

template <class T>
const T& max(const T& a, const T& b);

template <class T, class Compare>
const T& max(const T& a, const T& b, Compare comp);

template <class ForwardIt>
ForwardIt max_element(ForwardIt first, ForwardIt last);

template <class ForwardIt, class Compare>
ForwardIt max_element(ForwardIt first, ForwardIt last, Compare comp);
<---`std::max` Result--->
<---`std::min`--->
```cpp
#include <algorithm>

template <class T>
const T& min(const T& a, const T& b);

template <class T, class Compare>
const T& min(const T& a, const T& b, Compare comp);

template <class ForwardIt>
ForwardIt min_element(ForwardIt first, ForwardIt last);

template <class ForwardIt, class Compare>
ForwardIt min_element(ForwardIt first, ForwardIt last, Compare comp);
<---`std::min` Result--->
<---Ejemplo Básico con Dos Valores--->
```cpp
#include <iostream>
#include <algorithm>

int main() {
    int a = 10, b = 20;

    // Encontrar el valor máximo
    int maxVal = std::max(a, b);
    std::cout << "El mayor de " << a << " y " << b << " es " << maxVal << std::endl;

    // Encontrar el valor mínimo
    int minVal = std::min(a, b);
    std::cout << "El menor de " << a << " y " << b << " es " << minVal << std::endl;

    return 0;
}
<---Ejemplo Básico con Dos Valores Result--->
<---Ejemplo con Comparación Personalizada--->
```cpp
#include <iostream>
#include <vector>
#include <algorithm>

struct Punto {
    int x, y;
};

bool compararPorDistancia(const Punto& p1, const Punto& p2) {
    return (p1.x * p1.x + p1.y * p1.y) < (p2.x * p2.x + p2.y * p2.y);
}

int main() {
    std::vector<Punto> puntos = {{1, 2}, {3, 4}, {0, 5}, {-1, -1}};

    // Encontrar el punto más lejano del origen
    auto maxIt = std::max_element(puntos.begin(), puntos.end(), compararPorDistancia);
    std::cout << "El punto más lejano es: (" << maxIt->x << ", " << maxIt->y << ")" << std::endl;

    // Encontrar el punto más cercano al origen
    auto minIt = std::min_element(puntos.begin(), puntos.end(), compararPorDistancia);
    std::cout << "El punto más cercano es: (" << minIt->x << ", " << minIt->y << ")" << std::endl;

    return 0;
}
<---Ejemplo con Comparación Personalizada Result--->
<---Ejemplo Básico con un Rango de Elementos--->
```cpp
#include <iostream>
#include <vector>
#include <algorithm>

int main() {
    std::vector<int> vec = {1, 2, 3, 4, 5};

    // Encontrar el elemento máximo
    auto maxIt = std::max_element(vec.begin(), vec.end());
    std::cout << "El elemento máximo es: " << *maxIt << std::endl;

    // Encontrar el elemento mínimo
    auto minIt = std::min_element(vec.begin(), vec.end());
    std::cout << "El elemento mínimo es: " << *minIt << std::endl;

    return 0;
}
<---Ejemplo Básico con un Rango de Elementos Result--->
<---Sintaxis--->
```cpp
#include <algorithm>

template <class InputIt, class UnaryPredicate>
InputIt find_if(InputIt first, InputIt last, UnaryPredicate p);
<---Sintaxis Result--->
<---Ejemplo de Uso de `std::find`--->
```cpp
#include <iostream>
#include <vector>
#include <algorithm>

int main() {
    std::vector<int> vec = {1, 2, 3, 4, 5};

    // Buscar el valor 3
    auto it = std::find(vec.begin(), vec.end(), 3);

    if (it != vec.end()) {
        std::cout << "Elemento encontrado: " << *it << std::endl;
    } else {
        std::cout << "Elemento no encontrado" << std::endl;
    }

    return 0;
}
<---Ejemplo de Uso de `std::find` Result--->
<---Ejemplo de Uso de `std::find_if`--->
```cpp
#include <iostream>
#include <vector>
#include <algorithm>

bool esImpar(int n) {
    return n % 2 != 0;
}

int main() {
    std::vector<int> vec = {2, 4, 6, 7, 8};

    // Buscar el primer elemento impar
    auto it = std::find_if(vec.begin(), vec.end(), esImpar);

    if (it != vec.end()) {
        std::cout << "Primer elemento impar encontrado: " << *it << std::endl;
    } else {
        std::cout << "Elemento impar no encontrado" << std::endl;
    }

    return 0;
}
<---Ejemplo de Uso de `std::find_if` Result--->
<---Ejemplo de Uso de `std::find_if` con Lambda--->
```cpp
#include <iostream>
#include <vector>
#include <algorithm>

int main() {
    std::vector<int> vec = {2, 4, 6, 7, 8};

    // Usar una lambda para buscar el primer elemento impar
    auto it = std::find_if(vec.begin(), vec.end(), [](int n) {
        return n % 2 != 0;
    });

    if (it != vec.end()) {
        std::cout << "Primer elemento impar encontrado: " << *it << std::endl;
    } else {
        std::cout << "Elemento impar no encontrado" << std::endl;
    }

    return 0;
}
```cpp
#include <iostream>
#include <vector>
#include <algorithm>

struct Punto {
    int x, y;

    bool operator==(const Punto& otro) const {
        return x == otro.x && y == otro.y;
    }
};

int main() {
    std::vector<Punto> puntos = {{1, 2}, {3, 4}, {5, 6}, {7, 8}};
    Punto puntoABuscar = {5, 6};

    // Buscar el punto {5, 6}
    auto it = std::find(puntos.begin(), puntos.end(), puntoABuscar);

    if (it != puntos.end()) {
        std::cout << "Punto encontrado: (" << it->x << ", " << it->y << ")" << std::endl;
    } else {
        std::cout << "Punto no encontrado" << std::endl;
    }

    return 0;
}
```cpp
#include <iostream>
#include <vector>
#include <algorithm>

int main() {
    std::vector<int> vec = {2, 4, 6, 7, 8};

    // Usar una lambda para buscar el primer elemento mayor que 5
    auto it = std::find_if(vec.begin(), vec.end(), [](int n) {
        return n > 5;
    });

    if (it != vec.end()) {
        std::cout << "Primer elemento mayor que 5 encontrado: " << *it << std::endl;
    } else {
        std::cout << "Elemento mayor que 5 no encontrado" << std::endl;
    }

    return 0;
}
<---Ejemplo de Uso de `std::find_if` con Lambda Result--->
<---Ejemplo Básico--->
```cpp
#include <iostream>
#include <vector>
#include <algorithm>

int main() {
    std::vector<int> origen = {1, 2, 3, 4, 5};
    std::vector<int> destino(origen.size());

    // Usar std::copy para copiar los elementos
    std::copy(origen.begin(), origen.end(), destino.begin());

    // Mostrar los elementos copiados
    std::cout << "Elementos copiados al vector destino: ";
    for (int elem : destino) {
        std::cout << elem << " ";
    }
    std::cout << std::endl;

    return 0;
}
<---Ejemplo Básico Result--->
<---Ejemplo con Lambda--->
```cpp
#include <iostream>
#include <vector>
#include <algorithm>

int main() {
    std::vector<int> vec = {1, 2, 3, 4, 5};

    // Usar una lambda para imprimir cada elemento del vector
    std::for_each(vec.begin(), vec.end(), [](int n) {
        std::cout << n << " ";
    });
    std::cout << std::endl;

    return 0;
}
```cpp
#include <iostream>
#include <vector>
#include <algorithm>

int main() {
    std::vector<int> vec = {1, 2, 3, 4, 5};

    // Usar una lambda para incrementar cada elemento del vector
    std::for_each(vec.begin(), vec.end(), [](int& n) {
        n += 1;
    });

    // Imprimir los elementos incrementados
    std::for_each(vec.begin(), vec.end(), [](int n) {
        std::cout << n << " ";
    });
    std::cout << std::endl;

    return 0;
}
```cpp
#include <iostream>
#include <vector>
#include <algorithm>

struct Acumulador {
    int suma = 0;

    void operator()(int n) {
        suma += n;
    }
};

int main() {
    std::vector<int> vec = {1, 2, 3, 4, 5};

    Acumulador acumulador = std::for_each(vec.begin(), vec.end(), Acumulador());

    std::cout << "Suma de los elementos: " << acumulador.suma << std::endl;

    return 0;
}
<---Ejemplo con Lambda Result--->
<---Ejemplo Básico (Suma)--->
```cpp
#include <iostream>
#include <vector>
#include <numeric>

int main() {
    std::vector<int> vec = {1, 2, 3, 4, 5};

    // Usar std::accumulate para sumar todos los elementos
    int suma = std::accumulate(vec.begin(), vec.end(), 0);

    std::cout << "La suma de los elementos es: " << suma << std::endl;

    return 0;
}
<---Ejemplo Básico (Suma) Result--->
<---Ejemplo con Operación Binaria Personalizada (Multiplicación)--->
```cpp
#include <iostream>
#include <vector>
#include <numeric>

int main() {
    std::vector<int> vec = {1, 2, 3, 4, 5};

    // Usar std::accumulate para multiplicar todos los elementos
    int producto = std::accumulate(vec.begin(), vec.end(), 1, std::multiplies<int>());

    std::cout << "El producto de los elementos es: " << producto << std::endl;

    return 0;
}
```cpp
#include <iostream>
#include <vector>
#include <numeric>
#include <string>

int main() {
    std::vector<std::string> vec = {"Hola", " ", "mundo", "!"};

    // Usar std::accumulate para concatenar todas las cadenas
    std::string resultado = std::accumulate(vec.begin(), vec.end(), std::string(""));

    std::cout << "Cadena concatenada: " << resultado << std::endl;

    return 0;
}
```cpp
#include <iostream>
#include <vector>
#include <numeric>

int main() {
    std::vector<int> vec = {1, 2, 3, 4, 5};

    // Calcular la suma de los elementos
    int suma = std::accumulate(vec.begin(), vec.end(), 0);

    // Calcular la media
    double media = static_cast<double>(suma) / vec.size();

    std::cout << "La media de los elementos es: " << media << std::endl;

    return 0;
}
<---Ejemplo con Operación Binaria Personalizada (Multiplicación) Result--->
<---`std::max`--->
```cpp
#include <algorithm>

template <class T>
const T& max(const T& a, const T& b);

template <class T, class Compare>
const T& max(const T& a, const T& b, Compare comp);

template <class ForwardIt>
ForwardIt max_element(ForwardIt first, ForwardIt last);

template <class ForwardIt, class Compare>
ForwardIt max_element(ForwardIt first, ForwardIt last, Compare comp);
<---`std::max` Result--->
<---`std::min`--->
```cpp
#include <algorithm>

template <class T>
const T& min(const T& a, const T& b);

template <class T, class Compare>
const T& min(const T& a, const T& b, Compare comp);

template <class ForwardIt>
ForwardIt min_element(ForwardIt first, ForwardIt last);

template <class ForwardIt, class Compare>
ForwardIt min_element(ForwardIt first, ForwardIt last, Compare comp);
<---`std::min` Result--->
<---Ejemplo Básico con Dos Valores--->
```cpp
#include <iostream>
#include <algorithm>

int main() {
    int a = 10, b = 20;

    // Encontrar el valor máximo
    int maxVal = std::max(a, b);
    std::cout << "El mayor de " << a << " y " << b << " es " << maxVal << std::endl;

    // Encontrar el valor mínimo
    int minVal = std::min(a, b);
    std::cout << "El menor de " << a << " y " << b << " es " << minVal << std::endl;

    return 0;
}
<---Ejemplo Básico con Dos Valores Result--->
<---Ejemplo con Comparación Personalizada--->
```cpp
#include <iostream>
#include <vector>
#include <algorithm>

struct Punto {
    int x, y;
};

bool compararPorDistancia(const Punto& p1, const Punto& p2) {
    return (p1.x * p1.x + p1.y * p1.y) < (p2.x * p2.x + p2.y * p2.y);
}

int main() {
    std::vector<Punto> puntos = {{1, 2}, {3, 4}, {0, 5}, {-1, -1}};

    // Encontrar el punto más lejano del origen
    auto maxIt = std::max_element(puntos.begin(), puntos.end(), compararPorDistancia);
    std::cout << "El punto más lejano es: (" << maxIt->x << ", " << maxIt->y << ")" << std::endl;

    // Encontrar el punto más cercano al origen
    auto minIt = std::min_element(puntos.begin(), puntos.end(), compararPorDistancia);
    std::cout << "El punto más cercano es: (" << minIt->x << ", " << minIt->y << ")" << std::endl;

    return 0;
}
<---Ejemplo con Comparación Personalizada Result--->
<---Ejemplo Básico con un Rango de Elementos--->
```cpp
#include <iostream>
#include <vector>
#include <algorithm>

int main() {
    std::vector<int> vec = {1, 2, 3, 4, 5};

    // Encontrar el elemento máximo
    auto maxIt = std::max_element(vec.begin(), vec.end());
    std::cout << "El elemento máximo es: " << *maxIt << std::endl;

    // Encontrar el elemento mínimo
    auto minIt = std::min_element(vec.begin(), vec.end());
    std::cout << "El elemento mínimo es: " << *minIt << std::endl;

    return 0;
}
<---Ejemplo Básico con un Rango de Elementos Result--->
<---Sintaxis--->
```cpp
#include <algorithm>

template <class InputIt, class UnaryPredicate>
InputIt find_if(InputIt first, InputIt last, UnaryPredicate p);
<---Sintaxis Result--->
<---Ejemplo de Uso de `std::find`--->
```cpp
#include <iostream>
#include <vector>
#include <algorithm>

int main() {
    std::vector<int> vec = {1, 2, 3, 4, 5};

    // Buscar el valor 3
    auto it = std::find(vec.begin(), vec.end(), 3);

    if (it != vec.end()) {
        std::cout << "Elemento encontrado: " << *it << std::endl;
    } else {
        std::cout << "Elemento no encontrado" << std::endl;
    }

    return 0;
}
<---Ejemplo de Uso de `std::find` Result--->
<---Ejemplo de Uso de `std::find_if`--->
```cpp
#include <iostream>
#include <vector>
#include <algorithm>

bool esImpar(int n) {
    return n % 2 != 0;
}

int main() {
    std::vector<int> vec = {2, 4, 6, 7, 8};

    // Buscar el primer elemento impar
    auto it = std::find_if(vec.begin(), vec.end(), esImpar);

    if (it != vec.end()) {
        std::cout << "Primer elemento impar encontrado: " << *it << std::endl;
    } else {
        std::cout << "Elemento impar no encontrado" << std::endl;
    }

    return 0;
}
<---Ejemplo de Uso de `std::find_if` Result--->
<---Ejemplo de Uso de `std::find_if` con Lambda--->
```cpp
#include <iostream>
#include <vector>
#include <algorithm>

int main() {
    std::vector<int> vec = {2, 4, 6, 7, 8};

    // Usar una lambda para buscar el primer elemento impar
    auto it = std::find_if(vec.begin(), vec.end(), [](int n) {
        return n % 2 != 0;
    });

    if (it != vec.end()) {
        std::cout << "Primer elemento impar encontrado: " << *it << std::endl;
    } else {
        std::cout << "Elemento impar no encontrado" << std::endl;
    }

    return 0;
}
```cpp
#include <iostream>
#include <vector>
#include <algorithm>

struct Punto {
    int x, y;

    bool operator==(const Punto& otro) const {
        return x == otro.x && y == otro.y;
    }
};

int main() {
    std::vector<Punto> puntos = {{1, 2}, {3, 4}, {5, 6}, {7, 8}};
    Punto puntoABuscar = {5, 6};

    // Buscar el punto {5, 6}
    auto it = std::find(puntos.begin(), puntos.end(), puntoABuscar);

    if (it != puntos.end()) {
        std::cout << "Punto encontrado: (" << it->x << ", " << it->y << ")" << std::endl;
    } else {
        std::cout << "Punto no encontrado" << std::endl;
    }

    return 0;
}
```cpp
#include <iostream>
#include <vector>
#include <algorithm>

int main() {
    std::vector<int> vec = {2, 4, 6, 7, 8};

    // Usar una lambda para buscar el primer elemento mayor que 5
    auto it = std::find_if(vec.begin(), vec.end(), [](int n) {
        return n > 5;
    });

    if (it != vec.end()) {
        std::cout << "Primer elemento mayor que 5 encontrado: " << *it << std::endl;
    } else {
        std::cout << "Elemento mayor que 5 no encontrado" << std::endl;
    }

    return 0;
}
<---Ejemplo de Uso de `std::find_if` con Lambda Result--->
<---Copiar Elementos entre Diferentes Contenedores--->
```cpp
#include <iostream>
#include <vector>
#include <list>
#include <algorithm>

int main() {
    std::vector<int> origen = {1, 2, 3, 4, 5};
    std::list<int> destino(origen.size());

    // Usar std::copy para copiar los elementos
    std::copy(origen.begin(), origen.end(), destino.begin());

    // Mostrar los elementos copiados
    std::cout << "Elementos copiados a la lista destino: ";
    for (int elem : destino) {
        std::cout << elem << " ";
    }
    std::cout << std::endl;

    return 0;
}
```cpp
#include <iostream>
#include <vector>
#include <algorithm>

int main() {
    std::vector<int> origen = {1, 2, 3, 4, 5};
    std::vector<int> destino(3);

    // Usar std::copy para copiar los primeros 3 elementos
    std::copy(origen.begin(), origen.begin() + 3, destino.begin());

    // Mostrar los elementos copiados
    std::cout << "Primeros 3 elementos copiados al vector destino: ";
    for (int elem : destino) {
        std::cout << elem << " ";
    }
    std::cout << std::endl;

    return 0;
}
```cpp
#include <iostream>
#include <vector>
#include <algorithm>
#include <iterator>

int main() {
    std::vector<int> origen = {1, 2, 3, 4, 5};
    std::vector<int> destino;

    // Usar std::copy con std::back_inserter
    std::copy(origen.begin(), origen.end(), std::back_inserter(destino));

    // Mostrar los elementos copiados
    std::cout << "Elementos copiados al vector destino con back_inserter: ";
    for (int elem : destino) {
        std::cout << elem << " ";
    }
    std::cout << std::endl;

    return 0;
}
<---Copiar Elementos entre Diferentes Contenedores Result--->
<---Ejemplo Básico--->
```cpp
#include <iostream>
#include <vector>
#include <algorithm>

int main() {
    std::vector<int> origen = {1, 2, 3, 4, 5};
    std::vector<int> destino(origen.size());

    // Usar std::copy para copiar los elementos
    std::copy(origen.begin(), origen.end(), destino.begin());

    // Mostrar los elementos copiados
    std::cout << "Elementos copiados al vector destino: ";
    for (int elem : destino) {
        std::cout << elem << " ";
    }
    std::cout << std::endl;

    return 0;
}
<---Ejemplo Básico Result--->
<---Ejemplo con Lambda--->
```cpp
#include <iostream>
#include <vector>
#include <algorithm>

int main() {
    std::vector<int> vec = {1, 2, 3, 4, 5};

    // Usar una lambda para imprimir cada elemento del vector
    std::for_each(vec.begin(), vec.end(), [](int n) {
        std::cout << n << " ";
    });
    std::cout << std::endl;

    return 0;
}
```cpp
#include <iostream>
#include <vector>
#include <algorithm>

int main() {
    std::vector<int> vec = {1, 2, 3, 4, 5};

    // Usar una lambda para incrementar cada elemento del vector
    std::for_each(vec.begin(), vec.end(), [](int& n) {
        n += 1;
    });

    // Imprimir los elementos incrementados
    std::for_each(vec.begin(), vec.end(), [](int n) {
        std::cout << n << " ";
    });
    std::cout << std::endl;

    return 0;
}
```cpp
#include <iostream>
#include <vector>
#include <algorithm>

struct Acumulador {
    int suma = 0;

    void operator()(int n) {
        suma += n;
    }
};

int main() {
    std::vector<int> vec = {1, 2, 3, 4, 5};

    Acumulador acumulador = std::for_each(vec.begin(), vec.end(), Acumulador());

    std::cout << "Suma de los elementos: " << acumulador.suma << std::endl;

    return 0;
}
<---Ejemplo con Lambda Result--->
<---Ejemplo Básico (Suma)--->
```cpp
#include <iostream>
#include <vector>
#include <numeric>

int main() {
    std::vector<int> vec = {1, 2, 3, 4, 5};

    // Usar std::accumulate para sumar todos los elementos
    int suma = std::accumulate(vec.begin(), vec.end(), 0);

    std::cout << "La suma de los elementos es: " << suma << std::endl;

    return 0;
}
<---Ejemplo Básico (Suma) Result--->
<---Ejemplo con Operación Binaria Personalizada (Multiplicación)--->
```cpp
#include <iostream>
#include <vector>
#include <numeric>

int main() {
    std::vector<int> vec = {1, 2, 3, 4, 5};

    // Usar std::accumulate para multiplicar todos los elementos
    int producto = std::accumulate(vec.begin(), vec.end(), 1, std::multiplies<int>());

    std::cout << "El producto de los elementos es: " << producto << std::endl;

    return 0;
}
```cpp
#include <iostream>
#include <vector>
#include <numeric>
#include <string>

int main() {
    std::vector<std::string> vec = {"Hola", " ", "mundo", "!"};

    // Usar std::accumulate para concatenar todas las cadenas
    std::string resultado = std::accumulate(vec.begin(), vec.end(), std::string(""));

    std::cout << "Cadena concatenada: " << resultado << std::endl;

    return 0;
}
```cpp
#include <iostream>
#include <vector>
#include <numeric>

int main() {
    std::vector<int> vec = {1, 2, 3, 4, 5};

    // Calcular la suma de los elementos
    int suma = std::accumulate(vec.begin(), vec.end(), 0);

    // Calcular la media
    double media = static_cast<double>(suma) / vec.size();

    std::cout << "La media de los elementos es: " << media << std::endl;

    return 0;
}
<---Ejemplo con Operación Binaria Personalizada (Multiplicación) Result--->
<---`std::max`--->
```cpp
#include <algorithm>

template <class T>
const T& max(const T& a, const T& b);

template <class T, class Compare>
const T& max(const T& a, const T& b, Compare comp);

template <class ForwardIt>
ForwardIt max_element(ForwardIt first, ForwardIt last);

template <class ForwardIt, class Compare>
ForwardIt max_element(ForwardIt first, ForwardIt last, Compare comp);
<---`std::max` Result--->
<---`std::min`--->
```cpp
#include <algorithm>

template <class T>
const T& min(const T& a, const T& b);

template <class T, class Compare>
const T& min(const T& a, const T& b, Compare comp);

template <class ForwardIt>
ForwardIt min_element(ForwardIt first, ForwardIt last);

template <class ForwardIt, class Compare>
ForwardIt min_element(ForwardIt first, ForwardIt last, Compare comp);
<---`std::min` Result--->
<---Ejemplo Básico con Dos Valores--->
```cpp
#include <iostream>
#include <algorithm>

int main() {
    int a = 10, b = 20;

    // Encontrar el valor máximo
    int maxVal = std::max(a, b);
    std::cout << "El mayor de " << a << " y " << b << " es " << maxVal << std::endl;

    // Encontrar el valor mínimo
    int minVal = std::min(a, b);
    std::cout << "El menor de " << a << " y " << b << " es " << minVal << std::endl;

    return 0;
}
<---Ejemplo Básico con Dos Valores Result--->
<---Ejemplo con Comparación Personalizada--->
```cpp
#include <iostream>
#include <vector>
#include <algorithm>

struct Punto {
    int x, y;
};

bool compararPorDistancia(const Punto& p1, const Punto& p2) {
    return (p1.x * p1.x + p1.y * p1.y) < (p2.x * p2.x + p2.y * p2.y);
}

int main() {
    std::vector<Punto> puntos = {{1, 2}, {3, 4}, {0, 5}, {-1, -1}};

    // Encontrar el punto más lejano del origen
    auto maxIt = std::max_element(puntos.begin(), puntos.end(), compararPorDistancia);
    std::cout << "El punto más lejano es: (" << maxIt->x << ", " << maxIt->y << ")" << std::endl;

    // Encontrar el punto más cercano al origen
    auto minIt = std::min_element(puntos.begin(), puntos.end(), compararPorDistancia);
    std::cout << "El punto más cercano es: (" << minIt->x << ", " << minIt->y << ")" << std::endl;

    return 0;
}
<---Ejemplo con Comparación Personalizada Result--->
<---Ejemplo Básico con un Rango de Elementos--->
```cpp
#include <iostream>
#include <vector>
#include <algorithm>

int main() {
    std::vector<int> vec = {1, 2, 3, 4, 5};

    // Encontrar el elemento máximo
    auto maxIt = std::max_element(vec.begin(), vec.end());
    std::cout << "El elemento máximo es: " << *maxIt << std::endl;

    // Encontrar el elemento mínimo
    auto minIt = std::min_element(vec.begin(), vec.end());
    std::cout << "El elemento mínimo es: " << *minIt << std::endl;

    return 0;
}
<---Ejemplo Básico con un Rango de Elementos Result--->
<---Sintaxis--->
```cpp
#include <algorithm>

template <class InputIt, class UnaryPredicate>
InputIt find_if(InputIt first, InputIt last, UnaryPredicate p);
<---Sintaxis Result--->
<---Ejemplo de Uso de `std::find`--->
```cpp
#include <iostream>
#include <vector>
#include <algorithm>

int main() {
    std::vector<int> vec = {1, 2, 3, 4, 5};

    // Buscar el valor 3
    auto it = std::find(vec.begin(), vec.end(), 3);

    if (it != vec.end()) {
        std::cout << "Elemento encontrado: " << *it << std::endl;
    } else {
        std::cout << "Elemento no encontrado" << std::endl;
    }

    return 0;
}
<---Ejemplo de Uso de `std::find` Result--->
<---Ejemplo de Uso de `std::find_if`--->
```cpp
#include <iostream>
#include <vector>
#include <algorithm>

bool esImpar(int n) {
    return n % 2 != 0;
}

int main() {
    std::vector<int> vec = {2, 4, 6, 7, 8};

    // Buscar el primer elemento impar
    auto it = std::find_if(vec.begin(), vec.end(), esImpar);

    if (it != vec.end()) {
        std::cout << "Primer elemento impar encontrado: " << *it << std::endl;
    } else {
        std::cout << "Elemento impar no encontrado" << std::endl;
    }

    return 0;
}
<---Ejemplo de Uso de `std::find_if` Result--->
<---Ejemplo de Uso de `std::find_if` con Lambda--->
```cpp
#include <iostream>
#include <vector>
#include <algorithm>

int main() {
    std::vector<int> vec = {2, 4, 6, 7, 8};

    // Usar una lambda para buscar el primer elemento impar
    auto it = std::find_if(vec.begin(), vec.end(), [](int n) {
        return n % 2 != 0;
    });

    if (it != vec.end()) {
        std::cout << "Primer elemento impar encontrado: " << *it << std::endl;
    } else {
        std::cout << "Elemento impar no encontrado" << std::endl;
    }

    return 0;
}
```cpp
#include <iostream>
#include <vector>
#include <algorithm>

struct Punto {
    int x, y;

    bool operator==(const Punto& otro) const {
        return x == otro.x && y == otro.y;
    }
};

int main() {
    std::vector<Punto> puntos = {{1, 2}, {3, 4}, {5, 6}, {7, 8}};
    Punto puntoABuscar = {5, 6};

    // Buscar el punto {5, 6}
    auto it = std::find(puntos.begin(), puntos.end(), puntoABuscar);

    if (it != puntos.end()) {
        std::cout << "Punto encontrado: (" << it->x << ", " << it->y << ")" << std::endl;
    } else {
        std::cout << "Punto no encontrado" << std::endl;
    }

    return 0;
}
```cpp
#include <iostream>
#include <vector>
#include <algorithm>

int main() {
    std::vector<int> vec = {2, 4, 6, 7, 8};

    // Usar una lambda para buscar el primer elemento mayor que 5
    auto it = std::find_if(vec.begin(), vec.end(), [](int n) {
        return n > 5;
    });

    if (it != vec.end()) {
        std::cout << "Primer elemento mayor que 5 encontrado: " << *it << std::endl;
    } else {
        std::cout << "Elemento mayor que 5 no encontrado" << std::endl;
    }

    return 0;
}
<---Ejemplo de Uso de `std::find_if` con Lambda Result--->
<---Copiar Elementos entre Diferentes Contenedores--->
```cpp
#include <iostream>
#include <vector>
#include <list>
#include <algorithm>

int main() {
    std::vector<int> origen = {1, 2, 3, 4, 5};
    std::list<int> destino(origen.size());

    // Usar std::copy para copiar los elementos
    std::copy(origen.begin(), origen.end(), destino.begin());

    // Mostrar los elementos copiados
    std::cout << "Elementos copiados a la lista destino: ";
    for (int elem : destino) {
        std::cout << elem << " ";
    }
    std::cout << std::endl;

    return 0;
}
```cpp
#include <iostream>
#include <vector>
#include <algorithm>

int main() {
    std::vector<int> origen = {1, 2, 3, 4, 5};
    std::vector<int> destino(3);

    // Usar std::copy para copiar los primeros 3 elementos
    std::copy(origen.begin(), origen.begin() + 3, destino.begin());

    // Mostrar los elementos copiados
    std::cout << "Primeros 3 elementos copiados al vector destino: ";
    for (int elem : destino) {
        std::cout << elem << " ";
    }
    std::cout << std::endl;

    return 0;
}
```cpp
#include <iostream>
#include <vector>
#include <algorithm>
#include <iterator>

int main() {
    std::vector<int> origen = {1, 2, 3, 4, 5};
    std::vector<int> destino;

    // Usar std::copy con std::back_inserter
    std::copy(origen.begin(), origen.end(), std::back_inserter(destino));

    // Mostrar los elementos copiados
    std::cout << "Elementos copiados al vector destino con back_inserter: ";
    for (int elem : destino) {
        std::cout << elem << " ";
    }
    std::cout << std::endl;

    return 0;
}
<---Copiar Elementos entre Diferentes Contenedores Result--->
<---Ejemplo Básico (Orden Ascendente)--->
```cpp
#include <iostream>
#include <vector>
#include <algorithm>

int main() {
    std::vector<int> vec = {5, 2, 9, 1, 5, 6};

    // Usar std::sort para ordenar los elementos en orden ascendente
    std::sort(vec.begin(), vec.end());

    // Mostrar los elementos ordenados
    std::cout << "Elementos ordenados: ";
    for (int elem : vec) {
        std::cout << elem << " ";
    }
    std::cout << std::endl;

    return 0;
}
<---Ejemplo Básico (Orden Ascendente) Result--->
<---Ejemplo con Comparación Personalizada (Orden Descendente)--->
```cpp
#include <iostream>
#include <vector>
#include <algorithm>

int main() {
    std::vector<int> vec = {5, 2, 9, 1, 5, 6};

    // Usar std::sort con una función de comparación para ordenar en orden descendente
    std::sort(vec.begin(), vec.end(), std::greater<int>());

    // Mostrar los elementos ordenados
    std::cout << "Elementos ordenados en orden descendente: ";
    for (int elem : vec) {
        std::cout << elem << " ";
    }
    std::cout << std::endl;

    return 0;
}
<---Ejemplo con Comparación Personalizada (Orden Descendente) Result--->
<---Ordenar un `std::array`--->
```cpp
#include <iostream>
#include <array>
#include <algorithm>

int main() {
    std::array<int, 6> arr = {5, 2, 9, 1, 5, 6};

    // Usar std::sort para ordenar los elementos del array
    std::sort(arr.begin(), arr.end());

    // Mostrar los elementos ordenados
    std::cout << "Elementos del array ordenados: ";
    for (int elem : arr) {
        std::cout << elem << " ";
    }
    std::cout << std::endl;

    return 0;
}
<---Ordenar un `std::array` Result--->
<---Ejemplo Básico--->
```cpp
#include <iostream>
#include <vector>
#include <algorithm>

int main() {
    std::vector<int> origen = {1, 2, 3, 4, 5};
    std::vector<int> destino(origen.size());

    // Usar std::copy para copiar los elementos
    std::copy(origen.begin(), origen.end(), destino.begin());

    // Mostrar los elementos copiados
    std::cout << "Elementos copiados al vector destino: ";
    for (int elem : destino) {
        std::cout << elem << " ";
    }
    std::cout << std::endl;

    return 0;
}
<---Ejemplo Básico Result--->
<---Ejemplo con Lambda--->
```cpp
#include <iostream>
#include <vector>
#include <algorithm>

int main() {
    std::vector<int> vec = {1, 2, 3, 4, 5};

    // Usar una lambda para imprimir cada elemento del vector
    std::for_each(vec.begin(), vec.end(), [](int n) {
        std::cout << n << " ";
    });
    std::cout << std::endl;

    return 0;
}
```cpp
#include <iostream>
#include <vector>
#include <algorithm>

int main() {
    std::vector<int> vec = {1, 2, 3, 4, 5};

    // Usar una lambda para incrementar cada elemento del vector
    std::for_each(vec.begin(), vec.end(), [](int& n) {
        n += 1;
    });

    // Imprimir los elementos incrementados
    std::for_each(vec.begin(), vec.end(), [](int n) {
        std::cout << n << " ";
    });
    std::cout << std::endl;

    return 0;
}
```cpp
#include <iostream>
#include <vector>
#include <algorithm>

struct Acumulador {
    int suma = 0;

    void operator()(int n) {
        suma += n;
    }
};

int main() {
    std::vector<int> vec = {1, 2, 3, 4, 5};

    Acumulador acumulador = std::for_each(vec.begin(), vec.end(), Acumulador());

    std::cout << "Suma de los elementos: " << acumulador.suma << std::endl;

    return 0;
}
<---Ejemplo con Lambda Result--->
<---Ejemplo Básico (Suma)--->
```cpp
#include <iostream>
#include <vector>
#include <numeric>

int main() {
    std::vector<int> vec = {1, 2, 3, 4, 5};

    // Usar std::accumulate para sumar todos los elementos
    int suma = std::accumulate(vec.begin(), vec.end(), 0);

    std::cout << "La suma de los elementos es: " << suma << std::endl;

    return 0;
}
<---Ejemplo Básico (Suma) Result--->
<---Ejemplo con Operación Binaria Personalizada (Multiplicación)--->
```cpp
#include <iostream>
#include <vector>
#include <numeric>

int main() {
    std::vector<int> vec = {1, 2, 3, 4, 5};

    // Usar std::accumulate para multiplicar todos los elementos
    int producto = std::accumulate(vec.begin(), vec.end(), 1, std::multiplies<int>());

    std::cout << "El producto de los elementos es: " << producto << std::endl;

    return 0;
}
```cpp
#include <iostream>
#include <vector>
#include <numeric>
#include <string>

int main() {
    std::vector<std::string> vec = {"Hola", " ", "mundo", "!"};

    // Usar std::accumulate para concatenar todas las cadenas
    std::string resultado = std::accumulate(vec.begin(), vec.end(), std::string(""));

    std::cout << "Cadena concatenada: " << resultado << std::endl;

    return 0;
}
```cpp
#include <iostream>
#include <vector>
#include <numeric>

int main() {
    std::vector<int> vec = {1, 2, 3, 4, 5};

    // Calcular la suma de los elementos
    int suma = std::accumulate(vec.begin(), vec.end(), 0);

    // Calcular la media
    double media = static_cast<double>(suma) / vec.size();

    std::cout << "La media de los elementos es: " << media << std::endl;

    return 0;
}
<---Ejemplo con Operación Binaria Personalizada (Multiplicación) Result--->
<---`std::max`--->
```cpp
#include <algorithm>

template <class T>
const T& max(const T& a, const T& b);

template <class T, class Compare>
const T& max(const T& a, const T& b, Compare comp);

template <class ForwardIt>
ForwardIt max_element(ForwardIt first, ForwardIt last);

template <class ForwardIt, class Compare>
ForwardIt max_element(ForwardIt first, ForwardIt last, Compare comp);
<---`std::max` Result--->
<---`std::min`--->
```cpp
#include <algorithm>

template <class T>
const T& min(const T& a, const T& b);

template <class T, class Compare>
const T& min(const T& a, const T& b, Compare comp);

template <class ForwardIt>
ForwardIt min_element(ForwardIt first, ForwardIt last);

template <class ForwardIt, class Compare>
ForwardIt min_element(ForwardIt first, ForwardIt last, Compare comp);
<---`std::min` Result--->
<---Ejemplo Básico con Dos Valores--->
```cpp
#include <iostream>
#include <algorithm>

int main() {
    int a = 10, b = 20;

    // Encontrar el valor máximo
    int maxVal = std::max(a, b);
    std::cout << "El mayor de " << a << " y " << b << " es " << maxVal << std::endl;

    // Encontrar el valor mínimo
    int minVal = std::min(a, b);
    std::cout << "El menor de " << a << " y " << b << " es " << minVal << std::endl;

    return 0;
}
<---Ejemplo Básico con Dos Valores Result--->
<---Ejemplo con Comparación Personalizada--->
```cpp
#include <iostream>
#include <vector>
#include <algorithm>

struct Punto {
    int x, y;
};

bool compararPorDistancia(const Punto& p1, const Punto& p2) {
    return (p1.x * p1.x + p1.y * p1.y) < (p2.x * p2.x + p2.y * p2.y);
}

int main() {
    std::vector<Punto> puntos = {{1, 2}, {3, 4}, {0, 5}, {-1, -1}};

    // Encontrar el punto más lejano del origen
    auto maxIt = std::max_element(puntos.begin(), puntos.end(), compararPorDistancia);
    std::cout << "El punto más lejano es: (" << maxIt->x << ", " << maxIt->y << ")" << std::endl;

    // Encontrar el punto más cercano al origen
    auto minIt = std::min_element(puntos.begin(), puntos.end(), compararPorDistancia);
    std::cout << "El punto más cercano es: (" << minIt->x << ", " << minIt->y << ")" << std::endl;

    return 0;
}
<---Ejemplo con Comparación Personalizada Result--->
<---Ejemplo Básico con un Rango de Elementos--->
```cpp
#include <iostream>
#include <vector>
#include <algorithm>

int main() {
    std::vector<int> vec = {1, 2, 3, 4, 5};

    // Encontrar el elemento máximo
    auto maxIt = std::max_element(vec.begin(), vec.end());
    std::cout << "El elemento máximo es: " << *maxIt << std::endl;

    // Encontrar el elemento mínimo
    auto minIt = std::min_element(vec.begin(), vec.end());
    std::cout << "El elemento mínimo es: " << *minIt << std::endl;

    return 0;
}
<---Ejemplo Básico con un Rango de Elementos Result--->
<---Sintaxis--->
```cpp
#include <algorithm>

template <class InputIt, class UnaryPredicate>
InputIt find_if(InputIt first, InputIt last, UnaryPredicate p);
<---Sintaxis Result--->
<---Ejemplo de Uso de `std::find`--->
```cpp
#include <iostream>
#include <vector>
#include <algorithm>

int main() {
    std::vector<int> vec = {1, 2, 3, 4, 5};

    // Buscar el valor 3
    auto it = std::find(vec.begin(), vec.end(), 3);

    if (it != vec.end()) {
        std::cout << "Elemento encontrado: " << *it << std::endl;
    } else {
        std::cout << "Elemento no encontrado" << std::endl;
    }

    return 0;
}
<---Ejemplo de Uso de `std::find` Result--->
<---Ejemplo de Uso de `std::find_if`--->
```cpp
#include <iostream>
#include <vector>
#include <algorithm>

bool esImpar(int n) {
    return n % 2 != 0;
}

int main() {
    std::vector<int> vec = {2, 4, 6, 7, 8};

    // Buscar el primer elemento impar
    auto it = std::find_if(vec.begin(), vec.end(), esImpar);

    if (it != vec.end()) {
        std::cout << "Primer elemento impar encontrado: " << *it << std::endl;
    } else {
        std::cout << "Elemento impar no encontrado" << std::endl;
    }

    return 0;
}
<---Ejemplo de Uso de `std::find_if` Result--->
<---Ejemplo de Uso de `std::find_if` con Lambda--->
```cpp
#include <iostream>
#include <vector>
#include <algorithm>

int main() {
    std::vector<int> vec = {2, 4, 6, 7, 8};

    // Usar una lambda para buscar el primer elemento impar
    auto it = std::find_if(vec.begin(), vec.end(), [](int n) {
        return n % 2 != 0;
    });

    if (it != vec.end()) {
        std::cout << "Primer elemento impar encontrado: " << *it << std::endl;
    } else {
        std::cout << "Elemento impar no encontrado" << std::endl;
    }

    return 0;
}
```cpp
#include <iostream>
#include <vector>
#include <algorithm>

struct Punto {
    int x, y;

    bool operator==(const Punto& otro) const {
        return x == otro.x && y == otro.y;
    }
};

int main() {
    std::vector<Punto> puntos = {{1, 2}, {3, 4}, {5, 6}, {7, 8}};
    Punto puntoABuscar = {5, 6};

    // Buscar el punto {5, 6}
    auto it = std::find(puntos.begin(), puntos.end(), puntoABuscar);

    if (it != puntos.end()) {
        std::cout << "Punto encontrado: (" << it->x << ", " << it->y << ")" << std::endl;
    } else {
        std::cout << "Punto no encontrado" << std::endl;
    }

    return 0;
}
```cpp
#include <iostream>
#include <vector>
#include <algorithm>

int main() {
    std::vector<int> vec = {2, 4, 6, 7, 8};

    // Usar una lambda para buscar el primer elemento mayor que 5
    auto it = std::find_if(vec.begin(), vec.end(), [](int n) {
        return n > 5;
    });

    if (it != vec.end()) {
        std::cout << "Primer elemento mayor que 5 encontrado: " << *it << std::endl;
    } else {
        std::cout << "Elemento mayor que 5 no encontrado" << std::endl;
    }

    return 0;
}
<---Ejemplo de Uso de `std::find_if` con Lambda Result--->
<---Copiar Elementos entre Diferentes Contenedores--->
```cpp
#include <iostream>
#include <vector>
#include <list>
#include <algorithm>

int main() {
    std::vector<int> origen = {1, 2, 3, 4, 5};
    std::list<int> destino(origen.size());

    // Usar std::copy para copiar los elementos
    std::copy(origen.begin(), origen.end(), destino.begin());

    // Mostrar los elementos copiados
    std::cout << "Elementos copiados a la lista destino: ";
    for (int elem : destino) {
        std::cout << elem << " ";
    }
    std::cout << std::endl;

    return 0;
}
```cpp
#include <iostream>
#include <vector>
#include <algorithm>

int main() {
    std::vector<int> origen = {1, 2, 3, 4, 5};
    std::vector<int> destino(3);

    // Usar std::copy para copiar los primeros 3 elementos
    std::copy(origen.begin(), origen.begin() + 3, destino.begin());

    // Mostrar los elementos copiados
    std::cout << "Primeros 3 elementos copiados al vector destino: ";
    for (int elem : destino) {
        std::cout << elem << " ";
    }
    std::cout << std::endl;

    return 0;
}
```cpp
#include <iostream>
#include <vector>
#include <algorithm>
#include <iterator>

int main() {
    std::vector<int> origen = {1, 2, 3, 4, 5};
    std::vector<int> destino;

    // Usar std::copy con std::back_inserter
    std::copy(origen.begin(), origen.end(), std::back_inserter(destino));

    // Mostrar los elementos copiados
    std::cout << "Elementos copiados al vector destino con back_inserter: ";
    for (int elem : destino) {
        std::cout << elem << " ";
    }
    std::cout << std::endl;

    return 0;
}
<---Copiar Elementos entre Diferentes Contenedores Result--->
<---Ejemplo Básico (Orden Ascendente)--->
```cpp
#include <iostream>
#include <vector>
#include <algorithm>

int main() {
    std::vector<int> vec = {5, 2, 9, 1, 5, 6};

    // Usar std::sort para ordenar los elementos en orden ascendente
    std::sort(vec.begin(), vec.end());

    // Mostrar los elementos ordenados
    std::cout << "Elementos ordenados: ";
    for (int elem : vec) {
        std::cout << elem << " ";
    }
    std::cout << std::endl;

    return 0;
}
<---Ejemplo Básico (Orden Ascendente) Result--->
<---Ejemplo con Comparación Personalizada (Orden Descendente)--->
```cpp
#include <iostream>
#include <vector>
#include <algorithm>

int main() {
    std::vector<int> vec = {5, 2, 9, 1, 5, 6};

    // Usar std::sort con una función de comparación para ordenar en orden descendente
    std::sort(vec.begin(), vec.end(), std::greater<int>());

    // Mostrar los elementos ordenados
    std::cout << "Elementos ordenados en orden descendente: ";
    for (int elem : vec) {
        std::cout << elem << " ";
    }
    std::cout << std::endl;

    return 0;
}
<---Ejemplo con Comparación Personalizada (Orden Descendente) Result--->
<---Ordenar un `std::array`--->
```cpp
#include <iostream>
#include <array>
#include <algorithm>

int main() {
    std::array<int, 6> arr = {5, 2, 9, 1, 5, 6};

    // Usar std::sort para ordenar los elementos del array
    std::sort(arr.begin(), arr.end());

    // Mostrar los elementos ordenados
    std::cout << "Elementos del array ordenados: ";
    for (int elem : arr) {
        std::cout << elem << " ";
    }
    std::cout << std::endl;

    return 0;
}
<---Ordenar un `std::array` Result--->
<---Ejemplo Básico (Función Unaria)--->
```cpp
#include <iostream>
#include <vector>
#include <algorithm>

int main() {
    std::vector<int> origen = {1, 2, 3, 4, 5};
    std::vector<int> destino(origen.size());

    // Usar std::transform para duplicar cada elemento
    std::transform(origen.begin(), origen.end(), destino.begin(), [](int x) {
        return x * 2;
    });

    // Mostrar los elementos transformados
    std::cout << "Elementos transformados (duplicados): ";
    for (int elem : destino) {
        std::cout << elem << " ";
    }
    std::cout << std::endl;

    return 0;
}
<---Ejemplo Básico (Función Unaria) Result--->
<---Ejemplo con Función Binaria--->
```cpp
#include <iostream>
#include <vector>
#include <algorithm>

int main() {
    std::vector<int> vec1 = {1, 2, 3, 4, 5};
    std::vector<int> vec2 = {10, 20, 30, 40, 50};
    std::vector<int> resultado(vec1.size());

    // Usar std::transform para sumar elementos de dos vectores
    std::transform(vec1.begin(), vec1.end(), vec2.begin(), resultado.begin(), [](int x, int y) {
        return x + y;
    });

    // Mostrar los elementos transformados
    std::cout << "Elementos transformados (suma de vec1 y vec2): ";
    for (int elem : resultado) {
        std::cout << elem << " ";
    }
    std::cout << std::endl;

    return 0;
}
<---Ejemplo con Función Binaria Result--->
<---Transformar una Lista--->
```cpp
#include <iostream>
#include <list>
#include <algorithm>

int main() {
    std::list<int> origen = {1, 2, 3, 4, 5};
    std::list<int> destino(origen.size());

    // Usar std::transform para incrementar cada elemento
    std::transform(origen.begin(), origen.end(), destino.begin(), [](int x) {
        return x + 1;
    });

    // Mostrar los elementos transformados
    std::cout << "Elementos transformados (incrementados): ";
    for (int elem : destino) {
        std::cout << elem << " ";
    }
    std::cout << std::endl;

    return 0;
}
<---Transformar una Lista Result--->
<---Ejemplo Básico--->
```cpp
#include <iostream>
#include <vector>
#include <algorithm>

int main() {
    std::vector<int> vec(10);

    // Usar std::fill para asignar el valor 5 a todos los elementos del vector
    std::fill(vec.begin(), vec.end(), 5);

    // Mostrar los elementos del vector
    std::cout << "Elementos del vector después de std::fill: ";
    for (int elem : vec) {
        std::cout << elem << " ";
    }
    std::cout << std::endl;

    return 0;
}
<---Ejemplo Básico Result--->
<---Ejemplo con Lambda--->
```cpp
#include <iostream>
#include <vector>
#include <algorithm>

int main() {
    std::vector<int> vec = {1, 2, 3, 4, 5};

    // Usar una lambda para imprimir cada elemento del vector
    std::for_each(vec.begin(), vec.end(), [](int n) {
        std::cout << n << " ";
    });
    std::cout << std::endl;

    return 0;
}
```cpp
#include <iostream>
#include <vector>
#include <algorithm>

int main() {
    std::vector<int> vec = {1, 2, 3, 4, 5};

    // Usar una lambda para incrementar cada elemento del vector
    std::for_each(vec.begin(), vec.end(), [](int& n) {
        n += 1;
    });

    // Imprimir los elementos incrementados
    std::for_each(vec.begin(), vec.end(), [](int n) {
        std::cout << n << " ";
    });
    std::cout << std::endl;

    return 0;
}
```cpp
#include <iostream>
#include <vector>
#include <algorithm>

struct Acumulador {
    int suma = 0;

    void operator()(int n) {
        suma += n;
    }
};

int main() {
    std::vector<int> vec = {1, 2, 3, 4, 5};

    Acumulador acumulador = std::for_each(vec.begin(), vec.end(), Acumulador());

    std::cout << "Suma de los elementos: " << acumulador.suma << std::endl;

    return 0;
}
<---Ejemplo con Lambda Result--->
<---Ejemplo Básico (Suma)--->
```cpp
#include <iostream>
#include <vector>
#include <numeric>

int main() {
    std::vector<int> vec = {1, 2, 3, 4, 5};

    // Usar std::accumulate para sumar todos los elementos
    int suma = std::accumulate(vec.begin(), vec.end(), 0);

    std::cout << "La suma de los elementos es: " << suma << std::endl;

    return 0;
}
<---Ejemplo Básico (Suma) Result--->
<---Ejemplo con Operación Binaria Personalizada (Multiplicación)--->
```cpp
#include <iostream>
#include <vector>
#include <numeric>

int main() {
    std::vector<int> vec = {1, 2, 3, 4, 5};

    // Usar std::accumulate para multiplicar todos los elementos
    int producto = std::accumulate(vec.begin(), vec.end(), 1, std::multiplies<int>());

    std::cout << "El producto de los elementos es: " << producto << std::endl;

    return 0;
}
```cpp
#include <iostream>
#include <vector>
#include <numeric>
#include <string>

int main() {
    std::vector<std::string> vec = {"Hola", " ", "mundo", "!"};

    // Usar std::accumulate para concatenar todas las cadenas
    std::string resultado = std::accumulate(vec.begin(), vec.end(), std::string(""));

    std::cout << "Cadena concatenada: " << resultado << std::endl;

    return 0;
}
```cpp
#include <iostream>
#include <vector>
#include <numeric>

int main() {
    std::vector<int> vec = {1, 2, 3, 4, 5};

    // Calcular la suma de los elementos
    int suma = std::accumulate(vec.begin(), vec.end(), 0);

    // Calcular la media
    double media = static_cast<double>(suma) / vec.size();

    std::cout << "La media de los elementos es: " << media << std::endl;

    return 0;
}
<---Ejemplo con Operación Binaria Personalizada (Multiplicación) Result--->
<---`std::max`--->
```cpp
#include <algorithm>

template <class T>
const T& max(const T& a, const T& b);

template <class T, class Compare>
const T& max(const T& a, const T& b, Compare comp);

template <class ForwardIt>
ForwardIt max_element(ForwardIt first, ForwardIt last);

template <class ForwardIt, class Compare>
ForwardIt max_element(ForwardIt first, ForwardIt last, Compare comp);
<---`std::max` Result--->
<---`std::min`--->
```cpp
#include <algorithm>

template <class T>
const T& min(const T& a, const T& b);

template <class T, class Compare>
const T& min(const T& a, const T& b, Compare comp);

template <class ForwardIt>
ForwardIt min_element(ForwardIt first, ForwardIt last);

template <class ForwardIt, class Compare>
ForwardIt min_element(ForwardIt first, ForwardIt last, Compare comp);
<---`std::min` Result--->
<---Ejemplo Básico con Dos Valores--->
```cpp
#include <iostream>
#include <algorithm>

int main() {
    int a = 10, b = 20;

    // Encontrar el valor máximo
    int maxVal = std::max(a, b);
    std::cout << "El mayor de " << a << " y " << b << " es " << maxVal << std::endl;

    // Encontrar el valor mínimo
    int minVal = std::min(a, b);
    std::cout << "El menor de " << a << " y " << b << " es " << minVal << std::endl;

    return 0;
}
<---Ejemplo Básico con Dos Valores Result--->
<---Ejemplo con Comparación Personalizada--->
```cpp
#include <iostream>
#include <vector>
#include <algorithm>

struct Punto {
    int x, y;
};

bool compararPorDistancia(const Punto& p1, const Punto& p2) {
    return (p1.x * p1.x + p1.y * p1.y) < (p2.x * p2.x + p2.y * p2.y);
}

int main() {
    std::vector<Punto> puntos = {{1, 2}, {3, 4}, {0, 5}, {-1, -1}};

    // Encontrar el punto más lejano del origen
    auto maxIt = std::max_element(puntos.begin(), puntos.end(), compararPorDistancia);
    std::cout << "El punto más lejano es: (" << maxIt->x << ", " << maxIt->y << ")" << std::endl;

    // Encontrar el punto más cercano al origen
    auto minIt = std::min_element(puntos.begin(), puntos.end(), compararPorDistancia);
    std::cout << "El punto más cercano es: (" << minIt->x << ", " << minIt->y << ")" << std::endl;

    return 0;
}
<---Ejemplo con Comparación Personalizada Result--->
<---Ejemplo Básico con un Rango de Elementos--->
```cpp
#include <iostream>
#include <vector>
#include <algorithm>

int main() {
    std::vector<int> vec = {1, 2, 3, 4, 5};

    // Encontrar el elemento máximo
    auto maxIt = std::max_element(vec.begin(), vec.end());
    std::cout << "El elemento máximo es: " << *maxIt << std::endl;

    // Encontrar el elemento mínimo
    auto minIt = std::min_element(vec.begin(), vec.end());
    std::cout << "El elemento mínimo es: " << *minIt << std::endl;

    return 0;
}
<---Ejemplo Básico con un Rango de Elementos Result--->
<---Sintaxis--->
```cpp
#include <algorithm>

template <class InputIt, class UnaryPredicate>
InputIt find_if(InputIt first, InputIt last, UnaryPredicate p);
<---Sintaxis Result--->
<---Ejemplo de Uso de `std::find`--->
```cpp
#include <iostream>
#include <vector>
#include <algorithm>

int main() {
    std::vector<int> vec = {1, 2, 3, 4, 5};

    // Buscar el valor 3
    auto it = std::find(vec.begin(), vec.end(), 3);

    if (it != vec.end()) {
        std::cout << "Elemento encontrado: " << *it << std::endl;
    } else {
        std::cout << "Elemento no encontrado" << std::endl;
    }

    return 0;
}
<---Ejemplo de Uso de `std::find` Result--->
<---Ejemplo de Uso de `std::find_if`--->
```cpp
#include <iostream>
#include <vector>
#include <algorithm>

bool esImpar(int n) {
    return n % 2 != 0;
}

int main() {
    std::vector<int> vec = {2, 4, 6, 7, 8};

    // Buscar el primer elemento impar
    auto it = std::find_if(vec.begin(), vec.end(), esImpar);

    if (it != vec.end()) {
        std::cout << "Primer elemento impar encontrado: " << *it << std::endl;
    } else {
        std::cout << "Elemento impar no encontrado" << std::endl;
    }

    return 0;
}
<---Ejemplo de Uso de `std::find_if` Result--->
<---Ejemplo de Uso de `std::find_if` con Lambda--->
```cpp
#include <iostream>
#include <vector>
#include <algorithm>

int main() {
    std::vector<int> vec = {2, 4, 6, 7, 8};

    // Usar una lambda para buscar el primer elemento impar
    auto it = std::find_if(vec.begin(), vec.end(), [](int n) {
        return n % 2 != 0;
    });

    if (it != vec.end()) {
        std::cout << "Primer elemento impar encontrado: " << *it << std::endl;
    } else {
        std::cout << "Elemento impar no encontrado" << std::endl;
    }

    return 0;
}
```cpp
#include <iostream>
#include <vector>
#include <algorithm>

struct Punto {
    int x, y;

    bool operator==(const Punto& otro) const {
        return x == otro.x && y == otro.y;
    }
};

int main() {
    std::vector<Punto> puntos = {{1, 2}, {3, 4}, {5, 6}, {7, 8}};
    Punto puntoABuscar = {5, 6};

    // Buscar el punto {5, 6}
    auto it = std::find(puntos.begin(), puntos.end(), puntoABuscar);

    if (it != puntos.end()) {
        std::cout << "Punto encontrado: (" << it->x << ", " << it->y << ")" << std::endl;
    } else {
        std::cout << "Punto no encontrado" << std::endl;
    }

    return 0;
}
```cpp
#include <iostream>
#include <vector>
#include <algorithm>

int main() {
    std::vector<int> vec = {2, 4, 6, 7, 8};

    // Usar una lambda para buscar el primer elemento mayor que 5
    auto it = std::find_if(vec.begin(), vec.end(), [](int n) {
        return n > 5;
    });

    if (it != vec.end()) {
        std::cout << "Primer elemento mayor que 5 encontrado: " << *it << std::endl;
    } else {
        std::cout << "Elemento mayor que 5 no encontrado" << std::endl;
    }

    return 0;
}
<---Ejemplo de Uso de `std::find_if` con Lambda Result--->
<---Copiar Elementos entre Diferentes Contenedores--->
```cpp
#include <iostream>
#include <vector>
#include <list>
#include <algorithm>

int main() {
    std::vector<int> origen = {1, 2, 3, 4, 5};
    std::list<int> destino(origen.size());

    // Usar std::copy para copiar los elementos
    std::copy(origen.begin(), origen.end(), destino.begin());

    // Mostrar los elementos copiados
    std::cout << "Elementos copiados a la lista destino: ";
    for (int elem : destino) {
        std::cout << elem << " ";
    }
    std::cout << std::endl;

    return 0;
}
```cpp
#include <iostream>
#include <vector>
#include <algorithm>

int main() {
    std::vector<int> origen = {1, 2, 3, 4, 5};
    std::vector<int> destino(3);

    // Usar std::copy para copiar los primeros 3 elementos
    std::copy(origen.begin(), origen.begin() + 3, destino.begin());

    // Mostrar los elementos copiados
    std::cout << "Primeros 3 elementos copiados al vector destino: ";
    for (int elem : destino) {
        std::cout << elem << " ";
    }
    std::cout << std::endl;

    return 0;
}
```cpp
#include <iostream>
#include <vector>
#include <algorithm>
#include <iterator>

int main() {
    std::vector<int> origen = {1, 2, 3, 4, 5};
    std::vector<int> destino;

    // Usar std::copy con std::back_inserter
    std::copy(origen.begin(), origen.end(), std::back_inserter(destino));

    // Mostrar los elementos copiados
    std::cout << "Elementos copiados al vector destino con back_inserter: ";
    for (int elem : destino) {
        std::cout << elem << " ";
    }
    std::cout << std::endl;

    return 0;
}
<---Copiar Elementos entre Diferentes Contenedores Result--->
<---Ejemplo Básico (Orden Ascendente)--->
```cpp
#include <iostream>
#include <vector>
#include <algorithm>

int main() {
    std::vector<int> vec = {5, 2, 9, 1, 5, 6};

    // Usar std::sort para ordenar los elementos en orden ascendente
    std::sort(vec.begin(), vec.end());

    // Mostrar los elementos ordenados
    std::cout << "Elementos ordenados: ";
    for (int elem : vec) {
        std::cout << elem << " ";
    }
    std::cout << std::endl;

    return 0;
}
<---Ejemplo Básico (Orden Ascendente) Result--->
<---Ejemplo con Comparación Personalizada (Orden Descendente)--->
```cpp
#include <iostream>
#include <vector>
#include <algorithm>

int main() {
    std::vector<int> vec = {5, 2, 9, 1, 5, 6};

    // Usar std::sort con una función de comparación para ordenar en orden descendente
    std::sort(vec.begin(), vec.end(), std::greater<int>());

    // Mostrar los elementos ordenados
    std::cout << "Elementos ordenados en orden descendente: ";
    for (int elem : vec) {
        std::cout << elem << " ";
    }
    std::cout << std::endl;

    return 0;
}
<---Ejemplo con Comparación Personalizada (Orden Descendente) Result--->
<---Ordenar un `std::array`--->
```cpp
#include <iostream>
#include <array>
#include <algorithm>

int main() {
    std::array<int, 6> arr = {5, 2, 9, 1, 5, 6};

    // Usar std::sort para ordenar los elementos del array
    std::sort(arr.begin(), arr.end());

    // Mostrar los elementos ordenados
    std::cout << "Elementos del array ordenados: ";
    for (int elem : arr) {
        std::cout << elem << " ";
    }
    std::cout << std::endl;

    return 0;
}
<---Ordenar un `std::array` Result--->
<---Ejemplo Básico (Función Unaria)--->
```cpp
#include <iostream>
#include <vector>
#include <algorithm>

int main() {
    std::vector<int> origen = {1, 2, 3, 4, 5};
    std::vector<int> destino(origen.size());

    // Usar std::transform para duplicar cada elemento
    std::transform(origen.begin(), origen.end(), destino.begin(), [](int x) {
        return x * 2;
    });

    // Mostrar los elementos transformados
    std::cout << "Elementos transformados (duplicados): ";
    for (int elem : destino) {
        std::cout << elem << " ";
    }
    std::cout << std::endl;

    return 0;
}
<---Ejemplo Básico (Función Unaria) Result--->
<---Ejemplo con Función Binaria--->
```cpp
#include <iostream>
#include <vector>
#include <algorithm>

int main() {
    std::vector<int> vec1 = {1, 2, 3, 4, 5};
    std::vector<int> vec2 = {10, 20, 30, 40, 50};
    std::vector<int> resultado(vec1.size());

    // Usar std::transform para sumar elementos de dos vectores
    std::transform(vec1.begin(), vec1.end(), vec2.begin(), resultado.begin(), [](int x, int y) {
        return x + y;
    });

    // Mostrar los elementos transformados
    std::cout << "Elementos transformados (suma de vec1 y vec2): ";
    for (int elem : resultado) {
        std::cout << elem << " ";
    }
    std::cout << std::endl;

    return 0;
}
<---Ejemplo con Función Binaria Result--->
<---Transformar una Lista--->
```cpp
#include <iostream>
#include <list>
#include <algorithm>

int main() {
    std::list<int> origen = {1, 2, 3, 4, 5};
    std::list<int> destino(origen.size());

    // Usar std::transform para incrementar cada elemento
    std::transform(origen.begin(), origen.end(), destino.begin(), [](int x) {
        return x + 1;
    });

    // Mostrar los elementos transformados
    std::cout << "Elementos transformados (incrementados): ";
    for (int elem : destino) {
        std::cout << elem << " ";
    }
    std::cout << std::endl;

    return 0;
}
<---Transformar una Lista Result--->
<---Ejemplo con `std::array`--->
```cpp
#include <iostream>
#include <array>
#include <algorithm>

int main() {
    std::array<int, 5> arr;

    // Usar std::fill para asignar el valor 10 a todos los elementos del array
    std::fill(arr.begin(), arr.end(), 10);

    // Mostrar los elementos del array
    std::cout << "Elementos del array después de std::fill: ";
    for (int elem : arr) {
        std::cout << elem << " ";
    }
    std::cout << std::endl;

    return 0;
}
<---Ejemplo con `std::array` Result--->
<---Ejemplo con una Matriz--->
```cpp
#include <iostream>
#include <vector>
#include <algorithm>

int main() {
    std::vector<std::vector<int>> matrix(3, std::vector<int>(4));

    // Usar std::fill para asignar el valor 0 a todos los elementos de la matriz
    for (auto& row : matrix) {
        std::fill(row.begin(), row.end(), 0);
    }

    // Mostrar los elementos de la matriz
    std::cout << "Elementos de la matriz después de std::fill: " << std::endl;
    for (const auto& row : matrix) {
        for (int elem : row) {
            std::cout << elem << " ";
        }
        std::cout << std::endl;
    }

    return 0;
}
<---Ejemplo con una Matriz Result--->
<---Ejemplo de Rango Parcial--->
```cpp
#include <iostream>
#include <vector>
#include <algorithm>

int main() {
    std::vector<int> vec(10);

    // Asignar el valor 1 a la primera mitad del vector
    std::fill(vec.begin(), vec.begin() + vec.size() / 2, 1);

    // Asignar el valor 2 a la segunda mitad del vector
    std::fill(vec.begin() + vec.size() / 2, vec.end(), 2);

    // Mostrar los elementos del vector
    std::cout << "Elementos del vector después de std::fill en rangos parciales: ";
    for (int elem : vec) {
        std::cout << elem << " ";
    }
    std::cout << std::endl;

    return 0;
}
<---Ejemplo de Rango Parcial Result--->
<---Ejemplo Básico--->
```cpp
#include <iostream>
#include <vector>
#include <algorithm>

int main() {
    std::vector<int> vec = {1, 2, 3, 2, 5, 2};

    // Usar std::replace para reemplazar todos los 2 por 9
    std::replace(vec.begin(), vec.end(), 2, 9);

    // Mostrar los elementos modificados
    std::cout << "Elementos del vector después de std::replace: ";
    for (int elem : vec) {
        std::cout << elem << " ";
    }
    std::cout << std::endl;

    return 0;
}
<---Ejemplo Básico Result--->
<---Ejemplo con Lambda--->
```cpp
#include <iostream>
#include <vector>
#include <algorithm>

int main() {
    std::vector<int> vec = {1, 2, 3, 4, 5, 6};

    // Usar std::replace_if con una lambda para reemplazar todos los números mayores que 3 por 99
    std::replace_if(vec.begin(), vec.end(), [](int n) { return n > 3; }, 99);

    // Mostrar los elementos modificados
    std::cout << "Elementos del vector después de std::replace_if: ";
    for (int elem : vec) {
        std::cout << elem << " ";
    }
    std::cout << std::endl;

    return 0;
}
<---Ejemplo con Lambda Result--->
<---Ejemplo Básico (Suma)--->
```cpp
#include <iostream>
#include <vector>
#include <numeric>

int main() {
    std::vector<int> vec = {1, 2, 3, 4, 5};

    // Usar std::accumulate para sumar todos los elementos
    int suma = std::accumulate(vec.begin(), vec.end(), 0);

    std::cout << "La suma de los elementos es: " << suma << std::endl;

    return 0;
}
<---Ejemplo Básico (Suma) Result--->
<---Ejemplo con Operación Binaria Personalizada (Multiplicación)--->
```cpp
#include <iostream>
#include <vector>
#include <numeric>

int main() {
    std::vector<int> vec = {1, 2, 3, 4, 5};

    // Usar std::accumulate para multiplicar todos los elementos
    int producto = std::accumulate(vec.begin(), vec.end(), 1, std::multiplies<int>());

    std::cout << "El producto de los elementos es: " << producto << std::endl;

    return 0;
}
```cpp
#include <iostream>
#include <vector>
#include <numeric>
#include <string>

int main() {
    std::vector<std::string> vec = {"Hola", " ", "mundo", "!"};

    // Usar std::accumulate para concatenar todas las cadenas
    std::string resultado = std::accumulate(vec.begin(), vec.end(), std::string(""));

    std::cout << "Cadena concatenada: " << resultado << std::endl;

    return 0;
}
```cpp
#include <iostream>
#include <vector>
#include <numeric>

int main() {
    std::vector<int> vec = {1, 2, 3, 4, 5};

    // Calcular la suma de los elementos
    int suma = std::accumulate(vec.begin(), vec.end(), 0);

    // Calcular la media
    double media = static_cast<double>(suma) / vec.size();

    std::cout << "La media de los elementos es: " << media << std::endl;

    return 0;
}
<---Ejemplo con Operación Binaria Personalizada (Multiplicación) Result--->
<---`std::max`--->
```cpp
#include <algorithm>

template <class T>
const T& max(const T& a, const T& b);

template <class T, class Compare>
const T& max(const T& a, const T& b, Compare comp);

template <class ForwardIt>
ForwardIt max_element(ForwardIt first, ForwardIt last);

template <class ForwardIt, class Compare>
ForwardIt max_element(ForwardIt first, ForwardIt last, Compare comp);
<---`std::max` Result--->
<---`std::min`--->
```cpp
#include <algorithm>

template <class T>
const T& min(const T& a, const T& b);

template <class T, class Compare>
const T& min(const T& a, const T& b, Compare comp);

template <class ForwardIt>
ForwardIt min_element(ForwardIt first, ForwardIt last);

template <class ForwardIt, class Compare>
ForwardIt min_element(ForwardIt first, ForwardIt last, Compare comp);
<---`std::min` Result--->
<---Ejemplo Básico con Dos Valores--->
```cpp
#include <iostream>
#include <algorithm>

int main() {
    int a = 10, b = 20;

    // Encontrar el valor máximo
    int maxVal = std::max(a, b);
    std::cout << "El mayor de " << a << " y " << b << " es " << maxVal << std::endl;

    // Encontrar el valor mínimo
    int minVal = std::min(a, b);
    std::cout << "El menor de " << a << " y " << b << " es " << minVal << std::endl;

    return 0;
}
<---Ejemplo Básico con Dos Valores Result--->
<---Ejemplo con Comparación Personalizada--->
```cpp
#include <iostream>
#include <vector>
#include <algorithm>

struct Punto {
    int x, y;
};

bool compararPorDistancia(const Punto& p1, const Punto& p2) {
    return (p1.x * p1.x + p1.y * p1.y) < (p2.x * p2.x + p2.y * p2.y);
}

int main() {
    std::vector<Punto> puntos = {{1, 2}, {3, 4}, {0, 5}, {-1, -1}};

    // Encontrar el punto más lejano del origen
    auto maxIt = std::max_element(puntos.begin(), puntos.end(), compararPorDistancia);
    std::cout << "El punto más lejano es: (" << maxIt->x << ", " << maxIt->y << ")" << std::endl;

    // Encontrar el punto más cercano al origen
    auto minIt = std::min_element(puntos.begin(), puntos.end(), compararPorDistancia);
    std::cout << "El punto más cercano es: (" << minIt->x << ", " << minIt->y << ")" << std::endl;

    return 0;
}
<---Ejemplo con Comparación Personalizada Result--->
<---Ejemplo Básico con un Rango de Elementos--->
```cpp
#include <iostream>
#include <vector>
#include <algorithm>

int main() {
    std::vector<int> vec = {1, 2, 3, 4, 5};

    // Encontrar el elemento máximo
    auto maxIt = std::max_element(vec.begin(), vec.end());
    std::cout << "El elemento máximo es: " << *maxIt << std::endl;

    // Encontrar el elemento mínimo
    auto minIt = std::min_element(vec.begin(), vec.end());
    std::cout << "El elemento mínimo es: " << *minIt << std::endl;

    return 0;
}
<---Ejemplo Básico con un Rango de Elementos Result--->
<---Sintaxis--->
```cpp
#include <algorithm>

template <class InputIt, class UnaryPredicate>
InputIt find_if(InputIt first, InputIt last, UnaryPredicate p);
<---Sintaxis Result--->
<---Ejemplo de Uso de `std::find`--->
```cpp
#include <iostream>
#include <vector>
#include <algorithm>

int main() {
    std::vector<int> vec = {1, 2, 3, 4, 5};

    // Buscar el valor 3
    auto it = std::find(vec.begin(), vec.end(), 3);

    if (it != vec.end()) {
        std::cout << "Elemento encontrado: " << *it << std::endl;
    } else {
        std::cout << "Elemento no encontrado" << std::endl;
    }

    return 0;
}
<---Ejemplo de Uso de `std::find` Result--->
<---Ejemplo de Uso de `std::find_if`--->
```cpp
#include <iostream>
#include <vector>
#include <algorithm>

bool esImpar(int n) {
    return n % 2 != 0;
}

int main() {
    std::vector<int> vec = {2, 4, 6, 7, 8};

    // Buscar el primer elemento impar
    auto it = std::find_if(vec.begin(), vec.end(), esImpar);

    if (it != vec.end()) {
        std::cout << "Primer elemento impar encontrado: " << *it << std::endl;
    } else {
        std::cout << "Elemento impar no encontrado" << std::endl;
    }

    return 0;
}
<---Ejemplo de Uso de `std::find_if` Result--->
<---Ejemplo de Uso de `std::find_if` con Lambda--->
```cpp
#include <iostream>
#include <vector>
#include <algorithm>

int main() {
    std::vector<int> vec = {2, 4, 6, 7, 8};

    // Usar una lambda para buscar el primer elemento impar
    auto it = std::find_if(vec.begin(), vec.end(), [](int n) {
        return n % 2 != 0;
    });

    if (it != vec.end()) {
        std::cout << "Primer elemento impar encontrado: " << *it << std::endl;
    } else {
        std::cout << "Elemento impar no encontrado" << std::endl;
    }

    return 0;
}
```cpp
#include <iostream>
#include <vector>
#include <algorithm>

struct Punto {
    int x, y;

    bool operator==(const Punto& otro) const {
        return x == otro.x && y == otro.y;
    }
};

int main() {
    std::vector<Punto> puntos = {{1, 2}, {3, 4}, {5, 6}, {7, 8}};
    Punto puntoABuscar = {5, 6};

    // Buscar el punto {5, 6}
    auto it = std::find(puntos.begin(), puntos.end(), puntoABuscar);

    if (it != puntos.end()) {
        std::cout << "Punto encontrado: (" << it->x << ", " << it->y << ")" << std::endl;
    } else {
        std::cout << "Punto no encontrado" << std::endl;
    }

    return 0;
}
```cpp
#include <iostream>
#include <vector>
#include <algorithm>

int main() {
    std::vector<int> vec = {2, 4, 6, 7, 8};

    // Usar una lambda para buscar el primer elemento mayor que 5
    auto it = std::find_if(vec.begin(), vec.end(), [](int n) {
        return n > 5;
    });

    if (it != vec.end()) {
        std::cout << "Primer elemento mayor que 5 encontrado: " << *it << std::endl;
    } else {
        std::cout << "Elemento mayor que 5 no encontrado" << std::endl;
    }

    return 0;
}
<---Ejemplo de Uso de `std::find_if` con Lambda Result--->
<---Copiar Elementos entre Diferentes Contenedores--->
```cpp
#include <iostream>
#include <vector>
#include <list>
#include <algorithm>

int main() {
    std::vector<int> origen = {1, 2, 3, 4, 5};
    std::list<int> destino(origen.size());

    // Usar std::copy para copiar los elementos
    std::copy(origen.begin(), origen.end(), destino.begin());

    // Mostrar los elementos copiados
    std::cout << "Elementos copiados a la lista destino: ";
    for (int elem : destino) {
        std::cout << elem << " ";
    }
    std::cout << std::endl;

    return 0;
}
```cpp
#include <iostream>
#include <vector>
#include <algorithm>

int main() {
    std::vector<int> origen = {1, 2, 3, 4, 5};
    std::vector<int> destino(3);

    // Usar std::copy para copiar los primeros 3 elementos
    std::copy(origen.begin(), origen.begin() + 3, destino.begin());

    // Mostrar los elementos copiados
    std::cout << "Primeros 3 elementos copiados al vector destino: ";
    for (int elem : destino) {
        std::cout << elem << " ";
    }
    std::cout << std::endl;

    return 0;
}
```cpp
#include <iostream>
#include <vector>
#include <algorithm>
#include <iterator>

int main() {
    std::vector<int> origen = {1, 2, 3, 4, 5};
    std::vector<int> destino;

    // Usar std::copy con std::back_inserter
    std::copy(origen.begin(), origen.end(), std::back_inserter(destino));

    // Mostrar los elementos copiados
    std::cout << "Elementos copiados al vector destino con back_inserter: ";
    for (int elem : destino) {
        std::cout << elem << " ";
    }
    std::cout << std::endl;

    return 0;
}
<---Copiar Elementos entre Diferentes Contenedores Result--->
<---Ejemplo Básico (Orden Ascendente)--->
```cpp
#include <iostream>
#include <vector>
#include <algorithm>

int main() {
    std::vector<int> vec = {5, 2, 9, 1, 5, 6};

    // Usar std::sort para ordenar los elementos en orden ascendente
    std::sort(vec.begin(), vec.end());

    // Mostrar los elementos ordenados
    std::cout << "Elementos ordenados: ";
    for (int elem : vec) {
        std::cout << elem << " ";
    }
    std::cout << std::endl;

    return 0;
}
<---Ejemplo Básico (Orden Ascendente) Result--->
<---Ejemplo con Comparación Personalizada (Orden Descendente)--->
```cpp
#include <iostream>
#include <vector>
#include <algorithm>

int main() {
    std::vector<int> vec = {5, 2, 9, 1, 5, 6};

    // Usar std::sort con una función de comparación para ordenar en orden descendente
    std::sort(vec.begin(), vec.end(), std::greater<int>());

    // Mostrar los elementos ordenados
    std::cout << "Elementos ordenados en orden descendente: ";
    for (int elem : vec) {
        std::cout << elem << " ";
    }
    std::cout << std::endl;

    return 0;
}
<---Ejemplo con Comparación Personalizada (Orden Descendente) Result--->
<---Ordenar un `std::array`--->
```cpp
#include <iostream>
#include <array>
#include <algorithm>

int main() {
    std::array<int, 6> arr = {5, 2, 9, 1, 5, 6};

    // Usar std::sort para ordenar los elementos del array
    std::sort(arr.begin(), arr.end());

    // Mostrar los elementos ordenados
    std::cout << "Elementos del array ordenados: ";
    for (int elem : arr) {
        std::cout << elem << " ";
    }
    std::cout << std::endl;

    return 0;
}
<---Ordenar un `std::array` Result--->
<---Ejemplo Básico (Función Unaria)--->
```cpp
#include <iostream>
#include <vector>
#include <algorithm>

int main() {
    std::vector<int> origen = {1, 2, 3, 4, 5};
    std::vector<int> destino(origen.size());

    // Usar std::transform para duplicar cada elemento
    std::transform(origen.begin(), origen.end(), destino.begin(), [](int x) {
        return x * 2;
    });

    // Mostrar los elementos transformados
    std::cout << "Elementos transformados (duplicados): ";
    for (int elem : destino) {
        std::cout << elem << " ";
    }
    std::cout << std::endl;

    return 0;
}
<---Ejemplo Básico (Función Unaria) Result--->
<---Ejemplo con Función Binaria--->
```cpp
#include <iostream>
#include <vector>
#include <algorithm>

int main() {
    std::vector<int> vec1 = {1, 2, 3, 4, 5};
    std::vector<int> vec2 = {10, 20, 30, 40, 50};
    std::vector<int> resultado(vec1.size());

    // Usar std::transform para sumar elementos de dos vectores
    std::transform(vec1.begin(), vec1.end(), vec2.begin(), resultado.begin(), [](int x, int y) {
        return x + y;
    });

    // Mostrar los elementos transformados
    std::cout << "Elementos transformados (suma de vec1 y vec2): ";
    for (int elem : resultado) {
        std::cout << elem << " ";
    }
    std::cout << std::endl;

    return 0;
}
<---Ejemplo con Función Binaria Result--->
<---Transformar una Lista--->
```cpp
#include <iostream>
#include <list>
#include <algorithm>

int main() {
    std::list<int> origen = {1, 2, 3, 4, 5};
    std::list<int> destino(origen.size());

    // Usar std::transform para incrementar cada elemento
    std::transform(origen.begin(), origen.end(), destino.begin(), [](int x) {
        return x + 1;
    });

    // Mostrar los elementos transformados
    std::cout << "Elementos transformados (incrementados): ";
    for (int elem : destino) {
        std::cout << elem << " ";
    }
    std::cout << std::endl;

    return 0;
}
<---Transformar una Lista Result--->
<---Ejemplo con `std::array`--->
```cpp
#include <iostream>
#include <array>
#include <algorithm>

int main() {
    std::array<int, 5> arr;

    // Usar std::fill para asignar el valor 10 a todos los elementos del array
    std::fill(arr.begin(), arr.end(), 10);

    // Mostrar los elementos del array
    std::cout << "Elementos del array después de std::fill: ";
    for (int elem : arr) {
        std::cout << elem << " ";
    }
    std::cout << std::endl;

    return 0;
}
<---Ejemplo con `std::array` Result--->
<---Ejemplo con una Matriz--->
```cpp
#include <iostream>
#include <vector>
#include <algorithm>

int main() {
    std::vector<std::vector<int>> matrix(3, std::vector<int>(4));

    // Usar std::fill para asignar el valor 0 a todos los elementos de la matriz
    for (auto& row : matrix) {
        std::fill(row.begin(), row.end(), 0);
    }

    // Mostrar los elementos de la matriz
    std::cout << "Elementos de la matriz después de std::fill: " << std::endl;
    for (const auto& row : matrix) {
        for (int elem : row) {
            std::cout << elem << " ";
        }
        std::cout << std::endl;
    }

    return 0;
}
<---Ejemplo con una Matriz Result--->
<---Ejemplo de Rango Parcial--->
```cpp
#include <iostream>
#include <vector>
#include <algorithm>

int main() {
    std::vector<int> vec(10);

    // Asignar el valor 1 a la primera mitad del vector
    std::fill(vec.begin(), vec.begin() + vec.size() / 2, 1);

    // Asignar el valor 2 a la segunda mitad del vector
    std::fill(vec.begin() + vec.size() / 2, vec.end(), 2);

    // Mostrar los elementos del vector
    std::cout << "Elementos del vector después de std::fill en rangos parciales: ";
    for (int elem : vec) {
        std::cout << elem << " ";
    }
    std::cout << std::endl;

    return 0;
}
<---Ejemplo de Rango Parcial Result--->
<---Ejemplo con `std::list`--->
```cpp
#include <iostream>
#include <list>
#include <algorithm>

int main() {
    std::list<int> lst = {1, 2, 3, 2, 5, 2};

    // Usar std::replace para reemplazar todos los 2 por 9
    std::replace(lst.begin(), lst.end(), 2, 9);

    // Mostrar los elementos modificados
    std::cout << "Elementos de la lista después de std::replace: ";
    for (int elem : lst) {
        std::cout << elem << " ";
    }
    std::cout << std::endl;

    return 0;
}
```cpp
#include <iostream>
#include <vector>
#include <algorithm>

int main() {
    std::vector<int> vec = {1, 2, 3, 2, 5, 2};

    // Usar std::replace para reemplazar todos los 2 por 9 en la primera mitad del vector
    std::replace(vec.begin(), vec.begin() + vec.size() / 2, 2, 9);

    // Mostrar los elementos modificados
    std::cout << "Elementos del vector después de std::replace en la primera mitad: ";
    for (int elem : vec) {
        std::cout << elem << " ";
    }
    std::cout << std::endl;

    return 0;
}
```cpp
#include <algorithm>

template <class ForwardIt, class UnaryPredicate, class T>
void replace_if(ForwardIt first, ForwardIt last, UnaryPredicate p, const T& new_value);
<---Ejemplo con `std::list` Result--->
<---Ejemplo Básico con `std::replace_if`--->
```cpp
#include <iostream>
#include <vector>
#include <algorithm>

bool esPar(int n) {
    return n % 2 == 0;
}

int main() {
    std::vector<int> vec = {1, 2, 3, 4, 5, 6};

    // Usar std::replace_if para reemplazar todos los números pares por 0
    std::replace_if(vec.begin(), vec.end(), esPar, 0);

    // Mostrar los elementos modificados
    std::cout << "Elementos del vector después de std::replace_if: ";
    for (int elem : vec) {
        std::cout << elem << " ";
    }
    std::cout << std::endl;

    return 0;
}
<---Ejemplo Básico con `std::replace_if` Result--->
<---Ejemplo Básico--->
```cpp
#include <iostream>
#include <vector>
#include <algorithm>

int main() {
    std::vector<int> vec = {1, 2, 3, 2, 5, 2};

    // Usar std::remove para mover los elementos que no son 2 al principio
    auto it = std::remove(vec.begin(), vec.end(), 2);

    // Eliminar físicamente los elementos después del nuevo final lógico
    vec.erase(it, vec.end());

    // Mostrar los elementos restantes
    std::cout << "Elementos del vector después de std::remove y erase: ";
    for (int elem : vec) {
        std::cout << elem << " ";
    }
    std::cout << std::endl;

    return 0;
}
<---Ejemplo Básico Result--->
<---Ejemplo con Lambda--->
```cpp
#include <iostream>
#include <vector>
#include <algorithm>

int main() {
    std::vector<int> vec = {1, 2, 3, 4, 5, 6};

    // Usar std::remove_if con una lambda para mover los números mayores que 3 al final
    auto it = std::remove_if(vec.begin(), vec.end(), [](int n) { return n > 3; });

    // Eliminar físicamente los elementos después del nuevo final lógico
    vec.erase(it, vec.end());

    // Mostrar los elementos restantes
    std::cout << "Elementos del vector después de std::remove_if y erase: ";
    for (int elem : vec) {
        std::cout << elem << " ";
    }
    std::cout << std::endl;

    return 0;
}
<---Ejemplo con Lambda Result--->
<---Ejemplo Básico (Suma)--->
```cpp
#include <iostream>
#include <vector>
#include <numeric>

int main() {
    std::vector<int> vec = {1, 2, 3, 4, 5};

    // Usar std::accumulate para sumar todos los elementos
    int suma = std::accumulate(vec.begin(), vec.end(), 0);

    std::cout << "La suma de los elementos es: " << suma << std::endl;

    return 0;
}
<---Ejemplo Básico (Suma) Result--->
<---Ejemplo con Operación Binaria Personalizada (Multiplicación)--->
```cpp
#include <iostream>
#include <vector>
#include <numeric>

int main() {
    std::vector<int> vec = {1, 2, 3, 4, 5};

    // Usar std::accumulate para multiplicar todos los elementos
    int producto = std::accumulate(vec.begin(), vec.end(), 1, std::multiplies<int>());

    std::cout << "El producto de los elementos es: " << producto << std::endl;

    return 0;
}
```cpp
#include <iostream>
#include <vector>
#include <numeric>
#include <string>

int main() {
    std::vector<std::string> vec = {"Hola", " ", "mundo", "!"};

    // Usar std::accumulate para concatenar todas las cadenas
    std::string resultado = std::accumulate(vec.begin(), vec.end(), std::string(""));

    std::cout << "Cadena concatenada: " << resultado << std::endl;

    return 0;
}
```cpp
#include <iostream>
#include <vector>
#include <numeric>

int main() {
    std::vector<int> vec = {1, 2, 3, 4, 5};

    // Calcular la suma de los elementos
    int suma = std::accumulate(vec.begin(), vec.end(), 0);

    // Calcular la media
    double media = static_cast<double>(suma) / vec.size();

    std::cout << "La media de los elementos es: " << media << std::endl;

    return 0;
}
<---Ejemplo con Operación Binaria Personalizada (Multiplicación) Result--->
<---`std::max`--->
```cpp
#include <algorithm>

template <class T>
const T& max(const T& a, const T& b);

template <class T, class Compare>
const T& max(const T& a, const T& b, Compare comp);

template <class ForwardIt>
ForwardIt max_element(ForwardIt first, ForwardIt last);

template <class ForwardIt, class Compare>
ForwardIt max_element(ForwardIt first, ForwardIt last, Compare comp);
<---`std::max` Result--->
<---`std::min`--->
```cpp
#include <algorithm>

template <class T>
const T& min(const T& a, const T& b);

template <class T, class Compare>
const T& min(const T& a, const T& b, Compare comp);

template <class ForwardIt>
ForwardIt min_element(ForwardIt first, ForwardIt last);

template <class ForwardIt, class Compare>
ForwardIt min_element(ForwardIt first, ForwardIt last, Compare comp);
<---`std::min` Result--->
<---Ejemplo Básico con Dos Valores--->
```cpp
#include <iostream>
#include <algorithm>

int main() {
    int a = 10, b = 20;

    // Encontrar el valor máximo
    int maxVal = std::max(a, b);
    std::cout << "El mayor de " << a << " y " << b << " es " << maxVal << std::endl;

    // Encontrar el valor mínimo
    int minVal = std::min(a, b);
    std::cout << "El menor de " << a << " y " << b << " es " << minVal << std::endl;

    return 0;
}
<---Ejemplo Básico con Dos Valores Result--->
<---Ejemplo con Comparación Personalizada--->
```cpp
#include <iostream>
#include <vector>
#include <algorithm>

struct Punto {
    int x, y;
};

bool compararPorDistancia(const Punto& p1, const Punto& p2) {
    return (p1.x * p1.x + p1.y * p1.y) < (p2.x * p2.x + p2.y * p2.y);
}

int main() {
    std::vector<Punto> puntos = {{1, 2}, {3, 4}, {0, 5}, {-1, -1}};

    // Encontrar el punto más lejano del origen
    auto maxIt = std::max_element(puntos.begin(), puntos.end(), compararPorDistancia);
    std::cout << "El punto más lejano es: (" << maxIt->x << ", " << maxIt->y << ")" << std::endl;

    // Encontrar el punto más cercano al origen
    auto minIt = std::min_element(puntos.begin(), puntos.end(), compararPorDistancia);
    std::cout << "El punto más cercano es: (" << minIt->x << ", " << minIt->y << ")" << std::endl;

    return 0;
}
<---Ejemplo con Comparación Personalizada Result--->
<---Ejemplo Básico con un Rango de Elementos--->
```cpp
#include <iostream>
#include <vector>
#include <algorithm>

int main() {
    std::vector<int> vec = {1, 2, 3, 4, 5};

    // Encontrar el elemento máximo
    auto maxIt = std::max_element(vec.begin(), vec.end());
    std::cout << "El elemento máximo es: " << *maxIt << std::endl;

    // Encontrar el elemento mínimo
    auto minIt = std::min_element(vec.begin(), vec.end());
    std::cout << "El elemento mínimo es: " << *minIt << std::endl;

    return 0;
}
<---Ejemplo Básico con un Rango de Elementos Result--->
<---Sintaxis--->
```cpp
#include <algorithm>

template <class InputIt, class UnaryPredicate>
InputIt find_if(InputIt first, InputIt last, UnaryPredicate p);
<---Sintaxis Result--->
<---Ejemplo de Uso de `std::find`--->
```cpp
#include <iostream>
#include <vector>
#include <algorithm>

int main() {
    std::vector<int> vec = {1, 2, 3, 4, 5};

    // Buscar el valor 3
    auto it = std::find(vec.begin(), vec.end(), 3);

    if (it != vec.end()) {
        std::cout << "Elemento encontrado: " << *it << std::endl;
    } else {
        std::cout << "Elemento no encontrado" << std::endl;
    }

    return 0;
}
<---Ejemplo de Uso de `std::find` Result--->
<---Ejemplo de Uso de `std::find_if`--->
```cpp
#include <iostream>
#include <vector>
#include <algorithm>

bool esImpar(int n) {
    return n % 2 != 0;
}

int main() {
    std::vector<int> vec = {2, 4, 6, 7, 8};

    // Buscar el primer elemento impar
    auto it = std::find_if(vec.begin(), vec.end(), esImpar);

    if (it != vec.end()) {
        std::cout << "Primer elemento impar encontrado: " << *it << std::endl;
    } else {
        std::cout << "Elemento impar no encontrado" << std::endl;
    }

    return 0;
}
<---Ejemplo de Uso de `std::find_if` Result--->
<---Ejemplo de Uso de `std::find_if` con Lambda--->
```cpp
#include <iostream>
#include <vector>
#include <algorithm>

int main() {
    std::vector<int> vec = {2, 4, 6, 7, 8};

    // Usar una lambda para buscar el primer elemento impar
    auto it = std::find_if(vec.begin(), vec.end(), [](int n) {
        return n % 2 != 0;
    });

    if (it != vec.end()) {
        std::cout << "Primer elemento impar encontrado: " << *it << std::endl;
    } else {
        std::cout << "Elemento impar no encontrado" << std::endl;
    }

    return 0;
}
```cpp
#include <iostream>
#include <vector>
#include <algorithm>

struct Punto {
    int x, y;

    bool operator==(const Punto& otro) const {
        return x == otro.x && y == otro.y;
    }
};

int main() {
    std::vector<Punto> puntos = {{1, 2}, {3, 4}, {5, 6}, {7, 8}};
    Punto puntoABuscar = {5, 6};

    // Buscar el punto {5, 6}
    auto it = std::find(puntos.begin(), puntos.end(), puntoABuscar);

    if (it != puntos.end()) {
        std::cout << "Punto encontrado: (" << it->x << ", " << it->y << ")" << std::endl;
    } else {
        std::cout << "Punto no encontrado" << std::endl;
    }

    return 0;
}
```cpp
#include <iostream>
#include <vector>
#include <algorithm>

int main() {
    std::vector<int> vec = {2, 4, 6, 7, 8};

    // Usar una lambda para buscar el primer elemento mayor que 5
    auto it = std::find_if(vec.begin(), vec.end(), [](int n) {
        return n > 5;
    });

    if (it != vec.end()) {
        std::cout << "Primer elemento mayor que 5 encontrado: " << *it << std::endl;
    } else {
        std::cout << "Elemento mayor que 5 no encontrado" << std::endl;
    }

    return 0;
}
<---Ejemplo de Uso de `std::find_if` con Lambda Result--->
<---Copiar Elementos entre Diferentes Contenedores--->
```cpp
#include <iostream>
#include <vector>
#include <list>
#include <algorithm>

int main() {
    std::vector<int> origen = {1, 2, 3, 4, 5};
    std::list<int> destino(origen.size());

    // Usar std::copy para copiar los elementos
    std::copy(origen.begin(), origen.end(), destino.begin());

    // Mostrar los elementos copiados
    std::cout << "Elementos copiados a la lista destino: ";
    for (int elem : destino) {
        std::cout << elem << " ";
    }
    std::cout << std::endl;

    return 0;
}
```cpp
#include <iostream>
#include <vector>
#include <algorithm>

int main() {
    std::vector<int> origen = {1, 2, 3, 4, 5};
    std::vector<int> destino(3);

    // Usar std::copy para copiar los primeros 3 elementos
    std::copy(origen.begin(), origen.begin() + 3, destino.begin());

    // Mostrar los elementos copiados
    std::cout << "Primeros 3 elementos copiados al vector destino: ";
    for (int elem : destino) {
        std::cout << elem << " ";
    }
    std::cout << std::endl;

    return 0;
}
```cpp
#include <iostream>
#include <vector>
#include <algorithm>
#include <iterator>

int main() {
    std::vector<int> origen = {1, 2, 3, 4, 5};
    std::vector<int> destino;

    // Usar std::copy con std::back_inserter
    std::copy(origen.begin(), origen.end(), std::back_inserter(destino));

    // Mostrar los elementos copiados
    std::cout << "Elementos copiados al vector destino con back_inserter: ";
    for (int elem : destino) {
        std::cout << elem << " ";
    }
    std::cout << std::endl;

    return 0;
}
<---Copiar Elementos entre Diferentes Contenedores Result--->
<---Ejemplo Básico (Orden Ascendente)--->
```cpp
#include <iostream>
#include <vector>
#include <algorithm>

int main() {
    std::vector<int> vec = {5, 2, 9, 1, 5, 6};

    // Usar std::sort para ordenar los elementos en orden ascendente
    std::sort(vec.begin(), vec.end());

    // Mostrar los elementos ordenados
    std::cout << "Elementos ordenados: ";
    for (int elem : vec) {
        std::cout << elem << " ";
    }
    std::cout << std::endl;

    return 0;
}
<---Ejemplo Básico (Orden Ascendente) Result--->
<---Ejemplo con Comparación Personalizada (Orden Descendente)--->
```cpp
#include <iostream>
#include <vector>
#include <algorithm>

int main() {
    std::vector<int> vec = {5, 2, 9, 1, 5, 6};

    // Usar std::sort con una función de comparación para ordenar en orden descendente
    std::sort(vec.begin(), vec.end(), std::greater<int>());

    // Mostrar los elementos ordenados
    std::cout << "Elementos ordenados en orden descendente: ";
    for (int elem : vec) {
        std::cout << elem << " ";
    }
    std::cout << std::endl;

    return 0;
}
<---Ejemplo con Comparación Personalizada (Orden Descendente) Result--->
<---Ordenar un `std::array`--->
```cpp
#include <iostream>
#include <array>
#include <algorithm>

int main() {
    std::array<int, 6> arr = {5, 2, 9, 1, 5, 6};

    // Usar std::sort para ordenar los elementos del array
    std::sort(arr.begin(), arr.end());

    // Mostrar los elementos ordenados
    std::cout << "Elementos del array ordenados: ";
    for (int elem : arr) {
        std::cout << elem << " ";
    }
    std::cout << std::endl;

    return 0;
}
<---Ordenar un `std::array` Result--->
<---Ejemplo Básico (Función Unaria)--->
```cpp
#include <iostream>
#include <vector>
#include <algorithm>

int main() {
    std::vector<int> origen = {1, 2, 3, 4, 5};
    std::vector<int> destino(origen.size());

    // Usar std::transform para duplicar cada elemento
    std::transform(origen.begin(), origen.end(), destino.begin(), [](int x) {
        return x * 2;
    });

    // Mostrar los elementos transformados
    std::cout << "Elementos transformados (duplicados): ";
    for (int elem : destino) {
        std::cout << elem << " ";
    }
    std::cout << std::endl;

    return 0;
}
<---Ejemplo Básico (Función Unaria) Result--->
<---Ejemplo con Función Binaria--->
```cpp
#include <iostream>
#include <vector>
#include <algorithm>

int main() {
    std::vector<int> vec1 = {1, 2, 3, 4, 5};
    std::vector<int> vec2 = {10, 20, 30, 40, 50};
    std::vector<int> resultado(vec1.size());

    // Usar std::transform para sumar elementos de dos vectores
    std::transform(vec1.begin(), vec1.end(), vec2.begin(), resultado.begin(), [](int x, int y) {
        return x + y;
    });

    // Mostrar los elementos transformados
    std::cout << "Elementos transformados (suma de vec1 y vec2): ";
    for (int elem : resultado) {
        std::cout << elem << " ";
    }
    std::cout << std::endl;

    return 0;
}
<---Ejemplo con Función Binaria Result--->
<---Transformar una Lista--->
```cpp
#include <iostream>
#include <list>
#include <algorithm>

int main() {
    std::list<int> origen = {1, 2, 3, 4, 5};
    std::list<int> destino(origen.size());

    // Usar std::transform para incrementar cada elemento
    std::transform(origen.begin(), origen.end(), destino.begin(), [](int x) {
        return x + 1;
    });

    // Mostrar los elementos transformados
    std::cout << "Elementos transformados (incrementados): ";
    for (int elem : destino) {
        std::cout << elem << " ";
    }
    std::cout << std::endl;

    return 0;
}
<---Transformar una Lista Result--->
<---Ejemplo con `std::array`--->
```cpp
#include <iostream>
#include <array>
#include <algorithm>

int main() {
    std::array<int, 5> arr;

    // Usar std::fill para asignar el valor 10 a todos los elementos del array
    std::fill(arr.begin(), arr.end(), 10);

    // Mostrar los elementos del array
    std::cout << "Elementos del array después de std::fill: ";
    for (int elem : arr) {
        std::cout << elem << " ";
    }
    std::cout << std::endl;

    return 0;
}
<---Ejemplo con `std::array` Result--->
<---Ejemplo con una Matriz--->
```cpp
#include <iostream>
#include <vector>
#include <algorithm>

int main() {
    std::vector<std::vector<int>> matrix(3, std::vector<int>(4));

    // Usar std::fill para asignar el valor 0 a todos los elementos de la matriz
    for (auto& row : matrix) {
        std::fill(row.begin(), row.end(), 0);
    }

    // Mostrar los elementos de la matriz
    std::cout << "Elementos de la matriz después de std::fill: " << std::endl;
    for (const auto& row : matrix) {
        for (int elem : row) {
            std::cout << elem << " ";
        }
        std::cout << std::endl;
    }

    return 0;
}
<---Ejemplo con una Matriz Result--->
<---Ejemplo de Rango Parcial--->
```cpp
#include <iostream>
#include <vector>
#include <algorithm>

int main() {
    std::vector<int> vec(10);

    // Asignar el valor 1 a la primera mitad del vector
    std::fill(vec.begin(), vec.begin() + vec.size() / 2, 1);

    // Asignar el valor 2 a la segunda mitad del vector
    std::fill(vec.begin() + vec.size() / 2, vec.end(), 2);

    // Mostrar los elementos del vector
    std::cout << "Elementos del vector después de std::fill en rangos parciales: ";
    for (int elem : vec) {
        std::cout << elem << " ";
    }
    std::cout << std::endl;

    return 0;
}
<---Ejemplo de Rango Parcial Result--->
<---Ejemplo con `std::list`--->
```cpp
#include <iostream>
#include <list>
#include <algorithm>

int main() {
    std::list<int> lst = {1, 2, 3, 2, 5, 2};

    // Usar std::remove para mover los elementos que no son 2 al principio
    auto it = std::remove(lst.begin(), lst.end(), 2);

    // Eliminar físicamente los elementos después del nuevo final lógico
    lst.erase(it, lst.end());

    // Mostrar los elementos restantes
    std::cout << "Elementos de la lista después de std::remove y erase: ";
    for (int elem : lst) {
        std::cout << elem << " ";
    }
    std::cout << std::endl;

    return 0;
}
```cpp
#include <algorithm>

template <class ForwardIt, class UnaryPredicate>
ForwardIt remove_if(ForwardIt first, ForwardIt last, UnaryPredicate p);
<---Ejemplo con `std::list` Result--->
<---Ejemplo Básico con `std::replace_if`--->
```cpp
#include <iostream>
#include <vector>
#include <algorithm>

bool esPar(int n) {
    return n % 2 == 0;
}

int main() {
    std::vector<int> vec = {1, 2, 3, 4, 5, 6};

    // Usar std::replace_if para reemplazar todos los números pares por 0
    std::replace_if(vec.begin(), vec.end(), esPar, 0);

    // Mostrar los elementos modificados
    std::cout << "Elementos del vector después de std::replace_if: ";
    for (int elem : vec) {
        std::cout << elem << " ";
    }
    std::cout << std::endl;

    return 0;
}
<---Ejemplo Básico con `std::replace_if` Result--->
<---Ejemplo Básico con `std::remove_if`--->
```cpp
#include <iostream>
#include <vector>
#include <algorithm>

bool esPar(int n) {
    return n % 2 == 0;
}

int main() {
    std::vector<int> vec = {1, 2, 3, 4, 5, 6};

    // Usar std::remove_if para mover los números pares al final
    auto it = std::remove_if(vec.begin(), vec.end(), esPar);

    // Eliminar físicamente los elementos después del nuevo final lógico
    vec.erase(it, vec.end());

    // Mostrar los elementos restantes
    std::cout << "Elementos del vector después de std::remove_if y erase: ";
    for (int elem : vec) {
        std::cout << elem << " ";
    }
    std::cout << std::endl;

    return 0;
}
<---Ejemplo Básico con `std::remove_if` Result--->
<---Ejemplo Básico--->
```cpp
#include <iostream>
#include <vector>
#include <algorithm>

int main() {
    std::vector<int> vec = {1, 2, 3, 4, 5};

    // Usar std::reverse para invertir el orden de los elementos
    std::reverse(vec.begin(), vec.end());

    // Mostrar los elementos invertidos
    std::cout << "Elementos del vector después de std::reverse: ";
    for (int elem : vec) {
        std::cout << elem << " ";
    }
    std::cout << std::endl;

    return 0;
}
<---Ejemplo Básico Result--->
<---Ejemplo con Lambda--->
```cpp
#include <iostream>
#include <vector>
#include <algorithm>

int main() {
    std::vector<int> vec = {1, 2, 3, 4, 5, 6};

    // Usar std::remove_if con una lambda para mover los números mayores que 3 al final
    auto it = std::remove_if(vec.begin(), vec.end(), [](int n) { return n > 3; });

    // Eliminar físicamente los elementos después del nuevo final lógico
    vec.erase(it, vec.end());

    // Mostrar los elementos restantes
    std::cout << "Elementos del vector después de std::remove_if y erase: ";
    for (int elem : vec) {
        std::cout << elem << " ";
    }
    std::cout << std::endl;

    return 0;
}
<---Ejemplo con Lambda Result--->
<---Ejemplo Básico (Suma)--->
```cpp
#include <iostream>
#include <vector>
#include <numeric>

int main() {
    std::vector<int> vec = {1, 2, 3, 4, 5};

    // Usar std::accumulate para sumar todos los elementos
    int suma = std::accumulate(vec.begin(), vec.end(), 0);

    std::cout << "La suma de los elementos es: " << suma << std::endl;

    return 0;
}
<---Ejemplo Básico (Suma) Result--->
<---Ejemplo con Operación Binaria Personalizada (Multiplicación)--->
```cpp
#include <iostream>
#include <vector>
#include <numeric>

int main() {
    std::vector<int> vec = {1, 2, 3, 4, 5};

    // Usar std::accumulate para multiplicar todos los elementos
    int producto = std::accumulate(vec.begin(), vec.end(), 1, std::multiplies<int>());

    std::cout << "El producto de los elementos es: " << producto << std::endl;

    return 0;
}
```cpp
#include <iostream>
#include <vector>
#include <numeric>
#include <string>

int main() {
    std::vector<std::string> vec = {"Hola", " ", "mundo", "!"};

    // Usar std::accumulate para concatenar todas las cadenas
    std::string resultado = std::accumulate(vec.begin(), vec.end(), std::string(""));

    std::cout << "Cadena concatenada: " << resultado << std::endl;

    return 0;
}
```cpp
#include <iostream>
#include <vector>
#include <numeric>

int main() {
    std::vector<int> vec = {1, 2, 3, 4, 5};

    // Calcular la suma de los elementos
    int suma = std::accumulate(vec.begin(), vec.end(), 0);

    // Calcular la media
    double media = static_cast<double>(suma) / vec.size();

    std::cout << "La media de los elementos es: " << media << std::endl;

    return 0;
}
<---Ejemplo con Operación Binaria Personalizada (Multiplicación) Result--->
<---`std::max`--->
```cpp
#include <algorithm>

template <class T>
const T& max(const T& a, const T& b);

template <class T, class Compare>
const T& max(const T& a, const T& b, Compare comp);

template <class ForwardIt>
ForwardIt max_element(ForwardIt first, ForwardIt last);

template <class ForwardIt, class Compare>
ForwardIt max_element(ForwardIt first, ForwardIt last, Compare comp);
<---`std::max` Result--->
<---`std::min`--->
```cpp
#include <algorithm>

template <class T>
const T& min(const T& a, const T& b);

template <class T, class Compare>
const T& min(const T& a, const T& b, Compare comp);

template <class ForwardIt>
ForwardIt min_element(ForwardIt first, ForwardIt last);

template <class ForwardIt, class Compare>
ForwardIt min_element(ForwardIt first, ForwardIt last, Compare comp);
<---`std::min` Result--->
<---Ejemplo Básico con Dos Valores--->
```cpp
#include <iostream>
#include <algorithm>

int main() {
    int a = 10, b = 20;

    // Encontrar el valor máximo
    int maxVal = std::max(a, b);
    std::cout << "El mayor de " << a << " y " << b << " es " << maxVal << std::endl;

    // Encontrar el valor mínimo
    int minVal = std::min(a, b);
    std::cout << "El menor de " << a << " y " << b << " es " << minVal << std::endl;

    return 0;
}
<---Ejemplo Básico con Dos Valores Result--->
<---Ejemplo con Comparación Personalizada--->
```cpp
#include <iostream>
#include <vector>
#include <algorithm>

struct Punto {
    int x, y;
};

bool compararPorDistancia(const Punto& p1, const Punto& p2) {
    return (p1.x * p1.x + p1.y * p1.y) < (p2.x * p2.x + p2.y * p2.y);
}

int main() {
    std::vector<Punto> puntos = {{1, 2}, {3, 4}, {0, 5}, {-1, -1}};

    // Encontrar el punto más lejano del origen
    auto maxIt = std::max_element(puntos.begin(), puntos.end(), compararPorDistancia);
    std::cout << "El punto más lejano es: (" << maxIt->x << ", " << maxIt->y << ")" << std::endl;

    // Encontrar el punto más cercano al origen
    auto minIt = std::min_element(puntos.begin(), puntos.end(), compararPorDistancia);
    std::cout << "El punto más cercano es: (" << minIt->x << ", " << minIt->y << ")" << std::endl;

    return 0;
}
<---Ejemplo con Comparación Personalizada Result--->
<---Ejemplo Básico con un Rango de Elementos--->
```cpp
#include <iostream>
#include <vector>
#include <algorithm>

int main() {
    std::vector<int> vec = {1, 2, 3, 4, 5};

    // Encontrar el elemento máximo
    auto maxIt = std::max_element(vec.begin(), vec.end());
    std::cout << "El elemento máximo es: " << *maxIt << std::endl;

    // Encontrar el elemento mínimo
    auto minIt = std::min_element(vec.begin(), vec.end());
    std::cout << "El elemento mínimo es: " << *minIt << std::endl;

    return 0;
}
<---Ejemplo Básico con un Rango de Elementos Result--->
<---Sintaxis--->
```cpp
#include <algorithm>

template <class InputIt, class UnaryPredicate>
InputIt find_if(InputIt first, InputIt last, UnaryPredicate p);
<---Sintaxis Result--->
<---Ejemplo de Uso de `std::find`--->
```cpp
#include <iostream>
#include <vector>
#include <algorithm>

int main() {
    std::vector<int> vec = {1, 2, 3, 4, 5};

    // Buscar el valor 3
    auto it = std::find(vec.begin(), vec.end(), 3);

    if (it != vec.end()) {
        std::cout << "Elemento encontrado: " << *it << std::endl;
    } else {
        std::cout << "Elemento no encontrado" << std::endl;
    }

    return 0;
}
<---Ejemplo de Uso de `std::find` Result--->
<---Ejemplo de Uso de `std::find_if`--->
```cpp
#include <iostream>
#include <vector>
#include <algorithm>

bool esImpar(int n) {
    return n % 2 != 0;
}

int main() {
    std::vector<int> vec = {2, 4, 6, 7, 8};

    // Buscar el primer elemento impar
    auto it = std::find_if(vec.begin(), vec.end(), esImpar);

    if (it != vec.end()) {
        std::cout << "Primer elemento impar encontrado: " << *it << std::endl;
    } else {
        std::cout << "Elemento impar no encontrado" << std::endl;
    }

    return 0;
}
<---Ejemplo de Uso de `std::find_if` Result--->
<---Ejemplo de Uso de `std::find_if` con Lambda--->
```cpp
#include <iostream>
#include <vector>
#include <algorithm>

int main() {
    std::vector<int> vec = {2, 4, 6, 7, 8};

    // Usar una lambda para buscar el primer elemento impar
    auto it = std::find_if(vec.begin(), vec.end(), [](int n) {
        return n % 2 != 0;
    });

    if (it != vec.end()) {
        std::cout << "Primer elemento impar encontrado: " << *it << std::endl;
    } else {
        std::cout << "Elemento impar no encontrado" << std::endl;
    }

    return 0;
}
```cpp
#include <iostream>
#include <vector>
#include <algorithm>

struct Punto {
    int x, y;

    bool operator==(const Punto& otro) const {
        return x == otro.x && y == otro.y;
    }
};

int main() {
    std::vector<Punto> puntos = {{1, 2}, {3, 4}, {5, 6}, {7, 8}};
    Punto puntoABuscar = {5, 6};

    // Buscar el punto {5, 6}
    auto it = std::find(puntos.begin(), puntos.end(), puntoABuscar);

    if (it != puntos.end()) {
        std::cout << "Punto encontrado: (" << it->x << ", " << it->y << ")" << std::endl;
    } else {
        std::cout << "Punto no encontrado" << std::endl;
    }

    return 0;
}
```cpp
#include <iostream>
#include <vector>
#include <algorithm>

int main() {
    std::vector<int> vec = {2, 4, 6, 7, 8};

    // Usar una lambda para buscar el primer elemento mayor que 5
    auto it = std::find_if(vec.begin(), vec.end(), [](int n) {
        return n > 5;
    });

    if (it != vec.end()) {
        std::cout << "Primer elemento mayor que 5 encontrado: " << *it << std::endl;
    } else {
        std::cout << "Elemento mayor que 5 no encontrado" << std::endl;
    }

    return 0;
}
<---Ejemplo de Uso de `std::find_if` con Lambda Result--->
<---Copiar Elementos entre Diferentes Contenedores--->
```cpp
#include <iostream>
#include <vector>
#include <list>
#include <algorithm>

int main() {
    std::vector<int> origen = {1, 2, 3, 4, 5};
    std::list<int> destino(origen.size());

    // Usar std::copy para copiar los elementos
    std::copy(origen.begin(), origen.end(), destino.begin());

    // Mostrar los elementos copiados
    std::cout << "Elementos copiados a la lista destino: ";
    for (int elem : destino) {
        std::cout << elem << " ";
    }
    std::cout << std::endl;

    return 0;
}
```cpp
#include <iostream>
#include <vector>
#include <algorithm>

int main() {
    std::vector<int> origen = {1, 2, 3, 4, 5};
    std::vector<int> destino(3);

    // Usar std::copy para copiar los primeros 3 elementos
    std::copy(origen.begin(), origen.begin() + 3, destino.begin());

    // Mostrar los elementos copiados
    std::cout << "Primeros 3 elementos copiados al vector destino: ";
    for (int elem : destino) {
        std::cout << elem << " ";
    }
    std::cout << std::endl;

    return 0;
}
```cpp
#include <iostream>
#include <vector>
#include <algorithm>
#include <iterator>

int main() {
    std::vector<int> origen = {1, 2, 3, 4, 5};
    std::vector<int> destino;

    // Usar std::copy con std::back_inserter
    std::copy(origen.begin(), origen.end(), std::back_inserter(destino));

    // Mostrar los elementos copiados
    std::cout << "Elementos copiados al vector destino con back_inserter: ";
    for (int elem : destino) {
        std::cout << elem << " ";
    }
    std::cout << std::endl;

    return 0;
}
<---Copiar Elementos entre Diferentes Contenedores Result--->
<---Ejemplo Básico (Orden Ascendente)--->
```cpp
#include <iostream>
#include <vector>
#include <algorithm>

int main() {
    std::vector<int> vec = {5, 2, 9, 1, 5, 6};

    // Usar std::sort para ordenar los elementos en orden ascendente
    std::sort(vec.begin(), vec.end());

    // Mostrar los elementos ordenados
    std::cout << "Elementos ordenados: ";
    for (int elem : vec) {
        std::cout << elem << " ";
    }
    std::cout << std::endl;

    return 0;
}
<---Ejemplo Básico (Orden Ascendente) Result--->
<---Ejemplo con Comparación Personalizada (Orden Descendente)--->
```cpp
#include <iostream>
#include <vector>
#include <algorithm>

int main() {
    std::vector<int> vec = {5, 2, 9, 1, 5, 6};

    // Usar std::sort con una función de comparación para ordenar en orden descendente
    std::sort(vec.begin(), vec.end(), std::greater<int>());

    // Mostrar los elementos ordenados
    std::cout << "Elementos ordenados en orden descendente: ";
    for (int elem : vec) {
        std::cout << elem << " ";
    }
    std::cout << std::endl;

    return 0;
}
<---Ejemplo con Comparación Personalizada (Orden Descendente) Result--->
<---Ordenar un `std::array`--->
```cpp
#include <iostream>
#include <array>
#include <algorithm>

int main() {
    std::array<int, 6> arr = {5, 2, 9, 1, 5, 6};

    // Usar std::sort para ordenar los elementos del array
    std::sort(arr.begin(), arr.end());

    // Mostrar los elementos ordenados
    std::cout << "Elementos del array ordenados: ";
    for (int elem : arr) {
        std::cout << elem << " ";
    }
    std::cout << std::endl;

    return 0;
}
<---Ordenar un `std::array` Result--->
<---Ejemplo Básico (Función Unaria)--->
```cpp
#include <iostream>
#include <vector>
#include <algorithm>

int main() {
    std::vector<int> origen = {1, 2, 3, 4, 5};
    std::vector<int> destino(origen.size());

    // Usar std::transform para duplicar cada elemento
    std::transform(origen.begin(), origen.end(), destino.begin(), [](int x) {
        return x * 2;
    });

    // Mostrar los elementos transformados
    std::cout << "Elementos transformados (duplicados): ";
    for (int elem : destino) {
        std::cout << elem << " ";
    }
    std::cout << std::endl;

    return 0;
}
<---Ejemplo Básico (Función Unaria) Result--->
<---Ejemplo con Función Binaria--->
```cpp
#include <iostream>
#include <vector>
#include <algorithm>

int main() {
    std::vector<int> vec1 = {1, 2, 3, 4, 5};
    std::vector<int> vec2 = {10, 20, 30, 40, 50};
    std::vector<int> resultado(vec1.size());

    // Usar std::transform para sumar elementos de dos vectores
    std::transform(vec1.begin(), vec1.end(), vec2.begin(), resultado.begin(), [](int x, int y) {
        return x + y;
    });

    // Mostrar los elementos transformados
    std::cout << "Elementos transformados (suma de vec1 y vec2): ";
    for (int elem : resultado) {
        std::cout << elem << " ";
    }
    std::cout << std::endl;

    return 0;
}
<---Ejemplo con Función Binaria Result--->
<---Transformar una Lista--->
```cpp
#include <iostream>
#include <list>
#include <algorithm>

int main() {
    std::list<int> origen = {1, 2, 3, 4, 5};
    std::list<int> destino(origen.size());

    // Usar std::transform para incrementar cada elemento
    std::transform(origen.begin(), origen.end(), destino.begin(), [](int x) {
        return x + 1;
    });

    // Mostrar los elementos transformados
    std::cout << "Elementos transformados (incrementados): ";
    for (int elem : destino) {
        std::cout << elem << " ";
    }
    std::cout << std::endl;

    return 0;
}
<---Transformar una Lista Result--->
<---Ejemplo con `std::array`--->
```cpp
#include <iostream>
#include <array>
#include <algorithm>

int main() {
    std::array<int, 5> arr;

    // Usar std::fill para asignar el valor 10 a todos los elementos del array
    std::fill(arr.begin(), arr.end(), 10);

    // Mostrar los elementos del array
    std::cout << "Elementos del array después de std::fill: ";
    for (int elem : arr) {
        std::cout << elem << " ";
    }
    std::cout << std::endl;

    return 0;
}
<---Ejemplo con `std::array` Result--->
<---Ejemplo con una Matriz--->
```cpp
#include <iostream>
#include <vector>
#include <algorithm>

int main() {
    std::vector<std::vector<int>> matrix(3, std::vector<int>(4));

    // Usar std::fill para asignar el valor 0 a todos los elementos de la matriz
    for (auto& row : matrix) {
        std::fill(row.begin(), row.end(), 0);
    }

    // Mostrar los elementos de la matriz
    std::cout << "Elementos de la matriz después de std::fill: " << std::endl;
    for (const auto& row : matrix) {
        for (int elem : row) {
            std::cout << elem << " ";
        }
        std::cout << std::endl;
    }

    return 0;
}
<---Ejemplo con una Matriz Result--->
<---Ejemplo de Rango Parcial--->
```cpp
#include <iostream>
#include <vector>
#include <algorithm>

int main() {
    std::vector<int> vec(10);

    // Asignar el valor 1 a la primera mitad del vector
    std::fill(vec.begin(), vec.begin() + vec.size() / 2, 1);

    // Asignar el valor 2 a la segunda mitad del vector
    std::fill(vec.begin() + vec.size() / 2, vec.end(), 2);

    // Mostrar los elementos del vector
    std::cout << "Elementos del vector después de std::fill en rangos parciales: ";
    for (int elem : vec) {
        std::cout << elem << " ";
    }
    std::cout << std::endl;

    return 0;
}
<---Ejemplo de Rango Parcial Result--->
<---Ejemplo con `std::list`--->
```cpp
#include <iostream>
#include <list>
#include <algorithm>

int main() {
    std::list<int> lst = {1, 2, 3, 4, 5};

    // Usar std::reverse para invertir el orden de los elementos
    std::reverse(lst.begin(), lst.end());

    // Mostrar los elementos invertidos
    std::cout << "Elementos de la lista después de std::reverse: ";
    for (int elem : lst) {
        std::cout << elem << " ";
    }
    std::cout << std::endl;

    return 0;
}
<---Ejemplo con `std::list` Result--->
<---Ejemplo Básico con `std::replace_if`--->
```cpp
#include <iostream>
#include <vector>
#include <algorithm>

bool esPar(int n) {
    return n % 2 == 0;
}

int main() {
    std::vector<int> vec = {1, 2, 3, 4, 5, 6};

    // Usar std::replace_if para reemplazar todos los números pares por 0
    std::replace_if(vec.begin(), vec.end(), esPar, 0);

    // Mostrar los elementos modificados
    std::cout << "Elementos del vector después de std::replace_if: ";
    for (int elem : vec) {
        std::cout << elem << " ";
    }
    std::cout << std::endl;

    return 0;
}
<---Ejemplo Básico con `std::replace_if` Result--->
<---Ejemplo Básico con `std::remove_if`--->
```cpp
#include <iostream>
#include <vector>
#include <algorithm>

bool esPar(int n) {
    return n % 2 == 0;
}

int main() {
    std::vector<int> vec = {1, 2, 3, 4, 5, 6};

    // Usar std::remove_if para mover los números pares al final
    auto it = std::remove_if(vec.begin(), vec.end(), esPar);

    // Eliminar físicamente los elementos después del nuevo final lógico
    vec.erase(it, vec.end());

    // Mostrar los elementos restantes
    std::cout << "Elementos del vector después de std::remove_if y erase: ";
    for (int elem : vec) {
        std::cout << elem << " ";
    }
    std::cout << std::endl;

    return 0;
}
<---Ejemplo Básico con `std::remove_if` Result--->
<---Ejemplo de Subsección--->
```cpp
#include <iostream>
#include <vector>
#include <algorithm>

int main() {
    std::vector<int> vec = {1, 2, 3, 4, 5, 6, 7, 8};

    // Usar std::reverse para invertir el orden de los elementos en una subsección del vector
    std::reverse(vec.begin() + 2, vec.begin() + 6);

    // Mostrar los elementos del vector después de invertir la subsección
    std::cout << "Elementos del vector después de invertir una subsección: ";
    for (int elem : vec) {
        std::cout << elem << " ";
    }
    std::cout << std::endl;

    return 0;
}
<---Ejemplo de Subsección Result--->
<---Ejemplo con `std::string`--->
```cpp
#include <iostream>
#include <string>
#include <algorithm>

int main() {
    std::string str = "Hello, World!";

    // Usar std::reverse para invertir el orden de los caracteres en la cadena
    std::reverse(str.begin(), str.end());

    // Mostrar la cadena invertida
    std::cout << "Cadena después de std::reverse: " << str << std::endl;

    return 0;
}
<---Ejemplo con `std::string` Result--->
<---Ejemplo Básico--->
```cpp
#include <iostream>
#include <vector>
#include <algorithm>

bool esPar(int n) {
    return n % 2 == 0;
}

int main() {
    std::vector<int> vec = {1, 2, 3, 4, 5, 6};

    // Usar std::partition para particionar los elementos
    auto it = std::partition(vec.begin(), vec.end(), esPar);

    // Mostrar los elementos particionados
    std::cout << "Elementos después de std::partition: ";
    for (int elem : vec) {
        std::cout << elem << " ";
    }
    std::cout << std::endl;

    // Mostrar el punto de partición
    std::cout << "Punto de partición: " << *it << std::endl;

    return 0;
}
<---Ejemplo Básico Result--->
<---Ejemplo con Lambda--->
```cpp
#include <iostream>
#include <vector>
#include <algorithm>

int main() {
    std::vector<int> vec = {1, 2, 3, 4, 5, 6};

    // Usar std::remove_if con una lambda para mover los números mayores que 3 al final
    auto it = std::remove_if(vec.begin(), vec.end(), [](int n) { return n > 3; });

    // Eliminar físicamente los elementos después del nuevo final lógico
    vec.erase(it, vec.end());

    // Mostrar los elementos restantes
    std::cout << "Elementos del vector después de std::remove_if y erase: ";
    for (int elem : vec) {
        std::cout << elem << " ";
    }
    std::cout << std::endl;

    return 0;
}
<---Ejemplo con Lambda Result--->
<---Ejemplo Básico (Suma)--->
```cpp
#include <iostream>
#include <vector>
#include <numeric>

int main() {
    std::vector<int> vec = {1, 2, 3, 4, 5};

    // Usar std::accumulate para sumar todos los elementos
    int suma = std::accumulate(vec.begin(), vec.end(), 0);

    std::cout << "La suma de los elementos es: " << suma << std::endl;

    return 0;
}
<---Ejemplo Básico (Suma) Result--->
<---Ejemplo con Operación Binaria Personalizada (Multiplicación)--->
```cpp
#include <iostream>
#include <vector>
#include <numeric>

int main() {
    std::vector<int> vec = {1, 2, 3, 4, 5};

    // Usar std::accumulate para multiplicar todos los elementos
    int producto = std::accumulate(vec.begin(), vec.end(), 1, std::multiplies<int>());

    std::cout << "El producto de los elementos es: " << producto << std::endl;

    return 0;
}
```cpp
#include <iostream>
#include <vector>
#include <numeric>
#include <string>

int main() {
    std::vector<std::string> vec = {"Hola", " ", "mundo", "!"};

    // Usar std::accumulate para concatenar todas las cadenas
    std::string resultado = std::accumulate(vec.begin(), vec.end(), std::string(""));

    std::cout << "Cadena concatenada: " << resultado << std::endl;

    return 0;
}
```cpp
#include <iostream>
#include <vector>
#include <numeric>

int main() {
    std::vector<int> vec = {1, 2, 3, 4, 5};

    // Calcular la suma de los elementos
    int suma = std::accumulate(vec.begin(), vec.end(), 0);

    // Calcular la media
    double media = static_cast<double>(suma) / vec.size();

    std::cout << "La media de los elementos es: " << media << std::endl;

    return 0;
}
<---Ejemplo con Operación Binaria Personalizada (Multiplicación) Result--->
<---`std::max`--->
```cpp
#include <algorithm>

template <class T>
const T& max(const T& a, const T& b);

template <class T, class Compare>
const T& max(const T& a, const T& b, Compare comp);

template <class ForwardIt>
ForwardIt max_element(ForwardIt first, ForwardIt last);

template <class ForwardIt, class Compare>
ForwardIt max_element(ForwardIt first, ForwardIt last, Compare comp);
<---`std::max` Result--->
<---`std::min`--->
```cpp
#include <algorithm>

template <class T>
const T& min(const T& a, const T& b);

template <class T, class Compare>
const T& min(const T& a, const T& b, Compare comp);

template <class ForwardIt>
ForwardIt min_element(ForwardIt first, ForwardIt last);

template <class ForwardIt, class Compare>
ForwardIt min_element(ForwardIt first, ForwardIt last, Compare comp);
<---`std::min` Result--->
<---Ejemplo Básico con Dos Valores--->
```cpp
#include <iostream>
#include <algorithm>

int main() {
    int a = 10, b = 20;

    // Encontrar el valor máximo
    int maxVal = std::max(a, b);
    std::cout << "El mayor de " << a << " y " << b << " es " << maxVal << std::endl;

    // Encontrar el valor mínimo
    int minVal = std::min(a, b);
    std::cout << "El menor de " << a << " y " << b << " es " << minVal << std::endl;

    return 0;
}
<---Ejemplo Básico con Dos Valores Result--->
<---Ejemplo con Comparación Personalizada--->
```cpp
#include <iostream>
#include <vector>
#include <algorithm>

struct Punto {
    int x, y;
};

bool compararPorDistancia(const Punto& p1, const Punto& p2) {
    return (p1.x * p1.x + p1.y * p1.y) < (p2.x * p2.x + p2.y * p2.y);
}

int main() {
    std::vector<Punto> puntos = {{1, 2}, {3, 4}, {0, 5}, {-1, -1}};

    // Encontrar el punto más lejano del origen
    auto maxIt = std::max_element(puntos.begin(), puntos.end(), compararPorDistancia);
    std::cout << "El punto más lejano es: (" << maxIt->x << ", " << maxIt->y << ")" << std::endl;

    // Encontrar el punto más cercano al origen
    auto minIt = std::min_element(puntos.begin(), puntos.end(), compararPorDistancia);
    std::cout << "El punto más cercano es: (" << minIt->x << ", " << minIt->y << ")" << std::endl;

    return 0;
}
<---Ejemplo con Comparación Personalizada Result--->
<---Ejemplo Básico con un Rango de Elementos--->
```cpp
#include <iostream>
#include <vector>
#include <algorithm>

int main() {
    std::vector<int> vec = {1, 2, 3, 4, 5};

    // Encontrar el elemento máximo
    auto maxIt = std::max_element(vec.begin(), vec.end());
    std::cout << "El elemento máximo es: " << *maxIt << std::endl;

    // Encontrar el elemento mínimo
    auto minIt = std::min_element(vec.begin(), vec.end());
    std::cout << "El elemento mínimo es: " << *minIt << std::endl;

    return 0;
}
<---Ejemplo Básico con un Rango de Elementos Result--->
<---Sintaxis--->
```cpp
#include <algorithm>

template <class InputIt, class UnaryPredicate>
InputIt find_if(InputIt first, InputIt last, UnaryPredicate p);
<---Sintaxis Result--->
<---Ejemplo de Uso de `std::find`--->
```cpp
#include <iostream>
#include <vector>
#include <algorithm>

int main() {
    std::vector<int> vec = {1, 2, 3, 4, 5};

    // Buscar el valor 3
    auto it = std::find(vec.begin(), vec.end(), 3);

    if (it != vec.end()) {
        std::cout << "Elemento encontrado: " << *it << std::endl;
    } else {
        std::cout << "Elemento no encontrado" << std::endl;
    }

    return 0;
}
<---Ejemplo de Uso de `std::find` Result--->
<---Ejemplo de Uso de `std::find_if`--->
```cpp
#include <iostream>
#include <vector>
#include <algorithm>

bool esImpar(int n) {
    return n % 2 != 0;
}

int main() {
    std::vector<int> vec = {2, 4, 6, 7, 8};

    // Buscar el primer elemento impar
    auto it = std::find_if(vec.begin(), vec.end(), esImpar);

    if (it != vec.end()) {
        std::cout << "Primer elemento impar encontrado: " << *it << std::endl;
    } else {
        std::cout << "Elemento impar no encontrado" << std::endl;
    }

    return 0;
}
<---Ejemplo de Uso de `std::find_if` Result--->
<---Ejemplo de Uso de `std::find_if` con Lambda--->
```cpp
#include <iostream>
#include <vector>
#include <algorithm>

int main() {
    std::vector<int> vec = {2, 4, 6, 7, 8};

    // Usar una lambda para buscar el primer elemento impar
    auto it = std::find_if(vec.begin(), vec.end(), [](int n) {
        return n % 2 != 0;
    });

    if (it != vec.end()) {
        std::cout << "Primer elemento impar encontrado: " << *it << std::endl;
    } else {
        std::cout << "Elemento impar no encontrado" << std::endl;
    }

    return 0;
}
```cpp
#include <iostream>
#include <vector>
#include <algorithm>

struct Punto {
    int x, y;

    bool operator==(const Punto& otro) const {
        return x == otro.x && y == otro.y;
    }
};

int main() {
    std::vector<Punto> puntos = {{1, 2}, {3, 4}, {5, 6}, {7, 8}};
    Punto puntoABuscar = {5, 6};

    // Buscar el punto {5, 6}
    auto it = std::find(puntos.begin(), puntos.end(), puntoABuscar);

    if (it != puntos.end()) {
        std::cout << "Punto encontrado: (" << it->x << ", " << it->y << ")" << std::endl;
    } else {
        std::cout << "Punto no encontrado" << std::endl;
    }

    return 0;
}
```cpp
#include <iostream>
#include <vector>
#include <algorithm>

int main() {
    std::vector<int> vec = {2, 4, 6, 7, 8};

    // Usar una lambda para buscar el primer elemento mayor que 5
    auto it = std::find_if(vec.begin(), vec.end(), [](int n) {
        return n > 5;
    });

    if (it != vec.end()) {
        std::cout << "Primer elemento mayor que 5 encontrado: " << *it << std::endl;
    } else {
        std::cout << "Elemento mayor que 5 no encontrado" << std::endl;
    }

    return 0;
}
<---Ejemplo de Uso de `std::find_if` con Lambda Result--->
<---Copiar Elementos entre Diferentes Contenedores--->
```cpp
#include <iostream>
#include <vector>
#include <list>
#include <algorithm>

int main() {
    std::vector<int> origen = {1, 2, 3, 4, 5};
    std::list<int> destino(origen.size());

    // Usar std::copy para copiar los elementos
    std::copy(origen.begin(), origen.end(), destino.begin());

    // Mostrar los elementos copiados
    std::cout << "Elementos copiados a la lista destino: ";
    for (int elem : destino) {
        std::cout << elem << " ";
    }
    std::cout << std::endl;

    return 0;
}
```cpp
#include <iostream>
#include <vector>
#include <algorithm>

int main() {
    std::vector<int> origen = {1, 2, 3, 4, 5};
    std::vector<int> destino(3);

    // Usar std::copy para copiar los primeros 3 elementos
    std::copy(origen.begin(), origen.begin() + 3, destino.begin());

    // Mostrar los elementos copiados
    std::cout << "Primeros 3 elementos copiados al vector destino: ";
    for (int elem : destino) {
        std::cout << elem << " ";
    }
    std::cout << std::endl;

    return 0;
}
```cpp
#include <iostream>
#include <vector>
#include <algorithm>
#include <iterator>

int main() {
    std::vector<int> origen = {1, 2, 3, 4, 5};
    std::vector<int> destino;

    // Usar std::copy con std::back_inserter
    std::copy(origen.begin(), origen.end(), std::back_inserter(destino));

    // Mostrar los elementos copiados
    std::cout << "Elementos copiados al vector destino con back_inserter: ";
    for (int elem : destino) {
        std::cout << elem << " ";
    }
    std::cout << std::endl;

    return 0;
}
<---Copiar Elementos entre Diferentes Contenedores Result--->
<---Ejemplo Básico (Orden Ascendente)--->
```cpp
#include <iostream>
#include <vector>
#include <algorithm>

int main() {
    std::vector<int> vec = {5, 2, 9, 1, 5, 6};

    // Usar std::sort para ordenar los elementos en orden ascendente
    std::sort(vec.begin(), vec.end());

    // Mostrar los elementos ordenados
    std::cout << "Elementos ordenados: ";
    for (int elem : vec) {
        std::cout << elem << " ";
    }
    std::cout << std::endl;

    return 0;
}
<---Ejemplo Básico (Orden Ascendente) Result--->
<---Ejemplo con Comparación Personalizada (Orden Descendente)--->
```cpp
#include <iostream>
#include <vector>
#include <algorithm>

int main() {
    std::vector<int> vec = {5, 2, 9, 1, 5, 6};

    // Usar std::sort con una función de comparación para ordenar en orden descendente
    std::sort(vec.begin(), vec.end(), std::greater<int>());

    // Mostrar los elementos ordenados
    std::cout << "Elementos ordenados en orden descendente: ";
    for (int elem : vec) {
        std::cout << elem << " ";
    }
    std::cout << std::endl;

    return 0;
}
<---Ejemplo con Comparación Personalizada (Orden Descendente) Result--->
<---Ordenar un `std::array`--->
```cpp
#include <iostream>
#include <array>
#include <algorithm>

int main() {
    std::array<int, 6> arr = {5, 2, 9, 1, 5, 6};

    // Usar std::sort para ordenar los elementos del array
    std::sort(arr.begin(), arr.end());

    // Mostrar los elementos ordenados
    std::cout << "Elementos del array ordenados: ";
    for (int elem : arr) {
        std::cout << elem << " ";
    }
    std::cout << std::endl;

    return 0;
}
<---Ordenar un `std::array` Result--->
<---Ejemplo Básico (Función Unaria)--->
```cpp
#include <iostream>
#include <vector>
#include <algorithm>

int main() {
    std::vector<int> origen = {1, 2, 3, 4, 5};
    std::vector<int> destino(origen.size());

    // Usar std::transform para duplicar cada elemento
    std::transform(origen.begin(), origen.end(), destino.begin(), [](int x) {
        return x * 2;
    });

    // Mostrar los elementos transformados
    std::cout << "Elementos transformados (duplicados): ";
    for (int elem : destino) {
        std::cout << elem << " ";
    }
    std::cout << std::endl;

    return 0;
}
<---Ejemplo Básico (Función Unaria) Result--->
<---Ejemplo con Función Binaria--->
```cpp
#include <iostream>
#include <vector>
#include <algorithm>

int main() {
    std::vector<int> vec1 = {1, 2, 3, 4, 5};
    std::vector<int> vec2 = {10, 20, 30, 40, 50};
    std::vector<int> resultado(vec1.size());

    // Usar std::transform para sumar elementos de dos vectores
    std::transform(vec1.begin(), vec1.end(), vec2.begin(), resultado.begin(), [](int x, int y) {
        return x + y;
    });

    // Mostrar los elementos transformados
    std::cout << "Elementos transformados (suma de vec1 y vec2): ";
    for (int elem : resultado) {
        std::cout << elem << " ";
    }
    std::cout << std::endl;

    return 0;
}
<---Ejemplo con Función Binaria Result--->
<---Transformar una Lista--->
```cpp
#include <iostream>
#include <list>
#include <algorithm>

int main() {
    std::list<int> origen = {1, 2, 3, 4, 5};
    std::list<int> destino(origen.size());

    // Usar std::transform para incrementar cada elemento
    std::transform(origen.begin(), origen.end(), destino.begin(), [](int x) {
        return x + 1;
    });

    // Mostrar los elementos transformados
    std::cout << "Elementos transformados (incrementados): ";
    for (int elem : destino) {
        std::cout << elem << " ";
    }
    std::cout << std::endl;

    return 0;
}
<---Transformar una Lista Result--->
<---Ejemplo con `std::array`--->
```cpp
#include <iostream>
#include <array>
#include <algorithm>

int main() {
    std::array<int, 5> arr;

    // Usar std::fill para asignar el valor 10 a todos los elementos del array
    std::fill(arr.begin(), arr.end(), 10);

    // Mostrar los elementos del array
    std::cout << "Elementos del array después de std::fill: ";
    for (int elem : arr) {
        std::cout << elem << " ";
    }
    std::cout << std::endl;

    return 0;
}
<---Ejemplo con `std::array` Result--->
<---Ejemplo con una Matriz--->
```cpp
#include <iostream>
#include <vector>
#include <algorithm>

int main() {
    std::vector<std::vector<int>> matrix(3, std::vector<int>(4));

    // Usar std::fill para asignar el valor 0 a todos los elementos de la matriz
    for (auto& row : matrix) {
        std::fill(row.begin(), row.end(), 0);
    }

    // Mostrar los elementos de la matriz
    std::cout << "Elementos de la matriz después de std::fill: " << std::endl;
    for (const auto& row : matrix) {
        for (int elem : row) {
            std::cout << elem << " ";
        }
        std::cout << std::endl;
    }

    return 0;
}
<---Ejemplo con una Matriz Result--->
<---Ejemplo de Rango Parcial--->
```cpp
#include <iostream>
#include <vector>
#include <algorithm>

int main() {
    std::vector<int> vec(10);

    // Asignar el valor 1 a la primera mitad del vector
    std::fill(vec.begin(), vec.begin() + vec.size() / 2, 1);

    // Asignar el valor 2 a la segunda mitad del vector
    std::fill(vec.begin() + vec.size() / 2, vec.end(), 2);

    // Mostrar los elementos del vector
    std::cout << "Elementos del vector después de std::fill en rangos parciales: ";
    for (int elem : vec) {
        std::cout << elem << " ";
    }
    std::cout << std::endl;

    return 0;
}
<---Ejemplo de Rango Parcial Result--->
<---Ejemplo con `std::list`--->
```cpp
#include <iostream>
#include <list>
#include <algorithm>

bool esPositivo(int n) {
    return n > 0;
}

int main() {
    std::list<int> lst = {-1, 2, -3, 4, -5, 6};

    // Usar std::partition para particionar los elementos
    auto it = std::partition(lst.begin(), lst.end(), esPositivo);

    // Mostrar los elementos particionados
    std::cout << "Elementos de la lista después de std::partition: ";
    for (int elem : lst) {
        std::cout << elem << " ";
    }
    std::cout << std::endl;

    // Mostrar el punto de partición
    std::cout << "Punto de partición: " << *it << std::endl;

    return 0;
}
```cpp
#include <algorithm>

template <class ForwardIt, class UnaryPredicate>
ForwardIt stable_partition(ForwardIt first, ForwardIt last, UnaryPredicate p);
<---Ejemplo con `std::list` Result--->
<---Ejemplo Básico con `std::replace_if`--->
```cpp
#include <iostream>
#include <vector>
#include <algorithm>

bool esPar(int n) {
    return n % 2 == 0;
}

int main() {
    std::vector<int> vec = {1, 2, 3, 4, 5, 6};

    // Usar std::replace_if para reemplazar todos los números pares por 0
    std::replace_if(vec.begin(), vec.end(), esPar, 0);

    // Mostrar los elementos modificados
    std::cout << "Elementos del vector después de std::replace_if: ";
    for (int elem : vec) {
        std::cout << elem << " ";
    }
    std::cout << std::endl;

    return 0;
}
<---Ejemplo Básico con `std::replace_if` Result--->
<---Ejemplo Básico con `std::remove_if`--->
```cpp
#include <iostream>
#include <vector>
#include <algorithm>

bool esPar(int n) {
    return n % 2 == 0;
}

int main() {
    std::vector<int> vec = {1, 2, 3, 4, 5, 6};

    // Usar std::remove_if para mover los números pares al final
    auto it = std::remove_if(vec.begin(), vec.end(), esPar);

    // Eliminar físicamente los elementos después del nuevo final lógico
    vec.erase(it, vec.end());

    // Mostrar los elementos restantes
    std::cout << "Elementos del vector después de std::remove_if y erase: ";
    for (int elem : vec) {
        std::cout << elem << " ";
    }
    std::cout << std::endl;

    return 0;
}
<---Ejemplo Básico con `std::remove_if` Result--->
<---Ejemplo de Subsección--->
```cpp
#include <iostream>
#include <vector>
#include <algorithm>

int main() {
    std::vector<int> vec = {1, 2, 3, 4, 5, 6, 7, 8};

    // Usar std::reverse para invertir el orden de los elementos en una subsección del vector
    std::reverse(vec.begin() + 2, vec.begin() + 6);

    // Mostrar los elementos del vector después de invertir la subsección
    std::cout << "Elementos del vector después de invertir una subsección: ";
    for (int elem : vec) {
        std::cout << elem << " ";
    }
    std::cout << std::endl;

    return 0;
}
<---Ejemplo de Subsección Result--->
<---Ejemplo con `std::string`--->
```cpp
#include <iostream>
#include <string>
#include <algorithm>

int main() {
    std::string str = "Hello, World!";

    // Usar std::reverse para invertir el orden de los caracteres en la cadena
    std::reverse(str.begin(), str.end());

    // Mostrar la cadena invertida
    std::cout << "Cadena después de std::reverse: " << str << std::endl;

    return 0;
}
<---Ejemplo con `std::string` Result--->
<---Ejemplo Básico con `std::stable_partition`--->
```cpp
#include <iostream>
#include <vector>
#include <algorithm>

bool esPar(int n) {
    return n % 2 == 0;
}

int main() {
    std::vector<int> vec = {1, 2, 3, 4, 5, 6};

    // Usar std::stable_partition para particionar los elementos
    auto it = std::stable_partition(vec.begin(), vec.end(), esPar);

    // Mostrar los elementos particionados
    std::cout << "Elementos después de std::stable_partition: ";
    for (int elem : vec) {
        std::cout << elem << " ";
    }
    std::cout << std::endl;

    // Mostrar el punto de partición
    std::cout << "Punto de partición: " << *it << std::endl;

    return 0;
}
<---Ejemplo Básico con `std::stable_partition` Result--->
<---Ejemplo Básico--->
```cpp
#include <iostream>
#include <vector>
#include <algorithm>

bool esPar(int n) {
    return n % 2 == 0;
}

int main() {
    std::vector<int> vec = {1, 2, 3, 4, 5, 6};

    // Usar std::partition para particionar los elementos
    auto it = std::partition(vec.begin(), vec.end(), esPar);

    // Mostrar los elementos particionados
    std::cout << "Elementos después de std::partition: ";
    for (int elem : vec) {
        std::cout << elem << " ";
    }
    std::cout << std::endl;

    // Mostrar el punto de partición
    std::cout << "Punto de partición: " << *it << std::endl;

    return 0;
}
<---Ejemplo Básico Result--->
<---Ejemplo con Lambda--->
```cpp
#include <iostream>
#include <vector>
#include <algorithm>

int main() {
    std::vector<int> vec = {1, 2, 3, 4, 5, 6};

    // Usar std::remove_if con una lambda para mover los números mayores que 3 al final
    auto it = std::remove_if(vec.begin(), vec.end(), [](int n) { return n > 3; });

    // Eliminar físicamente los elementos después del nuevo final lógico
    vec.erase(it, vec.end());

    // Mostrar los elementos restantes
    std::cout << "Elementos del vector después de std::remove_if y erase: ";
    for (int elem : vec) {
        std::cout << elem << " ";
    }
    std::cout << std::endl;

    return 0;
}
<---Ejemplo con Lambda Result--->
<---Ejemplo Básico (Suma)--->
```cpp
#include <iostream>
#include <vector>
#include <numeric>

int main() {
    std::vector<int> vec = {1, 2, 3, 4, 5};

    // Usar std::accumulate para sumar todos los elementos
    int suma = std::accumulate(vec.begin(), vec.end(), 0);

    std::cout << "La suma de los elementos es: " << suma << std::endl;

    return 0;
}
<---Ejemplo Básico (Suma) Result--->
<---Ejemplo con Operación Binaria Personalizada (Multiplicación)--->
```cpp
#include <iostream>
#include <vector>
#include <numeric>

int main() {
    std::vector<int> vec = {1, 2, 3, 4, 5};

    // Usar std::accumulate para multiplicar todos los elementos
    int producto = std::accumulate(vec.begin(), vec.end(), 1, std::multiplies<int>());

    std::cout << "El producto de los elementos es: " << producto << std::endl;

    return 0;
}
```cpp
#include <iostream>
#include <vector>
#include <numeric>
#include <string>

int main() {
    std::vector<std::string> vec = {"Hola", " ", "mundo", "!"};

    // Usar std::accumulate para concatenar todas las cadenas
    std::string resultado = std::accumulate(vec.begin(), vec.end(), std::string(""));

    std::cout << "Cadena concatenada: " << resultado << std::endl;

    return 0;
}
```cpp
#include <iostream>
#include <vector>
#include <numeric>

int main() {
    std::vector<int> vec = {1, 2, 3, 4, 5};

    // Calcular la suma de los elementos
    int suma = std::accumulate(vec.begin(), vec.end(), 0);

    // Calcular la media
    double media = static_cast<double>(suma) / vec.size();

    std::cout << "La media de los elementos es: " << media << std::endl;

    return 0;
}
<---Ejemplo con Operación Binaria Personalizada (Multiplicación) Result--->
<---`std::max`--->
```cpp
#include <algorithm>

template <class T>
const T& max(const T& a, const T& b);

template <class T, class Compare>
const T& max(const T& a, const T& b, Compare comp);

template <class ForwardIt>
ForwardIt max_element(ForwardIt first, ForwardIt last);

template <class ForwardIt, class Compare>
ForwardIt max_element(ForwardIt first, ForwardIt last, Compare comp);
<---`std::max` Result--->
<---`std::min`--->
```cpp
#include <algorithm>

template <class T>
const T& min(const T& a, const T& b);

template <class T, class Compare>
const T& min(const T& a, const T& b, Compare comp);

template <class ForwardIt>
ForwardIt min_element(ForwardIt first, ForwardIt last);

template <class ForwardIt, class Compare>
ForwardIt min_element(ForwardIt first, ForwardIt last, Compare comp);
<---`std::min` Result--->
<---Ejemplo Básico con Dos Valores--->
```cpp
#include <iostream>
#include <algorithm>

int main() {
    int a = 10, b = 20;

    // Encontrar el valor máximo
    int maxVal = std::max(a, b);
    std::cout << "El mayor de " << a << " y " << b << " es " << maxVal << std::endl;

    // Encontrar el valor mínimo
    int minVal = std::min(a, b);
    std::cout << "El menor de " << a << " y " << b << " es " << minVal << std::endl;

    return 0;
}
<---Ejemplo Básico con Dos Valores Result--->
<---Ejemplo con Comparación Personalizada--->
```cpp
#include <iostream>
#include <vector>
#include <algorithm>

struct Persona {
    std::string nombre;
    int edad;
};

bool compararPorEdad(const Persona& a, const Persona& b) {
    return a.edad < b.edad;
}

int main() {
    std::vector<Persona> personas = {{"Ana", 25}, {"Luis", 30}, {"Carlos", 22}, {"Maria", 28}};

    // Ordenar las personas por edad
    std::sort(personas.begin(), personas.end(), compararPorEdad);

    Persona p = {"", 28}; // Solo la edad importa para la búsqueda

    // Usar std::lower_bound con comparación personalizada
    auto it = std::lower_bound(personas.begin(), personas.end(), p, compararPorEdad);

    // Mostrar el resultado
    if (it != personas.end()) {
        std::cout << "Primera persona con edad no menor que 28: " << it->nombre << " (" << it->edad << ")" << std::endl;
    } else {
        std::cout << "No se encontró una persona con edad no menor que 28" << std::endl;
    }

    return 0;
}
<---Ejemplo con Comparación Personalizada Result--->
<---Ejemplo Básico con un Rango de Elementos--->
```cpp
#include <iostream>
#include <vector>
#include <algorithm>

int main() {
    std::vector<int> vec = {1, 2, 3, 4, 5};

    // Encontrar el elemento máximo
    auto maxIt = std::max_element(vec.begin(), vec.end());
    std::cout << "El elemento máximo es: " << *maxIt << std::endl;

    // Encontrar el elemento mínimo
    auto minIt = std::min_element(vec.begin(), vec.end());
    std::cout << "El elemento mínimo es: " << *minIt << std::endl;

    return 0;
}
<---Ejemplo Básico con un Rango de Elementos Result--->
<---Sintaxis--->
```cpp
#include <algorithm>

template <class ForwardIt, class T>
ForwardIt upper_bound(ForwardIt first, ForwardIt last, const T& value);

template <class ForwardIt, class T, class Compare>
ForwardIt upper_bound(ForwardIt first, ForwardIt last, const T& value, Compare comp);
<---Sintaxis Result--->
<---Ejemplo de Uso de `std::find`--->
```cpp
#include <iostream>
#include <vector>
#include <algorithm>

int main() {
    std::vector<int> vec = {1, 2, 3, 4, 5};

    // Buscar el valor 3
    auto it = std::find(vec.begin(), vec.end(), 3);

    if (it != vec.end()) {
        std::cout << "Elemento encontrado: " << *it << std::endl;
    } else {
        std::cout << "Elemento no encontrado" << std::endl;
    }

    return 0;
}
<---Ejemplo de Uso de `std::find` Result--->
<---Ejemplo de Uso de `std::find_if`--->
```cpp
#include <iostream>
#include <vector>
#include <algorithm>

bool esImpar(int n) {
    return n % 2 != 0;
}

int main() {
    std::vector<int> vec = {2, 4, 6, 7, 8};

    // Buscar el primer elemento impar
    auto it = std::find_if(vec.begin(), vec.end(), esImpar);

    if (it != vec.end()) {
        std::cout << "Primer elemento impar encontrado: " << *it << std::endl;
    } else {
        std::cout << "Elemento impar no encontrado" << std::endl;
    }

    return 0;
}
<---Ejemplo de Uso de `std::find_if` Result--->
<---Ejemplo de Uso de `std::find_if` con Lambda--->
```cpp
#include <iostream>
#include <vector>
#include <algorithm>

int main() {
    std::vector<int> vec = {2, 4, 6, 7, 8};

    // Usar una lambda para buscar el primer elemento impar
    auto it = std::find_if(vec.begin(), vec.end(), [](int n) {
        return n % 2 != 0;
    });

    if (it != vec.end()) {
        std::cout << "Primer elemento impar encontrado: " << *it << std::endl;
    } else {
        std::cout << "Elemento impar no encontrado" << std::endl;
    }

    return 0;
}
```cpp
#include <iostream>
#include <vector>
#include <algorithm>

struct Punto {
    int x, y;

    bool operator==(const Punto& otro) const {
        return x == otro.x && y == otro.y;
    }
};

int main() {
    std::vector<Punto> puntos = {{1, 2}, {3, 4}, {5, 6}, {7, 8}};
    Punto puntoABuscar = {5, 6};

    // Buscar el punto {5, 6}
    auto it = std::find(puntos.begin(), puntos.end(), puntoABuscar);

    if (it != puntos.end()) {
        std::cout << "Punto encontrado: (" << it->x << ", " << it->y << ")" << std::endl;
    } else {
        std::cout << "Punto no encontrado" << std::endl;
    }

    return 0;
}
```cpp
#include <iostream>
#include <vector>
#include <algorithm>

int main() {
    std::vector<int> vec = {2, 4, 6, 7, 8};

    // Usar una lambda para buscar el primer elemento mayor que 5
    auto it = std::find_if(vec.begin(), vec.end(), [](int n) {
        return n > 5;
    });

    if (it != vec.end()) {
        std::cout << "Primer elemento mayor que 5 encontrado: " << *it << std::endl;
    } else {
        std::cout << "Elemento mayor que 5 no encontrado" << std::endl;
    }

    return 0;
}
<---Ejemplo de Uso de `std::find_if` con Lambda Result--->
<---Copiar Elementos entre Diferentes Contenedores--->
```cpp
#include <iostream>
#include <vector>
#include <list>
#include <algorithm>

int main() {
    std::vector<int> origen = {1, 2, 3, 4, 5};
    std::list<int> destino(origen.size());

    // Usar std::copy para copiar los elementos
    std::copy(origen.begin(), origen.end(), destino.begin());

    // Mostrar los elementos copiados
    std::cout << "Elementos copiados a la lista destino: ";
    for (int elem : destino) {
        std::cout << elem << " ";
    }
    std::cout << std::endl;

    return 0;
}
```cpp
#include <iostream>
#include <vector>
#include <algorithm>

int main() {
    std::vector<int> origen = {1, 2, 3, 4, 5};
    std::vector<int> destino(3);

    // Usar std::copy para copiar los primeros 3 elementos
    std::copy(origen.begin(), origen.begin() + 3, destino.begin());

    // Mostrar los elementos copiados
    std::cout << "Primeros 3 elementos copiados al vector destino: ";
    for (int elem : destino) {
        std::cout << elem << " ";
    }
    std::cout << std::endl;

    return 0;
}
```cpp
#include <iostream>
#include <vector>
#include <algorithm>
#include <iterator>

int main() {
    std::vector<int> origen = {1, 2, 3, 4, 5};
    std::vector<int> destino;

    // Usar std::copy con std::back_inserter
    std::copy(origen.begin(), origen.end(), std::back_inserter(destino));

    // Mostrar los elementos copiados
    std::cout << "Elementos copiados al vector destino con back_inserter: ";
    for (int elem : destino) {
        std::cout << elem << " ";
    }
    std::cout << std::endl;

    return 0;
}
<---Copiar Elementos entre Diferentes Contenedores Result--->
<---Ejemplo Básico (Orden Ascendente)--->
```cpp
#include <iostream>
#include <vector>
#include <algorithm>

int main() {
    std::vector<int> vec = {5, 2, 9, 1, 5, 6};

    // Usar std::sort para ordenar los elementos en orden ascendente
    std::sort(vec.begin(), vec.end());

    // Mostrar los elementos ordenados
    std::cout << "Elementos ordenados: ";
    for (int elem : vec) {
        std::cout << elem << " ";
    }
    std::cout << std::endl;

    return 0;
}
<---Ejemplo Básico (Orden Ascendente) Result--->
<---Ejemplo con Comparación Personalizada (Orden Descendente)--->
```cpp
#include <iostream>
#include <vector>
#include <algorithm>

int main() {
    std::vector<int> vec = {5, 2, 9, 1, 5, 6};

    // Usar std::sort con una función de comparación para ordenar en orden descendente
    std::sort(vec.begin(), vec.end(), std::greater<int>());

    // Mostrar los elementos ordenados
    std::cout << "Elementos ordenados en orden descendente: ";
    for (int elem : vec) {
        std::cout << elem << " ";
    }
    std::cout << std::endl;

    return 0;
}
<---Ejemplo con Comparación Personalizada (Orden Descendente) Result--->
<---Ordenar un `std::array`--->
```cpp
#include <iostream>
#include <array>
#include <algorithm>

int main() {
    std::array<int, 6> arr = {5, 2, 9, 1, 5, 6};

    // Usar std::sort para ordenar los elementos del array
    std::sort(arr.begin(), arr.end());

    // Mostrar los elementos ordenados
    std::cout << "Elementos del array ordenados: ";
    for (int elem : arr) {
        std::cout << elem << " ";
    }
    std::cout << std::endl;

    return 0;
}
<---Ordenar un `std::array` Result--->
<---Ejemplo Básico (Función Unaria)--->
```cpp
#include <iostream>
#include <vector>
#include <algorithm>

int main() {
    std::vector<int> origen = {1, 2, 3, 4, 5};
    std::vector<int> destino(origen.size());

    // Usar std::transform para duplicar cada elemento
    std::transform(origen.begin(), origen.end(), destino.begin(), [](int x) {
        return x * 2;
    });

    // Mostrar los elementos transformados
    std::cout << "Elementos transformados (duplicados): ";
    for (int elem : destino) {
        std::cout << elem << " ";
    }
    std::cout << std::endl;

    return 0;
}
<---Ejemplo Básico (Función Unaria) Result--->
<---Ejemplo con Función Binaria--->
```cpp
#include <iostream>
#include <vector>
#include <algorithm>

int main() {
    std::vector<int> vec1 = {1, 2, 3, 4, 5};
    std::vector<int> vec2 = {10, 20, 30, 40, 50};
    std::vector<int> resultado(vec1.size());

    // Usar std::transform para sumar elementos de dos vectores
    std::transform(vec1.begin(), vec1.end(), vec2.begin(), resultado.begin(), [](int x, int y) {
        return x + y;
    });

    // Mostrar los elementos transformados
    std::cout << "Elementos transformados (suma de vec1 y vec2): ";
    for (int elem : resultado) {
        std::cout << elem << " ";
    }
    std::cout << std::endl;

    return 0;
}
<---Ejemplo con Función Binaria Result--->
<---Transformar una Lista--->
```cpp
#include <iostream>
#include <list>
#include <algorithm>

int main() {
    std::list<int> origen = {1, 2, 3, 4, 5};
    std::list<int> destino(origen.size());

    // Usar std::transform para incrementar cada elemento
    std::transform(origen.begin(), origen.end(), destino.begin(), [](int x) {
        return x + 1;
    });

    // Mostrar los elementos transformados
    std::cout << "Elementos transformados (incrementados): ";
    for (int elem : destino) {
        std::cout << elem << " ";
    }
    std::cout << std::endl;

    return 0;
}
<---Transformar una Lista Result--->
<---Ejemplo con `std::array`--->
```cpp
#include <iostream>
#include <array>
#include <algorithm>

int main() {
    std::array<int, 5> arr;

    // Usar std::fill para asignar el valor 10 a todos los elementos del array
    std::fill(arr.begin(), arr.end(), 10);

    // Mostrar los elementos del array
    std::cout << "Elementos del array después de std::fill: ";
    for (int elem : arr) {
        std::cout << elem << " ";
    }
    std::cout << std::endl;

    return 0;
}
<---Ejemplo con `std::array` Result--->
<---Ejemplo con una Matriz--->
```cpp
#include <iostream>
#include <vector>
#include <algorithm>

int main() {
    std::vector<std::vector<int>> matrix(3, std::vector<int>(4));

    // Usar std::fill para asignar el valor 0 a todos los elementos de la matriz
    for (auto& row : matrix) {
        std::fill(row.begin(), row.end(), 0);
    }

    // Mostrar los elementos de la matriz
    std::cout << "Elementos de la matriz después de std::fill: " << std::endl;
    for (const auto& row : matrix) {
        for (int elem : row) {
            std::cout << elem << " ";
        }
        std::cout << std::endl;
    }

    return 0;
}
<---Ejemplo con una Matriz Result--->
<---Ejemplo de Rango Parcial--->
```cpp
#include <iostream>
#include <vector>
#include <algorithm>

int main() {
    std::vector<int> vec(10);

    // Asignar el valor 1 a la primera mitad del vector
    std::fill(vec.begin(), vec.begin() + vec.size() / 2, 1);

    // Asignar el valor 2 a la segunda mitad del vector
    std::fill(vec.begin() + vec.size() / 2, vec.end(), 2);

    // Mostrar los elementos del vector
    std::cout << "Elementos del vector después de std::fill en rangos parciales: ";
    for (int elem : vec) {
        std::cout << elem << " ";
    }
    std::cout << std::endl;

    return 0;
}
<---Ejemplo de Rango Parcial Result--->
<---Ejemplo con `std::list`--->
```cpp
#include <iostream>
#include <list>
#include <algorithm>

bool esPositivo(int n) {
    return n > 0;
}

int main() {
    std::list<int> lst = {-1, 2, -3, 4, -5, 6};

    // Usar std::partition para particionar los elementos
    auto it = std::partition(lst.begin(), lst.end(), esPositivo);

    // Mostrar los elementos particionados
    std::cout << "Elementos de la lista después de std::partition: ";
    for (int elem : lst) {
        std::cout << elem << " ";
    }
    std::cout << std::endl;

    // Mostrar el punto de partición
    std::cout << "Punto de partición: " << *it << std::endl;

    return 0;
}
```cpp
#include <algorithm>

template <class ForwardIt, class UnaryPredicate>
ForwardIt stable_partition(ForwardIt first, ForwardIt last, UnaryPredicate p);
<---Ejemplo con `std::list` Result--->
<---Ejemplo Básico con `std::replace_if`--->
```cpp
#include <iostream>
#include <vector>
#include <algorithm>

bool esPar(int n) {
    return n % 2 == 0;
}

int main() {
    std::vector<int> vec = {1, 2, 3, 4, 5, 6};

    // Usar std::replace_if para reemplazar todos los números pares por 0
    std::replace_if(vec.begin(), vec.end(), esPar, 0);

    // Mostrar los elementos modificados
    std::cout << "Elementos del vector después de std::replace_if: ";
    for (int elem : vec) {
        std::cout << elem << " ";
    }
    std::cout << std::endl;

    return 0;
}
<---Ejemplo Básico con `std::replace_if` Result--->
<---Ejemplo Básico con `std::remove_if`--->
```cpp
#include <iostream>
#include <vector>
#include <algorithm>

bool esPar(int n) {
    return n % 2 == 0;
}

int main() {
    std::vector<int> vec = {1, 2, 3, 4, 5, 6};

    // Usar std::remove_if para mover los números pares al final
    auto it = std::remove_if(vec.begin(), vec.end(), esPar);

    // Eliminar físicamente los elementos después del nuevo final lógico
    vec.erase(it, vec.end());

    // Mostrar los elementos restantes
    std::cout << "Elementos del vector después de std::remove_if y erase: ";
    for (int elem : vec) {
        std::cout << elem << " ";
    }
    std::cout << std::endl;

    return 0;
}
<---Ejemplo Básico con `std::remove_if` Result--->
<---Ejemplo de Subsección--->
```cpp
#include <iostream>
#include <vector>
#include <algorithm>

int main() {
    std::vector<int> vec = {1, 2, 3, 4, 5, 6, 7, 8};

    // Usar std::reverse para invertir el orden de los elementos en una subsección del vector
    std::reverse(vec.begin() + 2, vec.begin() + 6);

    // Mostrar los elementos del vector después de invertir la subsección
    std::cout << "Elementos del vector después de invertir una subsección: ";
    for (int elem : vec) {
        std::cout << elem << " ";
    }
    std::cout << std::endl;

    return 0;
}
<---Ejemplo de Subsección Result--->
<---Ejemplo con `std::string`--->
```cpp
#include <iostream>
#include <string>
#include <algorithm>

int main() {
    std::string str = "Hello, World!";

    // Usar std::reverse para invertir el orden de los caracteres en la cadena
    std::reverse(str.begin(), str.end());

    // Mostrar la cadena invertida
    std::cout << "Cadena después de std::reverse: " << str << std::endl;

    return 0;
}
<---Ejemplo con `std::string` Result--->
<---Ejemplo Básico con `std::stable_partition`--->
```cpp
#include <iostream>
#include <vector>
#include <algorithm>

bool esPar(int n) {
    return n % 2 == 0;
}

int main() {
    std::vector<int> vec = {1, 2, 3, 4, 5, 6};

    // Usar std::stable_partition para particionar los elementos
    auto it = std::stable_partition(vec.begin(), vec.end(), esPar);

    // Mostrar los elementos particionados
    std::cout << "Elementos después de std::stable_partition: ";
    for (int elem : vec) {
        std::cout << elem << " ";
    }
    std::cout << std::endl;

    // Mostrar el punto de partición
    std::cout << "Punto de partición: " << *it << std::endl;

    return 0;
}
<---Ejemplo Básico con `std::stable_partition` Result--->
<---Descripción--->
```cpp
#include <iostream>
#include <vector>
#include <algorithm>

int main() {
    std::vector<int> vec = {1, 2, 3, 4, 5, 6, 7, 8, 9};

    // Usar std::upper_bound para encontrar el primer elemento mayor que 5
    auto it = std::upper_bound(vec.begin(), vec.end(), 5);

    // Mostrar el resultado
    if (it != vec.end()) {
        std::cout << "El primer elemento mayor que 5 es: " << *it << std::endl;
    } else {
        std::cout << "No se encontró un elemento mayor que 5" << std::endl;
    }

    return 0;
}
<---Descripción Result--->
<---Ejemplo Básico--->
```cpp
#include <iostream>
#include <vector>
#include <algorithm>

int main() {
    std::vector<int> vec = {10, 4, 5, 8, 6, 11, 26};

    // Encontrar el tercer elemento más pequeño (índice 2)
    std::nth_element(vec.begin(), vec.begin() + 2, vec.end());

    // Mostrar el tercer elemento más pequeño
    std::cout << "El tercer elemento más pequeño es: " << vec[2] << std::endl;

    // Mostrar todos los elementos
    std::cout << "Elementos del vector después de std::nth_element: ";
    for (int elem : vec) {
        std::cout << elem << " ";
    }
    std::cout << std::endl;

    return 0;
}
<---Ejemplo Básico Result--->
<---Ejemplo con Lambda--->
```cpp
#include <iostream>
#include <vector>
#include <algorithm>

int main() {
    std::vector<int> vec = {1, 2, 3, 4, 5, 6};

    // Usar std::remove_if con una lambda para mover los números mayores que 3 al final
    auto it = std::remove_if(vec.begin(), vec.end(), [](int n) { return n > 3; });

    // Eliminar físicamente los elementos después del nuevo final lógico
    vec.erase(it, vec.end());

    // Mostrar los elementos restantes
    std::cout << "Elementos del vector después de std::remove_if y erase: ";
    for (int elem : vec) {
        std::cout << elem << " ";
    }
    std::cout << std::endl;

    return 0;
}
<---Ejemplo con Lambda Result--->
<---Ejemplo Básico (Suma)--->
```cpp
#include <iostream>
#include <vector>
#include <numeric>

int main() {
    std::vector<int> vec = {1, 2, 3, 4, 5};

    // Usar std::accumulate para sumar todos los elementos
    int suma = std::accumulate(vec.begin(), vec.end(), 0);

    std::cout << "La suma de los elementos es: " << suma << std::endl;

    return 0;
}
<---Ejemplo Básico (Suma) Result--->
<---Ejemplo con Operación Binaria Personalizada (Multiplicación)--->
```cpp
#include <iostream>
#include <vector>
#include <numeric>

int main() {
    std::vector<int> vec = {1, 2, 3, 4, 5};

    // Usar std::accumulate para multiplicar todos los elementos
    int producto = std::accumulate(vec.begin(), vec.end(), 1, std::multiplies<int>());

    std::cout << "El producto de los elementos es: " << producto << std::endl;

    return 0;
}
```cpp
#include <iostream>
#include <vector>
#include <numeric>
#include <string>

int main() {
    std::vector<std::string> vec = {"Hola", " ", "mundo", "!"};

    // Usar std::accumulate para concatenar todas las cadenas
    std::string resultado = std::accumulate(vec.begin(), vec.end(), std::string(""));

    std::cout << "Cadena concatenada: " << resultado << std::endl;

    return 0;
}
```cpp
#include <iostream>
#include <vector>
#include <numeric>

int main() {
    std::vector<int> vec = {1, 2, 3, 4, 5};

    // Calcular la suma de los elementos
    int suma = std::accumulate(vec.begin(), vec.end(), 0);

    // Calcular la media
    double media = static_cast<double>(suma) / vec.size();

    std::cout << "La media de los elementos es: " << media << std::endl;

    return 0;
}
<---Ejemplo con Operación Binaria Personalizada (Multiplicación) Result--->
<---`std::max`--->
```cpp
#include <algorithm>

template <class T>
const T& max(const T& a, const T& b);

template <class T, class Compare>
const T& max(const T& a, const T& b, Compare comp);

template <class ForwardIt>
ForwardIt max_element(ForwardIt first, ForwardIt last);

template <class ForwardIt, class Compare>
ForwardIt max_element(ForwardIt first, ForwardIt last, Compare comp);
<---`std::max` Result--->
<---`std::min`--->
```cpp
#include <algorithm>

template <class T>
const T& min(const T& a, const T& b);

template <class T, class Compare>
const T& min(const T& a, const T& b, Compare comp);

template <class ForwardIt>
ForwardIt min_element(ForwardIt first, ForwardIt last);

template <class ForwardIt, class Compare>
ForwardIt min_element(ForwardIt first, ForwardIt last, Compare comp);
<---`std::min` Result--->
<---Ejemplo Básico con Dos Valores--->
```cpp
#include <iostream>
#include <algorithm>

int main() {
    int a = 10, b = 20;

    // Encontrar el valor máximo
    int maxVal = std::max(a, b);
    std::cout << "El mayor de " << a << " y " << b << " es " << maxVal << std::endl;

    // Encontrar el valor mínimo
    int minVal = std::min(a, b);
    std::cout << "El menor de " << a << " y " << b << " es " << minVal << std::endl;

    return 0;
}
<---Ejemplo Básico con Dos Valores Result--->
<---Ejemplo con Comparación Personalizada--->
```cpp
#include <iostream>
#include <vector>
#include <algorithm>

struct Persona {
    std::string nombre;
    int edad;
};

bool compararPorEdad(const Persona& a, const Persona& b) {
    return a.edad < b.edad;
}

int main() {
    std::vector<Persona> personas = {{"Ana", 25}, {"Luis", 30}, {"Carlos", 22}, {"Maria", 28}, {"Jose", 24}};

    // Encontrar la tercera persona más joven
    std::nth_element(personas.begin(), personas.begin() + 2, personas.end(), compararPorEdad);

    // Mostrar la tercera persona más joven
    std::cout << "La tercera persona más joven es: " << personas[2].nombre << " (" << personas[2].edad << ")" << std::endl;

    // Mostrar todas las personas
    std::cout << "Personas después de std::nth_element: ";
    for (const auto& persona : personas) {
        std::cout << persona.nombre << " (" << persona.edad << "), ";
    }
    std::cout << std::endl;

    return 0;
}
<---Ejemplo con Comparación Personalizada Result--->
<---Ejemplo Básico con un Rango de Elementos--->
```cpp
#include <iostream>
#include <vector>
#include <algorithm>

int main() {
    std::vector<int> vec = {1, 2, 3, 4, 5};

    // Encontrar el elemento máximo
    auto maxIt = std::max_element(vec.begin(), vec.end());
    std::cout << "El elemento máximo es: " << *maxIt << std::endl;

    // Encontrar el elemento mínimo
    auto minIt = std::min_element(vec.begin(), vec.end());
    std::cout << "El elemento mínimo es: " << *minIt << std::endl;

    return 0;
}
<---Ejemplo Básico con un Rango de Elementos Result--->
<---Sintaxis--->
```cpp
#include <algorithm>

template <class ForwardIt, class T>
ForwardIt upper_bound(ForwardIt first, ForwardIt last, const T& value);

template <class ForwardIt, class T, class Compare>
ForwardIt upper_bound(ForwardIt first, ForwardIt last, const T& value, Compare comp);
<---Sintaxis Result--->
<---Ejemplo de Uso de `std::find`--->
```cpp
#include <iostream>
#include <vector>
#include <algorithm>

int main() {
    std::vector<int> vec = {1, 2, 3, 4, 5};

    // Buscar el valor 3
    auto it = std::find(vec.begin(), vec.end(), 3);

    if (it != vec.end()) {
        std::cout << "Elemento encontrado: " << *it << std::endl;
    } else {
        std::cout << "Elemento no encontrado" << std::endl;
    }

    return 0;
}
<---Ejemplo de Uso de `std::find` Result--->
<---Ejemplo de Uso de `std::find_if`--->
```cpp
#include <iostream>
#include <vector>
#include <algorithm>

bool esImpar(int n) {
    return n % 2 != 0;
}

int main() {
    std::vector<int> vec = {2, 4, 6, 7, 8};

    // Buscar el primer elemento impar
    auto it = std::find_if(vec.begin(), vec.end(), esImpar);

    if (it != vec.end()) {
        std::cout << "Primer elemento impar encontrado: " << *it << std::endl;
    } else {
        std::cout << "Elemento impar no encontrado" << std::endl;
    }

    return 0;
}
<---Ejemplo de Uso de `std::find_if` Result--->
<---Ejemplo de Uso de `std::find_if` con Lambda--->
```cpp
#include <iostream>
#include <vector>
#include <algorithm>

int main() {
    std::vector<int> vec = {2, 4, 6, 7, 8};

    // Usar una lambda para buscar el primer elemento impar
    auto it = std::find_if(vec.begin(), vec.end(), [](int n) {
        return n % 2 != 0;
    });

    if (it != vec.end()) {
        std::cout << "Primer elemento impar encontrado: " << *it << std::endl;
    } else {
        std::cout << "Elemento impar no encontrado" << std::endl;
    }

    return 0;
}
```cpp
#include <iostream>
#include <vector>
#include <algorithm>

struct Punto {
    int x, y;

    bool operator==(const Punto& otro) const {
        return x == otro.x && y == otro.y;
    }
};

int main() {
    std::vector<Punto> puntos = {{1, 2}, {3, 4}, {5, 6}, {7, 8}};
    Punto puntoABuscar = {5, 6};

    // Buscar el punto {5, 6}
    auto it = std::find(puntos.begin(), puntos.end(), puntoABuscar);

    if (it != puntos.end()) {
        std::cout << "Punto encontrado: (" << it->x << ", " << it->y << ")" << std::endl;
    } else {
        std::cout << "Punto no encontrado" << std::endl;
    }

    return 0;
}
```cpp
#include <iostream>
#include <vector>
#include <algorithm>

int main() {
    std::vector<int> vec = {2, 4, 6, 7, 8};

    // Usar una lambda para buscar el primer elemento mayor que 5
    auto it = std::find_if(vec.begin(), vec.end(), [](int n) {
        return n > 5;
    });

    if (it != vec.end()) {
        std::cout << "Primer elemento mayor que 5 encontrado: " << *it << std::endl;
    } else {
        std::cout << "Elemento mayor que 5 no encontrado" << std::endl;
    }

    return 0;
}
<---Ejemplo de Uso de `std::find_if` con Lambda Result--->
<---Copiar Elementos entre Diferentes Contenedores--->
```cpp
#include <iostream>
#include <vector>
#include <list>
#include <algorithm>

int main() {
    std::vector<int> origen = {1, 2, 3, 4, 5};
    std::list<int> destino(origen.size());

    // Usar std::copy para copiar los elementos
    std::copy(origen.begin(), origen.end(), destino.begin());

    // Mostrar los elementos copiados
    std::cout << "Elementos copiados a la lista destino: ";
    for (int elem : destino) {
        std::cout << elem << " ";
    }
    std::cout << std::endl;

    return 0;
}
```cpp
#include <iostream>
#include <vector>
#include <algorithm>

int main() {
    std::vector<int> origen = {1, 2, 3, 4, 5};
    std::vector<int> destino(3);

    // Usar std::copy para copiar los primeros 3 elementos
    std::copy(origen.begin(), origen.begin() + 3, destino.begin());

    // Mostrar los elementos copiados
    std::cout << "Primeros 3 elementos copiados al vector destino: ";
    for (int elem : destino) {
        std::cout << elem << " ";
    }
    std::cout << std::endl;

    return 0;
}
```cpp
#include <iostream>
#include <vector>
#include <algorithm>
#include <iterator>

int main() {
    std::vector<int> origen = {1, 2, 3, 4, 5};
    std::vector<int> destino;

    // Usar std::copy con std::back_inserter
    std::copy(origen.begin(), origen.end(), std::back_inserter(destino));

    // Mostrar los elementos copiados
    std::cout << "Elementos copiados al vector destino con back_inserter: ";
    for (int elem : destino) {
        std::cout << elem << " ";
    }
    std::cout << std::endl;

    return 0;
}
<---Copiar Elementos entre Diferentes Contenedores Result--->
<---Ejemplo Básico (Orden Ascendente)--->
```cpp
#include <iostream>
#include <vector>
#include <algorithm>

int main() {
    std::vector<int> vec = {5, 2, 9, 1, 5, 6};

    // Usar std::sort para ordenar los elementos en orden ascendente
    std::sort(vec.begin(), vec.end());

    // Mostrar los elementos ordenados
    std::cout << "Elementos ordenados: ";
    for (int elem : vec) {
        std::cout << elem << " ";
    }
    std::cout << std::endl;

    return 0;
}
<---Ejemplo Básico (Orden Ascendente) Result--->
<---Ejemplo con Comparación Personalizada (Orden Descendente)--->
```cpp
#include <iostream>
#include <vector>
#include <algorithm>

int main() {
    std::vector<int> vec = {5, 2, 9, 1, 5, 6};

    // Usar std::sort con una función de comparación para ordenar en orden descendente
    std::sort(vec.begin(), vec.end(), std::greater<int>());

    // Mostrar los elementos ordenados
    std::cout << "Elementos ordenados en orden descendente: ";
    for (int elem : vec) {
        std::cout << elem << " ";
    }
    std::cout << std::endl;

    return 0;
}
<---Ejemplo con Comparación Personalizada (Orden Descendente) Result--->
<---Ordenar un `std::array`--->
```cpp
#include <iostream>
#include <array>
#include <algorithm>

int main() {
    std::array<int, 6> arr = {5, 2, 9, 1, 5, 6};

    // Usar std::sort para ordenar los elementos del array
    std::sort(arr.begin(), arr.end());

    // Mostrar los elementos ordenados
    std::cout << "Elementos del array ordenados: ";
    for (int elem : arr) {
        std::cout << elem << " ";
    }
    std::cout << std::endl;

    return 0;
}
<---Ordenar un `std::array` Result--->
<---Ejemplo Básico (Función Unaria)--->
```cpp
#include <iostream>
#include <vector>
#include <algorithm>

int main() {
    std::vector<int> origen = {1, 2, 3, 4, 5};
    std::vector<int> destino(origen.size());

    // Usar std::transform para duplicar cada elemento
    std::transform(origen.begin(), origen.end(), destino.begin(), [](int x) {
        return x * 2;
    });

    // Mostrar los elementos transformados
    std::cout << "Elementos transformados (duplicados): ";
    for (int elem : destino) {
        std::cout << elem << " ";
    }
    std::cout << std::endl;

    return 0;
}
<---Ejemplo Básico (Función Unaria) Result--->
<---Ejemplo con Función Binaria--->
```cpp
#include <iostream>
#include <vector>
#include <algorithm>

int main() {
    std::vector<int> vec1 = {1, 2, 3, 4, 5};
    std::vector<int> vec2 = {10, 20, 30, 40, 50};
    std::vector<int> resultado(vec1.size());

    // Usar std::transform para sumar elementos de dos vectores
    std::transform(vec1.begin(), vec1.end(), vec2.begin(), resultado.begin(), [](int x, int y) {
        return x + y;
    });

    // Mostrar los elementos transformados
    std::cout << "Elementos transformados (suma de vec1 y vec2): ";
    for (int elem : resultado) {
        std::cout << elem << " ";
    }
    std::cout << std::endl;

    return 0;
}
<---Ejemplo con Función Binaria Result--->
<---Transformar una Lista--->
```cpp
#include <iostream>
#include <list>
#include <algorithm>

int main() {
    std::list<int> origen = {1, 2, 3, 4, 5};
    std::list<int> destino(origen.size());

    // Usar std::transform para incrementar cada elemento
    std::transform(origen.begin(), origen.end(), destino.begin(), [](int x) {
        return x + 1;
    });

    // Mostrar los elementos transformados
    std::cout << "Elementos transformados (incrementados): ";
    for (int elem : destino) {
        std::cout << elem << " ";
    }
    std::cout << std::endl;

    return 0;
}
<---Transformar una Lista Result--->
<---Ejemplo con `std::array`--->
```cpp
#include <iostream>
#include <array>
#include <algorithm>

int main() {
    std::array<int, 5> arr;

    // Usar std::fill para asignar el valor 10 a todos los elementos del array
    std::fill(arr.begin(), arr.end(), 10);

    // Mostrar los elementos del array
    std::cout << "Elementos del array después de std::fill: ";
    for (int elem : arr) {
        std::cout << elem << " ";
    }
    std::cout << std::endl;

    return 0;
}
<---Ejemplo con `std::array` Result--->
<---Ejemplo con una Matriz--->
```cpp
#include <iostream>
#include <vector>
#include <algorithm>

int main() {
    std::vector<std::vector<int>> matrix(3, std::vector<int>(4));

    // Usar std::fill para asignar el valor 0 a todos los elementos de la matriz
    for (auto& row : matrix) {
        std::fill(row.begin(), row.end(), 0);
    }

    // Mostrar los elementos de la matriz
    std::cout << "Elementos de la matriz después de std::fill: " << std::endl;
    for (const auto& row : matrix) {
        for (int elem : row) {
            std::cout << elem << " ";
        }
        std::cout << std::endl;
    }

    return 0;
}
<---Ejemplo con una Matriz Result--->
<---Ejemplo de Rango Parcial--->
```cpp
#include <iostream>
#include <vector>
#include <algorithm>

int main() {
    std::vector<int> vec(10);

    // Asignar el valor 1 a la primera mitad del vector
    std::fill(vec.begin(), vec.begin() + vec.size() / 2, 1);

    // Asignar el valor 2 a la segunda mitad del vector
    std::fill(vec.begin() + vec.size() / 2, vec.end(), 2);

    // Mostrar los elementos del vector
    std::cout << "Elementos del vector después de std::fill en rangos parciales: ";
    for (int elem : vec) {
        std::cout << elem << " ";
    }
    std::cout << std::endl;

    return 0;
}
<---Ejemplo de Rango Parcial Result--->
<---Ejemplo con `std::list`--->
```cpp
#include <iostream>
#include <list>
#include <algorithm>

bool esPositivo(int n) {
    return n > 0;
}

int main() {
    std::list<int> lst = {-1, 2, -3, 4, -5, 6};

    // Usar std::partition para particionar los elementos
    auto it = std::partition(lst.begin(), lst.end(), esPositivo);

    // Mostrar los elementos particionados
    std::cout << "Elementos de la lista después de std::partition: ";
    for (int elem : lst) {
        std::cout << elem << " ";
    }
    std::cout << std::endl;

    // Mostrar el punto de partición
    std::cout << "Punto de partición: " << *it << std::endl;

    return 0;
}
```cpp
#include <algorithm>

template <class ForwardIt, class UnaryPredicate>
ForwardIt stable_partition(ForwardIt first, ForwardIt last, UnaryPredicate p);
<---Ejemplo con `std::list` Result--->
<---Ejemplo Básico con `std::replace_if`--->
```cpp
#include <iostream>
#include <vector>
#include <algorithm>

bool esPar(int n) {
    return n % 2 == 0;
}

int main() {
    std::vector<int> vec = {1, 2, 3, 4, 5, 6};

    // Usar std::replace_if para reemplazar todos los números pares por 0
    std::replace_if(vec.begin(), vec.end(), esPar, 0);

    // Mostrar los elementos modificados
    std::cout << "Elementos del vector después de std::replace_if: ";
    for (int elem : vec) {
        std::cout << elem << " ";
    }
    std::cout << std::endl;

    return 0;
}
<---Ejemplo Básico con `std::replace_if` Result--->
<---Ejemplo Básico con `std::remove_if`--->
```cpp
#include <iostream>
#include <vector>
#include <algorithm>

bool esPar(int n) {
    return n % 2 == 0;
}

int main() {
    std::vector<int> vec = {1, 2, 3, 4, 5, 6};

    // Usar std::remove_if para mover los números pares al final
    auto it = std::remove_if(vec.begin(), vec.end(), esPar);

    // Eliminar físicamente los elementos después del nuevo final lógico
    vec.erase(it, vec.end());

    // Mostrar los elementos restantes
    std::cout << "Elementos del vector después de std::remove_if y erase: ";
    for (int elem : vec) {
        std::cout << elem << " ";
    }
    std::cout << std::endl;

    return 0;
}
<---Ejemplo Básico con `std::remove_if` Result--->
<---Ejemplo de Subsección--->
```cpp
#include <iostream>
#include <vector>
#include <algorithm>

int main() {
    std::vector<int> vec = {1, 2, 3, 4, 5, 6, 7, 8};

    // Usar std::reverse para invertir el orden de los elementos en una subsección del vector
    std::reverse(vec.begin() + 2, vec.begin() + 6);

    // Mostrar los elementos del vector después de invertir la subsección
    std::cout << "Elementos del vector después de invertir una subsección: ";
    for (int elem : vec) {
        std::cout << elem << " ";
    }
    std::cout << std::endl;

    return 0;
}
<---Ejemplo de Subsección Result--->
<---Ejemplo con `std::string`--->
```cpp
#include <iostream>
#include <string>
#include <algorithm>

int main() {
    std::string str = "Hello, World!";

    // Usar std::reverse para invertir el orden de los caracteres en la cadena
    std::reverse(str.begin(), str.end());

    // Mostrar la cadena invertida
    std::cout << "Cadena después de std::reverse: " << str << std::endl;

    return 0;
}
<---Ejemplo con `std::string` Result--->
<---Ejemplo Básico con `std::stable_partition`--->
```cpp
#include <iostream>
#include <vector>
#include <algorithm>

bool esPar(int n) {
    return n % 2 == 0;
}

int main() {
    std::vector<int> vec = {1, 2, 3, 4, 5, 6};

    // Usar std::stable_partition para particionar los elementos
    auto it = std::stable_partition(vec.begin(), vec.end(), esPar);

    // Mostrar los elementos particionados
    std::cout << "Elementos después de std::stable_partition: ";
    for (int elem : vec) {
        std::cout << elem << " ";
    }
    std::cout << std::endl;

    // Mostrar el punto de partición
    std::cout << "Punto de partición: " << *it << std::endl;

    return 0;
}
<---Ejemplo Básico con `std::stable_partition` Result--->
<---Descripción--->
```cpp
#include <iostream>
#include <vector>
#include <algorithm>

int main() {
    std::vector<int> vec = {1, 2, 3, 4, 5, 6, 7, 8, 9};

    // Usar std::upper_bound para encontrar el primer elemento mayor que 5
    auto it = std::upper_bound(vec.begin(), vec.end(), 5);

    // Mostrar el resultado
    if (it != vec.end()) {
        std::cout << "El primer elemento mayor que 5 es: " << *it << std::endl;
    } else {
        std::cout << "No se encontró un elemento mayor que 5" << std::endl;
    }

    return 0;
}
<---Descripción Result--->
<---Ejemplo Básico--->
```cpp
#include <iostream>
#include <vector>
#include <algorithm>

int main() {
    std::vector<int> vec1 = {1, 3, 5, 7};
    std::vector<int> vec2 = {2, 4, 6, 8};
    std::vector<int> result(vec1.size() + vec2.size());

    // Usar std::merge para fusionar los dos vectores ordenados
    std::merge(vec1.begin(), vec1.end(), vec2.begin(), vec2.end(), result.begin());

    // Mostrar los elementos fusionados
    std::cout << "Elementos fusionados: ";
    for (int elem : result) {
        std::cout << elem << " ";
    }
    std::cout << std::endl;

    return 0;
}
<---Ejemplo Básico Result--->
<---Ejemplo con Lambda--->
```cpp
#include <iostream>
#include <vector>
#include <algorithm>

int main() {
    std::vector<int> vec = {1, 2, 3, 4, 5, 6};

    // Usar std::remove_if con una lambda para mover los números mayores que 3 al final
    auto it = std::remove_if(vec.begin(), vec.end(), [](int n) { return n > 3; });

    // Eliminar físicamente los elementos después del nuevo final lógico
    vec.erase(it, vec.end());

    // Mostrar los elementos restantes
    std::cout << "Elementos del vector después de std::remove_if y erase: ";
    for (int elem : vec) {
        std::cout << elem << " ";
    }
    std::cout << std::endl;

    return 0;
}
<---Ejemplo con Lambda Result--->
<---Ejemplo Básico (Suma)--->
```cpp
#include <iostream>
#include <vector>
#include <numeric>

int main() {
    std::vector<int> vec = {1, 2, 3, 4, 5};

    // Usar std::accumulate para sumar todos los elementos
    int suma = std::accumulate(vec.begin(), vec.end(), 0);

    std::cout << "La suma de los elementos es: " << suma << std::endl;

    return 0;
}
<---Ejemplo Básico (Suma) Result--->
<---Ejemplo con Operación Binaria Personalizada (Multiplicación)--->
```cpp
#include <iostream>
#include <vector>
#include <numeric>

int main() {
    std::vector<int> vec = {1, 2, 3, 4, 5};

    // Usar std::accumulate para multiplicar todos los elementos
    int producto = std::accumulate(vec.begin(), vec.end(), 1, std::multiplies<int>());

    std::cout << "El producto de los elementos es: " << producto << std::endl;

    return 0;
}
```cpp
#include <iostream>
#include <vector>
#include <numeric>
#include <string>

int main() {
    std::vector<std::string> vec = {"Hola", " ", "mundo", "!"};

    // Usar std::accumulate para concatenar todas las cadenas
    std::string resultado = std::accumulate(vec.begin(), vec.end(), std::string(""));

    std::cout << "Cadena concatenada: " << resultado << std::endl;

    return 0;
}
```cpp
#include <iostream>
#include <vector>
#include <numeric>

int main() {
    std::vector<int> vec = {1, 2, 3, 4, 5};

    // Calcular la suma de los elementos
    int suma = std::accumulate(vec.begin(), vec.end(), 0);

    // Calcular la media
    double media = static_cast<double>(suma) / vec.size();

    std::cout << "La media de los elementos es: " << media << std::endl;

    return 0;
}
<---Ejemplo con Operación Binaria Personalizada (Multiplicación) Result--->
<---`std::max`--->
```cpp
#include <algorithm>

template <class T>
const T& max(const T& a, const T& b);

template <class T, class Compare>
const T& max(const T& a, const T& b, Compare comp);

template <class ForwardIt>
ForwardIt max_element(ForwardIt first, ForwardIt last);

template <class ForwardIt, class Compare>
ForwardIt max_element(ForwardIt first, ForwardIt last, Compare comp);
<---`std::max` Result--->
<---`std::min`--->
```cpp
#include <algorithm>

template <class T>
const T& min(const T& a, const T& b);

template <class T, class Compare>
const T& min(const T& a, const T& b, Compare comp);

template <class ForwardIt>
ForwardIt min_element(ForwardIt first, ForwardIt last);

template <class ForwardIt, class Compare>
ForwardIt min_element(ForwardIt first, ForwardIt last, Compare comp);
<---`std::min` Result--->
<---Ejemplo Básico con Dos Valores--->
```cpp
#include <iostream>
#include <algorithm>

int main() {
    int a = 10, b = 20;

    // Encontrar el valor máximo
    int maxVal = std::max(a, b);
    std::cout << "El mayor de " << a << " y " << b << " es " << maxVal << std::endl;

    // Encontrar el valor mínimo
    int minVal = std::min(a, b);
    std::cout << "El menor de " << a << " y " << b << " es " << minVal << std::endl;

    return 0;
}
<---Ejemplo Básico con Dos Valores Result--->
<---Ejemplo con Comparación Personalizada--->
```cpp
#include <iostream>
#include <vector>
#include <algorithm>

struct Persona {
    std::string nombre;
    int edad;
};

bool compararPorEdad(const Persona& a, const Persona& b) {
    return a.edad < b.edad;
}

int main() {
    std::vector<Persona> grupo1 = {{"Ana", 25}, {"Carlos", 30}};
    std::vector<Persona> grupo2 = {{"Luis", 22}, {"Maria", 28}};
    std::vector<Persona> resultado(grupo1.size() + grupo2.size());

    // Usar std::merge con comparación personalizada para fusionar los dos vectores ordenados
    std::merge(grupo1.begin(), grupo1.end(), grupo2.begin(), grupo2.end(), resultado.begin(), compararPorEdad);

    // Mostrar las personas fusionadas
    std::cout << "Personas fusionadas: ";
    for (const auto& persona : resultado) {
        std::cout << persona.nombre << " (" << persona.edad << "), ";
    }
    std::cout << std::endl;

    return 0;
}
```cpp
#include <algorithm>

template <class BidirIt>
void inplace_merge(BidirIt first, BidirIt middle, BidirIt last);

template <class BidirIt, class Compare>
void inplace_merge(BidirIt first, BidirIt middle, BidirIt last, Compare comp);
```cpp
#include <iostream>
#include <vector>
#include <algorithm>

int main() {
    std::vector<int> vec = {1, 3, 5, 7, 2, 4, 6, 8};

    // Usar std::inplace_merge para fusionar los dos rangos adyacentes
    std::inplace_merge(vec.begin(), vec.begin() + 4, vec.end());

    // Mostrar los elementos fusionados
    std::cout << "Elementos después de std::inplace_merge: ";
    for (int elem : vec) {
        std::cout << elem << " ";
    }
    std::cout << std::endl;

    return 0;
}
<---Ejemplo con Comparación Personalizada Result--->
<---Ejemplo Básico con un Rango de Elementos--->
```cpp
#include <iostream>
#include <vector>
#include <algorithm>

int main() {
    std::vector<int> vec = {1, 2, 3, 4, 5};

    // Encontrar el elemento máximo
    auto maxIt = std::max_element(vec.begin(), vec.end());
    std::cout << "El elemento máximo es: " << *maxIt << std::endl;

    // Encontrar el elemento mínimo
    auto minIt = std::min_element(vec.begin(), vec.end());
    std::cout << "El elemento mínimo es: " << *minIt << std::endl;

    return 0;
}
<---Ejemplo Básico con un Rango de Elementos Result--->
<---Sintaxis--->
```cpp
#include <algorithm>

template <class ForwardIt, class T>
ForwardIt upper_bound(ForwardIt first, ForwardIt last, const T& value);

template <class ForwardIt, class T, class Compare>
ForwardIt upper_bound(ForwardIt first, ForwardIt last, const T& value, Compare comp);
<---Sintaxis Result--->
<---Ejemplo de Uso de `std::find`--->
```cpp
#include <iostream>
#include <vector>
#include <algorithm>

int main() {
    std::vector<int> vec = {1, 2, 3, 4, 5};

    // Buscar el valor 3
    auto it = std::find(vec.begin(), vec.end(), 3);

    if (it != vec.end()) {
        std::cout << "Elemento encontrado: " << *it << std::endl;
    } else {
        std::cout << "Elemento no encontrado" << std::endl;
    }

    return 0;
}
<---Ejemplo de Uso de `std::find` Result--->
<---Ejemplo de Uso de `std::find_if`--->
```cpp
#include <iostream>
#include <vector>
#include <algorithm>

bool esImpar(int n) {
    return n % 2 != 0;
}

int main() {
    std::vector<int> vec = {2, 4, 6, 7, 8};

    // Buscar el primer elemento impar
    auto it = std::find_if(vec.begin(), vec.end(), esImpar);

    if (it != vec.end()) {
        std::cout << "Primer elemento impar encontrado: " << *it << std::endl;
    } else {
        std::cout << "Elemento impar no encontrado" << std::endl;
    }

    return 0;
}
<---Ejemplo de Uso de `std::find_if` Result--->
<---Ejemplo de Uso de `std::find_if` con Lambda--->
```cpp
#include <iostream>
#include <vector>
#include <algorithm>

int main() {
    std::vector<int> vec = {2, 4, 6, 7, 8};

    // Usar una lambda para buscar el primer elemento impar
    auto it = std::find_if(vec.begin(), vec.end(), [](int n) {
        return n % 2 != 0;
    });

    if (it != vec.end()) {
        std::cout << "Primer elemento impar encontrado: " << *it << std::endl;
    } else {
        std::cout << "Elemento impar no encontrado" << std::endl;
    }

    return 0;
}
```cpp
#include <iostream>
#include <vector>
#include <algorithm>

struct Punto {
    int x, y;

    bool operator==(const Punto& otro) const {
        return x == otro.x && y == otro.y;
    }
};

int main() {
    std::vector<Punto> puntos = {{1, 2}, {3, 4}, {5, 6}, {7, 8}};
    Punto puntoABuscar = {5, 6};

    // Buscar el punto {5, 6}
    auto it = std::find(puntos.begin(), puntos.end(), puntoABuscar);

    if (it != puntos.end()) {
        std::cout << "Punto encontrado: (" << it->x << ", " << it->y << ")" << std::endl;
    } else {
        std::cout << "Punto no encontrado" << std::endl;
    }

    return 0;
}
```cpp
#include <iostream>
#include <vector>
#include <algorithm>

int main() {
    std::vector<int> vec = {2, 4, 6, 7, 8};

    // Usar una lambda para buscar el primer elemento mayor que 5
    auto it = std::find_if(vec.begin(), vec.end(), [](int n) {
        return n > 5;
    });

    if (it != vec.end()) {
        std::cout << "Primer elemento mayor que 5 encontrado: " << *it << std::endl;
    } else {
        std::cout << "Elemento mayor que 5 no encontrado" << std::endl;
    }

    return 0;
}
<---Ejemplo de Uso de `std::find_if` con Lambda Result--->
<---Copiar Elementos entre Diferentes Contenedores--->
```cpp
#include <iostream>
#include <vector>
#include <list>
#include <algorithm>

int main() {
    std::vector<int> origen = {1, 2, 3, 4, 5};
    std::list<int> destino(origen.size());

    // Usar std::copy para copiar los elementos
    std::copy(origen.begin(), origen.end(), destino.begin());

    // Mostrar los elementos copiados
    std::cout << "Elementos copiados a la lista destino: ";
    for (int elem : destino) {
        std::cout << elem << " ";
    }
    std::cout << std::endl;

    return 0;
}
```cpp
#include <iostream>
#include <vector>
#include <algorithm>

int main() {
    std::vector<int> origen = {1, 2, 3, 4, 5};
    std::vector<int> destino(3);

    // Usar std::copy para copiar los primeros 3 elementos
    std::copy(origen.begin(), origen.begin() + 3, destino.begin());

    // Mostrar los elementos copiados
    std::cout << "Primeros 3 elementos copiados al vector destino: ";
    for (int elem : destino) {
        std::cout << elem << " ";
    }
    std::cout << std::endl;

    return 0;
}
```cpp
#include <iostream>
#include <vector>
#include <algorithm>
#include <iterator>

int main() {
    std::vector<int> origen = {1, 2, 3, 4, 5};
    std::vector<int> destino;

    // Usar std::copy con std::back_inserter
    std::copy(origen.begin(), origen.end(), std::back_inserter(destino));

    // Mostrar los elementos copiados
    std::cout << "Elementos copiados al vector destino con back_inserter: ";
    for (int elem : destino) {
        std::cout << elem << " ";
    }
    std::cout << std::endl;

    return 0;
}
<---Copiar Elementos entre Diferentes Contenedores Result--->
<---Ejemplo Básico (Orden Ascendente)--->
```cpp
#include <iostream>
#include <vector>
#include <algorithm>

int main() {
    std::vector<int> vec = {5, 2, 9, 1, 5, 6};

    // Usar std::sort para ordenar los elementos en orden ascendente
    std::sort(vec.begin(), vec.end());

    // Mostrar los elementos ordenados
    std::cout << "Elementos ordenados: ";
    for (int elem : vec) {
        std::cout << elem << " ";
    }
    std::cout << std::endl;

    return 0;
}
<---Ejemplo Básico (Orden Ascendente) Result--->
<---Ejemplo con Comparación Personalizada (Orden Descendente)--->
```cpp
#include <iostream>
#include <vector>
#include <algorithm>

int main() {
    std::vector<int> vec = {5, 2, 9, 1, 5, 6};

    // Usar std::sort con una función de comparación para ordenar en orden descendente
    std::sort(vec.begin(), vec.end(), std::greater<int>());

    // Mostrar los elementos ordenados
    std::cout << "Elementos ordenados en orden descendente: ";
    for (int elem : vec) {
        std::cout << elem << " ";
    }
    std::cout << std::endl;

    return 0;
}
<---Ejemplo con Comparación Personalizada (Orden Descendente) Result--->
<---Ordenar un `std::array`--->
```cpp
#include <iostream>
#include <array>
#include <algorithm>

int main() {
    std::array<int, 6> arr = {5, 2, 9, 1, 5, 6};

    // Usar std::sort para ordenar los elementos del array
    std::sort(arr.begin(), arr.end());

    // Mostrar los elementos ordenados
    std::cout << "Elementos del array ordenados: ";
    for (int elem : arr) {
        std::cout << elem << " ";
    }
    std::cout << std::endl;

    return 0;
}
<---Ordenar un `std::array` Result--->
<---Ejemplo Básico (Función Unaria)--->
```cpp
#include <iostream>
#include <vector>
#include <algorithm>

int main() {
    std::vector<int> origen = {1, 2, 3, 4, 5};
    std::vector<int> destino(origen.size());

    // Usar std::transform para duplicar cada elemento
    std::transform(origen.begin(), origen.end(), destino.begin(), [](int x) {
        return x * 2;
    });

    // Mostrar los elementos transformados
    std::cout << "Elementos transformados (duplicados): ";
    for (int elem : destino) {
        std::cout << elem << " ";
    }
    std::cout << std::endl;

    return 0;
}
<---Ejemplo Básico (Función Unaria) Result--->
<---Ejemplo con Función Binaria--->
```cpp
#include <iostream>
#include <vector>
#include <algorithm>

int main() {
    std::vector<int> vec1 = {1, 2, 3, 4, 5};
    std::vector<int> vec2 = {10, 20, 30, 40, 50};
    std::vector<int> resultado(vec1.size());

    // Usar std::transform para sumar elementos de dos vectores
    std::transform(vec1.begin(), vec1.end(), vec2.begin(), resultado.begin(), [](int x, int y) {
        return x + y;
    });

    // Mostrar los elementos transformados
    std::cout << "Elementos transformados (suma de vec1 y vec2): ";
    for (int elem : resultado) {
        std::cout << elem << " ";
    }
    std::cout << std::endl;

    return 0;
}
<---Ejemplo con Función Binaria Result--->
<---Transformar una Lista--->
```cpp
#include <iostream>
#include <list>
#include <algorithm>

int main() {
    std::list<int> origen = {1, 2, 3, 4, 5};
    std::list<int> destino(origen.size());

    // Usar std::transform para incrementar cada elemento
    std::transform(origen.begin(), origen.end(), destino.begin(), [](int x) {
        return x + 1;
    });

    // Mostrar los elementos transformados
    std::cout << "Elementos transformados (incrementados): ";
    for (int elem : destino) {
        std::cout << elem << " ";
    }
    std::cout << std::endl;

    return 0;
}
<---Transformar una Lista Result--->
<---Ejemplo con `std::array`--->
```cpp
#include <iostream>
#include <array>
#include <algorithm>

int main() {
    std::array<int, 5> arr;

    // Usar std::fill para asignar el valor 10 a todos los elementos del array
    std::fill(arr.begin(), arr.end(), 10);

    // Mostrar los elementos del array
    std::cout << "Elementos del array después de std::fill: ";
    for (int elem : arr) {
        std::cout << elem << " ";
    }
    std::cout << std::endl;

    return 0;
}
<---Ejemplo con `std::array` Result--->
<---Ejemplo con una Matriz--->
```cpp
#include <iostream>
#include <vector>
#include <algorithm>

int main() {
    std::vector<std::vector<int>> matrix(3, std::vector<int>(4));

    // Usar std::fill para asignar el valor 0 a todos los elementos de la matriz
    for (auto& row : matrix) {
        std::fill(row.begin(), row.end(), 0);
    }

    // Mostrar los elementos de la matriz
    std::cout << "Elementos de la matriz después de std::fill: " << std::endl;
    for (const auto& row : matrix) {
        for (int elem : row) {
            std::cout << elem << " ";
        }
        std::cout << std::endl;
    }

    return 0;
}
<---Ejemplo con una Matriz Result--->
<---Ejemplo de Rango Parcial--->
```cpp
#include <iostream>
#include <vector>
#include <algorithm>

int main() {
    std::vector<int> vec(10);

    // Asignar el valor 1 a la primera mitad del vector
    std::fill(vec.begin(), vec.begin() + vec.size() / 2, 1);

    // Asignar el valor 2 a la segunda mitad del vector
    std::fill(vec.begin() + vec.size() / 2, vec.end(), 2);

    // Mostrar los elementos del vector
    std::cout << "Elementos del vector después de std::fill en rangos parciales: ";
    for (int elem : vec) {
        std::cout << elem << " ";
    }
    std::cout << std::endl;

    return 0;
}
<---Ejemplo de Rango Parcial Result--->
<---Ejemplo con `std::list`--->
```cpp
#include <iostream>
#include <list>
#include <algorithm>

bool esPositivo(int n) {
    return n > 0;
}

int main() {
    std::list<int> lst = {-1, 2, -3, 4, -5, 6};

    // Usar std::partition para particionar los elementos
    auto it = std::partition(lst.begin(), lst.end(), esPositivo);

    // Mostrar los elementos particionados
    std::cout << "Elementos de la lista después de std::partition: ";
    for (int elem : lst) {
        std::cout << elem << " ";
    }
    std::cout << std::endl;

    // Mostrar el punto de partición
    std::cout << "Punto de partición: " << *it << std::endl;

    return 0;
}
```cpp
#include <algorithm>

template <class ForwardIt, class UnaryPredicate>
ForwardIt stable_partition(ForwardIt first, ForwardIt last, UnaryPredicate p);
<---Ejemplo con `std::list` Result--->
<---Ejemplo Básico con `std::replace_if`--->
```cpp
#include <iostream>
#include <vector>
#include <algorithm>

bool esPar(int n) {
    return n % 2 == 0;
}

int main() {
    std::vector<int> vec = {1, 2, 3, 4, 5, 6};

    // Usar std::replace_if para reemplazar todos los números pares por 0
    std::replace_if(vec.begin(), vec.end(), esPar, 0);

    // Mostrar los elementos modificados
    std::cout << "Elementos del vector después de std::replace_if: ";
    for (int elem : vec) {
        std::cout << elem << " ";
    }
    std::cout << std::endl;

    return 0;
}
<---Ejemplo Básico con `std::replace_if` Result--->
<---Ejemplo Básico con `std::remove_if`--->
```cpp
#include <iostream>
#include <vector>
#include <algorithm>

bool esPar(int n) {
    return n % 2 == 0;
}

int main() {
    std::vector<int> vec = {1, 2, 3, 4, 5, 6};

    // Usar std::remove_if para mover los números pares al final
    auto it = std::remove_if(vec.begin(), vec.end(), esPar);

    // Eliminar físicamente los elementos después del nuevo final lógico
    vec.erase(it, vec.end());

    // Mostrar los elementos restantes
    std::cout << "Elementos del vector después de std::remove_if y erase: ";
    for (int elem : vec) {
        std::cout << elem << " ";
    }
    std::cout << std::endl;

    return 0;
}
<---Ejemplo Básico con `std::remove_if` Result--->
<---Ejemplo de Subsección--->
```cpp
#include <iostream>
#include <vector>
#include <algorithm>

int main() {
    std::vector<int> vec = {1, 2, 3, 4, 5, 6, 7, 8};

    // Usar std::reverse para invertir el orden de los elementos en una subsección del vector
    std::reverse(vec.begin() + 2, vec.begin() + 6);

    // Mostrar los elementos del vector después de invertir la subsección
    std::cout << "Elementos del vector después de invertir una subsección: ";
    for (int elem : vec) {
        std::cout << elem << " ";
    }
    std::cout << std::endl;

    return 0;
}
<---Ejemplo de Subsección Result--->
<---Ejemplo con `std::string`--->
```cpp
#include <iostream>
#include <string>
#include <algorithm>

int main() {
    std::string str = "Hello, World!";

    // Usar std::reverse para invertir el orden de los caracteres en la cadena
    std::reverse(str.begin(), str.end());

    // Mostrar la cadena invertida
    std::cout << "Cadena después de std::reverse: " << str << std::endl;

    return 0;
}
<---Ejemplo con `std::string` Result--->
<---Ejemplo Básico con `std::stable_partition`--->
```cpp
#include <iostream>
#include <vector>
#include <algorithm>

bool esPar(int n) {
    return n % 2 == 0;
}

int main() {
    std::vector<int> vec = {1, 2, 3, 4, 5, 6};

    // Usar std::stable_partition para particionar los elementos
    auto it = std::stable_partition(vec.begin(), vec.end(), esPar);

    // Mostrar los elementos particionados
    std::cout << "Elementos después de std::stable_partition: ";
    for (int elem : vec) {
        std::cout << elem << " ";
    }
    std::cout << std::endl;

    // Mostrar el punto de partición
    std::cout << "Punto de partición: " << *it << std::endl;

    return 0;
}
<---Ejemplo Básico con `std::stable_partition` Result--->
<---Descripción--->
```cpp
#include <iostream>
#include <vector>
#include <algorithm>

int main() {
    std::vector<int> vec = {1, 2, 3, 4, 5, 6, 7, 8, 9};

    // Usar std::upper_bound para encontrar el primer elemento mayor que 5
    auto it = std::upper_bound(vec.begin(), vec.end(), 5);

    // Mostrar el resultado
    if (it != vec.end()) {
        std::cout << "El primer elemento mayor que 5 es: " << *it << std::endl;
    } else {
        std::cout << "No se encontró un elemento mayor que 5" << std::endl;
    }

    return 0;
}
<---Descripción Result--->
<---Ejemplo Básico--->
```cpp
#include <iostream>
#include <vector>
#include <algorithm>

int main() {
    std::vector<int> vec1 = {1, 2, 3, 4, 5};
    std::vector<int> vec2 = {3, 4, 5, 6, 7};
    std::vector<int> result;

    // Reservar espacio suficiente para el resultado
    result.reserve(std::min(vec1.size(), vec2.size()));

    // Usar std::set_intersection para encontrar la intersección de los dos vectores
    auto it = std::set_intersection(vec1.begin(), vec1.end(), vec2.begin(), vec2.end(), std::back_inserter(result));

    // Mostrar los elementos de la intersección
    std::cout << "Elementos de la intersección: ";
    for (int elem : result) {
        std::cout << elem << " ";
    }
    std::cout << std::endl;

    return 0;
}
<---Ejemplo Básico Result--->
<---Ejemplo con Lambda--->
```cpp
#include <iostream>
#include <vector>
#include <algorithm>

int main() {
    std::vector<int> vec = {1, 2, 3, 4, 5, 6};

    // Usar std::remove_if con una lambda para mover los números mayores que 3 al final
    auto it = std::remove_if(vec.begin(), vec.end(), [](int n) { return n > 3; });

    // Eliminar físicamente los elementos después del nuevo final lógico
    vec.erase(it, vec.end());

    // Mostrar los elementos restantes
    std::cout << "Elementos del vector después de std::remove_if y erase: ";
    for (int elem : vec) {
        std::cout << elem << " ";
    }
    std::cout << std::endl;

    return 0;
}
<---Ejemplo con Lambda Result--->
<---Ejemplo Básico (Suma)--->
```cpp
#include <iostream>
#include <vector>
#include <numeric>

int main() {
    std::vector<int> vec = {1, 2, 3, 4, 5};

    // Usar std::accumulate para sumar todos los elementos
    int suma = std::accumulate(vec.begin(), vec.end(), 0);

    std::cout << "La suma de los elementos es: " << suma << std::endl;

    return 0;
}
<---Ejemplo Básico (Suma) Result--->
<---Ejemplo con Operación Binaria Personalizada (Multiplicación)--->
```cpp
#include <iostream>
#include <vector>
#include <numeric>

int main() {
    std::vector<int> vec = {1, 2, 3, 4, 5};

    // Usar std::accumulate para multiplicar todos los elementos
    int producto = std::accumulate(vec.begin(), vec.end(), 1, std::multiplies<int>());

    std::cout << "El producto de los elementos es: " << producto << std::endl;

    return 0;
}
```cpp
#include <iostream>
#include <vector>
#include <numeric>
#include <string>

int main() {
    std::vector<std::string> vec = {"Hola", " ", "mundo", "!"};

    // Usar std::accumulate para concatenar todas las cadenas
    std::string resultado = std::accumulate(vec.begin(), vec.end(), std::string(""));

    std::cout << "Cadena concatenada: " << resultado << std::endl;

    return 0;
}
```cpp
#include <iostream>
#include <vector>
#include <numeric>

int main() {
    std::vector<int> vec = {1, 2, 3, 4, 5};

    // Calcular la suma de los elementos
    int suma = std::accumulate(vec.begin(), vec.end(), 0);

    // Calcular la media
    double media = static_cast<double>(suma) / vec.size();

    std::cout << "La media de los elementos es: " << media << std::endl;

    return 0;
}
<---Ejemplo con Operación Binaria Personalizada (Multiplicación) Result--->
<---`std::max`--->
```cpp
#include <algorithm>

template <class T>
const T& max(const T& a, const T& b);

template <class T, class Compare>
const T& max(const T& a, const T& b, Compare comp);

template <class ForwardIt>
ForwardIt max_element(ForwardIt first, ForwardIt last);

template <class ForwardIt, class Compare>
ForwardIt max_element(ForwardIt first, ForwardIt last, Compare comp);
<---`std::max` Result--->
<---`std::min`--->
```cpp
#include <algorithm>

template <class T>
const T& min(const T& a, const T& b);

template <class T, class Compare>
const T& min(const T& a, const T& b, Compare comp);

template <class ForwardIt>
ForwardIt min_element(ForwardIt first, ForwardIt last);

template <class ForwardIt, class Compare>
ForwardIt min_element(ForwardIt first, ForwardIt last, Compare comp);
<---`std::min` Result--->
<---Ejemplo Básico con Dos Valores--->
```cpp
#include <iostream>
#include <algorithm>

int main() {
    int a = 10, b = 20;

    // Encontrar el valor máximo
    int maxVal = std::max(a, b);
    std::cout << "El mayor de " << a << " y " << b << " es " << maxVal << std::endl;

    // Encontrar el valor mínimo
    int minVal = std::min(a, b);
    std::cout << "El menor de " << a << " y " << b << " es " << minVal << std::endl;

    return 0;
}
<---Ejemplo Básico con Dos Valores Result--->
<---Ejemplo con Comparación Personalizada--->
```cpp
#include <iostream>
#include <vector>
#include <algorithm>

struct Persona {
    std::string nombre;
    int edad;
};

bool compararPorEdad(const Persona& a, const Persona& b) {
    return a.edad < b.edad;
}

bool igualEdad(const Persona& a, const Persona& b) {
    return a.edad == b.edad;
}

int main() {
    std::vector<Persona> grupo1 = {{"Ana", 25}, {"Carlos", 30}, {"Jose", 28}};
    std::vector<Persona> grupo2 = {{"Luis", 22}, {"Maria", 28}, {"Pedro", 30}};
    std::vector<Persona> resultado;

    // Ordenar los vectores por edad
    std::sort(grupo1.begin(), grupo1.end(), compararPorEdad);
    std::sort(grupo2.begin(), grupo2.end(), compararPorEdad);

    // Usar std::set_intersection con comparación personalizada para encontrar la intersección
    std::set_intersection(grupo1.begin(), grupo1.end(), grupo2.begin(), grupo2.end(), std::back_inserter(resultado), compararPorEdad);

    // Mostrar las personas en la intersección
    std::cout << "Personas en la intersección: ";
    for (const auto& persona : resultado) {
        std::cout << persona.nombre << " (" << persona.edad << "), ";
    }
    std::cout << std::endl;

    return 0;
}
<---Ejemplo con Comparación Personalizada Result--->
<---Ejemplo Básico con un Rango de Elementos--->
```cpp
#include <iostream>
#include <vector>
#include <algorithm>

int main() {
    std::vector<int> vec = {1, 2, 3, 4, 5};

    // Encontrar el elemento máximo
    auto maxIt = std::max_element(vec.begin(), vec.end());
    std::cout << "El elemento máximo es: " << *maxIt << std::endl;

    // Encontrar el elemento mínimo
    auto minIt = std::min_element(vec.begin(), vec.end());
    std::cout << "El elemento mínimo es: " << *minIt << std::endl;

    return 0;
}
<---Ejemplo Básico con un Rango de Elementos Result--->
<---Sintaxis--->
```cpp
template <class InputIt1, class InputIt2, class OutputIt>
OutputIt set_symmetric_difference(InputIt1 first1, InputIt1 last1, InputIt2 first2, InputIt2 last2, OutputIt d_first);

template <class InputIt1, class InputIt2, class OutputIt, class Compare>
OutputIt set_symmetric_difference(InputIt1 first1, InputIt1 last1, InputIt2 first2, InputIt2 last2, OutputIt d_first, Compare comp);
<---Sintaxis Result--->
<---Ejemplo de Uso de `std::find`--->
```cpp
#include <iostream>
#include <vector>
#include <algorithm>

int main() {
    std::vector<int> vec = {1, 2, 3, 4, 5};

    // Buscar el valor 3
    auto it = std::find(vec.begin(), vec.end(), 3);

    if (it != vec.end()) {
        std::cout << "Elemento encontrado: " << *it << std::endl;
    } else {
        std::cout << "Elemento no encontrado" << std::endl;
    }

    return 0;
}
<---Ejemplo de Uso de `std::find` Result--->
<---Ejemplo de Uso de `std::find_if`--->
```cpp
#include <iostream>
#include <vector>
#include <algorithm>

bool esImpar(int n) {
    return n % 2 != 0;
}

int main() {
    std::vector<int> vec = {2, 4, 6, 7, 8};

    // Buscar el primer elemento impar
    auto it = std::find_if(vec.begin(), vec.end(), esImpar);

    if (it != vec.end()) {
        std::cout << "Primer elemento impar encontrado: " << *it << std::endl;
    } else {
        std::cout << "Elemento impar no encontrado" << std::endl;
    }

    return 0;
}
<---Ejemplo de Uso de `std::find_if` Result--->
<---Ejemplo de Uso de `std::find_if` con Lambda--->
```cpp
#include <iostream>
#include <vector>
#include <algorithm>

int main() {
    std::vector<int> vec = {2, 4, 6, 7, 8};

    // Usar una lambda para buscar el primer elemento impar
    auto it = std::find_if(vec.begin(), vec.end(), [](int n) {
        return n % 2 != 0;
    });

    if (it != vec.end()) {
        std::cout << "Primer elemento impar encontrado: " << *it << std::endl;
    } else {
        std::cout << "Elemento impar no encontrado" << std::endl;
    }

    return 0;
}
```cpp
#include <iostream>
#include <vector>
#include <algorithm>

struct Punto {
    int x, y;

    bool operator==(const Punto& otro) const {
        return x == otro.x && y == otro.y;
    }
};

int main() {
    std::vector<Punto> puntos = {{1, 2}, {3, 4}, {5, 6}, {7, 8}};
    Punto puntoABuscar = {5, 6};

    // Buscar el punto {5, 6}
    auto it = std::find(puntos.begin(), puntos.end(), puntoABuscar);

    if (it != puntos.end()) {
        std::cout << "Punto encontrado: (" << it->x << ", " << it->y << ")" << std::endl;
    } else {
        std::cout << "Punto no encontrado" << std::endl;
    }

    return 0;
}
```cpp
#include <iostream>
#include <vector>
#include <algorithm>

int main() {
    std::vector<int> vec = {2, 4, 6, 7, 8};

    // Usar una lambda para buscar el primer elemento mayor que 5
    auto it = std::find_if(vec.begin(), vec.end(), [](int n) {
        return n > 5;
    });

    if (it != vec.end()) {
        std::cout << "Primer elemento mayor que 5 encontrado: " << *it << std::endl;
    } else {
        std::cout << "Elemento mayor que 5 no encontrado" << std::endl;
    }

    return 0;
}
<---Ejemplo de Uso de `std::find_if` con Lambda Result--->
<---Copiar Elementos entre Diferentes Contenedores--->
```cpp
#include <iostream>
#include <vector>
#include <list>
#include <algorithm>

int main() {
    std::vector<int> origen = {1, 2, 3, 4, 5};
    std::list<int> destino(origen.size());

    // Usar std::copy para copiar los elementos
    std::copy(origen.begin(), origen.end(), destino.begin());

    // Mostrar los elementos copiados
    std::cout << "Elementos copiados a la lista destino: ";
    for (int elem : destino) {
        std::cout << elem << " ";
    }
    std::cout << std::endl;

    return 0;
}
```cpp
#include <iostream>
#include <vector>
#include <algorithm>

int main() {
    std::vector<int> origen = {1, 2, 3, 4, 5};
    std::vector<int> destino(3);

    // Usar std::copy para copiar los primeros 3 elementos
    std::copy(origen.begin(), origen.begin() + 3, destino.begin());

    // Mostrar los elementos copiados
    std::cout << "Primeros 3 elementos copiados al vector destino: ";
    for (int elem : destino) {
        std::cout << elem << " ";
    }
    std::cout << std::endl;

    return 0;
}
```cpp
#include <iostream>
#include <vector>
#include <algorithm>
#include <iterator>

int main() {
    std::vector<int> origen = {1, 2, 3, 4, 5};
    std::vector<int> destino;

    // Usar std::copy con std::back_inserter
    std::copy(origen.begin(), origen.end(), std::back_inserter(destino));

    // Mostrar los elementos copiados
    std::cout << "Elementos copiados al vector destino con back_inserter: ";
    for (int elem : destino) {
        std::cout << elem << " ";
    }
    std::cout << std::endl;

    return 0;
}
<---Copiar Elementos entre Diferentes Contenedores Result--->
<---Ejemplo Básico (Orden Ascendente)--->
```cpp
#include <iostream>
#include <vector>
#include <algorithm>

int main() {
    std::vector<int> vec = {5, 2, 9, 1, 5, 6};

    // Usar std::sort para ordenar los elementos en orden ascendente
    std::sort(vec.begin(), vec.end());

    // Mostrar los elementos ordenados
    std::cout << "Elementos ordenados: ";
    for (int elem : vec) {
        std::cout << elem << " ";
    }
    std::cout << std::endl;

    return 0;
}
<---Ejemplo Básico (Orden Ascendente) Result--->
<---Ejemplo con Comparación Personalizada (Orden Descendente)--->
```cpp
#include <iostream>
#include <vector>
#include <algorithm>

int main() {
    std::vector<int> vec = {5, 2, 9, 1, 5, 6};

    // Usar std::sort con una función de comparación para ordenar en orden descendente
    std::sort(vec.begin(), vec.end(), std::greater<int>());

    // Mostrar los elementos ordenados
    std::cout << "Elementos ordenados en orden descendente: ";
    for (int elem : vec) {
        std::cout << elem << " ";
    }
    std::cout << std::endl;

    return 0;
}
<---Ejemplo con Comparación Personalizada (Orden Descendente) Result--->
<---Ordenar un `std::array`--->
```cpp
#include <iostream>
#include <array>
#include <algorithm>

int main() {
    std::array<int, 6> arr = {5, 2, 9, 1, 5, 6};

    // Usar std::sort para ordenar los elementos del array
    std::sort(arr.begin(), arr.end());

    // Mostrar los elementos ordenados
    std::cout << "Elementos del array ordenados: ";
    for (int elem : arr) {
        std::cout << elem << " ";
    }
    std::cout << std::endl;

    return 0;
}
<---Ordenar un `std::array` Result--->
<---Ejemplo Básico (Función Unaria)--->
```cpp
#include <iostream>
#include <vector>
#include <algorithm>

int main() {
    std::vector<int> origen = {1, 2, 3, 4, 5};
    std::vector<int> destino(origen.size());

    // Usar std::transform para duplicar cada elemento
    std::transform(origen.begin(), origen.end(), destino.begin(), [](int x) {
        return x * 2;
    });

    // Mostrar los elementos transformados
    std::cout << "Elementos transformados (duplicados): ";
    for (int elem : destino) {
        std::cout << elem << " ";
    }
    std::cout << std::endl;

    return 0;
}
<---Ejemplo Básico (Función Unaria) Result--->
<---Ejemplo con Función Binaria--->
```cpp
#include <iostream>
#include <vector>
#include <algorithm>

int main() {
    std::vector<int> vec1 = {1, 2, 3, 4, 5};
    std::vector<int> vec2 = {10, 20, 30, 40, 50};
    std::vector<int> resultado(vec1.size());

    // Usar std::transform para sumar elementos de dos vectores
    std::transform(vec1.begin(), vec1.end(), vec2.begin(), resultado.begin(), [](int x, int y) {
        return x + y;
    });

    // Mostrar los elementos transformados
    std::cout << "Elementos transformados (suma de vec1 y vec2): ";
    for (int elem : resultado) {
        std::cout << elem << " ";
    }
    std::cout << std::endl;

    return 0;
}
<---Ejemplo con Función Binaria Result--->
<---Transformar una Lista--->
```cpp
#include <iostream>
#include <list>
#include <algorithm>

int main() {
    std::list<int> origen = {1, 2, 3, 4, 5};
    std::list<int> destino(origen.size());

    // Usar std::transform para incrementar cada elemento
    std::transform(origen.begin(), origen.end(), destino.begin(), [](int x) {
        return x + 1;
    });

    // Mostrar los elementos transformados
    std::cout << "Elementos transformados (incrementados): ";
    for (int elem : destino) {
        std::cout << elem << " ";
    }
    std::cout << std::endl;

    return 0;
}
<---Transformar una Lista Result--->
<---Ejemplo con `std::array`--->
```cpp
#include <iostream>
#include <array>
#include <algorithm>

int main() {
    std::array<int, 5> arr;

    // Usar std::fill para asignar el valor 10 a todos los elementos del array
    std::fill(arr.begin(), arr.end(), 10);

    // Mostrar los elementos del array
    std::cout << "Elementos del array después de std::fill: ";
    for (int elem : arr) {
        std::cout << elem << " ";
    }
    std::cout << std::endl;

    return 0;
}
<---Ejemplo con `std::array` Result--->
<---Ejemplo con una Matriz--->
```cpp
#include <iostream>
#include <vector>
#include <algorithm>

int main() {
    std::vector<std::vector<int>> matrix(3, std::vector<int>(4));

    // Usar std::fill para asignar el valor 0 a todos los elementos de la matriz
    for (auto& row : matrix) {
        std::fill(row.begin(), row.end(), 0);
    }

    // Mostrar los elementos de la matriz
    std::cout << "Elementos de la matriz después de std::fill: " << std::endl;
    for (const auto& row : matrix) {
        for (int elem : row) {
            std::cout << elem << " ";
        }
        std::cout << std::endl;
    }

    return 0;
}
<---Ejemplo con una Matriz Result--->
<---Ejemplo de Rango Parcial--->
```cpp
#include <iostream>
#include <vector>
#include <algorithm>

int main() {
    std::vector<int> vec(10);

    // Asignar el valor 1 a la primera mitad del vector
    std::fill(vec.begin(), vec.begin() + vec.size() / 2, 1);

    // Asignar el valor 2 a la segunda mitad del vector
    std::fill(vec.begin() + vec.size() / 2, vec.end(), 2);

    // Mostrar los elementos del vector
    std::cout << "Elementos del vector después de std::fill en rangos parciales: ";
    for (int elem : vec) {
        std::cout << elem << " ";
    }
    std::cout << std::endl;

    return 0;
}
<---Ejemplo de Rango Parcial Result--->
<---Ejemplo con `std::list`--->
```cpp
#include <iostream>
#include <list>
#include <algorithm>

bool esPositivo(int n) {
    return n > 0;
}

int main() {
    std::list<int> lst = {-1, 2, -3, 4, -5, 6};

    // Usar std::partition para particionar los elementos
    auto it = std::partition(lst.begin(), lst.end(), esPositivo);

    // Mostrar los elementos particionados
    std::cout << "Elementos de la lista después de std::partition: ";
    for (int elem : lst) {
        std::cout << elem << " ";
    }
    std::cout << std::endl;

    // Mostrar el punto de partición
    std::cout << "Punto de partición: " << *it << std::endl;

    return 0;
}
```cpp
#include <algorithm>

template <class ForwardIt, class UnaryPredicate>
ForwardIt stable_partition(ForwardIt first, ForwardIt last, UnaryPredicate p);
<---Ejemplo con `std::list` Result--->
<---Ejemplo Básico con `std::replace_if`--->
```cpp
#include <iostream>
#include <vector>
#include <algorithm>

bool esPar(int n) {
    return n % 2 == 0;
}

int main() {
    std::vector<int> vec = {1, 2, 3, 4, 5, 6};

    // Usar std::replace_if para reemplazar todos los números pares por 0
    std::replace_if(vec.begin(), vec.end(), esPar, 0);

    // Mostrar los elementos modificados
    std::cout << "Elementos del vector después de std::replace_if: ";
    for (int elem : vec) {
        std::cout << elem << " ";
    }
    std::cout << std::endl;

    return 0;
}
<---Ejemplo Básico con `std::replace_if` Result--->
<---Ejemplo Básico con `std::remove_if`--->
```cpp
#include <iostream>
#include <vector>
#include <algorithm>

bool esPar(int n) {
    return n % 2 == 0;
}

int main() {
    std::vector<int> vec = {1, 2, 3, 4, 5, 6};

    // Usar std::remove_if para mover los números pares al final
    auto it = std::remove_if(vec.begin(), vec.end(), esPar);

    // Eliminar físicamente los elementos después del nuevo final lógico
    vec.erase(it, vec.end());

    // Mostrar los elementos restantes
    std::cout << "Elementos del vector después de std::remove_if y erase: ";
    for (int elem : vec) {
        std::cout << elem << " ";
    }
    std::cout << std::endl;

    return 0;
}
<---Ejemplo Básico con `std::remove_if` Result--->
<---Ejemplo de Subsección--->
```cpp
#include <iostream>
#include <vector>
#include <algorithm>

int main() {
    std::vector<int> vec = {1, 2, 3, 4, 5, 6, 7, 8};

    // Usar std::reverse para invertir el orden de los elementos en una subsección del vector
    std::reverse(vec.begin() + 2, vec.begin() + 6);

    // Mostrar los elementos del vector después de invertir la subsección
    std::cout << "Elementos del vector después de invertir una subsección: ";
    for (int elem : vec) {
        std::cout << elem << " ";
    }
    std::cout << std::endl;

    return 0;
}
<---Ejemplo de Subsección Result--->
<---Ejemplo con `std::string`--->
```cpp
#include <iostream>
#include <string>
#include <algorithm>

int main() {
    std::string str = "Hello, World!";

    // Usar std::reverse para invertir el orden de los caracteres en la cadena
    std::reverse(str.begin(), str.end());

    // Mostrar la cadena invertida
    std::cout << "Cadena después de std::reverse: " << str << std::endl;

    return 0;
}
<---Ejemplo con `std::string` Result--->
<---Ejemplo Básico con `std::stable_partition`--->
```cpp
#include <iostream>
#include <vector>
#include <algorithm>

bool esPar(int n) {
    return n % 2 == 0;
}

int main() {
    std::vector<int> vec = {1, 2, 3, 4, 5, 6};

    // Usar std::stable_partition para particionar los elementos
    auto it = std::stable_partition(vec.begin(), vec.end(), esPar);

    // Mostrar los elementos particionados
    std::cout << "Elementos después de std::stable_partition: ";
    for (int elem : vec) {
        std::cout << elem << " ";
    }
    std::cout << std::endl;

    // Mostrar el punto de partición
    std::cout << "Punto de partición: " << *it << std::endl;

    return 0;
}
<---Ejemplo Básico con `std::stable_partition` Result--->
<---Descripción--->
```cpp
#include <iostream>
#include <vector>
#include <algorithm>

int main() {
    std::vector<int> vec = {1, 2, 3, 4, 5, 6, 7, 8, 9};

    // Usar std::upper_bound para encontrar el primer elemento mayor que 5
    auto it = std::upper_bound(vec.begin(), vec.end(), 5);

    // Mostrar el resultado
    if (it != vec.end()) {
        std::cout << "El primer elemento mayor que 5 es: " << *it << std::endl;
    } else {
        std::cout << "No se encontró un elemento mayor que 5" << std::endl;
    }

    return 0;
}
<---Descripción Result--->
