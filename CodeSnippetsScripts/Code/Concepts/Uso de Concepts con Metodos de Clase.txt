<---EXPLANATION--->
### Introducción a Concepts en C++

Los Concepts en C++ son una característica introducida en C++20 que permite especificar restricciones sobre los tipos que se pueden utilizar con plantillas. Los Concepts mejoran la claridad y la mantenibilidad del código al proporcionar una manera clara y concisa de expresar requisitos de plantilla, lo que facilita la detección de errores en tiempo de compilación.

#### ¿Qué son los Concepts?

Un Concept es una forma de definir un conjunto de requisitos que un tipo debe cumplir para ser utilizado en una plantilla. Estos requisitos pueden incluir la existencia de ciertas operaciones, tipos miembros, o propiedades específicas.

##### Ejemplo Básico de Concept

```cpp
#include <concepts>
#include <iostream>

// Definir un Concept que requiere que T sea un tipo integral
template<typename T>
concept Integral = std::is_integral_v<T>;

// Función plantilla que utiliza el Concept Integral
template<Integral T>
T sumar(T a, T b) {
    return a + b;
}

int main() {
    int a = 5, b = 3;
    std::cout << sumar(a, b) << std::endl; // Funciona: int es un tipo integral

    // double x = 5.0, y = 3.0;
    // std::cout << sumar(x, y) << std::endl; // Error de compilación: double no es un tipo integral
}
```

En este ejemplo:
- El Concept `Integral` se define para verificar si un tipo es integral utilizando `std::is_integral_v`.
- La función plantilla `sumar` utiliza el Concept `Integral`, asegurando que solo acepte tipos integrales.

### Cómo Definir Concepts

Los Concepts se definen utilizando la palabra clave `concept` seguida del nombre del Concept y una expresión que representa la condición del Concept.

#### Ejemplo de Concept Personalizado

```cpp
#include <concepts>
#include <type_traits>
#include <iostream>

// Definir un Concept que requiere que T tenga un método `size()`
template<typename T>
concept HasSizeMethod = requires(T a) {
    { a.size() } -> std::convertible_to<std::size_t>;
};

// Clase con método `size()`
class ConSize {
public:
    std::size_t size() const {
        return 42;
    }
};

// Clase sin método `size()`
class SinSize {
public:
    int length() const {
        return 84;
    }
};

// Función plantilla que utiliza el Concept HasSizeMethod
template<HasSizeMethod T>
std::size_t obtenerSize(const T& obj) {
    return obj.size();
}

int main() {
    ConSize cs;
    std::cout << obtenerSize(cs) << std::endl; // Funciona: ConSize tiene método `size()`

    // SinSize ss;
    // std::cout << obtenerSize(ss) << std::endl; // Error de compilación: SinSize no tiene método `size()`
}
```

En este ejemplo:
- El Concept `HasSizeMethod` se define para verificar si un tipo tiene un método `size()` que retorna un tipo convertible a `std::size_t`.
- La función plantilla `obtenerSize` utiliza el Concept `HasSizeMethod`, asegurando que solo acepte tipos que tengan un método `size()`.

### Uso de Concepts para Mejorar la Legibilidad

Los Concepts no solo restringen los tipos aceptados por las plantillas, sino que también mejoran la legibilidad del código al proporcionar un contexto claro sobre lo que se espera de los parámetros de plantilla.

#### Ejemplo de Uso de Concepts en Funciones Plantilla

```cpp
#include <concepts>
#include <iostream>

// Concept que requiere que T sea un número flotante
template<typename T>
concept FloatingPoint = std::is_floating_point_v<T>;

// Función plantilla que utiliza el Concept FloatingPoint
template<FloatingPoint T>
T multiplicar(T a, T b) {
    return a * b;
}

int main() {
    float a = 2.5f, b = 4.0f;
    std::cout << multiplicar(a, b) << std::endl; // Funciona: float es un tipo flotante

    // int x = 2, y = 3;
    // std::cout << multiplicar(x, y) << std::endl; // Error de compilación: int no es un tipo flotante
}
```

### Buenas Prácticas con Concepts

#### 1. Definir Concepts Significativos

Defina Concepts que sean significativos y útiles en el contexto de su código. Los Concepts deben expresar claramente las expectativas sobre los tipos que se usarán.

#### 2. Evitar Concepts Demasiado Amplios

Evite definir Concepts que sean demasiado amplios o vagos. Un Concept demasiado amplio puede no proporcionar una verificación útil y puede permitir tipos no deseados.

#### 3. Utilizar Concepts para Mejorar los Mensajes de Error

Los Concepts pueden mejorar los mensajes de error al compilar, proporcionando información clara sobre por qué un tipo no cumple con los requisitos de la plantilla.

#### 4. Documentar los Concepts

Documente adecuadamente los Concepts y los requisitos que imponen. Esto facilita la comprensión y el uso correcto de los Concepts en su código.

### Conclusión

Los Concepts en C++ son una herramienta poderosa para definir y verificar restricciones de tipos en plantillas. Utilizando Concepts, puede escribir código más claro, mantenible y libre de errores. Al definir y aplicar Concepts de manera adecuada, se mejorará la robustez y la legibilidad de su código C++.
### Uso de Concepts con Funciones y Clases en C++

Los Concepts en C++ pueden aplicarse tanto a funciones como a clases, permitiendo definir restricciones claras y específicas para los tipos utilizados en plantillas. A continuación, veremos cómo usar Concepts con funciones y clases, y cómo esta práctica mejora la claridad y robustez del código.

#### Uso de Concepts con Funciones

Los Concepts se utilizan frecuentemente con funciones para restringir los tipos que pueden ser pasados como argumentos de plantilla. Esto se logra mediante la palabra clave `template` y la sintaxis `Concept Nombre`.

##### Ejemplo de Concept con Función

```cpp
#include <concepts>
#include <iostream>

// Concept que requiere que T sea un tipo integral
template<typename T>
concept Integral = std::is_integral_v<T>;

// Función plantilla que utiliza el Concept Integral
template<Integral T>
T sumar(T a, T b) {
    return a + b;
}

int main() {
    int a = 5, b = 3;
    std::cout << sumar(a, b) << std::endl; // Funciona: int es un tipo integral

    // double x = 5.0, y = 3.0;
    // std::cout << sumar(x, y) << std::endl; // Error de compilación: double no es un tipo integral
}
```

En este ejemplo:
- El Concept `Integral` se define para verificar si un tipo es integral.
- La función plantilla `sumar` utiliza el Concept `Integral`, asegurando que solo acepte tipos integrales.

#### Uso de Concepts con Clases

Además de funciones, los Concepts pueden aplicarse a clases para restringir los tipos que se pueden utilizar con plantillas de clase.

##### Ejemplo de Concept con Clase

```cpp
#include <concepts>
#include <iostream>

// Concept que requiere que T sea un tipo flotante
template<typename T>
concept FloatingPoint = std::is_floating_point_v<T>;

// Clase plantilla que utiliza el Concept FloatingPoint
template<FloatingPoint T>
class Calculadora {
public:
    T sumar(T a, T b) {
        return a + b;
    }

    T multiplicar(T a, T b) {
        return a * b;
    }
};

int main() {
    Calculadora<float> calc;
    std::cout << calc.sumar(2.5f, 3.0f) << std::endl; // Funciona: float es un tipo flotante
    std::cout << calc.multiplicar(2.5f, 3.0f) << std::endl; // Funciona: float es un tipo flotante

    // Calculadora<int> calcInt;
    // std::cout << calcInt.sumar(2, 3) << std::endl; // Error de compilación: int no es un tipo flotante
}
```

En este ejemplo:
- El Concept `FloatingPoint` se define para verificar si un tipo es flotante.
- La clase plantilla `Calculadora` utiliza el Concept `FloatingPoint`, asegurando que solo acepte tipos flotantes.

### Buenas Prácticas al Usar Concepts con Funciones y Clases

#### 1. Definir Concepts Específicos y Claros

Defina Concepts que sean claros y específicos para el contexto de su aplicación. Esto ayuda a evitar confusiones y errores.

#### 2. Utilizar Concepts para Mejorar la Legibilidad

Aplique Concepts para mejorar la legibilidad y la mantenibilidad del código, proporcionando contexto claro sobre los tipos esperados en plantillas.

#### 3. Documentar los Concepts y sus Requisitos

Documente adecuadamente los Concepts y los requisitos que imponen para facilitar su comprensión y correcto uso.

#### 4. Aprovechar los Concepts para Mejorar la Seguridad del Código

Utilice Concepts para verificar los requisitos de los tipos en tiempo de compilación, mejorando la seguridad y la robustez del código.

### Ejemplo Avanzado: Uso Combinado de Concepts en Funciones y Clases

Para ilustrar el uso combinado de Concepts en funciones y clases, considere el siguiente ejemplo:

```cpp
#include <concepts>
#include <iostream>
#include <vector>
#include <list>

// Concept que requiere que T sea iterable
template<typename T>
concept Iterable = requires(T t) {
    t.begin();
    t.end();
};

// Clase plantilla que usa el Concept Iterable
template<Iterable T>
class Procesador {
public:
    void mostrarElementos(const T& contenedor) {
        for (const auto& elem : contenedor) {
            std::cout << elem << ' ';
        }
        std::cout << std::endl;
    }
};

// Función plantilla que usa el Concept Iterable
template<Iterable T>
void procesarContenedor(const T& contenedor) {
    for (const auto& elem : contenedor) {
        std::cout << elem << ' ';
    }
    std::cout << std::endl;
}

int main() {
    std::vector<int> vec = {1, 2, 3, 4, 5};
    std::list<std::string> lst = {"uno", "dos", "tres"};

    Procesador<std::vector<int>> procVec;
    procVec.mostrarElementos(vec); // Funciona: vector es iterable

    Procesador<std::list<std::string>> procLst;
    procLst.mostrarElementos(lst); // Funciona: list es iterable

    procesarContenedor(vec); // Funciona: vector es iterable
    procesarContenedor(lst); // Funciona: list es iterable

    // int num = 42;
    // procesarContenedor(num); // Error de compilación: int no es iterable
}
```

En este ejemplo:
- El Concept `Iterable` se define para verificar si un tipo es iterable mediante `begin()` y `end()`.
- La clase `Procesador` y la función `procesarContenedor` utilizan el Concept `Iterable`, asegurando que solo acepten tipos iterables.

### Conclusión

Los Concepts en C++ proporcionan una forma poderosa de definir y verificar restricciones de tipos en plantillas, mejorando la claridad, seguridad y mantenibilidad del código. Al utilizar Concepts con funciones y clases, puede asegurar que solo se utilicen tipos adecuados, evitar errores de compilación y proporcionar un contexto claro sobre las expectativas de su código.
### Concepts Predefinidos en C++

C++20 introdujo una serie de Concepts predefinidos en la biblioteca estándar, que cubren un amplio rango de propiedades y operaciones comunes. Estos Concepts predefinidos facilitan la creación de plantillas al proporcionar restricciones listas para usar que aseguran que los tipos cumplan con ciertos requisitos.

#### Lista de Concepts Predefinidos

Aquí hay algunos de los Concepts predefinidos más importantes:

1. `Same`
2. `DerivedFrom`
3. `ConvertibleTo`
4. `Common`
5. `Integral`
6. `SignedIntegral`
7. `UnsignedIntegral`
8. `FloatingPoint`
9. `Swappable`
10. `DefaultConstructible`
11. `MoveConstructible`
12. `CopyConstructible`

### Ejemplos de Uso de Concepts Predefinidos

#### 1. Concept `Same`

El Concept `Same` verifica si dos tipos son el mismo.

##### Ejemplo

```cpp
#include <concepts>
#include <iostream>

// Función plantilla que solo acepta argumentos del mismo tipo
template<std::same_as<int> T>
void imprimir(T valor) {
    std::cout << valor << std::endl;
}

int main() {
    imprimir(42);  // Funciona: 42 es un int

    // imprimir(42.0);  // Error de compilación: 42.0 es un double
}
```

#### 2. Concept `DerivedFrom`

El Concept `DerivedFrom` verifica si un tipo es derivado de otro.

##### Ejemplo

```cpp
#include <concepts>
#include <iostream>

class Base {};
class Derivada : public Base {};

// Función plantilla que solo acepta tipos derivados de Base
template<std::derived_from<Base> T>
void mostrarBase(const T&) {
    std::cout << "Derivado de Base" << std::endl;
}

int main() {
    Base b;
    Derivada d;

    mostrarBase(d);  // Funciona: Derivada es derivada de Base

    // mostrarBase(b);  // Error de compilación: Base no es derivada de Base
}
```

#### 3. Concept `ConvertibleTo`

El Concept `ConvertibleTo` verifica si un tipo puede ser convertido a otro.

##### Ejemplo

```cpp
#include <concepts>
#include <iostream>

// Función plantilla que solo acepta tipos convertibles a int
template<std::convertible_to<int> T>
void convertir(T valor) {
    int convertido = static_cast<int>(valor);
    std::cout << convertido << std::endl;
}

int main() {
    convertir(42);     // Funciona: int es convertible a int
    convertir(42.0);   // Funciona: double es convertible a int

    // convertir("42");  // Error de compilación: const char* no es convertible a int
}
```

#### 4. Concept `Common`

El Concept `Common` verifica si hay un tipo común entre dos tipos dados.

##### Ejemplo

```cpp
#include <concepts>
#include <iostream>

// Función plantilla que solo acepta tipos con un tipo común
template<std::common_with<int> T>
void sumarComun(T a, T b) {
    std::cout << (a + b) << std::endl;
}

int main() {
    sumarComun(3, 5);   // Funciona: int es común con int
    sumarComun(3.0, 5); // Funciona: double es común con int

    // sumarComun("3", 5);  // Error de compilación: const char* no es común con int
}
```

#### 5. Concept `Integral`

El Concept `Integral` verifica si un tipo es un tipo integral.

##### Ejemplo

```cpp
#include <concepts>
#include <iostream>

// Función plantilla que solo acepta tipos integrales
template<std::integral T>
T multiplicar(T a, T b) {
    return a * b;
}

int main() {
    int a = 5, b = 3;
    std::cout << multiplicar(a, b) << std::endl;  // Funciona: int es un tipo integral

    // double x = 5.0, y = 3.0;
    // std::cout << multiplicar(x, y) << std::endl;  // Error de compilación: double no es un tipo integral
}
```

### Otros Concepts Predefinidos

- **SignedIntegral**: Verifica si un tipo es un entero con signo.
- **UnsignedIntegral**: Verifica si un tipo es un entero sin signo.
- **FloatingPoint**: Verifica si un tipo es un punto flotante.
- **Swappable**: Verifica si dos objetos pueden intercambiarse.
- **DefaultConstructible**: Verifica si un tipo puede ser construido por defecto.
- **MoveConstructible**: Verifica si un tipo puede ser movido.
- **CopyConstructible**: Verifica si un tipo puede ser copiado.

### Conclusión

Los Concepts predefinidos en C++20 son una herramienta poderosa para imponer restricciones de tipos en plantillas. Estos Concepts proporcionan una manera clara y concisa de especificar requisitos de tipos, mejorando la seguridad y legibilidad del código. Al utilizar estos Concepts, puede asegurarse de que sus plantillas solo acepten tipos adecuados y evitar errores de compilación difíciles de diagnosticar.
### Concepts Personalizados en C++

Además de los Concepts predefinidos, C++ permite definir Concepts personalizados para imponer restricciones específicas a los tipos utilizados en plantillas. Los Concepts personalizados son especialmente útiles cuando se trabaja con tipos de datos y operaciones específicos que no están cubiertos por los Concepts predefinidos.

### Definición de Concepts Personalizados

Para definir un Concept personalizado, se utiliza la palabra clave `concept` seguida del nombre del Concept y una expresión que representa la condición que debe cumplir el tipo. Veamos algunos ejemplos de cómo definir y utilizar Concepts personalizados.

#### Ejemplo 1: Concepto `HasSizeMethod`

Este Concept verifica si un tipo tiene un método `size()` que retorna un valor convertible a `std::size_t`.

```cpp
#include <concepts>
#include <type_traits>
#include <iostream>

// Definir un Concept que requiere que T tenga un método `size()`
template<typename T>
concept HasSizeMethod = requires(T a) {
    { a.size() } -> std::convertible_to<std::size_t>;
};

// Clase con método `size()`
class ConSize {
public:
    std::size_t size() const {
        return 42;
    }
};

// Clase sin método `size()`
class SinSize {
public:
    int length() const {
        return 84;
    }
};

// Función plantilla que utiliza el Concept HasSizeMethod
template<HasSizeMethod T>
std::size_t obtenerSize(const T& obj) {
    return obj.size();
}

int main() {
    ConSize cs;
    std::cout << obtenerSize(cs) << std::endl; // Funciona: ConSize tiene método `size()`

    // SinSize ss;
    // std::cout << obtenerSize(ss) << std::endl; // Error de compilación: SinSize no tiene método `size()`
}
```

#### Ejemplo 2: Concepto `Addable`

Este Concept verifica si dos instancias de un tipo pueden sumarse utilizando el operador `+`.

```cpp
#include <concepts>
#include <iostream>

// Definir un Concept que requiere que T soporte la operación de suma
template<typename T>
concept Addable = requires(T a, T b) {
    { a + b } -> std::same_as<T>;
};

// Función plantilla que utiliza el Concept Addable
template<Addable T>
T sumar(T a, T b) {
    return a + b;
}

int main() {
    int x = 5, y = 3;
    std::cout << sumar(x, y) << std::endl; // Funciona: int soporta la suma

    double p = 5.5, q = 3.5;
    std::cout << sumar(p, q) << std::endl; // Funciona: double soporta la suma

    // std::string s1 = "Hola, ", s2 = "Mundo!";
    // std::cout << sumar(s1, s2) << std::endl; // Funciona: std::string soporta la suma (concatenación)
}
```

#### Ejemplo 3: Concepto `EqualityComparable`

Este Concept verifica si dos instancias de un tipo pueden compararse por igualdad utilizando el operador `==`.

```cpp
#include <concepts>
#include <iostream>

// Definir un Concept que requiere que T soporte la comparación de igualdad
template<typename T>
concept EqualityComparable = requires(T a, T b) {
    { a == b } -> std::convertible_to<bool>;
};

// Función plantilla que utiliza el Concept EqualityComparable
template<EqualityComparable T>
bool sonIguales(T a, T b) {
    return a == b;
}

int main() {
    int a = 5, b = 5;
    std::cout << std::boolalpha << sonIguales(a, b) << std::endl; // Funciona: int soporta la comparación de igualdad

    double x = 3.14, y = 3.14;
    std::cout << std::boolalpha << sonIguales(x, y) << std::endl; // Funciona: double soporta la comparación de igualdad

    // std::string s1 = "Hola", s2 = "Hola";
    // std::cout << std::boolalpha << sonIguales(s1, s2) << std::endl; // Funciona: std::string soporta la comparación de igualdad
}
```

### Cómo Utilizar Concepts Personalizados

Para utilizar Concepts personalizados en funciones y clases plantilla, simplemente incluya el Concept en la declaración de la plantilla utilizando la sintaxis `template<Concept Nombre>`.

#### Ejemplo: Uso de Concepts en Clases Plantilla

```cpp
#include <concepts>
#include <iostream>

// Concept personalizado que verifica si T es default constructible
template<typename T>
concept DefaultConstructible = std::is_default_constructible_v<T>;

// Clase plantilla que utiliza el Concept DefaultConstructible
template<DefaultConstructible T>
class Contenedor {
    T valor;
public:
    Contenedor() : valor{} {} // Requiere que T sea default constructible
    void mostrarValor() const {
        std::cout << valor << std::endl;
    }
};

int main() {
    Contenedor<int> c; // Funciona: int es default constructible
    c.mostrarValor();

    // Contenedor<std::ostream> c2; // Error de compilación: std::ostream no es default constructible
}
```

### Buenas Prácticas al Definir Concepts Personalizados

1. **Definir Requirements Claros**: Asegúrese de que los requisitos del Concept sean claros y específicos.
2. **Mantener la Simplicidad**: Evite hacer Concepts demasiado complejos o incluir demasiados requisitos.
3. **Documentación**: Documente cada Concept personalizado para facilitar su comprensión y uso correcto.
4. **Reutilización**: Defina Concepts reutilizables que puedan aplicarse en múltiples contextos.

### Conclusión

Los Concepts personalizados en C++ permiten definir restricciones específicas para los tipos utilizados en plantillas, mejorando la claridad y la robustez del código. Al aprovechar los Concepts personalizados, puede asegurarse de que solo se utilicen tipos adecuados en sus plantillas, evitando errores en tiempo de compilación y mejorando la mantenibilidad del código.
### Concepts en Funciones para Restringir el Tipo de Parámetro en C++

Los Concepts en C++20 son una herramienta poderosa que permite restringir los tipos de parámetros que pueden ser pasados a funciones plantilla. Esto mejora la seguridad del código al asegurar que solo los tipos que cumplen ciertos requisitos puedan ser utilizados.

### Definición de Concepts en Funciones

Para usar un Concept en una función, se especifica el Concept en la declaración de la plantilla. Aquí hay una guía paso a paso y ejemplos de cómo hacerlo.

#### Ejemplo 1: Uso de `std::integral`

Este Concept predefinido verifica si un tipo es un tipo integral (como `int`, `char`, etc.).

```cpp
#include <concepts>
#include <iostream>

// Función plantilla que solo acepta tipos integrales
template<std::integral T>
T sumar(T a, T b) {
    return a + b;
}

int main() {
    int x = 5, y = 3;
    std::cout << sumar(x, y) << std::endl;  // Funciona: int es un tipo integral

    // double a = 5.0, b = 3.0;
    // std::cout << sumar(a, b) << std::endl;  // Error de compilación: double no es un tipo integral
}
```

En este ejemplo, la función plantilla `sumar` solo acepta parámetros de tipo integral debido al Concept `std::integral`.

#### Ejemplo 2: Uso de `std::floating_point`

Este Concept predefinido verifica si un tipo es un tipo de punto flotante (como `float`, `double`, etc.).

```cpp
#include <concepts>
#include <iostream>

// Función plantilla que solo acepta tipos de punto flotante
template<std::floating_point T>
T multiplicar(T a, T b) {
    return a * b;
}

int main() {
    double x = 2.5, y = 3.5;
    std::cout << multiplicar(x, y) << std::endl;  // Funciona: double es un tipo de punto flotante

    // int a = 2, b = 3;
    // std::cout << multiplicar(a, b) << std::endl;  // Error de compilación: int no es un tipo de punto flotante
}
```

#### Ejemplo 3: Concept Personalizado `HasSizeMethod`

Este Concept verifica si un tipo tiene un método `size()` que retorna un valor convertible a `std::size_t`.

```cpp
#include <concepts>
#include <type_traits>
#include <iostream>

// Definir un Concept que requiere que T tenga un método `size()`
template<typename T>
concept HasSizeMethod = requires(T a) {
    { a.size() } -> std::convertible_to<std::size_t>;
};

// Función plantilla que solo acepta tipos que tienen un método `size()`
template<HasSizeMethod T>
std::size_t obtenerSize(const T& obj) {
    return obj.size();
}

class ConSize {
public:
    std::size_t size() const {
        return 42;
    }
};

class SinSize {
public:
    int length() const {
        return 84;
    }
};

int main() {
    ConSize cs;
    std::cout << obtenerSize(cs) << std::endl; // Funciona: ConSize tiene método `size()`

    // SinSize ss;
    // std::cout << obtenerSize(ss) << std::endl; // Error de compilación: SinSize no tiene método `size()`
}
```

#### Ejemplo 4: Concept Personalizado `Addable`

Este Concept verifica si dos instancias de un tipo pueden sumarse utilizando el operador `+`.

```cpp
#include <concepts>
#include <iostream>

// Definir un Concept que requiere que T soporte la operación de suma
template<typename T>
concept Addable = requires(T a, T b) {
    { a + b } -> std::same_as<T>;
};

// Función plantilla que solo acepta tipos que soportan la suma
template<Addable T>
T sumar(T a, T b) {
    return a + b;
}

int main() {
    int x = 5, y = 3;
    std::cout << sumar(x, y) << std::endl;  // Funciona: int soporta la suma

    double p = 5.5, q = 3.5;
    std::cout << sumar(p, q) << std::endl;  // Funciona: double soporta la suma

    // std::string s1 = "Hola, ", s2 = "Mundo!";
    // std::cout << sumar(s1, s2) << std::endl;  // Funciona: std::string soporta la suma (concatenación)
}
```

### Uso de Concepts en Parámetros de Funciones

Los Concepts también pueden ser utilizados directamente en la lista de parámetros de una función para restringir los tipos permitidos.

#### Ejemplo 5: Uso de Concepts en Parámetros

```cpp
#include <concepts>
#include <iostream>

// Definir un Concept que requiere que T sea un tipo integral
template<typename T>
concept Integral = std::is_integral_v<T>;

// Función que utiliza el Concept directamente en los parámetros
void imprimir(Integral auto valor) {
    std::cout << valor << std::endl;
}

int main() {
    imprimir(42);  // Funciona: 42 es un int (integral)
    // imprimir(42.0);  // Error de compilación: 42.0 es un double (no integral)
}
```

### Buenas Prácticas al Usar Concepts en Funciones

1. **Definir Concepts Claros y Específicos**: Asegúrese de que los Concepts sean claros y específicos para evitar confusiones.
2. **Reutilizar Concepts**: Defina Concepts reutilizables que puedan ser aplicados en múltiples funciones y contextos.
3. **Documentar**: Documente los Concepts y las funciones que los utilizan para facilitar la comprensión del código.
4. **Evitar Complejidad**: Mantenga los Concepts lo más simples posible para no complicar innecesariamente el código.

### Conclusión

Los Concepts en C++ permiten restringir los tipos de parámetros en funciones plantilla, proporcionando una forma clara y concisa de imponer restricciones de tipos. Esto no solo mejora la seguridad y la robustez del código, sino que también facilita la detección de errores en tiempo de compilación y mejora la legibilidad del código. Al definir y utilizar Concepts personalizados, puede asegurar que sus funciones solo acepten los tipos adecuados, evitando errores y mejorando la mantenibilidad del código.
### Uso de Concepts en la Sobrecarga de Funciones en C++

Los Concepts en C++20 no solo permiten restringir los tipos de parámetros en plantillas, sino que también pueden utilizarse para sobrecargar funciones de manera más precisa y clara. Esto facilita la creación de funciones sobrecargadas que solo aceptan tipos específicos, mejorando la seguridad y la legibilidad del código.

### Ejemplos de Uso de Concepts en la Sobrecarga de Funciones

#### Ejemplo 1: Sobrecarga Basada en `std::integral` y `std::floating_point`

Vamos a definir dos versiones de una función `procesar`, una que acepte tipos integrales y otra que acepte tipos de punto flotante.

```cpp
#include <concepts>
#include <iostream>

// Función plantilla que solo acepta tipos integrales
void procesar(std::integral auto valor) {
    std::cout << "Procesando un tipo integral: " << valor << std::endl;
}

// Función plantilla que solo acepta tipos de punto flotante
void procesar(std::floating_point auto valor) {
    std::cout << "Procesando un tipo de punto flotante: " << valor << std::endl;
}

int main() {
    int entero = 42;
    double flotante = 3.14;

    procesar(entero);     // Llama a la versión para tipos integrales
    procesar(flotante);   // Llama a la versión para tipos de punto flotante

    // std::string texto = "Hola";
    // procesar(texto);  // Error de compilación: std::string no cumple con std::integral ni std::floating_point
}
```

#### Ejemplo 2: Sobrecarga Basada en un Concept Personalizado

Definamos un Concept personalizado `Printable` que verifica si un tipo puede ser impreso utilizando `std::ostream`.

```cpp
#include <concepts>
#include <iostream>
#include <string>

// Concept que verifica si T puede ser impreso usando std::ostream
template<typename T>
concept Printable = requires(T a) {
    { std::cout << a };
};

// Función plantilla que solo acepta tipos que cumplen con Printable
void imprimir(Printable auto valor) {
    std::cout << "Valor imprimible: " << valor << std::endl;
}

// Función plantilla para tipos no imprimibles
void imprimir(auto valor) {
    std::cout << "Valor no imprimible" << std::endl;
}

int main() {
    int numero = 42;
    std::string texto = "Hola";

    imprimir(numero);  // Llama a la versión imprimible
    imprimir(texto);   // Llama a la versión imprimible

    struct NoPrintable {}; // Tipo no imprimible
    NoPrintable np;
    imprimir(np);  // Llama a la versión no imprimible
}
```

En este ejemplo:
- Se define un Concept `Printable` para verificar si un tipo puede ser impreso con `std::cout`.
- Se sobrecarga la función `imprimir` para manejar tipos imprimibles y no imprimibles.

### Sobrecarga de Funciones con Múltiples Concepts

Los Concepts pueden combinarse para crear sobrecargas más específicas. Por ejemplo, supongamos que queremos sobrecargar una función `procesar` para diferentes combinaciones de tipos integrales y de punto flotante.

```cpp
#include <concepts>
#include <iostream>

// Función plantilla que acepta dos tipos integrales
void procesar(std::integral auto a, std::integral auto b) {
    std::cout << "Procesando dos tipos integrales: " << a << " y " << b << std::endl;
}

// Función plantilla que acepta dos tipos de punto flotante
void procesar(std::floating_point auto a, std::floating_point auto b) {
    std::cout << "Procesando dos tipos de punto flotante: " << a << " y " << b << std::endl;
}

// Función plantilla que acepta un tipo integral y uno de punto flotante
void procesar(std::integral auto a, std::floating_point auto b) {
    std::cout << "Procesando un tipo integral y uno de punto flotante: " << a << " y " << b << std::endl;
}

// Función plantilla que acepta un tipo de punto flotante y uno integral
void procesar(std::floating_point auto a, std::integral auto b) {
    std::cout << "Procesando un tipo de punto flotante y uno integral: " << a << " y " << b << std::endl;
}

int main() {
    int entero1 = 10, entero2 = 20;
    double flotante1 = 1.5, flotante2 = 2.5;

    procesar(entero1, entero2);         // Llama a la versión para dos tipos integrales
    procesar(flotante1, flotante2);     // Llama a la versión para dos tipos de punto flotante
    procesar(entero1, flotante1);       // Llama a la versión para un tipo integral y uno de punto flotante
    procesar(flotante1, entero1);       // Llama a la versión para un tipo de punto flotante y uno integral
}
```

En este ejemplo:
- Se definen cuatro versiones de la función `procesar` para manejar diferentes combinaciones de tipos integrales y de punto flotante.
- Cada sobrecarga de `procesar` maneja una combinación específica de tipos.

### Buenas Prácticas al Usar Concepts en la Sobrecarga de Funciones

1. **Mantener la Claridad**: Asegúrese de que cada sobrecarga tenga un propósito claro y específico.
2. **Definir Concepts Reutilizables**: Defina Concepts reutilizables que puedan ser aplicados en múltiples funciones.
3. **Documentar los Concepts**: Documente los Concepts y las funciones que los utilizan para facilitar la comprensión del código.
4. **Evitar la Ambigüedad**: Asegúrese de que las sobrecargas sean mutuamente excluyentes para evitar ambigüedades en la resolución de sobrecargas.

### Conclusión

Los Concepts en C++ permiten sobrecargar funciones de manera más precisa y clara, proporcionando una forma poderosa de imponer restricciones de tipos. Esto no solo mejora la seguridad y la robustez del código, sino que también facilita la detección de errores en tiempo de compilación y mejora la legibilidad del código. Al definir y utilizar Concepts personalizados en la sobrecarga de funciones, puede asegurar que sus funciones solo acepten los tipos adecuados, evitando errores y mejorando la mantenibilidad del código.
### Concepts en Clases y Plantillas de Clases en C++

Los Concepts en C++20 permiten imponer restricciones no solo en funciones, sino también en clases y plantillas de clases. Esto permite definir clases plantilla que solo aceptan tipos que cumplen ciertos requisitos, mejorando la seguridad y claridad del código.

### Definición de Concepts en Clases y Plantillas de Clases

#### Ejemplo 1: Concept en una Clase

Supongamos que queremos definir una clase `Contenedor` que solo acepte tipos integrales. Podemos utilizar el Concept predefinido `std::integral`.

```cpp
#include <concepts>
#include <iostream>

// Clase plantilla que solo acepta tipos integrales
template<std::integral T>
class Contenedor {
    T valor;
public:
    Contenedor(T v) : valor(v) {}

    T obtenerValor() const {
        return valor;
    }

    void mostrarValor() const {
        std::cout << "Valor: " << valor << std::endl;
    }
};

int main() {
    Contenedor<int> c(42);  // Funciona: int es un tipo integral
    c.mostrarValor();

    // Contenedor<double> c2(3.14);  // Error de compilación: double no es un tipo integral
}
```

En este ejemplo:
- La clase `Contenedor` está restringida a tipos que cumplen con el Concept `std::integral`, asegurando que solo acepte tipos integrales.

#### Ejemplo 2: Concept Personalizado en una Clase Plantilla

Definamos un Concept personalizado `HasSizeMethod` que verifica si un tipo tiene un método `size()` y usemos este Concept en una clase plantilla.

```cpp
#include <concepts>
#include <iostream>
#include <vector>

// Concept personalizado que requiere que T tenga un método `size()`
template<typename T>
concept HasSizeMethod = requires(T a) {
    { a.size() } -> std::convertible_to<std::size_t>;
};

// Clase plantilla que solo acepta tipos que cumplen con HasSizeMethod
template<HasSizeMethod T>
class Coleccion {
    T coleccion;
public:
    Coleccion(T c) : coleccion(c) {}

    void mostrarTamano() const {
        std::cout << "Tamaño: " << coleccion.size() << std::endl;
    }
};

int main() {
    std::vector<int> vec = {1, 2, 3, 4, 5};
    Coleccion<std::vector<int>> col(vec);  // Funciona: std::vector tiene método size()
    col.mostrarTamano();

    // int num = 42;
    // Coleccion<int> col2(num);  // Error de compilación: int no tiene método size()
}
```

En este ejemplo:
- La clase `Coleccion` está restringida a tipos que cumplen con el Concept `HasSizeMethod`, asegurando que solo acepte tipos que tienen un método `size()`.

### Sobrecarga de Plantillas de Clases usando Concepts

#### Ejemplo 3: Sobrecarga Basada en Concepts

Vamos a definir dos versiones de una clase `Calculadora`, una que acepte tipos integrales y otra que acepte tipos de punto flotante.

```cpp
#include <concepts>
#include <iostream>

// Clase plantilla que solo acepta tipos integrales
template<std::integral T>
class Calculadora {
public:
    T sumar(T a, T b) {
        return a + b;
    }

    T multiplicar(T a, T b) {
        return a * b;
    }
};

// Clase plantilla que solo acepta tipos de punto flotante
template<std::floating_point T>
class Calculadora {
public:
    T sumar(T a, T b) {
        return a + b;
    }

    T multiplicar(T a, T b) {
        return a * b;
    }
};

int main() {
    Calculadora<int> calcInt;
    std::cout << "Suma (int): " << calcInt.sumar(3, 4) << std::endl;
    std::cout << "Multiplicación (int): " << calcInt.multiplicar(3, 4) << std::endl;

    Calculadora<double> calcFloat;
    std::cout << "Suma (double): " << calcFloat.sumar(3.0, 4.0) << std::endl;
    std::cout << "Multiplicación (double): " << calcFloat.multiplicar(3.0, 4.0) << std::endl;

    // Calculadora<std::string> calcStr;  // Error de compilación: std::string no cumple con std::integral ni std::floating_point
}
```

En este ejemplo:
- Se definen dos versiones de la clase `Calculadora` usando Concepts para restringir los tipos que pueden aceptar.

### Concepts en Plantillas de Clases Mixtas

#### Ejemplo 4: Plantilla de Clase con Múltiples Concepts

Vamos a definir una clase `Par` que solo acepta pares de tipos donde ambos tipos cumplen ciertos requisitos.

```cpp
#include <concepts>
#include <iostream>

// Concept personalizado que verifica si T es default constructible
template<typename T>
concept DefaultConstructible = std::is_default_constructible_v<T>;

// Concept personalizado que verifica si T es comparable por igualdad
template<typename T>
concept EqualityComparable = requires(T a, T b) {
    { a == b } -> std::convertible_to<bool>;
};

// Clase plantilla que solo acepta pares de tipos que son DefaultConstructible y EqualityComparable
template<DefaultConstructible T1, EqualityComparable T2>
class Par {
    T1 primero;
    T2 segundo;
public:
    Par(T1 p, T2 s) : primero(p), segundo(s) {}

    bool sonIguales() const {
        return primero == segundo;
    }

    void mostrarPar() const {
        std::cout << "Par: (" << primero << ", " << segundo << ")" << std::endl;
    }
};

int main() {
    Par<int, int> p1(1, 1);  // Funciona: int cumple con DefaultConstructible y EqualityComparable
    p1.mostrarPar();
    std::cout << "Son iguales: " << std::boolalpha << p1.sonIguales() << std::endl;

    // Par<int, std::string> p2(1, "1");  // Error de compilación: std::string no cumple con DefaultConstructible
}
```

En este ejemplo:
- La clase `Par` está restringida a pares de tipos donde ambos tipos deben ser `DefaultConstructible` y el segundo tipo debe ser `EqualityComparable`.

### Buenas Prácticas al Usar Concepts en Clases y Plantillas de Clases

1. **Definir Concepts Claros y Específicos**: Asegúrese de que los Concepts sean claros y específicos para evitar confusiones.
2. **Reutilizar Concepts**: Defina Concepts reutilizables que puedan ser aplicados en múltiples clases y contextos.
3. **Documentar los Concepts**: Documente los Concepts y las clases que los utilizan para facilitar la comprensión del código.
4. **Evitar Complejidad**: Mantenga los Concepts lo más simples posible para no complicar innecesariamente el código.

### Conclusión

Los Concepts en C++ permiten imponer restricciones claras y precisas en las plantillas de clases, mejorando la seguridad y la robustez del código. Al definir y utilizar Concepts personalizados, puede asegurar que sus clases solo acepten los tipos adecuados, evitando errores en tiempo de compilación y mejorando la mantenibilidad del código.
### Uso de Concepts con Métodos de Clase en C++

Los Concepts en C++20 no solo se pueden utilizar para restringir los tipos de parámetros en funciones y clases plantilla, sino también para definir restricciones en métodos de clase. Esto permite una mayor granularidad al especificar qué tipos pueden ser utilizados con métodos específicos dentro de una clase.

### Definición de Concepts en Métodos de Clase

Vamos a ver cómo se pueden utilizar los Concepts para restringir los métodos de una clase, asegurando que solo ciertos tipos sean válidos para esos métodos.

#### Ejemplo 1: Restricción de Métodos con Conceptos Predefinidos

Supongamos que tenemos una clase `Calculadora` que tiene métodos para sumar y multiplicar, pero queremos restringir el método `sumar` a tipos integrales y el método `multiplicar` a tipos de punto flotante.

```cpp
#include <concepts>
#include <iostream>

// Clase Calculadora con métodos restringidos por Concepts
class Calculadora {
public:
    // Método sumar restringido a tipos integrales
    template<std::integral T>
    T sumar(T a, T b) {
        return a + b;
    }

    // Método multiplicar restringido a tipos de punto flotante
    template<std::floating_point T>
    T multiplicar(T a, T b) {
        return a * b;
    }
};

int main() {
    Calculadora calc;
    
    int x = 5, y = 3;
    std::cout << "Suma (int): " << calc.sumar(x, y) << std::endl; // Funciona: int es un tipo integral

    double a = 2.5, b = 4.0;
    std::cout << "Multiplicación (double): " << calc.multiplicar(a, b) << std::endl; // Funciona: double es un tipo de punto flotante

    // std::cout << calc.sumar(a, b) << std::endl; // Error de compilación: double no es un tipo integral
    // std::cout << calc.multiplicar(x, y) << std::endl; // Error de compilación: int no es un tipo de punto flotante
}
```

#### Ejemplo 2: Concept Personalizado `HasSizeMethod` en Métodos de Clase

Definamos un Concept personalizado `HasSizeMethod` que verifica si un tipo tiene un método `size()` y usemos este Concept para restringir un método de una clase `Coleccion`.

```cpp
#include <concepts>
#include <iostream>
#include <vector>

// Concept personalizado que requiere que T tenga un método `size()`
template<typename T>
concept HasSizeMethod = requires(T a) {
    { a.size() } -> std::convertible_to<std::size_t>;
};

// Clase Coleccion con un método restringido por el Concept HasSizeMethod
class Coleccion {
public:
    // Método mostrarTamano restringido a tipos que cumplen con HasSizeMethod
    template<HasSizeMethod T>
    void mostrarTamano(const T& contenedor) {
        std::cout << "Tamaño: " << contenedor.size() << std::endl;
    }
};

int main() {
    Coleccion col;
    std::vector<int> vec = {1, 2, 3, 4, 5};
    col.mostrarTamano(vec); // Funciona: std::vector tiene método size()

    // int num = 42;
    // col.mostrarTamano(num); // Error de compilación: int no tiene método size()
}
```

### Combinación de Concepts en Métodos de Clase

#### Ejemplo 3: Métodos con Múltiples Concepts

Vamos a definir una clase `Comparador` que tiene métodos para comparar si dos elementos son iguales y si un elemento es menor que otro. Usaremos Concepts para restringir estos métodos.

```cpp
#include <concepts>
#include <iostream>

// Concept personalizado que verifica si T es comparable por igualdad
template<typename T>
concept EqualityComparable = requires(T a, T b) {
    { a == b } -> std::convertible_to<bool>;
};

// Concept personalizado que verifica si T es comparable por menos que
template<typename T>
concept LessThanComparable = requires(T a, T b) {
    { a < b } -> std::convertible_to<bool>;
};

// Clase Comparador con métodos restringidos por Concepts
class Comparador {
public:
    // Método esIgual restringido a tipos que cumplen con EqualityComparable
    template<EqualityComparable T>
    bool esIgual(const T& a, const T& b) {
        return a == b;
    }

    // Método esMenor restringido a tipos que cumplen con LessThanComparable
    template<LessThanComparable T>
    bool esMenor(const T& a, const T& b) {
        return a < b;
    }
};

int main() {
    Comparador comp;

    int a = 5, b = 5, c = 3;
    std::cout << std::boolalpha << "a == b: " << comp.esIgual(a, b) << std::endl; // Funciona: int es EqualityComparable
    std::cout << "a < c: " << comp.esMenor(a, c) << std::endl; // Funciona: int es LessThanComparable

    std::string str1 = "hello", str2 = "world";
    std::cout << "str1 == str2: " << comp.esIgual(str1, str2) << std::endl; // Funciona: std::string es EqualityComparable
    std::cout << "str1 < str2: " << comp.esMenor(str1, str2) << std::endl; // Funciona: std::string es LessThanComparable

    // double d1 = 1.1, d2 = 2.2;
    // std::cout << "d1 == d2: " << comp.esIgual(d1, d2) << std::endl; // Error de compilación: double no cumple con EqualityComparable
    // std::cout << "d1 < d2: " << comp.esMenor(d1, d2) << std::endl; // Error de compilación: double no cumple con LessThanComparable
}
```

En este ejemplo:
- La clase `Comparador` tiene dos métodos, `esIgual` y `esMenor`, que están restringidos a tipos que cumplen con `EqualityComparable` y `LessThanComparable`, respectivamente.

### Buenas Prácticas al Usar Concepts en Métodos de Clase

1. **Definir Concepts Claros y Específicos**: Asegúrese de que los Concepts sean claros y específicos para evitar confusiones.
2. **Reutilizar Concepts**: Defina Concepts reutilizables que puedan ser aplicados en múltiples métodos y contextos.
3. **Documentar los Concepts y Métodos**: Documente los Concepts y los métodos que los utilizan para facilitar la comprensión del código.
4. **Evitar Complejidad Innecesaria**: Mantenga los Concepts y las restricciones lo más simples posible para no complicar innecesariamente el código.

### Conclusión

Los Concepts en C++ permiten imponer restricciones claras y precisas en los métodos de clase, mejorando la seguridad y la robustez del código. Al definir y utilizar Concepts personalizados en métodos de clase, puede asegurar que sus métodos solo acepten los tipos adecuados, evitando errores en tiempo de compilación y mejorando la mantenibilidad del código.
<---FILES--->
Ejemplo Básico de Concept
Ejemplo Básico de Concept Result
Ejemplo Básico de Concept
Ejemplo Básico de Concept Result
Ejemplo de Concept con Función
Ejemplo de Concept con Función Result
Ejemplo de Concept con Clase
Ejemplo de Concept con Clase Result
Ejemplo Básico de Concept
Ejemplo Básico de Concept Result
Ejemplo de Concept con Función
Ejemplo de Concept con Función Result
Ejemplo de Concept con Clase
Ejemplo de Concept con Clase Result
Ejemplo
Ejemplo Result
Ejemplo Básico de Concept
Ejemplo Básico de Concept Result
Ejemplo de Concept con Función
Ejemplo de Concept con Función Result
Ejemplo de Concept con Clase
Ejemplo de Concept con Clase Result
Ejemplo
Ejemplo Result
Ejemplo Básico de Concept
Ejemplo Básico de Concept Result
Ejemplo de Concept con Función
Ejemplo de Concept con Función Result
Ejemplo de Concept con Clase
Ejemplo de Concept con Clase Result
Ejemplo
Ejemplo Result
Ejemplo Básico de Concept
Ejemplo Básico de Concept Result
Ejemplo de Concept con Función
Ejemplo de Concept con Función Result
Ejemplo de Concept con Clase
Ejemplo de Concept con Clase Result
Ejemplo
Ejemplo Result
Ejemplo Básico de Concept
Ejemplo Básico de Concept Result
Ejemplo de Concept con Función
Ejemplo de Concept con Función Result
Ejemplo de Concept con Clase
Ejemplo de Concept con Clase Result
Ejemplo
Ejemplo Result
Ejemplo Básico de Concept
Ejemplo Básico de Concept Result
Ejemplo de Concept con Función
Ejemplo de Concept con Función Result
Ejemplo de Concept con Clase
Ejemplo de Concept con Clase Result
Ejemplo
Ejemplo Result
<---Ejemplo Básico de Concept--->
```cpp
#include <concepts>
#include <iostream>

// Definir un Concept que requiere que T sea un tipo integral
template<typename T>
concept Integral = std::is_integral_v<T>;

// Función plantilla que utiliza el Concept Integral
template<Integral T>
T sumar(T a, T b) {
    return a + b;
}

int main() {
    int a = 5, b = 3;
    std::cout << sumar(a, b) << std::endl; // Funciona: int es un tipo integral

    // double x = 5.0, y = 3.0;
    // std::cout << sumar(x, y) << std::endl; // Error de compilación: double no es un tipo integral
}
```cpp
#include <concepts>
#include <type_traits>
#include <iostream>

// Definir un Concept que requiere que T tenga un método `size()`
template<typename T>
concept HasSizeMethod = requires(T a) {
    { a.size() } -> std::convertible_to<std::size_t>;
};

// Clase con método `size()`
class ConSize {
public:
    std::size_t size() const {
        return 42;
    }
};

// Clase sin método `size()`
class SinSize {
public:
    int length() const {
        return 84;
    }
};

// Función plantilla que utiliza el Concept HasSizeMethod
template<HasSizeMethod T>
std::size_t obtenerSize(const T& obj) {
    return obj.size();
}

int main() {
    ConSize cs;
    std::cout << obtenerSize(cs) << std::endl; // Funciona: ConSize tiene método `size()`

    // SinSize ss;
    // std::cout << obtenerSize(ss) << std::endl; // Error de compilación: SinSize no tiene método `size()`
}
```cpp
#include <concepts>
#include <iostream>

// Concept que requiere que T sea un número flotante
template<typename T>
concept FloatingPoint = std::is_floating_point_v<T>;

// Función plantilla que utiliza el Concept FloatingPoint
template<FloatingPoint T>
T multiplicar(T a, T b) {
    return a * b;
}

int main() {
    float a = 2.5f, b = 4.0f;
    std::cout << multiplicar(a, b) << std::endl; // Funciona: float es un tipo flotante

    // int x = 2, y = 3;
    // std::cout << multiplicar(x, y) << std::endl; // Error de compilación: int no es un tipo flotante
}
<---Ejemplo Básico de Concept Result--->
<---Ejemplo Básico de Concept--->
```cpp
#include <concepts>
#include <iostream>

// Definir un Concept que requiere que T sea un tipo integral
template<typename T>
concept Integral = std::is_integral_v<T>;

// Función plantilla que utiliza el Concept Integral
template<Integral T>
T sumar(T a, T b) {
    return a + b;
}

int main() {
    int a = 5, b = 3;
    std::cout << sumar(a, b) << std::endl; // Funciona: int es un tipo integral

    // double x = 5.0, y = 3.0;
    // std::cout << sumar(x, y) << std::endl; // Error de compilación: double no es un tipo integral
}
```cpp
#include <concepts>
#include <type_traits>
#include <iostream>

// Definir un Concept que requiere que T tenga un método `size()`
template<typename T>
concept HasSizeMethod = requires(T a) {
    { a.size() } -> std::convertible_to<std::size_t>;
};

// Clase con método `size()`
class ConSize {
public:
    std::size_t size() const {
        return 42;
    }
};

// Clase sin método `size()`
class SinSize {
public:
    int length() const {
        return 84;
    }
};

// Función plantilla que utiliza el Concept HasSizeMethod
template<HasSizeMethod T>
std::size_t obtenerSize(const T& obj) {
    return obj.size();
}

int main() {
    ConSize cs;
    std::cout << obtenerSize(cs) << std::endl; // Funciona: ConSize tiene método `size()`

    // SinSize ss;
    // std::cout << obtenerSize(ss) << std::endl; // Error de compilación: SinSize no tiene método `size()`
}
```cpp
#include <concepts>
#include <iostream>

// Concept que requiere que T sea un número flotante
template<typename T>
concept FloatingPoint = std::is_floating_point_v<T>;

// Función plantilla que utiliza el Concept FloatingPoint
template<FloatingPoint T>
T multiplicar(T a, T b) {
    return a * b;
}

int main() {
    float a = 2.5f, b = 4.0f;
    std::cout << multiplicar(a, b) << std::endl; // Funciona: float es un tipo flotante

    // int x = 2, y = 3;
    // std::cout << multiplicar(x, y) << std::endl; // Error de compilación: int no es un tipo flotante
}
<---Ejemplo Básico de Concept Result--->
<---Ejemplo de Concept con Función--->
```cpp
#include <concepts>
#include <iostream>

// Concept que requiere que T sea un tipo integral
template<typename T>
concept Integral = std::is_integral_v<T>;

// Función plantilla que utiliza el Concept Integral
template<Integral T>
T sumar(T a, T b) {
    return a + b;
}

int main() {
    int a = 5, b = 3;
    std::cout << sumar(a, b) << std::endl; // Funciona: int es un tipo integral

    // double x = 5.0, y = 3.0;
    // std::cout << sumar(x, y) << std::endl; // Error de compilación: double no es un tipo integral
}
<---Ejemplo de Concept con Función Result--->
<---Ejemplo de Concept con Clase--->
```cpp
#include <concepts>
#include <iostream>

// Concept que requiere que T sea un tipo flotante
template<typename T>
concept FloatingPoint = std::is_floating_point_v<T>;

// Clase plantilla que utiliza el Concept FloatingPoint
template<FloatingPoint T>
class Calculadora {
public:
    T sumar(T a, T b) {
        return a + b;
    }

    T multiplicar(T a, T b) {
        return a * b;
    }
};

int main() {
    Calculadora<float> calc;
    std::cout << calc.sumar(2.5f, 3.0f) << std::endl; // Funciona: float es un tipo flotante
    std::cout << calc.multiplicar(2.5f, 3.0f) << std::endl; // Funciona: float es un tipo flotante

    // Calculadora<int> calcInt;
    // std::cout << calcInt.sumar(2, 3) << std::endl; // Error de compilación: int no es un tipo flotante
}
```cpp
#include <concepts>
#include <iostream>
#include <vector>
#include <list>

// Concept que requiere que T sea iterable
template<typename T>
concept Iterable = requires(T t) {
    t.begin();
    t.end();
};

// Clase plantilla que usa el Concept Iterable
template<Iterable T>
class Procesador {
public:
    void mostrarElementos(const T& contenedor) {
        for (const auto& elem : contenedor) {
            std::cout << elem << ' ';
        }
        std::cout << std::endl;
    }
};

// Función plantilla que usa el Concept Iterable
template<Iterable T>
void procesarContenedor(const T& contenedor) {
    for (const auto& elem : contenedor) {
        std::cout << elem << ' ';
    }
    std::cout << std::endl;
}

int main() {
    std::vector<int> vec = {1, 2, 3, 4, 5};
    std::list<std::string> lst = {"uno", "dos", "tres"};

    Procesador<std::vector<int>> procVec;
    procVec.mostrarElementos(vec); // Funciona: vector es iterable

    Procesador<std::list<std::string>> procLst;
    procLst.mostrarElementos(lst); // Funciona: list es iterable

    procesarContenedor(vec); // Funciona: vector es iterable
    procesarContenedor(lst); // Funciona: list es iterable

    // int num = 42;
    // procesarContenedor(num); // Error de compilación: int no es iterable
}
<---Ejemplo de Concept con Clase Result--->
<---Ejemplo Básico de Concept--->
```cpp
#include <concepts>
#include <iostream>

// Definir un Concept que requiere que T sea un tipo integral
template<typename T>
concept Integral = std::is_integral_v<T>;

// Función plantilla que utiliza el Concept Integral
template<Integral T>
T sumar(T a, T b) {
    return a + b;
}

int main() {
    int a = 5, b = 3;
    std::cout << sumar(a, b) << std::endl; // Funciona: int es un tipo integral

    // double x = 5.0, y = 3.0;
    // std::cout << sumar(x, y) << std::endl; // Error de compilación: double no es un tipo integral
}
```cpp
#include <concepts>
#include <type_traits>
#include <iostream>

// Definir un Concept que requiere que T tenga un método `size()`
template<typename T>
concept HasSizeMethod = requires(T a) {
    { a.size() } -> std::convertible_to<std::size_t>;
};

// Clase con método `size()`
class ConSize {
public:
    std::size_t size() const {
        return 42;
    }
};

// Clase sin método `size()`
class SinSize {
public:
    int length() const {
        return 84;
    }
};

// Función plantilla que utiliza el Concept HasSizeMethod
template<HasSizeMethod T>
std::size_t obtenerSize(const T& obj) {
    return obj.size();
}

int main() {
    ConSize cs;
    std::cout << obtenerSize(cs) << std::endl; // Funciona: ConSize tiene método `size()`

    // SinSize ss;
    // std::cout << obtenerSize(ss) << std::endl; // Error de compilación: SinSize no tiene método `size()`
}
```cpp
#include <concepts>
#include <iostream>

// Concept que requiere que T sea un número flotante
template<typename T>
concept FloatingPoint = std::is_floating_point_v<T>;

// Función plantilla que utiliza el Concept FloatingPoint
template<FloatingPoint T>
T multiplicar(T a, T b) {
    return a * b;
}

int main() {
    float a = 2.5f, b = 4.0f;
    std::cout << multiplicar(a, b) << std::endl; // Funciona: float es un tipo flotante

    // int x = 2, y = 3;
    // std::cout << multiplicar(x, y) << std::endl; // Error de compilación: int no es un tipo flotante
}
<---Ejemplo Básico de Concept Result--->
<---Ejemplo de Concept con Función--->
```cpp
#include <concepts>
#include <iostream>

// Concept que requiere que T sea un tipo integral
template<typename T>
concept Integral = std::is_integral_v<T>;

// Función plantilla que utiliza el Concept Integral
template<Integral T>
T sumar(T a, T b) {
    return a + b;
}

int main() {
    int a = 5, b = 3;
    std::cout << sumar(a, b) << std::endl; // Funciona: int es un tipo integral

    // double x = 5.0, y = 3.0;
    // std::cout << sumar(x, y) << std::endl; // Error de compilación: double no es un tipo integral
}
<---Ejemplo de Concept con Función Result--->
<---Ejemplo de Concept con Clase--->
```cpp
#include <concepts>
#include <iostream>

// Concept que requiere que T sea un tipo flotante
template<typename T>
concept FloatingPoint = std::is_floating_point_v<T>;

// Clase plantilla que utiliza el Concept FloatingPoint
template<FloatingPoint T>
class Calculadora {
public:
    T sumar(T a, T b) {
        return a + b;
    }

    T multiplicar(T a, T b) {
        return a * b;
    }
};

int main() {
    Calculadora<float> calc;
    std::cout << calc.sumar(2.5f, 3.0f) << std::endl; // Funciona: float es un tipo flotante
    std::cout << calc.multiplicar(2.5f, 3.0f) << std::endl; // Funciona: float es un tipo flotante

    // Calculadora<int> calcInt;
    // std::cout << calcInt.sumar(2, 3) << std::endl; // Error de compilación: int no es un tipo flotante
}
```cpp
#include <concepts>
#include <iostream>
#include <vector>
#include <list>

// Concept que requiere que T sea iterable
template<typename T>
concept Iterable = requires(T t) {
    t.begin();
    t.end();
};

// Clase plantilla que usa el Concept Iterable
template<Iterable T>
class Procesador {
public:
    void mostrarElementos(const T& contenedor) {
        for (const auto& elem : contenedor) {
            std::cout << elem << ' ';
        }
        std::cout << std::endl;
    }
};

// Función plantilla que usa el Concept Iterable
template<Iterable T>
void procesarContenedor(const T& contenedor) {
    for (const auto& elem : contenedor) {
        std::cout << elem << ' ';
    }
    std::cout << std::endl;
}

int main() {
    std::vector<int> vec = {1, 2, 3, 4, 5};
    std::list<std::string> lst = {"uno", "dos", "tres"};

    Procesador<std::vector<int>> procVec;
    procVec.mostrarElementos(vec); // Funciona: vector es iterable

    Procesador<std::list<std::string>> procLst;
    procLst.mostrarElementos(lst); // Funciona: list es iterable

    procesarContenedor(vec); // Funciona: vector es iterable
    procesarContenedor(lst); // Funciona: list es iterable

    // int num = 42;
    // procesarContenedor(num); // Error de compilación: int no es iterable
}
<---Ejemplo de Concept con Clase Result--->
<---Ejemplo--->
```cpp
#include <concepts>
#include <iostream>

// Función plantilla que solo acepta tipos integrales
template<std::integral T>
T multiplicar(T a, T b) {
    return a * b;
}

int main() {
    int a = 5, b = 3;
    std::cout << multiplicar(a, b) << std::endl;  // Funciona: int es un tipo integral

    // double x = 5.0, y = 3.0;
    // std::cout << multiplicar(x, y) << std::endl;  // Error de compilación: double no es un tipo integral
}
<---Ejemplo Result--->
<---Ejemplo Básico de Concept--->
```cpp
#include <concepts>
#include <iostream>

// Definir un Concept que requiere que T sea un tipo integral
template<typename T>
concept Integral = std::is_integral_v<T>;

// Función plantilla que utiliza el Concept Integral
template<Integral T>
T sumar(T a, T b) {
    return a + b;
}

int main() {
    int a = 5, b = 3;
    std::cout << sumar(a, b) << std::endl; // Funciona: int es un tipo integral

    // double x = 5.0, y = 3.0;
    // std::cout << sumar(x, y) << std::endl; // Error de compilación: double no es un tipo integral
}
```cpp
#include <concepts>
#include <type_traits>
#include <iostream>

// Definir un Concept que requiere que T tenga un método `size()`
template<typename T>
concept HasSizeMethod = requires(T a) {
    { a.size() } -> std::convertible_to<std::size_t>;
};

// Clase con método `size()`
class ConSize {
public:
    std::size_t size() const {
        return 42;
    }
};

// Clase sin método `size()`
class SinSize {
public:
    int length() const {
        return 84;
    }
};

// Función plantilla que utiliza el Concept HasSizeMethod
template<HasSizeMethod T>
std::size_t obtenerSize(const T& obj) {
    return obj.size();
}

int main() {
    ConSize cs;
    std::cout << obtenerSize(cs) << std::endl; // Funciona: ConSize tiene método `size()`

    // SinSize ss;
    // std::cout << obtenerSize(ss) << std::endl; // Error de compilación: SinSize no tiene método `size()`
}
```cpp
#include <concepts>
#include <iostream>

// Concept que requiere que T sea un número flotante
template<typename T>
concept FloatingPoint = std::is_floating_point_v<T>;

// Función plantilla que utiliza el Concept FloatingPoint
template<FloatingPoint T>
T multiplicar(T a, T b) {
    return a * b;
}

int main() {
    float a = 2.5f, b = 4.0f;
    std::cout << multiplicar(a, b) << std::endl; // Funciona: float es un tipo flotante

    // int x = 2, y = 3;
    // std::cout << multiplicar(x, y) << std::endl; // Error de compilación: int no es un tipo flotante
}
<---Ejemplo Básico de Concept Result--->
<---Ejemplo de Concept con Función--->
```cpp
#include <concepts>
#include <iostream>

// Concept que requiere que T sea un tipo integral
template<typename T>
concept Integral = std::is_integral_v<T>;

// Función plantilla que utiliza el Concept Integral
template<Integral T>
T sumar(T a, T b) {
    return a + b;
}

int main() {
    int a = 5, b = 3;
    std::cout << sumar(a, b) << std::endl; // Funciona: int es un tipo integral

    // double x = 5.0, y = 3.0;
    // std::cout << sumar(x, y) << std::endl; // Error de compilación: double no es un tipo integral
}
<---Ejemplo de Concept con Función Result--->
<---Ejemplo de Concept con Clase--->
```cpp
#include <concepts>
#include <iostream>

// Concept que requiere que T sea un tipo flotante
template<typename T>
concept FloatingPoint = std::is_floating_point_v<T>;

// Clase plantilla que utiliza el Concept FloatingPoint
template<FloatingPoint T>
class Calculadora {
public:
    T sumar(T a, T b) {
        return a + b;
    }

    T multiplicar(T a, T b) {
        return a * b;
    }
};

int main() {
    Calculadora<float> calc;
    std::cout << calc.sumar(2.5f, 3.0f) << std::endl; // Funciona: float es un tipo flotante
    std::cout << calc.multiplicar(2.5f, 3.0f) << std::endl; // Funciona: float es un tipo flotante

    // Calculadora<int> calcInt;
    // std::cout << calcInt.sumar(2, 3) << std::endl; // Error de compilación: int no es un tipo flotante
}
```cpp
#include <concepts>
#include <iostream>
#include <vector>
#include <list>

// Concept que requiere que T sea iterable
template<typename T>
concept Iterable = requires(T t) {
    t.begin();
    t.end();
};

// Clase plantilla que usa el Concept Iterable
template<Iterable T>
class Procesador {
public:
    void mostrarElementos(const T& contenedor) {
        for (const auto& elem : contenedor) {
            std::cout << elem << ' ';
        }
        std::cout << std::endl;
    }
};

// Función plantilla que usa el Concept Iterable
template<Iterable T>
void procesarContenedor(const T& contenedor) {
    for (const auto& elem : contenedor) {
        std::cout << elem << ' ';
    }
    std::cout << std::endl;
}

int main() {
    std::vector<int> vec = {1, 2, 3, 4, 5};
    std::list<std::string> lst = {"uno", "dos", "tres"};

    Procesador<std::vector<int>> procVec;
    procVec.mostrarElementos(vec); // Funciona: vector es iterable

    Procesador<std::list<std::string>> procLst;
    procLst.mostrarElementos(lst); // Funciona: list es iterable

    procesarContenedor(vec); // Funciona: vector es iterable
    procesarContenedor(lst); // Funciona: list es iterable

    // int num = 42;
    // procesarContenedor(num); // Error de compilación: int no es iterable
}
<---Ejemplo de Concept con Clase Result--->
<---Ejemplo--->
```cpp
#include <concepts>
#include <iostream>

// Función plantilla que solo acepta tipos integrales
template<std::integral T>
T multiplicar(T a, T b) {
    return a * b;
}

int main() {
    int a = 5, b = 3;
    std::cout << multiplicar(a, b) << std::endl;  // Funciona: int es un tipo integral

    // double x = 5.0, y = 3.0;
    // std::cout << multiplicar(x, y) << std::endl;  // Error de compilación: double no es un tipo integral
}
<---Ejemplo Result--->
<---Ejemplo Básico de Concept--->
```cpp
#include <concepts>
#include <iostream>

// Definir un Concept que requiere que T sea un tipo integral
template<typename T>
concept Integral = std::is_integral_v<T>;

// Función plantilla que utiliza el Concept Integral
template<Integral T>
T sumar(T a, T b) {
    return a + b;
}

int main() {
    int a = 5, b = 3;
    std::cout << sumar(a, b) << std::endl; // Funciona: int es un tipo integral

    // double x = 5.0, y = 3.0;
    // std::cout << sumar(x, y) << std::endl; // Error de compilación: double no es un tipo integral
}
```cpp
#include <concepts>
#include <type_traits>
#include <iostream>

// Definir un Concept que requiere que T tenga un método `size()`
template<typename T>
concept HasSizeMethod = requires(T a) {
    { a.size() } -> std::convertible_to<std::size_t>;
};

// Clase con método `size()`
class ConSize {
public:
    std::size_t size() const {
        return 42;
    }
};

// Clase sin método `size()`
class SinSize {
public:
    int length() const {
        return 84;
    }
};

// Función plantilla que utiliza el Concept HasSizeMethod
template<HasSizeMethod T>
std::size_t obtenerSize(const T& obj) {
    return obj.size();
}

int main() {
    ConSize cs;
    std::cout << obtenerSize(cs) << std::endl; // Funciona: ConSize tiene método `size()`

    // SinSize ss;
    // std::cout << obtenerSize(ss) << std::endl; // Error de compilación: SinSize no tiene método `size()`
}
```cpp
#include <concepts>
#include <iostream>

// Concept que requiere que T sea un número flotante
template<typename T>
concept FloatingPoint = std::is_floating_point_v<T>;

// Función plantilla que utiliza el Concept FloatingPoint
template<FloatingPoint T>
T multiplicar(T a, T b) {
    return a * b;
}

int main() {
    float a = 2.5f, b = 4.0f;
    std::cout << multiplicar(a, b) << std::endl; // Funciona: float es un tipo flotante

    // int x = 2, y = 3;
    // std::cout << multiplicar(x, y) << std::endl; // Error de compilación: int no es un tipo flotante
}
<---Ejemplo Básico de Concept Result--->
<---Ejemplo de Concept con Función--->
```cpp
#include <concepts>
#include <iostream>

// Concept que requiere que T sea un tipo integral
template<typename T>
concept Integral = std::is_integral_v<T>;

// Función plantilla que utiliza el Concept Integral
template<Integral T>
T sumar(T a, T b) {
    return a + b;
}

int main() {
    int a = 5, b = 3;
    std::cout << sumar(a, b) << std::endl; // Funciona: int es un tipo integral

    // double x = 5.0, y = 3.0;
    // std::cout << sumar(x, y) << std::endl; // Error de compilación: double no es un tipo integral
}
<---Ejemplo de Concept con Función Result--->
<---Ejemplo de Concept con Clase--->
```cpp
#include <concepts>
#include <iostream>

// Concept que requiere que T sea un tipo flotante
template<typename T>
concept FloatingPoint = std::is_floating_point_v<T>;

// Clase plantilla que utiliza el Concept FloatingPoint
template<FloatingPoint T>
class Calculadora {
public:
    T sumar(T a, T b) {
        return a + b;
    }

    T multiplicar(T a, T b) {
        return a * b;
    }
};

int main() {
    Calculadora<float> calc;
    std::cout << calc.sumar(2.5f, 3.0f) << std::endl; // Funciona: float es un tipo flotante
    std::cout << calc.multiplicar(2.5f, 3.0f) << std::endl; // Funciona: float es un tipo flotante

    // Calculadora<int> calcInt;
    // std::cout << calcInt.sumar(2, 3) << std::endl; // Error de compilación: int no es un tipo flotante
}
```cpp
#include <concepts>
#include <iostream>
#include <vector>
#include <list>

// Concept que requiere que T sea iterable
template<typename T>
concept Iterable = requires(T t) {
    t.begin();
    t.end();
};

// Clase plantilla que usa el Concept Iterable
template<Iterable T>
class Procesador {
public:
    void mostrarElementos(const T& contenedor) {
        for (const auto& elem : contenedor) {
            std::cout << elem << ' ';
        }
        std::cout << std::endl;
    }
};

// Función plantilla que usa el Concept Iterable
template<Iterable T>
void procesarContenedor(const T& contenedor) {
    for (const auto& elem : contenedor) {
        std::cout << elem << ' ';
    }
    std::cout << std::endl;
}

int main() {
    std::vector<int> vec = {1, 2, 3, 4, 5};
    std::list<std::string> lst = {"uno", "dos", "tres"};

    Procesador<std::vector<int>> procVec;
    procVec.mostrarElementos(vec); // Funciona: vector es iterable

    Procesador<std::list<std::string>> procLst;
    procLst.mostrarElementos(lst); // Funciona: list es iterable

    procesarContenedor(vec); // Funciona: vector es iterable
    procesarContenedor(lst); // Funciona: list es iterable

    // int num = 42;
    // procesarContenedor(num); // Error de compilación: int no es iterable
}
<---Ejemplo de Concept con Clase Result--->
<---Ejemplo--->
```cpp
#include <concepts>
#include <iostream>

// Función plantilla que solo acepta tipos integrales
template<std::integral T>
T multiplicar(T a, T b) {
    return a * b;
}

int main() {
    int a = 5, b = 3;
    std::cout << multiplicar(a, b) << std::endl;  // Funciona: int es un tipo integral

    // double x = 5.0, y = 3.0;
    // std::cout << multiplicar(x, y) << std::endl;  // Error de compilación: double no es un tipo integral
}
<---Ejemplo Result--->
<---Ejemplo Básico de Concept--->
```cpp
#include <concepts>
#include <iostream>

// Definir un Concept que requiere que T sea un tipo integral
template<typename T>
concept Integral = std::is_integral_v<T>;

// Función plantilla que utiliza el Concept Integral
template<Integral T>
T sumar(T a, T b) {
    return a + b;
}

int main() {
    int a = 5, b = 3;
    std::cout << sumar(a, b) << std::endl; // Funciona: int es un tipo integral

    // double x = 5.0, y = 3.0;
    // std::cout << sumar(x, y) << std::endl; // Error de compilación: double no es un tipo integral
}
```cpp
#include <concepts>
#include <type_traits>
#include <iostream>

// Definir un Concept que requiere que T tenga un método `size()`
template<typename T>
concept HasSizeMethod = requires(T a) {
    { a.size() } -> std::convertible_to<std::size_t>;
};

// Clase con método `size()`
class ConSize {
public:
    std::size_t size() const {
        return 42;
    }
};

// Clase sin método `size()`
class SinSize {
public:
    int length() const {
        return 84;
    }
};

// Función plantilla que utiliza el Concept HasSizeMethod
template<HasSizeMethod T>
std::size_t obtenerSize(const T& obj) {
    return obj.size();
}

int main() {
    ConSize cs;
    std::cout << obtenerSize(cs) << std::endl; // Funciona: ConSize tiene método `size()`

    // SinSize ss;
    // std::cout << obtenerSize(ss) << std::endl; // Error de compilación: SinSize no tiene método `size()`
}
```cpp
#include <concepts>
#include <iostream>

// Concept que requiere que T sea un número flotante
template<typename T>
concept FloatingPoint = std::is_floating_point_v<T>;

// Función plantilla que utiliza el Concept FloatingPoint
template<FloatingPoint T>
T multiplicar(T a, T b) {
    return a * b;
}

int main() {
    float a = 2.5f, b = 4.0f;
    std::cout << multiplicar(a, b) << std::endl; // Funciona: float es un tipo flotante

    // int x = 2, y = 3;
    // std::cout << multiplicar(x, y) << std::endl; // Error de compilación: int no es un tipo flotante
}
<---Ejemplo Básico de Concept Result--->
<---Ejemplo de Concept con Función--->
```cpp
#include <concepts>
#include <iostream>

// Concept que requiere que T sea un tipo integral
template<typename T>
concept Integral = std::is_integral_v<T>;

// Función plantilla que utiliza el Concept Integral
template<Integral T>
T sumar(T a, T b) {
    return a + b;
}

int main() {
    int a = 5, b = 3;
    std::cout << sumar(a, b) << std::endl; // Funciona: int es un tipo integral

    // double x = 5.0, y = 3.0;
    // std::cout << sumar(x, y) << std::endl; // Error de compilación: double no es un tipo integral
}
<---Ejemplo de Concept con Función Result--->
<---Ejemplo de Concept con Clase--->
```cpp
#include <concepts>
#include <iostream>

// Concept que requiere que T sea un tipo flotante
template<typename T>
concept FloatingPoint = std::is_floating_point_v<T>;

// Clase plantilla que utiliza el Concept FloatingPoint
template<FloatingPoint T>
class Calculadora {
public:
    T sumar(T a, T b) {
        return a + b;
    }

    T multiplicar(T a, T b) {
        return a * b;
    }
};

int main() {
    Calculadora<float> calc;
    std::cout << calc.sumar(2.5f, 3.0f) << std::endl; // Funciona: float es un tipo flotante
    std::cout << calc.multiplicar(2.5f, 3.0f) << std::endl; // Funciona: float es un tipo flotante

    // Calculadora<int> calcInt;
    // std::cout << calcInt.sumar(2, 3) << std::endl; // Error de compilación: int no es un tipo flotante
}
```cpp
#include <concepts>
#include <iostream>
#include <vector>
#include <list>

// Concept que requiere que T sea iterable
template<typename T>
concept Iterable = requires(T t) {
    t.begin();
    t.end();
};

// Clase plantilla que usa el Concept Iterable
template<Iterable T>
class Procesador {
public:
    void mostrarElementos(const T& contenedor) {
        for (const auto& elem : contenedor) {
            std::cout << elem << ' ';
        }
        std::cout << std::endl;
    }
};

// Función plantilla que usa el Concept Iterable
template<Iterable T>
void procesarContenedor(const T& contenedor) {
    for (const auto& elem : contenedor) {
        std::cout << elem << ' ';
    }
    std::cout << std::endl;
}

int main() {
    std::vector<int> vec = {1, 2, 3, 4, 5};
    std::list<std::string> lst = {"uno", "dos", "tres"};

    Procesador<std::vector<int>> procVec;
    procVec.mostrarElementos(vec); // Funciona: vector es iterable

    Procesador<std::list<std::string>> procLst;
    procLst.mostrarElementos(lst); // Funciona: list es iterable

    procesarContenedor(vec); // Funciona: vector es iterable
    procesarContenedor(lst); // Funciona: list es iterable

    // int num = 42;
    // procesarContenedor(num); // Error de compilación: int no es iterable
}
<---Ejemplo de Concept con Clase Result--->
<---Ejemplo--->
```cpp
#include <concepts>
#include <iostream>

// Función plantilla que solo acepta tipos integrales
template<std::integral T>
T multiplicar(T a, T b) {
    return a * b;
}

int main() {
    int a = 5, b = 3;
    std::cout << multiplicar(a, b) << std::endl;  // Funciona: int es un tipo integral

    // double x = 5.0, y = 3.0;
    // std::cout << multiplicar(x, y) << std::endl;  // Error de compilación: double no es un tipo integral
}
<---Ejemplo Result--->
<---Ejemplo Básico de Concept--->
```cpp
#include <concepts>
#include <iostream>

// Definir un Concept que requiere que T sea un tipo integral
template<typename T>
concept Integral = std::is_integral_v<T>;

// Función plantilla que utiliza el Concept Integral
template<Integral T>
T sumar(T a, T b) {
    return a + b;
}

int main() {
    int a = 5, b = 3;
    std::cout << sumar(a, b) << std::endl; // Funciona: int es un tipo integral

    // double x = 5.0, y = 3.0;
    // std::cout << sumar(x, y) << std::endl; // Error de compilación: double no es un tipo integral
}
```cpp
#include <concepts>
#include <type_traits>
#include <iostream>

// Definir un Concept que requiere que T tenga un método `size()`
template<typename T>
concept HasSizeMethod = requires(T a) {
    { a.size() } -> std::convertible_to<std::size_t>;
};

// Clase con método `size()`
class ConSize {
public:
    std::size_t size() const {
        return 42;
    }
};

// Clase sin método `size()`
class SinSize {
public:
    int length() const {
        return 84;
    }
};

// Función plantilla que utiliza el Concept HasSizeMethod
template<HasSizeMethod T>
std::size_t obtenerSize(const T& obj) {
    return obj.size();
}

int main() {
    ConSize cs;
    std::cout << obtenerSize(cs) << std::endl; // Funciona: ConSize tiene método `size()`

    // SinSize ss;
    // std::cout << obtenerSize(ss) << std::endl; // Error de compilación: SinSize no tiene método `size()`
}
```cpp
#include <concepts>
#include <iostream>

// Concept que requiere que T sea un número flotante
template<typename T>
concept FloatingPoint = std::is_floating_point_v<T>;

// Función plantilla que utiliza el Concept FloatingPoint
template<FloatingPoint T>
T multiplicar(T a, T b) {
    return a * b;
}

int main() {
    float a = 2.5f, b = 4.0f;
    std::cout << multiplicar(a, b) << std::endl; // Funciona: float es un tipo flotante

    // int x = 2, y = 3;
    // std::cout << multiplicar(x, y) << std::endl; // Error de compilación: int no es un tipo flotante
}
<---Ejemplo Básico de Concept Result--->
<---Ejemplo de Concept con Función--->
```cpp
#include <concepts>
#include <iostream>

// Concept que requiere que T sea un tipo integral
template<typename T>
concept Integral = std::is_integral_v<T>;

// Función plantilla que utiliza el Concept Integral
template<Integral T>
T sumar(T a, T b) {
    return a + b;
}

int main() {
    int a = 5, b = 3;
    std::cout << sumar(a, b) << std::endl; // Funciona: int es un tipo integral

    // double x = 5.0, y = 3.0;
    // std::cout << sumar(x, y) << std::endl; // Error de compilación: double no es un tipo integral
}
<---Ejemplo de Concept con Función Result--->
<---Ejemplo de Concept con Clase--->
```cpp
#include <concepts>
#include <iostream>

// Concept que requiere que T sea un tipo flotante
template<typename T>
concept FloatingPoint = std::is_floating_point_v<T>;

// Clase plantilla que utiliza el Concept FloatingPoint
template<FloatingPoint T>
class Calculadora {
public:
    T sumar(T a, T b) {
        return a + b;
    }

    T multiplicar(T a, T b) {
        return a * b;
    }
};

int main() {
    Calculadora<float> calc;
    std::cout << calc.sumar(2.5f, 3.0f) << std::endl; // Funciona: float es un tipo flotante
    std::cout << calc.multiplicar(2.5f, 3.0f) << std::endl; // Funciona: float es un tipo flotante

    // Calculadora<int> calcInt;
    // std::cout << calcInt.sumar(2, 3) << std::endl; // Error de compilación: int no es un tipo flotante
}
```cpp
#include <concepts>
#include <iostream>
#include <vector>
#include <list>

// Concept que requiere que T sea iterable
template<typename T>
concept Iterable = requires(T t) {
    t.begin();
    t.end();
};

// Clase plantilla que usa el Concept Iterable
template<Iterable T>
class Procesador {
public:
    void mostrarElementos(const T& contenedor) {
        for (const auto& elem : contenedor) {
            std::cout << elem << ' ';
        }
        std::cout << std::endl;
    }
};

// Función plantilla que usa el Concept Iterable
template<Iterable T>
void procesarContenedor(const T& contenedor) {
    for (const auto& elem : contenedor) {
        std::cout << elem << ' ';
    }
    std::cout << std::endl;
}

int main() {
    std::vector<int> vec = {1, 2, 3, 4, 5};
    std::list<std::string> lst = {"uno", "dos", "tres"};

    Procesador<std::vector<int>> procVec;
    procVec.mostrarElementos(vec); // Funciona: vector es iterable

    Procesador<std::list<std::string>> procLst;
    procLst.mostrarElementos(lst); // Funciona: list es iterable

    procesarContenedor(vec); // Funciona: vector es iterable
    procesarContenedor(lst); // Funciona: list es iterable

    // int num = 42;
    // procesarContenedor(num); // Error de compilación: int no es iterable
}
<---Ejemplo de Concept con Clase Result--->
<---Ejemplo--->
```cpp
#include <concepts>
#include <iostream>

// Función plantilla que solo acepta tipos integrales
template<std::integral T>
T multiplicar(T a, T b) {
    return a * b;
}

int main() {
    int a = 5, b = 3;
    std::cout << multiplicar(a, b) << std::endl;  // Funciona: int es un tipo integral

    // double x = 5.0, y = 3.0;
    // std::cout << multiplicar(x, y) << std::endl;  // Error de compilación: double no es un tipo integral
}
<---Ejemplo Result--->
<---Ejemplo Básico de Concept--->
```cpp
#include <concepts>
#include <iostream>

// Definir un Concept que requiere que T sea un tipo integral
template<typename T>
concept Integral = std::is_integral_v<T>;

// Función plantilla que utiliza el Concept Integral
template<Integral T>
T sumar(T a, T b) {
    return a + b;
}

int main() {
    int a = 5, b = 3;
    std::cout << sumar(a, b) << std::endl; // Funciona: int es un tipo integral

    // double x = 5.0, y = 3.0;
    // std::cout << sumar(x, y) << std::endl; // Error de compilación: double no es un tipo integral
}
```cpp
#include <concepts>
#include <type_traits>
#include <iostream>

// Definir un Concept que requiere que T tenga un método `size()`
template<typename T>
concept HasSizeMethod = requires(T a) {
    { a.size() } -> std::convertible_to<std::size_t>;
};

// Clase con método `size()`
class ConSize {
public:
    std::size_t size() const {
        return 42;
    }
};

// Clase sin método `size()`
class SinSize {
public:
    int length() const {
        return 84;
    }
};

// Función plantilla que utiliza el Concept HasSizeMethod
template<HasSizeMethod T>
std::size_t obtenerSize(const T& obj) {
    return obj.size();
}

int main() {
    ConSize cs;
    std::cout << obtenerSize(cs) << std::endl; // Funciona: ConSize tiene método `size()`

    // SinSize ss;
    // std::cout << obtenerSize(ss) << std::endl; // Error de compilación: SinSize no tiene método `size()`
}
```cpp
#include <concepts>
#include <iostream>

// Concept que requiere que T sea un número flotante
template<typename T>
concept FloatingPoint = std::is_floating_point_v<T>;

// Función plantilla que utiliza el Concept FloatingPoint
template<FloatingPoint T>
T multiplicar(T a, T b) {
    return a * b;
}

int main() {
    float a = 2.5f, b = 4.0f;
    std::cout << multiplicar(a, b) << std::endl; // Funciona: float es un tipo flotante

    // int x = 2, y = 3;
    // std::cout << multiplicar(x, y) << std::endl; // Error de compilación: int no es un tipo flotante
}
<---Ejemplo Básico de Concept Result--->
<---Ejemplo de Concept con Función--->
```cpp
#include <concepts>
#include <iostream>

// Concept que requiere que T sea un tipo integral
template<typename T>
concept Integral = std::is_integral_v<T>;

// Función plantilla que utiliza el Concept Integral
template<Integral T>
T sumar(T a, T b) {
    return a + b;
}

int main() {
    int a = 5, b = 3;
    std::cout << sumar(a, b) << std::endl; // Funciona: int es un tipo integral

    // double x = 5.0, y = 3.0;
    // std::cout << sumar(x, y) << std::endl; // Error de compilación: double no es un tipo integral
}
<---Ejemplo de Concept con Función Result--->
<---Ejemplo de Concept con Clase--->
```cpp
#include <concepts>
#include <iostream>

// Concept que requiere que T sea un tipo flotante
template<typename T>
concept FloatingPoint = std::is_floating_point_v<T>;

// Clase plantilla que utiliza el Concept FloatingPoint
template<FloatingPoint T>
class Calculadora {
public:
    T sumar(T a, T b) {
        return a + b;
    }

    T multiplicar(T a, T b) {
        return a * b;
    }
};

int main() {
    Calculadora<float> calc;
    std::cout << calc.sumar(2.5f, 3.0f) << std::endl; // Funciona: float es un tipo flotante
    std::cout << calc.multiplicar(2.5f, 3.0f) << std::endl; // Funciona: float es un tipo flotante

    // Calculadora<int> calcInt;
    // std::cout << calcInt.sumar(2, 3) << std::endl; // Error de compilación: int no es un tipo flotante
}
```cpp
#include <concepts>
#include <iostream>
#include <vector>
#include <list>

// Concept que requiere que T sea iterable
template<typename T>
concept Iterable = requires(T t) {
    t.begin();
    t.end();
};

// Clase plantilla que usa el Concept Iterable
template<Iterable T>
class Procesador {
public:
    void mostrarElementos(const T& contenedor) {
        for (const auto& elem : contenedor) {
            std::cout << elem << ' ';
        }
        std::cout << std::endl;
    }
};

// Función plantilla que usa el Concept Iterable
template<Iterable T>
void procesarContenedor(const T& contenedor) {
    for (const auto& elem : contenedor) {
        std::cout << elem << ' ';
    }
    std::cout << std::endl;
}

int main() {
    std::vector<int> vec = {1, 2, 3, 4, 5};
    std::list<std::string> lst = {"uno", "dos", "tres"};

    Procesador<std::vector<int>> procVec;
    procVec.mostrarElementos(vec); // Funciona: vector es iterable

    Procesador<std::list<std::string>> procLst;
    procLst.mostrarElementos(lst); // Funciona: list es iterable

    procesarContenedor(vec); // Funciona: vector es iterable
    procesarContenedor(lst); // Funciona: list es iterable

    // int num = 42;
    // procesarContenedor(num); // Error de compilación: int no es iterable
}
<---Ejemplo de Concept con Clase Result--->
<---Ejemplo--->
```cpp
#include <concepts>
#include <iostream>

// Función plantilla que solo acepta tipos integrales
template<std::integral T>
T multiplicar(T a, T b) {
    return a * b;
}

int main() {
    int a = 5, b = 3;
    std::cout << multiplicar(a, b) << std::endl;  // Funciona: int es un tipo integral

    // double x = 5.0, y = 3.0;
    // std::cout << multiplicar(x, y) << std::endl;  // Error de compilación: double no es un tipo integral
}
<---Ejemplo Result--->
