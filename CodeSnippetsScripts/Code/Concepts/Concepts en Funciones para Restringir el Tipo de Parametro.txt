<---EXPLANATION--->
### Introducción a Concepts en C++

Los Concepts en C++ son una característica introducida en C++20 que permite especificar restricciones sobre los tipos que se pueden utilizar con plantillas. Los Concepts mejoran la claridad y la mantenibilidad del código al proporcionar una manera clara y concisa de expresar requisitos de plantilla, lo que facilita la detección de errores en tiempo de compilación.

#### ¿Qué son los Concepts?

Un Concept es una forma de definir un conjunto de requisitos que un tipo debe cumplir para ser utilizado en una plantilla. Estos requisitos pueden incluir la existencia de ciertas operaciones, tipos miembros, o propiedades específicas.

##### Ejemplo Básico de Concept

```cpp
#include <concepts>
#include <iostream>

// Definir un Concept que requiere que T sea un tipo integral
template<typename T>
concept Integral = std::is_integral_v<T>;

// Función plantilla que utiliza el Concept Integral
template<Integral T>
T sumar(T a, T b) {
    return a + b;
}

int main() {
    int a = 5, b = 3;
    std::cout << sumar(a, b) << std::endl; // Funciona: int es un tipo integral

    // double x = 5.0, y = 3.0;
    // std::cout << sumar(x, y) << std::endl; // Error de compilación: double no es un tipo integral
}
```

En este ejemplo:
- El Concept `Integral` se define para verificar si un tipo es integral utilizando `std::is_integral_v`.
- La función plantilla `sumar` utiliza el Concept `Integral`, asegurando que solo acepte tipos integrales.

### Cómo Definir Concepts

Los Concepts se definen utilizando la palabra clave `concept` seguida del nombre del Concept y una expresión que representa la condición del Concept.

#### Ejemplo de Concept Personalizado

```cpp
#include <concepts>
#include <type_traits>
#include <iostream>

// Definir un Concept que requiere que T tenga un método `size()`
template<typename T>
concept HasSizeMethod = requires(T a) {
    { a.size() } -> std::convertible_to<std::size_t>;
};

// Clase con método `size()`
class ConSize {
public:
    std::size_t size() const {
        return 42;
    }
};

// Clase sin método `size()`
class SinSize {
public:
    int length() const {
        return 84;
    }
};

// Función plantilla que utiliza el Concept HasSizeMethod
template<HasSizeMethod T>
std::size_t obtenerSize(const T& obj) {
    return obj.size();
}

int main() {
    ConSize cs;
    std::cout << obtenerSize(cs) << std::endl; // Funciona: ConSize tiene método `size()`

    // SinSize ss;
    // std::cout << obtenerSize(ss) << std::endl; // Error de compilación: SinSize no tiene método `size()`
}
```

En este ejemplo:
- El Concept `HasSizeMethod` se define para verificar si un tipo tiene un método `size()` que retorna un tipo convertible a `std::size_t`.
- La función plantilla `obtenerSize` utiliza el Concept `HasSizeMethod`, asegurando que solo acepte tipos que tengan un método `size()`.

### Uso de Concepts para Mejorar la Legibilidad

Los Concepts no solo restringen los tipos aceptados por las plantillas, sino que también mejoran la legibilidad del código al proporcionar un contexto claro sobre lo que se espera de los parámetros de plantilla.

#### Ejemplo de Uso de Concepts en Funciones Plantilla

```cpp
#include <concepts>
#include <iostream>

// Concept que requiere que T sea un número flotante
template<typename T>
concept FloatingPoint = std::is_floating_point_v<T>;

// Función plantilla que utiliza el Concept FloatingPoint
template<FloatingPoint T>
T multiplicar(T a, T b) {
    return a * b;
}

int main() {
    float a = 2.5f, b = 4.0f;
    std::cout << multiplicar(a, b) << std::endl; // Funciona: float es un tipo flotante

    // int x = 2, y = 3;
    // std::cout << multiplicar(x, y) << std::endl; // Error de compilación: int no es un tipo flotante
}
```

### Buenas Prácticas con Concepts

#### 1. Definir Concepts Significativos

Defina Concepts que sean significativos y útiles en el contexto de su código. Los Concepts deben expresar claramente las expectativas sobre los tipos que se usarán.

#### 2. Evitar Concepts Demasiado Amplios

Evite definir Concepts que sean demasiado amplios o vagos. Un Concept demasiado amplio puede no proporcionar una verificación útil y puede permitir tipos no deseados.

#### 3. Utilizar Concepts para Mejorar los Mensajes de Error

Los Concepts pueden mejorar los mensajes de error al compilar, proporcionando información clara sobre por qué un tipo no cumple con los requisitos de la plantilla.

#### 4. Documentar los Concepts

Documente adecuadamente los Concepts y los requisitos que imponen. Esto facilita la comprensión y el uso correcto de los Concepts en su código.

### Conclusión

Los Concepts en C++ son una herramienta poderosa para definir y verificar restricciones de tipos en plantillas. Utilizando Concepts, puede escribir código más claro, mantenible y libre de errores. Al definir y aplicar Concepts de manera adecuada, se mejorará la robustez y la legibilidad de su código C++.
### Uso de Concepts con Funciones y Clases en C++

Los Concepts en C++ pueden aplicarse tanto a funciones como a clases, permitiendo definir restricciones claras y específicas para los tipos utilizados en plantillas. A continuación, veremos cómo usar Concepts con funciones y clases, y cómo esta práctica mejora la claridad y robustez del código.

#### Uso de Concepts con Funciones

Los Concepts se utilizan frecuentemente con funciones para restringir los tipos que pueden ser pasados como argumentos de plantilla. Esto se logra mediante la palabra clave `template` y la sintaxis `Concept Nombre`.

##### Ejemplo de Concept con Función

```cpp
#include <concepts>
#include <iostream>

// Concept que requiere que T sea un tipo integral
template<typename T>
concept Integral = std::is_integral_v<T>;

// Función plantilla que utiliza el Concept Integral
template<Integral T>
T sumar(T a, T b) {
    return a + b;
}

int main() {
    int a = 5, b = 3;
    std::cout << sumar(a, b) << std::endl; // Funciona: int es un tipo integral

    // double x = 5.0, y = 3.0;
    // std::cout << sumar(x, y) << std::endl; // Error de compilación: double no es un tipo integral
}
```

En este ejemplo:
- El Concept `Integral` se define para verificar si un tipo es integral.
- La función plantilla `sumar` utiliza el Concept `Integral`, asegurando que solo acepte tipos integrales.

#### Uso de Concepts con Clases

Además de funciones, los Concepts pueden aplicarse a clases para restringir los tipos que se pueden utilizar con plantillas de clase.

##### Ejemplo de Concept con Clase

```cpp
#include <concepts>
#include <iostream>

// Concept que requiere que T sea un tipo flotante
template<typename T>
concept FloatingPoint = std::is_floating_point_v<T>;

// Clase plantilla que utiliza el Concept FloatingPoint
template<FloatingPoint T>
class Calculadora {
public:
    T sumar(T a, T b) {
        return a + b;
    }

    T multiplicar(T a, T b) {
        return a * b;
    }
};

int main() {
    Calculadora<float> calc;
    std::cout << calc.sumar(2.5f, 3.0f) << std::endl; // Funciona: float es un tipo flotante
    std::cout << calc.multiplicar(2.5f, 3.0f) << std::endl; // Funciona: float es un tipo flotante

    // Calculadora<int> calcInt;
    // std::cout << calcInt.sumar(2, 3) << std::endl; // Error de compilación: int no es un tipo flotante
}
```

En este ejemplo:
- El Concept `FloatingPoint` se define para verificar si un tipo es flotante.
- La clase plantilla `Calculadora` utiliza el Concept `FloatingPoint`, asegurando que solo acepte tipos flotantes.

### Buenas Prácticas al Usar Concepts con Funciones y Clases

#### 1. Definir Concepts Específicos y Claros

Defina Concepts que sean claros y específicos para el contexto de su aplicación. Esto ayuda a evitar confusiones y errores.

#### 2. Utilizar Concepts para Mejorar la Legibilidad

Aplique Concepts para mejorar la legibilidad y la mantenibilidad del código, proporcionando contexto claro sobre los tipos esperados en plantillas.

#### 3. Documentar los Concepts y sus Requisitos

Documente adecuadamente los Concepts y los requisitos que imponen para facilitar su comprensión y correcto uso.

#### 4. Aprovechar los Concepts para Mejorar la Seguridad del Código

Utilice Concepts para verificar los requisitos de los tipos en tiempo de compilación, mejorando la seguridad y la robustez del código.

### Ejemplo Avanzado: Uso Combinado de Concepts en Funciones y Clases

Para ilustrar el uso combinado de Concepts en funciones y clases, considere el siguiente ejemplo:

```cpp
#include <concepts>
#include <iostream>
#include <vector>
#include <list>

// Concept que requiere que T sea iterable
template<typename T>
concept Iterable = requires(T t) {
    t.begin();
    t.end();
};

// Clase plantilla que usa el Concept Iterable
template<Iterable T>
class Procesador {
public:
    void mostrarElementos(const T& contenedor) {
        for (const auto& elem : contenedor) {
            std::cout << elem << ' ';
        }
        std::cout << std::endl;
    }
};

// Función plantilla que usa el Concept Iterable
template<Iterable T>
void procesarContenedor(const T& contenedor) {
    for (const auto& elem : contenedor) {
        std::cout << elem << ' ';
    }
    std::cout << std::endl;
}

int main() {
    std::vector<int> vec = {1, 2, 3, 4, 5};
    std::list<std::string> lst = {"uno", "dos", "tres"};

    Procesador<std::vector<int>> procVec;
    procVec.mostrarElementos(vec); // Funciona: vector es iterable

    Procesador<std::list<std::string>> procLst;
    procLst.mostrarElementos(lst); // Funciona: list es iterable

    procesarContenedor(vec); // Funciona: vector es iterable
    procesarContenedor(lst); // Funciona: list es iterable

    // int num = 42;
    // procesarContenedor(num); // Error de compilación: int no es iterable
}
```

En este ejemplo:
- El Concept `Iterable` se define para verificar si un tipo es iterable mediante `begin()` y `end()`.
- La clase `Procesador` y la función `procesarContenedor` utilizan el Concept `Iterable`, asegurando que solo acepten tipos iterables.

### Conclusión

Los Concepts en C++ proporcionan una forma poderosa de definir y verificar restricciones de tipos en plantillas, mejorando la claridad, seguridad y mantenibilidad del código. Al utilizar Concepts con funciones y clases, puede asegurar que solo se utilicen tipos adecuados, evitar errores de compilación y proporcionar un contexto claro sobre las expectativas de su código.
### Concepts Predefinidos en C++

C++20 introdujo una serie de Concepts predefinidos en la biblioteca estándar, que cubren un amplio rango de propiedades y operaciones comunes. Estos Concepts predefinidos facilitan la creación de plantillas al proporcionar restricciones listas para usar que aseguran que los tipos cumplan con ciertos requisitos.

#### Lista de Concepts Predefinidos

Aquí hay algunos de los Concepts predefinidos más importantes:

1. `Same`
2. `DerivedFrom`
3. `ConvertibleTo`
4. `Common`
5. `Integral`
6. `SignedIntegral`
7. `UnsignedIntegral`
8. `FloatingPoint`
9. `Swappable`
10. `DefaultConstructible`
11. `MoveConstructible`
12. `CopyConstructible`

### Ejemplos de Uso de Concepts Predefinidos

#### 1. Concept `Same`

El Concept `Same` verifica si dos tipos son el mismo.

##### Ejemplo

```cpp
#include <concepts>
#include <iostream>

// Función plantilla que solo acepta argumentos del mismo tipo
template<std::same_as<int> T>
void imprimir(T valor) {
    std::cout << valor << std::endl;
}

int main() {
    imprimir(42);  // Funciona: 42 es un int

    // imprimir(42.0);  // Error de compilación: 42.0 es un double
}
```

#### 2. Concept `DerivedFrom`

El Concept `DerivedFrom` verifica si un tipo es derivado de otro.

##### Ejemplo

```cpp
#include <concepts>
#include <iostream>

class Base {};
class Derivada : public Base {};

// Función plantilla que solo acepta tipos derivados de Base
template<std::derived_from<Base> T>
void mostrarBase(const T&) {
    std::cout << "Derivado de Base" << std::endl;
}

int main() {
    Base b;
    Derivada d;

    mostrarBase(d);  // Funciona: Derivada es derivada de Base

    // mostrarBase(b);  // Error de compilación: Base no es derivada de Base
}
```

#### 3. Concept `ConvertibleTo`

El Concept `ConvertibleTo` verifica si un tipo puede ser convertido a otro.

##### Ejemplo

```cpp
#include <concepts>
#include <iostream>

// Función plantilla que solo acepta tipos convertibles a int
template<std::convertible_to<int> T>
void convertir(T valor) {
    int convertido = static_cast<int>(valor);
    std::cout << convertido << std::endl;
}

int main() {
    convertir(42);     // Funciona: int es convertible a int
    convertir(42.0);   // Funciona: double es convertible a int

    // convertir("42");  // Error de compilación: const char* no es convertible a int
}
```

#### 4. Concept `Common`

El Concept `Common` verifica si hay un tipo común entre dos tipos dados.

##### Ejemplo

```cpp
#include <concepts>
#include <iostream>

// Función plantilla que solo acepta tipos con un tipo común
template<std::common_with<int> T>
void sumarComun(T a, T b) {
    std::cout << (a + b) << std::endl;
}

int main() {
    sumarComun(3, 5);   // Funciona: int es común con int
    sumarComun(3.0, 5); // Funciona: double es común con int

    // sumarComun("3", 5);  // Error de compilación: const char* no es común con int
}
```

#### 5. Concept `Integral`

El Concept `Integral` verifica si un tipo es un tipo integral.

##### Ejemplo

```cpp
#include <concepts>
#include <iostream>

// Función plantilla que solo acepta tipos integrales
template<std::integral T>
T multiplicar(T a, T b) {
    return a * b;
}

int main() {
    int a = 5, b = 3;
    std::cout << multiplicar(a, b) << std::endl;  // Funciona: int es un tipo integral

    // double x = 5.0, y = 3.0;
    // std::cout << multiplicar(x, y) << std::endl;  // Error de compilación: double no es un tipo integral
}
```

### Otros Concepts Predefinidos

- **SignedIntegral**: Verifica si un tipo es un entero con signo.
- **UnsignedIntegral**: Verifica si un tipo es un entero sin signo.
- **FloatingPoint**: Verifica si un tipo es un punto flotante.
- **Swappable**: Verifica si dos objetos pueden intercambiarse.
- **DefaultConstructible**: Verifica si un tipo puede ser construido por defecto.
- **MoveConstructible**: Verifica si un tipo puede ser movido.
- **CopyConstructible**: Verifica si un tipo puede ser copiado.

### Conclusión

Los Concepts predefinidos en C++20 son una herramienta poderosa para imponer restricciones de tipos en plantillas. Estos Concepts proporcionan una manera clara y concisa de especificar requisitos de tipos, mejorando la seguridad y legibilidad del código. Al utilizar estos Concepts, puede asegurarse de que sus plantillas solo acepten tipos adecuados y evitar errores de compilación difíciles de diagnosticar.
### Concepts Personalizados en C++

Además de los Concepts predefinidos, C++ permite definir Concepts personalizados para imponer restricciones específicas a los tipos utilizados en plantillas. Los Concepts personalizados son especialmente útiles cuando se trabaja con tipos de datos y operaciones específicos que no están cubiertos por los Concepts predefinidos.

### Definición de Concepts Personalizados

Para definir un Concept personalizado, se utiliza la palabra clave `concept` seguida del nombre del Concept y una expresión que representa la condición que debe cumplir el tipo. Veamos algunos ejemplos de cómo definir y utilizar Concepts personalizados.

#### Ejemplo 1: Concepto `HasSizeMethod`

Este Concept verifica si un tipo tiene un método `size()` que retorna un valor convertible a `std::size_t`.

```cpp
#include <concepts>
#include <type_traits>
#include <iostream>

// Definir un Concept que requiere que T tenga un método `size()`
template<typename T>
concept HasSizeMethod = requires(T a) {
    { a.size() } -> std::convertible_to<std::size_t>;
};

// Clase con método `size()`
class ConSize {
public:
    std::size_t size() const {
        return 42;
    }
};

// Clase sin método `size()`
class SinSize {
public:
    int length() const {
        return 84;
    }
};

// Función plantilla que utiliza el Concept HasSizeMethod
template<HasSizeMethod T>
std::size_t obtenerSize(const T& obj) {
    return obj.size();
}

int main() {
    ConSize cs;
    std::cout << obtenerSize(cs) << std::endl; // Funciona: ConSize tiene método `size()`

    // SinSize ss;
    // std::cout << obtenerSize(ss) << std::endl; // Error de compilación: SinSize no tiene método `size()`
}
```

#### Ejemplo 2: Concepto `Addable`

Este Concept verifica si dos instancias de un tipo pueden sumarse utilizando el operador `+`.

```cpp
#include <concepts>
#include <iostream>

// Definir un Concept que requiere que T soporte la operación de suma
template<typename T>
concept Addable = requires(T a, T b) {
    { a + b } -> std::same_as<T>;
};

// Función plantilla que utiliza el Concept Addable
template<Addable T>
T sumar(T a, T b) {
    return a + b;
}

int main() {
    int x = 5, y = 3;
    std::cout << sumar(x, y) << std::endl; // Funciona: int soporta la suma

    double p = 5.5, q = 3.5;
    std::cout << sumar(p, q) << std::endl; // Funciona: double soporta la suma

    // std::string s1 = "Hola, ", s2 = "Mundo!";
    // std::cout << sumar(s1, s2) << std::endl; // Funciona: std::string soporta la suma (concatenación)
}
```

#### Ejemplo 3: Concepto `EqualityComparable`

Este Concept verifica si dos instancias de un tipo pueden compararse por igualdad utilizando el operador `==`.

```cpp
#include <concepts>
#include <iostream>

// Definir un Concept que requiere que T soporte la comparación de igualdad
template<typename T>
concept EqualityComparable = requires(T a, T b) {
    { a == b } -> std::convertible_to<bool>;
};

// Función plantilla que utiliza el Concept EqualityComparable
template<EqualityComparable T>
bool sonIguales(T a, T b) {
    return a == b;
}

int main() {
    int a = 5, b = 5;
    std::cout << std::boolalpha << sonIguales(a, b) << std::endl; // Funciona: int soporta la comparación de igualdad

    double x = 3.14, y = 3.14;
    std::cout << std::boolalpha << sonIguales(x, y) << std::endl; // Funciona: double soporta la comparación de igualdad

    // std::string s1 = "Hola", s2 = "Hola";
    // std::cout << std::boolalpha << sonIguales(s1, s2) << std::endl; // Funciona: std::string soporta la comparación de igualdad
}
```

### Cómo Utilizar Concepts Personalizados

Para utilizar Concepts personalizados en funciones y clases plantilla, simplemente incluya el Concept en la declaración de la plantilla utilizando la sintaxis `template<Concept Nombre>`.

#### Ejemplo: Uso de Concepts en Clases Plantilla

```cpp
#include <concepts>
#include <iostream>

// Concept personalizado que verifica si T es default constructible
template<typename T>
concept DefaultConstructible = std::is_default_constructible_v<T>;

// Clase plantilla que utiliza el Concept DefaultConstructible
template<DefaultConstructible T>
class Contenedor {
    T valor;
public:
    Contenedor() : valor{} {} // Requiere que T sea default constructible
    void mostrarValor() const {
        std::cout << valor << std::endl;
    }
};

int main() {
    Contenedor<int> c; // Funciona: int es default constructible
    c.mostrarValor();

    // Contenedor<std::ostream> c2; // Error de compilación: std::ostream no es default constructible
}
```

### Buenas Prácticas al Definir Concepts Personalizados

1. **Definir Requirements Claros**: Asegúrese de que los requisitos del Concept sean claros y específicos.
2. **Mantener la Simplicidad**: Evite hacer Concepts demasiado complejos o incluir demasiados requisitos.
3. **Documentación**: Documente cada Concept personalizado para facilitar su comprensión y uso correcto.
4. **Reutilización**: Defina Concepts reutilizables que puedan aplicarse en múltiples contextos.

### Conclusión

Los Concepts personalizados en C++ permiten definir restricciones específicas para los tipos utilizados en plantillas, mejorando la claridad y la robustez del código. Al aprovechar los Concepts personalizados, puede asegurarse de que solo se utilicen tipos adecuados en sus plantillas, evitando errores en tiempo de compilación y mejorando la mantenibilidad del código.
### Concepts en Funciones para Restringir el Tipo de Parámetro en C++

Los Concepts en C++20 son una herramienta poderosa que permite restringir los tipos de parámetros que pueden ser pasados a funciones plantilla. Esto mejora la seguridad del código al asegurar que solo los tipos que cumplen ciertos requisitos puedan ser utilizados.

### Definición de Concepts en Funciones

Para usar un Concept en una función, se especifica el Concept en la declaración de la plantilla. Aquí hay una guía paso a paso y ejemplos de cómo hacerlo.

#### Ejemplo 1: Uso de `std::integral`

Este Concept predefinido verifica si un tipo es un tipo integral (como `int`, `char`, etc.).

```cpp
#include <concepts>
#include <iostream>

// Función plantilla que solo acepta tipos integrales
template<std::integral T>
T sumar(T a, T b) {
    return a + b;
}

int main() {
    int x = 5, y = 3;
    std::cout << sumar(x, y) << std::endl;  // Funciona: int es un tipo integral

    // double a = 5.0, b = 3.0;
    // std::cout << sumar(a, b) << std::endl;  // Error de compilación: double no es un tipo integral
}
```

En este ejemplo, la función plantilla `sumar` solo acepta parámetros de tipo integral debido al Concept `std::integral`.

#### Ejemplo 2: Uso de `std::floating_point`

Este Concept predefinido verifica si un tipo es un tipo de punto flotante (como `float`, `double`, etc.).

```cpp
#include <concepts>
#include <iostream>

// Función plantilla que solo acepta tipos de punto flotante
template<std::floating_point T>
T multiplicar(T a, T b) {
    return a * b;
}

int main() {
    double x = 2.5, y = 3.5;
    std::cout << multiplicar(x, y) << std::endl;  // Funciona: double es un tipo de punto flotante

    // int a = 2, b = 3;
    // std::cout << multiplicar(a, b) << std::endl;  // Error de compilación: int no es un tipo de punto flotante
}
```

#### Ejemplo 3: Concept Personalizado `HasSizeMethod`

Este Concept verifica si un tipo tiene un método `size()` que retorna un valor convertible a `std::size_t`.

```cpp
#include <concepts>
#include <type_traits>
#include <iostream>

// Definir un Concept que requiere que T tenga un método `size()`
template<typename T>
concept HasSizeMethod = requires(T a) {
    { a.size() } -> std::convertible_to<std::size_t>;
};

// Función plantilla que solo acepta tipos que tienen un método `size()`
template<HasSizeMethod T>
std::size_t obtenerSize(const T& obj) {
    return obj.size();
}

class ConSize {
public:
    std::size_t size() const {
        return 42;
    }
};

class SinSize {
public:
    int length() const {
        return 84;
    }
};

int main() {
    ConSize cs;
    std::cout << obtenerSize(cs) << std::endl; // Funciona: ConSize tiene método `size()`

    // SinSize ss;
    // std::cout << obtenerSize(ss) << std::endl; // Error de compilación: SinSize no tiene método `size()`
}
```

#### Ejemplo 4: Concept Personalizado `Addable`

Este Concept verifica si dos instancias de un tipo pueden sumarse utilizando el operador `+`.

```cpp
#include <concepts>
#include <iostream>

// Definir un Concept que requiere que T soporte la operación de suma
template<typename T>
concept Addable = requires(T a, T b) {
    { a + b } -> std::same_as<T>;
};

// Función plantilla que solo acepta tipos que soportan la suma
template<Addable T>
T sumar(T a, T b) {
    return a + b;
}

int main() {
    int x = 5, y = 3;
    std::cout << sumar(x, y) << std::endl;  // Funciona: int soporta la suma

    double p = 5.5, q = 3.5;
    std::cout << sumar(p, q) << std::endl;  // Funciona: double soporta la suma

    // std::string s1 = "Hola, ", s2 = "Mundo!";
    // std::cout << sumar(s1, s2) << std::endl;  // Funciona: std::string soporta la suma (concatenación)
}
```

### Uso de Concepts en Parámetros de Funciones

Los Concepts también pueden ser utilizados directamente en la lista de parámetros de una función para restringir los tipos permitidos.

#### Ejemplo 5: Uso de Concepts en Parámetros

```cpp
#include <concepts>
#include <iostream>

// Definir un Concept que requiere que T sea un tipo integral
template<typename T>
concept Integral = std::is_integral_v<T>;

// Función que utiliza el Concept directamente en los parámetros
void imprimir(Integral auto valor) {
    std::cout << valor << std::endl;
}

int main() {
    imprimir(42);  // Funciona: 42 es un int (integral)
    // imprimir(42.0);  // Error de compilación: 42.0 es un double (no integral)
}
```

### Buenas Prácticas al Usar Concepts en Funciones

1. **Definir Concepts Claros y Específicos**: Asegúrese de que los Concepts sean claros y específicos para evitar confusiones.
2. **Reutilizar Concepts**: Defina Concepts reutilizables que puedan ser aplicados en múltiples funciones y contextos.
3. **Documentar**: Documente los Concepts y las funciones que los utilizan para facilitar la comprensión del código.
4. **Evitar Complejidad**: Mantenga los Concepts lo más simples posible para no complicar innecesariamente el código.

### Conclusión

Los Concepts en C++ permiten restringir los tipos de parámetros en funciones plantilla, proporcionando una forma clara y concisa de imponer restricciones de tipos. Esto no solo mejora la seguridad y la robustez del código, sino que también facilita la detección de errores en tiempo de compilación y mejora la legibilidad del código. Al definir y utilizar Concepts personalizados, puede asegurar que sus funciones solo acepten los tipos adecuados, evitando errores y mejorando la mantenibilidad del código.
<---FILES--->
Ejemplo Básico de Concept
Ejemplo Básico de Concept Result
Ejemplo Básico de Concept
Ejemplo Básico de Concept Result
Ejemplo de Concept con Función
Ejemplo de Concept con Función Result
Ejemplo de Concept con Clase
Ejemplo de Concept con Clase Result
Ejemplo Básico de Concept
Ejemplo Básico de Concept Result
Ejemplo de Concept con Función
Ejemplo de Concept con Función Result
Ejemplo de Concept con Clase
Ejemplo de Concept con Clase Result
Ejemplo
Ejemplo Result
Ejemplo Básico de Concept
Ejemplo Básico de Concept Result
Ejemplo de Concept con Función
Ejemplo de Concept con Función Result
Ejemplo de Concept con Clase
Ejemplo de Concept con Clase Result
Ejemplo
Ejemplo Result
Ejemplo Básico de Concept
Ejemplo Básico de Concept Result
Ejemplo de Concept con Función
Ejemplo de Concept con Función Result
Ejemplo de Concept con Clase
Ejemplo de Concept con Clase Result
Ejemplo
Ejemplo Result
<---Ejemplo Básico de Concept--->
```cpp
#include <concepts>
#include <iostream>

// Definir un Concept que requiere que T sea un tipo integral
template<typename T>
concept Integral = std::is_integral_v<T>;

// Función plantilla que utiliza el Concept Integral
template<Integral T>
T sumar(T a, T b) {
    return a + b;
}

int main() {
    int a = 5, b = 3;
    std::cout << sumar(a, b) << std::endl; // Funciona: int es un tipo integral

    // double x = 5.0, y = 3.0;
    // std::cout << sumar(x, y) << std::endl; // Error de compilación: double no es un tipo integral
}
```cpp
#include <concepts>
#include <type_traits>
#include <iostream>

// Definir un Concept que requiere que T tenga un método `size()`
template<typename T>
concept HasSizeMethod = requires(T a) {
    { a.size() } -> std::convertible_to<std::size_t>;
};

// Clase con método `size()`
class ConSize {
public:
    std::size_t size() const {
        return 42;
    }
};

// Clase sin método `size()`
class SinSize {
public:
    int length() const {
        return 84;
    }
};

// Función plantilla que utiliza el Concept HasSizeMethod
template<HasSizeMethod T>
std::size_t obtenerSize(const T& obj) {
    return obj.size();
}

int main() {
    ConSize cs;
    std::cout << obtenerSize(cs) << std::endl; // Funciona: ConSize tiene método `size()`

    // SinSize ss;
    // std::cout << obtenerSize(ss) << std::endl; // Error de compilación: SinSize no tiene método `size()`
}
```cpp
#include <concepts>
#include <iostream>

// Concept que requiere que T sea un número flotante
template<typename T>
concept FloatingPoint = std::is_floating_point_v<T>;

// Función plantilla que utiliza el Concept FloatingPoint
template<FloatingPoint T>
T multiplicar(T a, T b) {
    return a * b;
}

int main() {
    float a = 2.5f, b = 4.0f;
    std::cout << multiplicar(a, b) << std::endl; // Funciona: float es un tipo flotante

    // int x = 2, y = 3;
    // std::cout << multiplicar(x, y) << std::endl; // Error de compilación: int no es un tipo flotante
}
<---Ejemplo Básico de Concept Result--->
<---Ejemplo Básico de Concept--->
```cpp
#include <concepts>
#include <iostream>

// Definir un Concept que requiere que T sea un tipo integral
template<typename T>
concept Integral = std::is_integral_v<T>;

// Función plantilla que utiliza el Concept Integral
template<Integral T>
T sumar(T a, T b) {
    return a + b;
}

int main() {
    int a = 5, b = 3;
    std::cout << sumar(a, b) << std::endl; // Funciona: int es un tipo integral

    // double x = 5.0, y = 3.0;
    // std::cout << sumar(x, y) << std::endl; // Error de compilación: double no es un tipo integral
}
```cpp
#include <concepts>
#include <type_traits>
#include <iostream>

// Definir un Concept que requiere que T tenga un método `size()`
template<typename T>
concept HasSizeMethod = requires(T a) {
    { a.size() } -> std::convertible_to<std::size_t>;
};

// Clase con método `size()`
class ConSize {
public:
    std::size_t size() const {
        return 42;
    }
};

// Clase sin método `size()`
class SinSize {
public:
    int length() const {
        return 84;
    }
};

// Función plantilla que utiliza el Concept HasSizeMethod
template<HasSizeMethod T>
std::size_t obtenerSize(const T& obj) {
    return obj.size();
}

int main() {
    ConSize cs;
    std::cout << obtenerSize(cs) << std::endl; // Funciona: ConSize tiene método `size()`

    // SinSize ss;
    // std::cout << obtenerSize(ss) << std::endl; // Error de compilación: SinSize no tiene método `size()`
}
```cpp
#include <concepts>
#include <iostream>

// Concept que requiere que T sea un número flotante
template<typename T>
concept FloatingPoint = std::is_floating_point_v<T>;

// Función plantilla que utiliza el Concept FloatingPoint
template<FloatingPoint T>
T multiplicar(T a, T b) {
    return a * b;
}

int main() {
    float a = 2.5f, b = 4.0f;
    std::cout << multiplicar(a, b) << std::endl; // Funciona: float es un tipo flotante

    // int x = 2, y = 3;
    // std::cout << multiplicar(x, y) << std::endl; // Error de compilación: int no es un tipo flotante
}
<---Ejemplo Básico de Concept Result--->
<---Ejemplo de Concept con Función--->
```cpp
#include <concepts>
#include <iostream>

// Concept que requiere que T sea un tipo integral
template<typename T>
concept Integral = std::is_integral_v<T>;

// Función plantilla que utiliza el Concept Integral
template<Integral T>
T sumar(T a, T b) {
    return a + b;
}

int main() {
    int a = 5, b = 3;
    std::cout << sumar(a, b) << std::endl; // Funciona: int es un tipo integral

    // double x = 5.0, y = 3.0;
    // std::cout << sumar(x, y) << std::endl; // Error de compilación: double no es un tipo integral
}
<---Ejemplo de Concept con Función Result--->
<---Ejemplo de Concept con Clase--->
```cpp
#include <concepts>
#include <iostream>

// Concept que requiere que T sea un tipo flotante
template<typename T>
concept FloatingPoint = std::is_floating_point_v<T>;

// Clase plantilla que utiliza el Concept FloatingPoint
template<FloatingPoint T>
class Calculadora {
public:
    T sumar(T a, T b) {
        return a + b;
    }

    T multiplicar(T a, T b) {
        return a * b;
    }
};

int main() {
    Calculadora<float> calc;
    std::cout << calc.sumar(2.5f, 3.0f) << std::endl; // Funciona: float es un tipo flotante
    std::cout << calc.multiplicar(2.5f, 3.0f) << std::endl; // Funciona: float es un tipo flotante

    // Calculadora<int> calcInt;
    // std::cout << calcInt.sumar(2, 3) << std::endl; // Error de compilación: int no es un tipo flotante
}
```cpp
#include <concepts>
#include <iostream>
#include <vector>
#include <list>

// Concept que requiere que T sea iterable
template<typename T>
concept Iterable = requires(T t) {
    t.begin();
    t.end();
};

// Clase plantilla que usa el Concept Iterable
template<Iterable T>
class Procesador {
public:
    void mostrarElementos(const T& contenedor) {
        for (const auto& elem : contenedor) {
            std::cout << elem << ' ';
        }
        std::cout << std::endl;
    }
};

// Función plantilla que usa el Concept Iterable
template<Iterable T>
void procesarContenedor(const T& contenedor) {
    for (const auto& elem : contenedor) {
        std::cout << elem << ' ';
    }
    std::cout << std::endl;
}

int main() {
    std::vector<int> vec = {1, 2, 3, 4, 5};
    std::list<std::string> lst = {"uno", "dos", "tres"};

    Procesador<std::vector<int>> procVec;
    procVec.mostrarElementos(vec); // Funciona: vector es iterable

    Procesador<std::list<std::string>> procLst;
    procLst.mostrarElementos(lst); // Funciona: list es iterable

    procesarContenedor(vec); // Funciona: vector es iterable
    procesarContenedor(lst); // Funciona: list es iterable

    // int num = 42;
    // procesarContenedor(num); // Error de compilación: int no es iterable
}
<---Ejemplo de Concept con Clase Result--->
<---Ejemplo Básico de Concept--->
```cpp
#include <concepts>
#include <iostream>

// Definir un Concept que requiere que T sea un tipo integral
template<typename T>
concept Integral = std::is_integral_v<T>;

// Función plantilla que utiliza el Concept Integral
template<Integral T>
T sumar(T a, T b) {
    return a + b;
}

int main() {
    int a = 5, b = 3;
    std::cout << sumar(a, b) << std::endl; // Funciona: int es un tipo integral

    // double x = 5.0, y = 3.0;
    // std::cout << sumar(x, y) << std::endl; // Error de compilación: double no es un tipo integral
}
```cpp
#include <concepts>
#include <type_traits>
#include <iostream>

// Definir un Concept que requiere que T tenga un método `size()`
template<typename T>
concept HasSizeMethod = requires(T a) {
    { a.size() } -> std::convertible_to<std::size_t>;
};

// Clase con método `size()`
class ConSize {
public:
    std::size_t size() const {
        return 42;
    }
};

// Clase sin método `size()`
class SinSize {
public:
    int length() const {
        return 84;
    }
};

// Función plantilla que utiliza el Concept HasSizeMethod
template<HasSizeMethod T>
std::size_t obtenerSize(const T& obj) {
    return obj.size();
}

int main() {
    ConSize cs;
    std::cout << obtenerSize(cs) << std::endl; // Funciona: ConSize tiene método `size()`

    // SinSize ss;
    // std::cout << obtenerSize(ss) << std::endl; // Error de compilación: SinSize no tiene método `size()`
}
```cpp
#include <concepts>
#include <iostream>

// Concept que requiere que T sea un número flotante
template<typename T>
concept FloatingPoint = std::is_floating_point_v<T>;

// Función plantilla que utiliza el Concept FloatingPoint
template<FloatingPoint T>
T multiplicar(T a, T b) {
    return a * b;
}

int main() {
    float a = 2.5f, b = 4.0f;
    std::cout << multiplicar(a, b) << std::endl; // Funciona: float es un tipo flotante

    // int x = 2, y = 3;
    // std::cout << multiplicar(x, y) << std::endl; // Error de compilación: int no es un tipo flotante
}
<---Ejemplo Básico de Concept Result--->
<---Ejemplo de Concept con Función--->
```cpp
#include <concepts>
#include <iostream>

// Concept que requiere que T sea un tipo integral
template<typename T>
concept Integral = std::is_integral_v<T>;

// Función plantilla que utiliza el Concept Integral
template<Integral T>
T sumar(T a, T b) {
    return a + b;
}

int main() {
    int a = 5, b = 3;
    std::cout << sumar(a, b) << std::endl; // Funciona: int es un tipo integral

    // double x = 5.0, y = 3.0;
    // std::cout << sumar(x, y) << std::endl; // Error de compilación: double no es un tipo integral
}
<---Ejemplo de Concept con Función Result--->
<---Ejemplo de Concept con Clase--->
```cpp
#include <concepts>
#include <iostream>

// Concept que requiere que T sea un tipo flotante
template<typename T>
concept FloatingPoint = std::is_floating_point_v<T>;

// Clase plantilla que utiliza el Concept FloatingPoint
template<FloatingPoint T>
class Calculadora {
public:
    T sumar(T a, T b) {
        return a + b;
    }

    T multiplicar(T a, T b) {
        return a * b;
    }
};

int main() {
    Calculadora<float> calc;
    std::cout << calc.sumar(2.5f, 3.0f) << std::endl; // Funciona: float es un tipo flotante
    std::cout << calc.multiplicar(2.5f, 3.0f) << std::endl; // Funciona: float es un tipo flotante

    // Calculadora<int> calcInt;
    // std::cout << calcInt.sumar(2, 3) << std::endl; // Error de compilación: int no es un tipo flotante
}
```cpp
#include <concepts>
#include <iostream>
#include <vector>
#include <list>

// Concept que requiere que T sea iterable
template<typename T>
concept Iterable = requires(T t) {
    t.begin();
    t.end();
};

// Clase plantilla que usa el Concept Iterable
template<Iterable T>
class Procesador {
public:
    void mostrarElementos(const T& contenedor) {
        for (const auto& elem : contenedor) {
            std::cout << elem << ' ';
        }
        std::cout << std::endl;
    }
};

// Función plantilla que usa el Concept Iterable
template<Iterable T>
void procesarContenedor(const T& contenedor) {
    for (const auto& elem : contenedor) {
        std::cout << elem << ' ';
    }
    std::cout << std::endl;
}

int main() {
    std::vector<int> vec = {1, 2, 3, 4, 5};
    std::list<std::string> lst = {"uno", "dos", "tres"};

    Procesador<std::vector<int>> procVec;
    procVec.mostrarElementos(vec); // Funciona: vector es iterable

    Procesador<std::list<std::string>> procLst;
    procLst.mostrarElementos(lst); // Funciona: list es iterable

    procesarContenedor(vec); // Funciona: vector es iterable
    procesarContenedor(lst); // Funciona: list es iterable

    // int num = 42;
    // procesarContenedor(num); // Error de compilación: int no es iterable
}
<---Ejemplo de Concept con Clase Result--->
<---Ejemplo--->
```cpp
#include <concepts>
#include <iostream>

// Función plantilla que solo acepta tipos integrales
template<std::integral T>
T multiplicar(T a, T b) {
    return a * b;
}

int main() {
    int a = 5, b = 3;
    std::cout << multiplicar(a, b) << std::endl;  // Funciona: int es un tipo integral

    // double x = 5.0, y = 3.0;
    // std::cout << multiplicar(x, y) << std::endl;  // Error de compilación: double no es un tipo integral
}
<---Ejemplo Result--->
<---Ejemplo Básico de Concept--->
```cpp
#include <concepts>
#include <iostream>

// Definir un Concept que requiere que T sea un tipo integral
template<typename T>
concept Integral = std::is_integral_v<T>;

// Función plantilla que utiliza el Concept Integral
template<Integral T>
T sumar(T a, T b) {
    return a + b;
}

int main() {
    int a = 5, b = 3;
    std::cout << sumar(a, b) << std::endl; // Funciona: int es un tipo integral

    // double x = 5.0, y = 3.0;
    // std::cout << sumar(x, y) << std::endl; // Error de compilación: double no es un tipo integral
}
```cpp
#include <concepts>
#include <type_traits>
#include <iostream>

// Definir un Concept que requiere que T tenga un método `size()`
template<typename T>
concept HasSizeMethod = requires(T a) {
    { a.size() } -> std::convertible_to<std::size_t>;
};

// Clase con método `size()`
class ConSize {
public:
    std::size_t size() const {
        return 42;
    }
};

// Clase sin método `size()`
class SinSize {
public:
    int length() const {
        return 84;
    }
};

// Función plantilla que utiliza el Concept HasSizeMethod
template<HasSizeMethod T>
std::size_t obtenerSize(const T& obj) {
    return obj.size();
}

int main() {
    ConSize cs;
    std::cout << obtenerSize(cs) << std::endl; // Funciona: ConSize tiene método `size()`

    // SinSize ss;
    // std::cout << obtenerSize(ss) << std::endl; // Error de compilación: SinSize no tiene método `size()`
}
```cpp
#include <concepts>
#include <iostream>

// Concept que requiere que T sea un número flotante
template<typename T>
concept FloatingPoint = std::is_floating_point_v<T>;

// Función plantilla que utiliza el Concept FloatingPoint
template<FloatingPoint T>
T multiplicar(T a, T b) {
    return a * b;
}

int main() {
    float a = 2.5f, b = 4.0f;
    std::cout << multiplicar(a, b) << std::endl; // Funciona: float es un tipo flotante

    // int x = 2, y = 3;
    // std::cout << multiplicar(x, y) << std::endl; // Error de compilación: int no es un tipo flotante
}
<---Ejemplo Básico de Concept Result--->
<---Ejemplo de Concept con Función--->
```cpp
#include <concepts>
#include <iostream>

// Concept que requiere que T sea un tipo integral
template<typename T>
concept Integral = std::is_integral_v<T>;

// Función plantilla que utiliza el Concept Integral
template<Integral T>
T sumar(T a, T b) {
    return a + b;
}

int main() {
    int a = 5, b = 3;
    std::cout << sumar(a, b) << std::endl; // Funciona: int es un tipo integral

    // double x = 5.0, y = 3.0;
    // std::cout << sumar(x, y) << std::endl; // Error de compilación: double no es un tipo integral
}
<---Ejemplo de Concept con Función Result--->
<---Ejemplo de Concept con Clase--->
```cpp
#include <concepts>
#include <iostream>

// Concept que requiere que T sea un tipo flotante
template<typename T>
concept FloatingPoint = std::is_floating_point_v<T>;

// Clase plantilla que utiliza el Concept FloatingPoint
template<FloatingPoint T>
class Calculadora {
public:
    T sumar(T a, T b) {
        return a + b;
    }

    T multiplicar(T a, T b) {
        return a * b;
    }
};

int main() {
    Calculadora<float> calc;
    std::cout << calc.sumar(2.5f, 3.0f) << std::endl; // Funciona: float es un tipo flotante
    std::cout << calc.multiplicar(2.5f, 3.0f) << std::endl; // Funciona: float es un tipo flotante

    // Calculadora<int> calcInt;
    // std::cout << calcInt.sumar(2, 3) << std::endl; // Error de compilación: int no es un tipo flotante
}
```cpp
#include <concepts>
#include <iostream>
#include <vector>
#include <list>

// Concept que requiere que T sea iterable
template<typename T>
concept Iterable = requires(T t) {
    t.begin();
    t.end();
};

// Clase plantilla que usa el Concept Iterable
template<Iterable T>
class Procesador {
public:
    void mostrarElementos(const T& contenedor) {
        for (const auto& elem : contenedor) {
            std::cout << elem << ' ';
        }
        std::cout << std::endl;
    }
};

// Función plantilla que usa el Concept Iterable
template<Iterable T>
void procesarContenedor(const T& contenedor) {
    for (const auto& elem : contenedor) {
        std::cout << elem << ' ';
    }
    std::cout << std::endl;
}

int main() {
    std::vector<int> vec = {1, 2, 3, 4, 5};
    std::list<std::string> lst = {"uno", "dos", "tres"};

    Procesador<std::vector<int>> procVec;
    procVec.mostrarElementos(vec); // Funciona: vector es iterable

    Procesador<std::list<std::string>> procLst;
    procLst.mostrarElementos(lst); // Funciona: list es iterable

    procesarContenedor(vec); // Funciona: vector es iterable
    procesarContenedor(lst); // Funciona: list es iterable

    // int num = 42;
    // procesarContenedor(num); // Error de compilación: int no es iterable
}
<---Ejemplo de Concept con Clase Result--->
<---Ejemplo--->
```cpp
#include <concepts>
#include <iostream>

// Función plantilla que solo acepta tipos integrales
template<std::integral T>
T multiplicar(T a, T b) {
    return a * b;
}

int main() {
    int a = 5, b = 3;
    std::cout << multiplicar(a, b) << std::endl;  // Funciona: int es un tipo integral

    // double x = 5.0, y = 3.0;
    // std::cout << multiplicar(x, y) << std::endl;  // Error de compilación: double no es un tipo integral
}
<---Ejemplo Result--->
<---Ejemplo Básico de Concept--->
```cpp
#include <concepts>
#include <iostream>

// Definir un Concept que requiere que T sea un tipo integral
template<typename T>
concept Integral = std::is_integral_v<T>;

// Función plantilla que utiliza el Concept Integral
template<Integral T>
T sumar(T a, T b) {
    return a + b;
}

int main() {
    int a = 5, b = 3;
    std::cout << sumar(a, b) << std::endl; // Funciona: int es un tipo integral

    // double x = 5.0, y = 3.0;
    // std::cout << sumar(x, y) << std::endl; // Error de compilación: double no es un tipo integral
}
```cpp
#include <concepts>
#include <type_traits>
#include <iostream>

// Definir un Concept que requiere que T tenga un método `size()`
template<typename T>
concept HasSizeMethod = requires(T a) {
    { a.size() } -> std::convertible_to<std::size_t>;
};

// Clase con método `size()`
class ConSize {
public:
    std::size_t size() const {
        return 42;
    }
};

// Clase sin método `size()`
class SinSize {
public:
    int length() const {
        return 84;
    }
};

// Función plantilla que utiliza el Concept HasSizeMethod
template<HasSizeMethod T>
std::size_t obtenerSize(const T& obj) {
    return obj.size();
}

int main() {
    ConSize cs;
    std::cout << obtenerSize(cs) << std::endl; // Funciona: ConSize tiene método `size()`

    // SinSize ss;
    // std::cout << obtenerSize(ss) << std::endl; // Error de compilación: SinSize no tiene método `size()`
}
```cpp
#include <concepts>
#include <iostream>

// Concept que requiere que T sea un número flotante
template<typename T>
concept FloatingPoint = std::is_floating_point_v<T>;

// Función plantilla que utiliza el Concept FloatingPoint
template<FloatingPoint T>
T multiplicar(T a, T b) {
    return a * b;
}

int main() {
    float a = 2.5f, b = 4.0f;
    std::cout << multiplicar(a, b) << std::endl; // Funciona: float es un tipo flotante

    // int x = 2, y = 3;
    // std::cout << multiplicar(x, y) << std::endl; // Error de compilación: int no es un tipo flotante
}
<---Ejemplo Básico de Concept Result--->
<---Ejemplo de Concept con Función--->
```cpp
#include <concepts>
#include <iostream>

// Concept que requiere que T sea un tipo integral
template<typename T>
concept Integral = std::is_integral_v<T>;

// Función plantilla que utiliza el Concept Integral
template<Integral T>
T sumar(T a, T b) {
    return a + b;
}

int main() {
    int a = 5, b = 3;
    std::cout << sumar(a, b) << std::endl; // Funciona: int es un tipo integral

    // double x = 5.0, y = 3.0;
    // std::cout << sumar(x, y) << std::endl; // Error de compilación: double no es un tipo integral
}
<---Ejemplo de Concept con Función Result--->
<---Ejemplo de Concept con Clase--->
```cpp
#include <concepts>
#include <iostream>

// Concept que requiere que T sea un tipo flotante
template<typename T>
concept FloatingPoint = std::is_floating_point_v<T>;

// Clase plantilla que utiliza el Concept FloatingPoint
template<FloatingPoint T>
class Calculadora {
public:
    T sumar(T a, T b) {
        return a + b;
    }

    T multiplicar(T a, T b) {
        return a * b;
    }
};

int main() {
    Calculadora<float> calc;
    std::cout << calc.sumar(2.5f, 3.0f) << std::endl; // Funciona: float es un tipo flotante
    std::cout << calc.multiplicar(2.5f, 3.0f) << std::endl; // Funciona: float es un tipo flotante

    // Calculadora<int> calcInt;
    // std::cout << calcInt.sumar(2, 3) << std::endl; // Error de compilación: int no es un tipo flotante
}
```cpp
#include <concepts>
#include <iostream>
#include <vector>
#include <list>

// Concept que requiere que T sea iterable
template<typename T>
concept Iterable = requires(T t) {
    t.begin();
    t.end();
};

// Clase plantilla que usa el Concept Iterable
template<Iterable T>
class Procesador {
public:
    void mostrarElementos(const T& contenedor) {
        for (const auto& elem : contenedor) {
            std::cout << elem << ' ';
        }
        std::cout << std::endl;
    }
};

// Función plantilla que usa el Concept Iterable
template<Iterable T>
void procesarContenedor(const T& contenedor) {
    for (const auto& elem : contenedor) {
        std::cout << elem << ' ';
    }
    std::cout << std::endl;
}

int main() {
    std::vector<int> vec = {1, 2, 3, 4, 5};
    std::list<std::string> lst = {"uno", "dos", "tres"};

    Procesador<std::vector<int>> procVec;
    procVec.mostrarElementos(vec); // Funciona: vector es iterable

    Procesador<std::list<std::string>> procLst;
    procLst.mostrarElementos(lst); // Funciona: list es iterable

    procesarContenedor(vec); // Funciona: vector es iterable
    procesarContenedor(lst); // Funciona: list es iterable

    // int num = 42;
    // procesarContenedor(num); // Error de compilación: int no es iterable
}
<---Ejemplo de Concept con Clase Result--->
<---Ejemplo--->
```cpp
#include <concepts>
#include <iostream>

// Función plantilla que solo acepta tipos integrales
template<std::integral T>
T multiplicar(T a, T b) {
    return a * b;
}

int main() {
    int a = 5, b = 3;
    std::cout << multiplicar(a, b) << std::endl;  // Funciona: int es un tipo integral

    // double x = 5.0, y = 3.0;
    // std::cout << multiplicar(x, y) << std::endl;  // Error de compilación: double no es un tipo integral
}
<---Ejemplo Result--->
