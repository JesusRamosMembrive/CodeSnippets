<---EXPLANATION--->
### Algoritmos de la Biblioteca Estándar: `std::lower_bound` y `std::upper_bound`

Los algoritmos `std::lower_bound` y `std::upper_bound` son parte de la biblioteca estándar de C++ y se utilizan para realizar búsquedas en contenedores ordenados. Estas funciones permiten encontrar posiciones específicas de elementos en rangos ordenados de manera eficiente utilizando la búsqueda binaria. Son parte del encabezado `<algorithm>`.

#### `std::lower_bound`

`std::lower_bound` encuentra el primer elemento en un rango ordenado que no es menor que un valor especificado.

##### Sintaxis

```cpp
#include <algorithm>

template <class ForwardIt, class T>
ForwardIt lower_bound(ForwardIt first, ForwardIt last, const T& value);

template <class ForwardIt, class T, class Compare>
ForwardIt lower_bound(ForwardIt first, ForwardIt last, const T& value, Compare comp);
```

- **`ForwardIt first`**: Iterador al primer elemento del rango.
- **`ForwardIt last`**: Iterador al elemento después del último en el rango.
- **`const T& value`**: Valor que se busca.
- **`Compare comp`**: (Opcional) Función de comparación que toma dos argumentos.

##### Descripción

`std::lower_bound` realiza una búsqueda binaria en el rango `[first, last)` para encontrar el primer elemento que no es menor que `value`. Si `comp` se proporciona, se utiliza como función de comparación en lugar del operador `<`.

#### Ejemplo de Uso de `std::lower_bound`

```cpp
#include <iostream>
#include <vector>
#include <algorithm>

int main() {
    std::vector<int> vec = {1, 2, 3, 4, 5, 6, 7, 8, 9};

    // Usar std::lower_bound para encontrar el primer elemento no menor que 5
    auto it = std::lower_bound(vec.begin(), vec.end(), 5);

    // Mostrar el resultado
    if (it != vec.end()) {
        std::cout << "El primer elemento no menor que 5 es: " << *it << std::endl;
    } else {
        std::cout << "No se encontró un elemento no menor que 5" << std::endl;
    }

    return 0;
}
```

En este ejemplo:
- `std::lower_bound(vec.begin(), vec.end(), 5)` devuelve un iterador al primer elemento en `vec` que no es menor que `5`.

### `std::upper_bound`

`std::upper_bound` encuentra el primer elemento en un rango ordenado que es mayor que un valor especificado.

##### Sintaxis

```cpp
#include <algorithm>

template <class ForwardIt, class T>
ForwardIt upper_bound(ForwardIt first, ForwardIt last, const T& value);

template <class ForwardIt, class T, class Compare>
ForwardIt upper_bound(ForwardIt first, ForwardIt last, const T& value, Compare comp);
```

- **`ForwardIt first`**: Iterador al primer elemento del rango.
- **`ForwardIt last`**: Iterador al elemento después del último en el rango.
- **`const T& value`**: Valor que se busca.
- **`Compare comp`**: (Opcional) Función de comparación que toma dos argumentos.

##### Descripción

`std::upper_bound` realiza una búsqueda binaria en el rango `[first, last)` para encontrar el primer elemento que es mayor que `value`. Si `comp` se proporciona, se utiliza como función de comparación en lugar del operador `<`.

#### Ejemplo de Uso de `std::upper_bound`

```cpp
#include <iostream>
#include <vector>
#include <algorithm>

int main() {
    std::vector<int> vec = {1, 2, 3, 4, 5, 6, 7, 8, 9};

    // Usar std::upper_bound para encontrar el primer elemento mayor que 5
    auto it = std::upper_bound(vec.begin(), vec.end(), 5);

    // Mostrar el resultado
    if (it != vec.end()) {
        std::cout << "El primer elemento mayor que 5 es: " << *it << std::endl;
    } else {
        std::cout << "No se encontró un elemento mayor que 5" << std::endl;
    }

    return 0;
}
```

En este ejemplo:
- `std::upper_bound(vec.begin(), vec.end(), 5)` devuelve un iterador al primer elemento en `vec` que es mayor que `5`.

### Uso con Comparaciones Personalizadas

Tanto `std::lower_bound` como `std::upper_bound` pueden utilizar una función de comparación personalizada para realizar búsquedas en rangos ordenados según un criterio específico.

##### Ejemplo con Comparación Personalizada

```cpp
#include <iostream>
#include <vector>
#include <algorithm>

struct Persona {
    std::string nombre;
    int edad;
};

bool compararPorEdad(const Persona& a, const Persona& b) {
    return a.edad < b.edad;
}

int main() {
    std::vector<Persona> personas = {{"Ana", 25}, {"Luis", 30}, {"Carlos", 22}, {"Maria", 28}};

    // Ordenar las personas por edad
    std::sort(personas.begin(), personas.end(), compararPorEdad);

    Persona p = {"", 28}; // Solo la edad importa para la búsqueda

    // Usar std::lower_bound con comparación personalizada
    auto it = std::lower_bound(personas.begin(), personas.end(), p, compararPorEdad);

    // Mostrar el resultado
    if (it != personas.end()) {
        std::cout << "Primera persona con edad no menor que 28: " << it->nombre << " (" << it->edad << ")" << std::endl;
    } else {
        std::cout << "No se encontró una persona con edad no menor que 28" << std::endl;
    }

    return 0;
}
```

En este ejemplo:
- `std::lower_bound(personas.begin(), personas.end(), p, compararPorEdad)` utiliza una función de comparación personalizada para encontrar la primera persona cuya edad no es menor que `28`.

### Consideraciones

- **Rendimiento:** Tanto `std::lower_bound` como `std::upper_bound` tienen un rendimiento logarítmico (`O(log n)`) debido a la búsqueda binaria.
- **Orden:** Los rangos de entrada deben estar ordenados según el criterio de comparación utilizado (ya sea por el operador `<` o una función de comparación personalizada).
- **Iteradores:** Estos algoritmos requieren iteradores de avance o mejor, ya que utilizan operaciones de búsqueda binaria.

### Conclusión

`std::lower_bound` y `std::upper_bound` son algoritmos de búsqueda binaria eficientes de la biblioteca estándar de C++ que permiten encontrar posiciones específicas de elementos en rangos ordenados. Son fundamentales para trabajar con contenedores ordenados y pueden utilizar comparaciones personalizadas para realizar búsquedas según criterios específicos. Comprender y utilizar estos algoritmos es esencial para realizar búsquedas rápidas y eficientes en contenedores en C++.
<---FILES--->
Sintaxis
Sintaxis Result
Descripción
Descripción Result
Ejemplo con Comparación Personalizada
Ejemplo con Comparación Personalizada Result
<---Sintaxis--->
```cpp
#include <algorithm>

template <class ForwardIt, class T>
ForwardIt upper_bound(ForwardIt first, ForwardIt last, const T& value);

template <class ForwardIt, class T, class Compare>
ForwardIt upper_bound(ForwardIt first, ForwardIt last, const T& value, Compare comp);
<---Sintaxis Result--->
<---Descripción--->
```cpp
#include <iostream>
#include <vector>
#include <algorithm>

int main() {
    std::vector<int> vec = {1, 2, 3, 4, 5, 6, 7, 8, 9};

    // Usar std::upper_bound para encontrar el primer elemento mayor que 5
    auto it = std::upper_bound(vec.begin(), vec.end(), 5);

    // Mostrar el resultado
    if (it != vec.end()) {
        std::cout << "El primer elemento mayor que 5 es: " << *it << std::endl;
    } else {
        std::cout << "No se encontró un elemento mayor que 5" << std::endl;
    }

    return 0;
}
<---Descripción Result--->
<---Ejemplo con Comparación Personalizada--->
```cpp
#include <iostream>
#include <vector>
#include <algorithm>

struct Persona {
    std::string nombre;
    int edad;
};

bool compararPorEdad(const Persona& a, const Persona& b) {
    return a.edad < b.edad;
}

int main() {
    std::vector<Persona> personas = {{"Ana", 25}, {"Luis", 30}, {"Carlos", 22}, {"Maria", 28}};

    // Ordenar las personas por edad
    std::sort(personas.begin(), personas.end(), compararPorEdad);

    Persona p = {"", 28}; // Solo la edad importa para la búsqueda

    // Usar std::lower_bound con comparación personalizada
    auto it = std::lower_bound(personas.begin(), personas.end(), p, compararPorEdad);

    // Mostrar el resultado
    if (it != personas.end()) {
        std::cout << "Primera persona con edad no menor que 28: " << it->nombre << " (" << it->edad << ")" << std::endl;
    } else {
        std::cout << "No se encontró una persona con edad no menor que 28" << std::endl;
    }

    return 0;
}
<---Ejemplo con Comparación Personalizada Result--->
