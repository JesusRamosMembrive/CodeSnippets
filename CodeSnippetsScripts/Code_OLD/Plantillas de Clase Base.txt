<---EXPLANATION--->
### Plantillas de Clase Base en C++

En C++, las plantillas de clase base permiten definir clases genéricas que pueden ser utilizadas como base para otras clases. Esto facilita la creación de jerarquías de clases altamente flexibles y reutilizables, donde las clases derivadas pueden aprovechar la funcionalidad genérica proporcionada por las clases base plantilla.

#### Definición de Clases Base Plantilla

Una clase base plantilla es simplemente una clase definida como plantilla que puede ser utilizada para derivar otras clases.

##### Sintaxis

```cpp
template <typename T>
class Base {
    // Implementación
};
```

#### Ejemplo de Clase Base Plantilla

Vamos a definir una clase base plantilla y una clase derivada que hereda de ella.

##### Clase Base Plantilla

```cpp
#include <iostream>

// Definición de la clase base plantilla
template <typename T>
class Base {
public:
    T valor;

    Base(T v) : valor(v) {}

    void mostrar() const {
        std::cout << "Valor en Base: " << valor << std::endl;
    }
};
```

En este ejemplo:
- `Base` es una clase plantilla que acepta un tipo genérico `T`.
- Tiene un miembro de datos `valor` y un método `mostrar` que imprime este valor.

##### Clase Derivada que Hereda de la Clase Base Plantilla

```cpp
// Definición de la clase derivada
template <typename T>
class Derivada : public Base<T> {
public:
    Derivada(T v) : Base<T>(v) {}

    void mostrarDerivado() const {
        std::cout << "Valor en Derivada: " << this->valor << std::endl;
    }
};

int main() {
    Derivada<int> obj(10);
    obj.mostrar();            // Llama al método de la clase base
    obj.mostrarDerivado();    // Llama al método de la clase derivada

    return 0;
}
```

En este ejemplo:
- `Derivada` es una clase plantilla que hereda de `Base<T>`.
- Utiliza el constructor de `Base` para inicializar `valor`.
- Añade un método `mostrarDerivado` que imprime el valor.

#### Plantillas de Clase Base con Tipos Adicionales

A veces, la clase derivada puede necesitar más parámetros de plantilla adicionales a los de la clase base.

##### Ejemplo con Clases Derivadas con Múltiples Plantillas

```cpp
#include <iostream>

// Definición de la clase base plantilla
template <typename T>
class Base {
public:
    T valor;

    Base(T v) : valor(v) {}

    void mostrar() const {
        std::cout << "Valor en Base: " << valor << std::endl;
    }
};

// Definición de la clase derivada con un tipo adicional
template <typename T, typename U>
class Derivada : public Base<T> {
public:
    U otroValor;

    Derivada(T v, U ov) : Base<T>(v), otroValor(ov) {}

    void mostrarDerivado() const {
        std::cout << "Valor en Derivada: " << this->valor << ", Otro valor: " << otroValor << std::endl;
    }
};

int main() {
    Derivada<int, double> obj(10, 5.5);
    obj.mostrar();            // Llama al método de la clase base
    obj.mostrarDerivado();    // Llama al método de la clase derivada

    Derivada<std::string, int> obj2("Hola", 42);
    obj2.mostrar();           // Llama al método de la clase base
    obj2.mostrarDerivado();   // Llama al método de la clase derivada

    return 0;
}
```

En este ejemplo:
- `Derivada` acepta dos tipos genéricos: `T` para el tipo base y `U` para un tipo adicional específico de la clase derivada.
- El constructor de `Derivada` inicializa tanto la clase base como el nuevo miembro `otroValor`.

### Consideraciones al Usar Plantillas de Clase Base

1. **Acceso a Miembros Base:** En las clases derivadas plantillas, puede ser necesario utilizar el prefijo `this->` para acceder a los miembros de la clase base debido a la naturaleza dependiente del contexto de las plantillas.
2. **Compatibilidad y Reutilización:** Las plantillas permiten una gran flexibilidad, pero es importante asegurarse de que las clases derivadas mantengan la compatibilidad con las interfaces de la clase base para maximizar la reutilización del código.
3. **Especialización:** Las clases derivadas pueden especializar las funciones de la clase base según sea necesario para proporcionar implementaciones específicas de tipo.

### Ventajas de Usar Plantillas de Clase Base

1. **Reutilización del Código:** Facilitan la reutilización del código al permitir que las clases derivadas aprovechen la funcionalidad genérica de la clase base.
2. **Flexibilidad:** Permiten la creación de jerarquías de clases flexibles que pueden trabajar con múltiples tipos genéricos.
3. **Modularidad:** Mejoran la modularidad del código al separar la lógica genérica de la lógica específica del tipo.

### Conclusión

Las plantillas de clase base en C++ permiten crear jerarquías de clases altamente reutilizables y flexibles. Al definir clases genéricas que pueden ser utilizadas como base para otras clases, los desarrolladores pueden escribir código más modular y adaptable a diferentes tipos y necesidades. La comprensión y el uso adecuado de las plantillas de clase base son esenciales para aprovechar al máximo las capacidades de C++ en el diseño orientado a objetos.
<---FILES--->
Sintaxis
Sintaxis Result
Clase Base Plantilla
Clase Base Plantilla Result
Clase Derivada que Hereda de la Clase Base Plantilla
Clase Derivada que Hereda de la Clase Base Plantilla Result
Ejemplo con Clases Derivadas con Múltiples Plantillas
Ejemplo con Clases Derivadas con Múltiples Plantillas Result
<---Sintaxis--->
```cpp
template <typename T>
class Base {
    // Implementación
};
<---Sintaxis Result--->
<---Clase Base Plantilla--->
```cpp
#include <iostream>

// Definición de la clase base plantilla
template <typename T>
class Base {
public:
    T valor;

    Base(T v) : valor(v) {}

    void mostrar() const {
        std::cout << "Valor en Base: " << valor << std::endl;
    }
};
<---Clase Base Plantilla Result--->
<---Clase Derivada que Hereda de la Clase Base Plantilla--->
```cpp
// Definición de la clase derivada
template <typename T>
class Derivada : public Base<T> {
public:
    Derivada(T v) : Base<T>(v) {}

    void mostrarDerivado() const {
        std::cout << "Valor en Derivada: " << this->valor << std::endl;
    }
};

int main() {
    Derivada<int> obj(10);
    obj.mostrar();            // Llama al método de la clase base
    obj.mostrarDerivado();    // Llama al método de la clase derivada

    return 0;
}
<---Clase Derivada que Hereda de la Clase Base Plantilla Result--->
<---Ejemplo con Clases Derivadas con Múltiples Plantillas--->
```cpp
#include <iostream>

// Definición de la clase base plantilla
template <typename T>
class Base {
public:
    T valor;

    Base(T v) : valor(v) {}

    void mostrar() const {
        std::cout << "Valor en Base: " << valor << std::endl;
    }
};

// Definición de la clase derivada con un tipo adicional
template <typename T, typename U>
class Derivada : public Base<T> {
public:
    U otroValor;

    Derivada(T v, U ov) : Base<T>(v), otroValor(ov) {}

    void mostrarDerivado() const {
        std::cout << "Valor en Derivada: " << this->valor << ", Otro valor: " << otroValor << std::endl;
    }
};

int main() {
    Derivada<int, double> obj(10, 5.5);
    obj.mostrar();            // Llama al método de la clase base
    obj.mostrarDerivado();    // Llama al método de la clase derivada

    Derivada<std::string, int> obj2("Hola", 42);
    obj2.mostrar();           // Llama al método de la clase base
    obj2.mostrarDerivado();   // Llama al método de la clase derivada

    return 0;
}
<---Ejemplo con Clases Derivadas con Múltiples Plantillas Result--->
